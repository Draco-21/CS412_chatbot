{
  "title": "Wombat Machine",
  "language": "cpp",
  "topics": [
    "database",
    "networking",
    "data_structures",
    "fundamentals"
  ],
  "purpose": "right hand side to the location on the left hand side.",
  "code": "{+,-,*,/}. A generic operation is specified by op. PC+2 represents\nadding two to the PC, while ACC op BUS represents performing an op-\neration (specified by control codes) on values stored in the accumulator\nand the bus.\n\u2022 Input reads a 2 byte signed integer from the input device to inREG.\n\u2022 Output writes a 2 byte signed integer from the outREG to the output\ndevice.\n\u2022 Conditionalbranchesareevaluatedusingtheif (expression) operation\nformat.\n2.4 Instruction Set\nTable 2.1 instructions are supported in the enhanced wombat instruction set.\n10 CHAPTER 2. ARCHITECTURE\nMnemonic OpCode Operand Operand Bits RTN\nSTOP 0 Stop Execution\nLOAD 1 address 0 through 11 ACC \u2190 M[address]\nSTORE 2 address 0 through 11 M[address] \u2190 ACC\nREAD 3 Input\nACC \u2190 inREG\nWRITE 4 outREG \u2190 ACC\nOutput\nADD 5 address 0 through 11 ACC \u2190 ACC + M[address]\nSUBTRACT 6 address 0 through 11 ACC \u2190 ACC - M[address]\nMULTIPLY 7 address 0 through 11 ACC \u2190 ACC * M[address]\nDIVIDE 8 address 0 through 11 ACC \u2190 ACC / M[address]\nJMPZ 9 address 0 through 11 if (ACC == 0)\nPC \u2190 address\nJMPN A address 0 through 11 if (ACC < 0)\nPC \u2190 address\nJMP B address 0 through 11 PC \u2190 address\nADDI C immediate 0 through 11 ACC \u2190 ACC + immediate\nLOADI D address 0 through 11 ACC \u2190 M[M[address]]\nSTOREI E address 0 through 11 M[M[address]] \u2190 ACC\nTable 2.1: The WOMBAT instruction set\nChapter 3\nAssembler\nThe assembler is currently in beta version. It has weak syntax error diag-\nnostic reporting.\nThe assembler is line oriented and only one instruction is permitted per\nline. All elements are delimited by white space.\nThe general form of an assembly line are:\n[label:] [mnemonic [label | number]] [comment]\nlabel: .data number number [comment]\n3.1 Comments\nComments begin with either a semicolon (;) or with two slashes (//) and end\nwith the end of the line. As such, a comment must be the last item on a line.\n3.2 Numeric Literals (numbers)\nThe assembler supports signed integer literals in four formats: binary, octal,\ndecimal and hex. Decimal values are the default and are represented as\nintegers. Rules for encoding other values are given in table 3.1\n3.3 Mnemonics\nThe instruction set is given in table 2.1 with Mnemonics listed in the first\ncolumn. Mnemonics are case insensitive but must be delimited by white\n11\n12 CHAPTER 3. ASSEMBLER\nFormat Prefix Example\nBinary bx -bx0011001000001001\nOctal ox ox1734\nDecimal -1234\nHexadecimal hx hx3245\nTable 3.1: WAS Number Representation\nspace.\n3.4 Labels\nLabels are case sensitive, must begin with an alpha character and contain\nonly letters, digits and the underscore. A label must not be a reserved word.\nLabels can be used in place of any operand. All labels must be resolved in\nthe first pass of the assembler.\nInorderforalabeltoberesolved, itmustbedeclared. Labelsaredeclared\nas an optional first element of a line. A label declaration consists of a legal\nlabel followed by a colon. Multiple labels can point to the same address.\n3.5 Data\nDataisdeclaredwithadataline. Suchalinemustbeginwithalabel, contain\nthe assembly directive .data, a size (in bytes) and a value. The byte size\nmust be even. All words are assigned the same value.\nThe directive:\nfoo: .data 6 -1\nsets aside three words (6 bytes) at the current memory location. Each word\nis initialized to -1.\n3.6 Invoking the Assembler\nThe current version of the assembler expects the filename of the source code\nto be the last argument given. Other arguments are listed in table 3.2.\nExamples of command line use include:\n3.7. EXAMPLE CODE 13\nFlag Arguments Explanation\n-o output file name The default output file is a.out. This flag will override\nthe default and use the next argument as the output file\nname.\n-v Verbose. A small amount of diagnostic information is\nprinted when the -v flag is used.\n-t Symbol Table. Print the labels encountered in the pro-\ngram along with addresses.\nTable 3.2: WAS Command Line Arguments\nwas bigger.a\nAssembles bigger.a to produce the executable file a.out.\nwas -o bigger bigger.a\nAssembles bigger.a to produce the executable file bigger.\n3.7 Example Code\nThe following code examples represent the test cases for the was assembler.\nThe source code for these programs in available in the progs directory in the\nWOMBAT source code tree.\nPlease note, the text processing package may have wrapped some of the\nlines in the code listing in this document. Comments extending over multiple\nlines are not legal in WOMBAT assembly.\n;\n; This program will read in two values and print out the\nbigger\n;\n; read and store the first number\nread\nstore a\n; read and store the second number\nread\n14 CHAPTER 3. ASSEMBLER\nstore b\n; subtract acc = b\u2212a\n; if acc < 0 then a> b, else b>= a\nsubtract a\njmpn bigA\n; b is bigger , so load b for output\nload b\njmp end\n; a is bigger , so load a for output\nbigA: load a\n; print the bigger number\nend: write\n; exit\nstop\n; storage for the numbers\na: .data 2 0\nb: .data 2 0\nListing 3.1: bigger.a, code to print the larger of two numbers\nThis program will read two values from the user and print the larger of\nthe two.\nload zero ; initialize the LCV\nLoop:\nstore LCV ; store the LCV\nsubtract maxsize ; if lcv >= MAXSIZE\njmpz END ; exit the program\nload LCV ; tmp = lcv \u2217 lcv\nmultiply LCV\nwrite ; cout << tmp\nload LCV ; lcv ++\naddi 1\njmp Loop\nEND: stop\n3.7. EXAMPLE CODE 15\nzero : .data 2 0\nLCV: .data 2 0\nmaxsize: .data 2 10;\nListing 3.2: power.a, code to compute i2 for i <= 10\nA simple looping program to compute i2 for 0 <= i <= 10. This pro-\ngram demonstrates use of a loop control variable (LCV), the addi and jmpz\ninstructions.\n; this program will attempt to emulate a random number\ngenerator\n;\nread\nstore RNG seed\n; i = 0\nload zero\nstore i\nLoop:\nload i\nsubtract max\njmpz EXIT\n; seed \u2217 a + c\nload RNG seed\nmultiply RNGA\nadd RNGC\nstore RNG seed\n; seed % m <\u2212> seed \u2212 (seed/m)\u2217m\ndivide RNGM\nMULTIPLY RNGM\nstore RNGTMP\nload RNG seed\nsubtract RNGTMP\nstore RNG seed\n// done with RNG\nwrite\nload i\n16 CHAPTER 3. ASSEMBLER\naddi 1\nstore i\njmp Loop\nEXIT: stop\n; data for the main loop\nzero : .data 2 0\ni : .data 2 0\nmax: .data 2 10\n; data area for the RNG\nRNG seed: .data 2 0\nRNGA: .data 2 41 ;(a\u22121) should be divisable by\nall prime factors of m\nRNGC: .data 2 17 ; c and m should be relatively\nprime\nRNGM: .data 2 100\nRNGTMP: .data 2 0\nListing 3.3: random.a, a program to generate 10 random numbers\nThis program uses the Linear congenital method for random number gen-\neration. (X \u2261 (aX +c)%m). The program asks the user for a seed value\nn+1 n\nand generates ten random values based upon that seed.\n; This program will compute the squares of the numbers 0\nthrough 19\n; But it will do it by storing the values in an array and\nthen squaring\n; each entry into the array\n;\n; It will finish by printing the array\n; initialize the array\n; for(i=0;i<size ; i++) {\n; array [ i ] = i\n; }\nLoop1:\nload i ; load lcv\n3.7. EXAMPLE CODE 17\nsubtract size ; subtract the upper limit\njmpz Loop1E ; branch if the two are equal , (\nexit loop)\nload i ; load i\nadd i ; (2i)\naddi array ; compute the effective address (\nbase + 2\u2217i)\nstore address\nload i\nstorei address ; m[ address ] = i\naddi 1 ; i++\nstore i ; store the new lcv back to i\njmp Loop1\nLoop1E:\n; Now step through and square all elements in the array\n; for(i=0;i<size ; i++) {\n; array [ i ] \u2217= array [ i ]\n; }\nload i ; i = 0\nsubtract i\nstore i\nLoop2:\nload i ; if i == size\nsubtract size\njmpz Loop2E ; end loop\nload i ; address = base + 2\u2217i\nadd i\naddi array\nstore address\nloadi address ; tmp = m[ address ]\nstore tmp ; tmp = tmp \u2217 tmp\nmultiply tmp\n18 CHAPTER 3. ASSEMBLER\nstorei address ; m[ address ] = tmp\u2217 tmp\nload i ; i++\naddi 1\nstore i ;\njmp Loop2\nLoop2E:\n; finally , print out the array\nload i ; i = 0\nsubtract i\nstore i\nLoop3:\nload i ; if i == size\nsubtract size\njmpz EXIT ; end loop\nload i\nadd i ; address = base + 2\u2217i\naddi array\nstore address\nloadi address ;\nwrite\nload i ; i++\naddi 1\nstore i ;\njmp Loop3\nEXIT:\nstop\n// data section\ni : .data 2 0\ntmp: .data 2 0\nsize : .data 2 20\n3.8. ERROR MESSAGES 19\naddress : .data 2 0\narray : .data 40 \u22121 ; initialize the entire array\nto be \u22121\nListing 3.4: SimpleArray.a, a program to demonstrate array access\nThis program demonstrates array access.\n3.8 Error Messages\n20 CHAPTER 3. ASSEMBLER\nChapter 4\nSimulator\nThere are two version of the simulator. An instruction level based simulator\nand a microcode level GUI simulation.\n21\n",
  "context": "right hand side to the location on the left hand side. ACC \u2190 BUS\nrepresents moving the value on the bus to the accumulator.\n\u2022 Basic arithmetic operations are represented by the following symbols:",
  "source_file": "resources\\Year 2\\Wombat Machine\\Wombat Machine.pdf",
  "line_numbers": [
    107,
    398
  ]
}
{
  "title": "introduction-to-matlab",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "1.4.11 Getting help .",
  "code": "2.1 Mathematical functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.1.1 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\ni\n2.2 Basic plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2.2.1 overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2.2.2 Creating simple plots . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2.2.3 Adding titles, axis labels, and annotations . . . . . . . . . . . . . . . 15\n2.2.4 Multiple data sets in one plot . . . . . . . . . . . . . . . . . . . . . . 16\n2.2.5 Specifying line styles and colors . . . . . . . . . . . . . . . . . . . . . 17\n2.3 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n2.4 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2.5 Matrix generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2.5.1 Entering a vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2.5.2 Entering a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n2.5.3 Matrix indexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n2.5.4 Colon operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n2.5.5 Linear spacing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n2.5.6 Colon operator in a matrix . . . . . . . . . . . . . . . . . . . . . . . . 22\n2.5.7 Creating a sub-matrix . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n2.5.8 Deleting row or column . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n2.5.9 Dimension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n2.5.10 Continuation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2.5.11 Transposing a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2.5.12 Concatenating matrices . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2.5.13 Matrix generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n2.5.14 Special matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n2.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n3 Array operations and Linear equations 30\n3.1 Array operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n3.1.1 Matrix arithmetic operations . . . . . . . . . . . . . . . . . . . . . . . 30\n3.1.2 Array arithmetic operations . . . . . . . . . . . . . . . . . . . . . . . 30\n3.2 Solving linear equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n3.2.1 Matrix inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nii\n3.2.2 Matrix functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n3.3 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n4 Introduction to programming in MATLAB 35\n4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n4.2 M-File Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n4.2.1 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n4.2.2 Script side-effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n4.3 M-File functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n4.3.1 Anatomy of a M-File function . . . . . . . . . . . . . . . . . . . . . . 38\n4.3.2 Input and output arguments . . . . . . . . . . . . . . . . . . . . . . . 40\n4.4 Input to a script file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n4.5 Output commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n4.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n5 Control flow and operators 43\n5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n5.2 Control flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n5.2.1 The \u2018\u2018if...end\u2019\u2019 structure . . . . . . . . . . . . . . . . . . . . . . . 43\n5.2.2 Relational and logical operators . . . . . . . . . . . . . . . . . . . . . 45\n5.2.3 The \u2018\u2018for...end\u2019\u2019 loop . . . . . . . . . . . . . . . . . . . . . . . . . 45\n5.2.4 The \u2018\u2018while...end\u2019\u2019 loop . . . . . . . . . . . . . . . . . . . . . . . 46\n5.2.5 Other flow structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n5.2.6 Operator precedence . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n5.3 Saving output to a file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n5.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n6 Debugging M-files 49\n6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n6.2 Debugging process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n6.2.1 Preparing for debugging . . . . . . . . . . . . . . . . . . . . . . . . . 50\n6.2.2 Setting breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\niii\n6.2.3 Running with breakpoints . . . . . . . . . . . . . . . . . . . . . . . . 50\n6.2.4 Examining values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n6.2.5 Correcting and ending debugging . . . . . . . . . . . . . . . . . . . . 51\n6.2.6 Ending debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n6.2.7 Correcting an M-file . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nA Summary of commands 53\nB Release notes for Release 14 with Service Pack 2 58\nB.1 Summary of changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nB.2 Other changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nB.3 Further details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nC Main characteristics of MATLAB 62\nC.1 History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\nC.2 Strengths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\nC.3 Weaknesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nC.4 Competition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\niv\nList of Tables\n1.1 Basic arithmetic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.2 Hierarchy of arithmetic operations . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.1 Elementary functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.2 Predefined constant values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2.3 Attributes for plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n2.4 Elementary matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n2.5 Special matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n3.1 Array operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n3.2 Summary of matrix and array operations . . . . . . . . . . . . . . . . . . . . 32\n3.3 Matrix functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n4.1 Anatomy of a M-File function . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n4.2 Difference between scripts and functions . . . . . . . . . . . . . . . . . . . . 39\n4.3 Example of input and output arguments . . . . . . . . . . . . . . . . . . . . 40\n4.4 disp and fprintf commands . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n5.1 Relational and logical operators . . . . . . . . . . . . . . . . . . . . . . . . . 45\n5.2 Operator precedence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nA.1 Arithmetic operators and special characters . . . . . . . . . . . . . . . 53\nA.2 Array operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\nA.3 Relational and logical operators . . . . . . . . . . . . . . . . . . . . . . 54\nA.4 Managing workspace and file commands . . . . . . . . . . . . . . . . . 55\nA.5 Predefined variables and math constants . . . . . . . . . . . . . . . . . 55\nv\nA.6 Elementary matrices and arrays . . . . . . . . . . . . . . . . . . . . . . 56\nA.7 Arrays and Matrices: Basic information . . . . . . . . . . . . . . . . . 56\nA.8 Arrays and Matrices: operations and manipulation . . . . . . . . . . 56\nA.9 Arrays and Matrices: matrix analysis and linear equations . . . . . 57\nvi\nList of Figures\n1.1 The graphical interface to the MATLAB workspace . . . . . . . . . . . . . . 3\n2.1 Plot for the vectors x and y . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.2 Plot of the Sine function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n2.3 Typical example of multiple plots . . . . . . . . . . . . . . . . . . . . . . . . 17\nvii\nPreface\n\u201cIntroduction to MATLAB for Engineering Students\u201d is a document for an introductory\ncourse in MATLAB\n(cid:176)R\n1 and technical computing. It is used for freshmen classes at North-\nwestern University. This document is not a comprehensive introduction or a reference man-\nual. Instead, it focuses on the specific features of MATLAB that are useful for engineering\nclasses. The lab sessions are used with one main goal: to allow students to become familiar\nwith computer software (e.g., MATLAB) to solve application problems. We assume that the\nstudents have no prior experience with MATLAB.\nTheavailabilityoftechnicalcomputingenvironmentsuchasMATLABisnowreshaping\nthe role and applications of computer laboratory projects to involve students in more intense\nproblem-solving experience. This availability also provides an opportunity to easily conduct\nnumerical experiments and to tackle realistic and more complicated problems.\nOriginally, the manual is divided into computer laboratory sessions (labs). The lab\ndocument is designed to be used by the students while working at the computer. The\nemphasis here is \u201clearning by doing\u201d. This quiz-likesession is supposed to be fully completed\nin 50 minutes in class.\nThe seven lab sessions include not only the basic concepts of MATLAB, but also an in-\ntroduction to scientific computing, in which they will be useful for the upcoming engineering\ncourses. In addition, engineering students will see MATLAB in their other courses.\nThe end of this document contains two useful sections: a Glossary which contains the\nbrief summary of the commands and built-in functions as well as a collection of release notes.\nThe release notes, which include several new features of the Release 14 with Service Pack\n2, well known as R14SP2, can also be found in Appendix. All of the MATLAB commands\nhave been tested to take advantage with new features of the current version of MATLAB\navailable here at Northwestern (R14SP2). Although, most of the examples and exercises still\nwork with previous releases as well.\nThis manual reflects the ongoing effort of the McCormick School of Engineering and\nApplied Science leading by Dean Stephen Carr to institute a significant technical computing\nin the Engineering First\n(cid:176)R\n2 courses taught at Northwestern University.\nFinally, the students - Engineering Analysis (EA) Section - deserve my special grati-\ntude. They were very active participants in class.\nDavid Houcque\nEvanston, Illinois\nAugust 2005\n1MATLAB\n(cid:176)R\nis a registered trademark of MathWorks, Inc.\n2Engineering First\n(cid:176)R\nis a registered trademark of McCormick\nSchool of Engineering and Applied Science (Northwestern University)\nviii\nAcknowledgements\nI would like to thank Dean Stephen Carr for his constant support. I am grateful to a number\nof people who offered helpful advice and comments. I want to thank the EA1 instructors\n(Fall Quarter 2004), in particular Randy Freeman, Jorge Nocedal, and Allen Taflove for\ntheir helpful reviews on some specific parts of the document. I also want to thank Malcomb\nMacIver, EA3 Honors instructor (Spring 2005) for helping me to better understand the\nanimation of system dynamics using MATLAB. I am particularly indebted to the many\nstudents (340 or so) who have used these materials, and have communicated their comments\nand suggestions. Finally, I want to thank IT personnel for helping setting up the classes and\nother computer related work: Rebecca Swierz, Jesse Becker, Rick Mazec, Alan Wolff, Ken\nKalan, Mike Vilches, and Daniel Lee.\nAbout the author\nDavid Houcque has more than 25 years\u2019 experience in the modeling and simulation of struc-\ntures and solid continua including 14 years in industry. In industry, he has been working as\nR&D engineer in the fields of nuclear engineering, oil rig platform offshore design, oil reser-\nvoir engineering, and steel industry. All of these include working in different international\nenvironments: Germany, France, Norway, and United Arab Emirates. Among other things,\nhe has a combined background experience: scientific computing and engineering expertise.\nHe earned his academic degrees from Europe and the United States.\nHere at Northwestern University, he is working under the supervision of Professor Brian\nMoran, a world-renowned expert in fracture mechanics, to investigate the integrity assess-\nment of the aging highway bridges under severe operating conditions and corrosion.\nix\nChapter 1\nTutorial lessons 1\n1.1 Introduction\nThe tutorials are independent of the rest of the document. The primarily objective is to help\nyou learn quickly the first steps. The emphasis here is \u201clearning by doing\u201d. Therefore, the\nbest way to learn is by trying it yourself. Working through the examples will give you a feel\nfor the way that MATLAB operates. In this introduction we will describe how MATLAB\nhandles simple numerical expressions and mathematical formulas.\nThe name MATLAB stands for MATrix LABoratory. MATLAB was written originally\ntoprovideeasyaccesstomatrixsoftwaredevelopedbytheLINPACK(linearsystempackage)\nand EISPACK (Eigen system package) projects.\nMATLAB [1] is a high-performance language for technical computing. It integrates\ncomputation, visualization, and programming environment. Furthermore, MATLAB is a\nmodern programming language environment: it has sophisticated data structures, contains\nbuilt-ineditinganddebugging tools,andsupportsobject-oriented programming. Thesefactors\nmake MATLAB an excellent tool for teaching and research.\nMATLAB has many advantages compared to conventional computer languages (e.g.,\nC, FORTRAN) for solving technical problems. MATLAB is an interactive system whose\nbasic data element is an array that does not require dimensioning. The software package\nhas been commercially available since 1984 and is now considered as a standard tool at most\nuniversities and industries worldwide.\nIt has powerful built-in routines that enable a very wide variety of computations. It\nalso has easy to use graphics commands that make the visualization of results immediately\navailable. Specific applications are collected in packages referred to as toolbox. There are\ntoolboxes for signal processing, symbolic computation, control theory, simulation, optimiza-\ntion, and several other fields of applied science and engineering.\nInadditiontotheMATLABdocumentationwhichismostlyavailableon-line, wewould\n1\nrecommend the following books: [2], [3], [4], [5], [6], [7], [8], and [9]. They are excellent in\ntheir specific applications.\n1.2 Basic features\nAs we mentioned earlier, the following tutorial lessons are designed to get you started\nquickly in MATLAB. The lessons are intended to make you familiar with the basics of\nMATLAB. We urge you to complete the exercises given at the end of each lesson.\n1.3 A minimum MATLAB session\nThe goal of this minimum session (also called starting and exiting sessions) is to learn the\nfirst steps:\n\u2022 How to log on\n\u2022 Invoke MATLAB\n\u2022 Do a few simple calculations\n\u2022 How to quit MATLAB\n1.3.1 Starting MATLAB\nAfterloggingintoyouraccount, youcanenterMATLABbydouble-clickingontheMATLAB\nshortcut icon (MATLAB 7.0.4) on your Windows desktop. When you start MATLAB, a\nspecialwindowcalledtheMATLABdesktopappears. Thedesktopisawindowthatcontains\nother windows. The major tools within or accessible from the desktop are:\n\u2022 The Command Window\n\u2022 The Command History\n\u2022 The Workspace\n\u2022 The Current Directory\n\u2022 The Help Browser\n\u2022 The Start button\n2\nFigure 1.1: The graphical interface to the MATLAB workspace\n3\nWhen MATLAB is started for the first time, the screen looks like the one that shown\nin the Figure 1.1. This illustration also shows the default configuration of the MATLAB\ndesktop. You can customize the arrangement of tools and documents to suit your needs.\nNow, we are interested in doing some simple calculations. We will assume that you\nhave sufficient understanding of your computer under which MATLAB is being run.\nYou are now faced with the MATLAB desktop on your computer, which contains the prompt\n(>>) in the Command Window. Usually, there are 2 types of prompt:\n>> for full version\nEDU> for educational version\nNote: To simplify the notation, we will use this prompt, >>, as a standard prompt sign,\nthough our MATLAB version is for educational purpose.\n1.3.2 Using MATLAB as a calculator\nAs an example of a simple interactive calculation, just type the expression you want to\nevaluate. Let\u2019s start at the very beginning. For example, let\u2019s suppose you want to calculate\nthe expression, 1+2\u00d73. You type it at the prompt command (>>) as follows,\n>> 1+2*3\nans =\n7\nYou will have noticed that if you do not specify an output variable, MATLAB uses a\ndefault variable ans, short for answer, to store the results of the current calculation. Note\nthat the variable ans is created (or overwritten, if it is already existed). To avoid this, you\nmay assign a value to a variable or output argument name. For example,\n>> x = 1+2*3\nx =\n7\nwill result in x being given the value 1 + 2 \u00d7 3 = 7. This variable name can always\nbe used to refer to the results of the previous computations. Therefore, computing 4x will\nresult in\n>> 4*x\nans =\n28.0000\nBefore we conclude this minimum session, Table 1.1 gives the partial list of arithmetic\noperators.\n4\nTable 1.1: Basic arithmetic operators\nSymbol Operation Example\n+ Addition 2+3\n\u2212 Subtraction 2\u22123\n\u2217 Multiplication 2\u22173\n/ Division 2/3\n1.3.3 Quitting MATLAB\nTo end your MATLAB session, type quit in the Command Window, or select File \u2212\u2192 Exit\nMATLAB in the desktop main menu.\n1.4 Getting started\nAfter learning the minimum MATLAB session, we will now learn to use some additional\noperations.\n1.4.1 Creating MATLAB variables\nMATLAB variables are created with an assignment statement. The syntax of variable as-\nsignment is\nvariable name = a value (or an expression)\nFor example,\n>> x = expression\nwhere expression is a combination of numerical values, mathematical operators, variables,\nand function calls. On other words, expression can involve:\n\u2022 manual entry\n\u2022 built-in functions\n\u2022 user-defined functions\n5\n1.4.2 Overwriting variable\nOnce a variable has been created, it can be reassigned. In addition, if you do not wish to\nsee the intermediate results, you can suppress the numerical output by putting a semicolon\n(;) at the end of the line. Then the sequence of commands looks like this:\n>> t = 5;\n>> t = t+1\nt =\n6\n1.4.3 Error messages\nIf we enter an expression incorrectly, MATLAB will return an error message. For example,\nin the following, we left out the multiplication sign, *, in the following expression\n>> x = 10;\n>> 5x\n??? 5x\n|\nError: Unexpected MATLAB expression.\n1.4.4 Making corrections\nTo make corrections, we can, of course retype the expressions. But if the expression is\nlengthy, we make more mistakes by typing a second time. A previously typed command\ncan be recalled with the up-arrow key \u2191. When the command is displayed at the command\nprompt, it can be modified if needed and executed.\n1.4.5 Controlling the hierarchy of operations or precedence\nLet\u2019s consider the previous arithmetic operation, but now we will include parentheses. For\nexample, 1+2\u00d73 will become (1+2)\u00d73\n>> (1+2)*3\nans =\n9\nand, from previous example\n6\n>> 1+2*3\nans =\n7\nBy adding parentheses, these two expressions give different results: 9 and 7.\nThe order in which MATLAB performs arithmetic operations is exactly that taught\nin high school algebra courses. Exponentiations are done first, followed by multiplications\nand divisions, and finally by additions and subtractions. However, the standard order of\nprecedence of arithmetic operations can be changed by inserting parentheses. For example,\ntheresultof1+2\u00d73isquitedifferentthanthesimilarexpressionwithparentheses(1+2)\u00d73.\nThe results are 7 and 9 respectively. Parentheses can always be used to overrule priority,\nand their use is recommended in some complex expressions to avoid ambiguity.\nTherefore, to make the evaluation of expressions unambiguous, MATLAB has estab-\nlished a series of rules. The order in which the arithmetic operations are evaluated is given\nin Table 1.2. MATLAB arithmetic operators obey the same precedence rules as those in\nTable 1.2: Hierarchy of arithmetic operations\nPrecedence Mathematical operations\nFirst The contents of all parentheses are evaluated first, starting\nfrom the innermost parentheses and working outward.\nSecond All exponentials are evaluated, working from left to right\nThird All multiplications and divisions are evaluated, working\nfrom left to right\nFourth All additions and subtractions are evaluated, starting\nfrom left to right\nmost computer programs. For operators of equal precedence, evaluation is from left to right.\nNow, consider another example:\n1 4 6\n+ \u00d7\n2+32 5 7\nIn MATLAB, it becomes\n>> 1/(2+3^2)+4/5*6/7\nans =\n0.7766\nor, if parentheses are missing,\n>> 1/2+3^2+4/5*6/7\nans =\n10.1857\n7\nSo here what we get: two different results. Therefore, we want to emphasize the importance\nof precedence rule in order to avoid ambiguity.\n1.4.6 Controlling the appearance of floating point number\nMATLAB by default displays only 4 decimals in the result of the calculations, for example\n\u2212163.6667, as shown in above examples. However, MATLAB does numerical calculations\nin double precision, which is 15 digits. The command format controls how the results of\ncomputations are displayed. Here are some examples of the different formats together with\nthe resulting outputs.\n>> format short\n>> x=-163.6667\nIf we want to see all 15 digits, we use the command format long\n>> format long\n>> x= -1.636666666666667e+002\nTo return to the standard format, enter format short, or simply format.\nThere are several other formats. For more details, see the MATLAB documentation,\nor type help format.\nNote - Up to now, we have let MATLAB repeat everything that we enter at the\nprompt (>>). Sometimes this is not quite useful, in particular when the output is pages en\nlength. To prevent MATLAB from echoing what we type, simply enter a semicolon (;) at\nthe end of the command. For example,\n>> x=-163.6667;\nand then ask about the value of x by typing,\n>> x\nx =\n-163.6667\n1.4.7 Managing the workspace\nThe contents of the workspace persist between the executions of separate commands. There-\nfore, it is possible for the results of one problem to have an effect on the next one. To avoid\nthis possibility, it is a good idea to issue a clear command at the start of each new inde-\npendent calculation.\n8\n>> clear\nThe command clear or clear all removes all variables from the workspace. This\nfrees up system memory. In order to display a list of the variables currently in the memory,\ntype\n>> who\nwhile, whos will give more details which include size, space allocation, and class of the\nvariables.\n1.4.8 Keeping track of your work session\nIt is possible to keep track of everything done during a MATLAB session with the diary\ncommand.\n>> diary\nor give a name to a created file,\n>> diary FileName\nwhere FileName could be any arbitrary name you choose.\nThe function diary is useful if you want to save a complete MATLAB session. They\nsave all input and output as they appear in the MATLAB window. When you want to stop\nthe recording, enter diary off. If you want to start recording again, enter diary on. The\nfile that is created is a simple text file. It can be opened by an editor or a word processing\nprogram and edited to remove extraneous material, or to add your comments. You can\nuse the function type to view the diary file or you can edit in a text editor or print. This\ncommand is useful, for example in the process of preparing a homework or lab submission.\n1.4.9 Entering multiple statements per line\nIt is possible to enter multiple statements per line. Use commas (,) or semicolons (;) to\nenter more than one statement at once. Commas (,) allow multiple statements per line\nwithout suppressing output.\n>> a=7; b=cos(a), c=cosh(a)\nb =\n0.6570\nc =\n548.3170\n9\n1.4.10 Miscellaneous commands\nHere are few additional useful commands:\n\u2022 To clear the Command Window, type clc\n\u2022 To abort a MATLAB computation, type ctrl-c\n\u2022 To continue a line, type ...\n1.4.11 Getting help\nTo view the online documentation, select MATLAB Help from Help menu or MATLAB Help\ndirectly in the Command Window. The preferred method is to use the Help Browser. The\nHelp Browser can be started by selecting the ? icon from the desktop toolbar. On the other\nhand, information about any command is available by typing\n>> help Command\nAnother way to get help is to use the lookfor command. The lookfor command differs\nfrom the help command. The help command searches for an exact function name match,\nwhile the lookfor command searches the quick summary information in each function for\na match. For example, suppose that we were looking for a function to take the inverse of\na matrix. Since MATLAB does not have a function named inverse, the command help\ninverse will produce nothing. On the other hand, the command lookfor inverse will\nproduce detailed information, which includes the function of interest, inv.\n>> lookfor inverse\nNote - At this particular time of our study, it is important to emphasize one main point.\nBecause MATLAB is a huge program; it is impossible to cover all the details of each function\none by one. However, we will give you information how to get help. Here are some examples:\n\u2022 Use on-line help to request info on a specific function\n>> help sqrt\n\u2022 In the current version (MATLAB version 7), the doc function opens the on-line version\nof the help manual. This is very helpful for more complex commands.\n>> doc plot\n10\n\u2022 Use lookfor to find functions by keywords. The general form is\n>> lookfor FunctionName\n1.5 Exercises\nNote: DuetotheteachingclassduringthisFall2005, the problems aretemporarily removed\nfrom this section.\n11\nChapter 2\nTutorial lessons 2\n2.1 Mathematical functions\nMATLAB offers many predefined mathematical functions for technical computing which\ncontains a large set of mathematical functions.\nTyping help elfun and help specfun calls up full lists of elementary and special\nfunctions respectively.\nThere is a long list of mathematical functions that are built into MATLAB. These\nfunctions are called built-ins. Many standard mathematical functions, such as sin(x), cos(x),\ntan(x), ex, ln(x), are evaluated by the functions sin, cos, tan, exp, and log respectively in\nMATLAB.\nTable 2.1 lists some commonly used functions, where variables x and y can be numbers,\nvectors, or matrices.\nTable 2.1: Elementary functions\ncos(x) Cosine abs(x) Absolute value\nsin(x) Sine sign(x) Signum function\ntan(x) Tangent max(x) Maximum value\nacos(x) Arc cosine min(x) Minimum value\nasin(x) Arc sine ceil(x) Round towards +\u221e\natan(x) Arc tangent floor(x) Round towards \u2212\u221e\nexp(x) Exponential round(x) Round to nearest integer\nsqrt(x) Square root rem(x) Remainder after division\nlog(x) Natural logarithm angle(x) Phase angle\nlog10(x) Common logarithm conj(x) Complex conjugate\nIn addition to the elementary functions, MATLAB includes a number of predefined\n12\nconstant values. A list of the most common values is given in Table 2.2.\nTable 2.2: Predefined constant values\npi The \u03c0 number, \u03c0 = 3.14159...\n\u221a\ni,j The imaginary unit i, \u22121\nInf The infinity, \u221e\nNaN Not a number\n2.1.1 Examples\nWeillustrateheresometypicalexampleswhichrelatedtotheelementaryfunctionspreviously\ndefined.\n\u221a\nAs a first example, the value of the expression y = e\u2212asin(x)+10 y, for a = 5, x = 2, and\ny = 8 is computed by\n>> a = 5; x = 2; y = 8;\n>> y = exp(-a)*sin(x)+10*sqrt(y)\ny =\n28.2904\nThe subsequent examples are\n>> log(142)\nans =\n4.9558\n>> log10(142)\nans =\n2.1523\nNote the difference between the natural logarithm log(x) and the decimal logarithm (base\n10) log10(x).\nTo calculate sin(\u03c0/4) and e10, we enter the following commands in MATLAB,\n>> sin(pi/4)\nans =\n0.7071\n>> exp(10)\nans =\n2.2026e+004\n13\nNotes:\n\u2022 Only use built-in functions on the right hand side of an expression. Reassigning the\nvalue to a built-in function can create problems.\n\u221a\n\u2022 There are some exceptions. For example, i and j are pre-assigned to \u22121. However,\none or both of i or j are often used as loop indices.\n\u2022 To avoid any possible confusion, it is suggested to use instead ii or jj as loop indices.\n2.2 Basic plotting\n2.2.1 overview\nMATLAB has an excellent set of graphic tools. Plotting a given data set or the results\nof computation is possible with very few commands. You are highly encouraged to plot\nmathematical functions and results of analysis as often as possible. Trying to understand\nmathematicalequationswithgraphicsisanenjoyableandveryefficientwayoflearningmath-\nematics. Being able to plot mathematical functions and data freely is the most important\nstep, and this section is written to assist you to do just that.\n2.2.2 Creating simple plots\nThe basic MATLAB graphing procedure, for example in 2D, is to take a vector of x-\ncoordinates, x = (x ,...,x ), and a vector of y-coordinates, y = (y ,...,y ), locate the\n1 N 1 N\npoints (x ,y ), with i = 1,2,...,n and then join them by straight lines. You need to prepare\ni i\nx and y in an identical array form; namely, x and y are both row arrays or column arrays of\nthe same length.\nThe MATLAB command to plot a graph is plot(x,y). The vectors x = (1,2,3,4,5,6)\nand y = (3,\u22121,2,4,5,1) produce the picture shown in Figure 2.1.\n>> x = [1 2 3 4 5 6];\n>> y = [3 -1 2 4 5 1];\n>> plot(x,y)\nNote: The plot functions has different forms depending on the input arguments. If y is a\nvector plot(y)produces a piecewise linear graph of the elements of y versus the index of the\nelements of y. If we specify two vectors, as mentioned above, plot(x,y) produces a graph\nof y versus x.\nFor example, to plot the function sin(x) on the interval [0,2\u03c0], we first create a vector of\nx values ranging from 0 to 2\u03c0, then compute the sine of these values, and finally plot the\nresult:\n14\n5\n4\n3\n2\n1\n0\n\u22121\n1 2 3 4 5 6\nFigure 2.1: Plot for the vectors x and y\n>> x = 0:pi/100:2*pi;\n>> y = sin(x);\n>> plot(x,y)\nNotes:\n\u2022 0:pi/100:2*pi yields a vector that\n\u2013 starts at 0,\n\u2013 takes steps (or increments) of \u03c0/100,\n\u2013 stops when 2\u03c0 is reached.\n\u2022 If you omit the increment, MATLAB automatically increments by 1.\n2.2.3 Adding titles, axis labels, and annotations\nMATLAB enables you to add axis labels and titles. For example, using the graph from the\nprevious example, add an x- and y-axis labels.\nNow label the axes and add a title. The character \\pi creates the symbol \u03c0. An\nexample of 2D plot is shown in Figure 2.2.\n15\n1\n0.8\n0.6\n0.4\n0.2\n0\n\u22120.2\n\u22120.4\n\u22120.6\n\u22120.8\n\u22121\n0 1 2 3 4 5 6 7\nx = 0:2p\nx\nfo\neniS\nPlot of the Sine function\nFigure 2.2: Plot of the Sine function\n>> xlabel(\u2019x = 0:2\\pi\u2019)\n>> ylabel(\u2019Sine of x\u2019)\n>> title(\u2019Plot of the Sine function\u2019)\nThe color of a single curve is, by default, blue, but other colors are possible. The desired\ncolor is indicated by a third argument. For example, red is selected by plot(x,y,\u2019r\u2019). Note\nthe single quotes, \u2019 \u2019, around r.\n2.2.4 Multiple data sets in one plot\nMultiple(x,y)pairs argumentscreatemultiple graphswithasinglecalltoplot. Forexample,\nthese statements plot three related functions of x: y = 2cos(x), y = cos(x), and y =\n1 2 3\n0.5\u2217cos(x), in the interval 0 \u2264 x \u2264 2\u03c0.\n>> x = 0:pi/100:2*pi;\n>> y1 = 2*cos(x);\n>> y2 = cos(x);\n>> y3 = 0.5*cos(x);\n>> plot(x,y1,\u2019--\u2019,x,y2,\u2019-\u2019,x,y3,\u2019:\u2019)\n>> xlabel(\u20190 \\leq x \\leq 2\\pi\u2019)\n>> ylabel(\u2019Cosine functions\u2019)\n>> legend(\u20192*cos(x)\u2019,\u2019cos(x)\u2019,\u20190.5*cos(x)\u2019)\n16\n>> title(\u2019Typical example of multiple plots\u2019)\n>> axis([0 2*pi -3 3])\nThe result of multiple data sets in one graph plot is shown in Figure 2.3.\n3\n2\n1\n0\n\u22121\n\u22122\n\u22123\n0 1 2 3 4 5 6\n0 \u00a3 x \u00a3 2p\nsnoitcnuf\nenisoC\nTypical example of multiple plots\n2*cos(x)\ncos(x)\n0.5*cos(x)\nFigure 2.3: Typical example of multiple plots\nBy default, MATLAB uses line style and color to distinguish the data sets plotted in\nthe graph. However, you can change the appearance of these graphic components or add\nannotations to the graph to help explain your data for presentation.\n2.2.5 Specifying line styles and colors\nIt is possible to specify line styles, colors, and markers (e.g., circles, plus signs, ...) using\nthe plot command:\nplot(x,y,\u2019style_color_marker\u2019)\nwhere style_color_marker is a triplet of values from Table 2.3.\nTo find additional information, type help plot or doc plot.\n17\nTable 2.3: Attributes for plot\nSymbol Color Symbol Line Style Symbol Marker\nk Black \u2212 Solid + Plus sign\nr Red \u2212\u2212 Dashed o Circle\nb Blue : Dotted \u2217 Asterisk\ng Green \u2212. Dash-dot . Point\nc Cyan none No line \u00d7 Cross\nm Magenta s Square\ny Yellow d Diamond\n2.3 Exercises\nNote: Due to the teaching class during this Fall Quarter 2005, the problems are temporarily\nremoved from this section.\n18\n2.4 Introduction\nMatricesarethebasicelementsoftheMATLABenvironment. Amatrixisatwo-dimensional\narray consisting of m rows and n columns. Special cases are column vectors (n = 1) and row\nvectors (m = 1).\nIn this section we will illustrate how to apply different operations on matrices. The following\ntopicsarediscussed: vectorsandmatricesinMATLAB,theinverseofamatrix,determinants,\nand matrix manipulation.\nMATLAB supports two types of operations, known as matrix operations and array opera-\ntions. Matrix operations will be discussed first.\n2.5 Matrix generation\nMatrices are fundamental to MATLAB. Therefore, we need to become familiar with matrix\ngeneration and manipulation. Matrices can be generated in several ways.\n2.5.1 Entering a vector\nA vector is a special case of a matrix. The purpose of this section is to show how to create\nvectors and matrices in MATLAB. As discussed earlier, an array of dimension 1\u00d7n is called\na row vector, whereas an array of dimension m\u00d71 is called a column vector. The elements\nof vectors in MATLAB are enclosed by square brackets and are separated by spaces or by\ncommas. For example, to enter a row vector, v, type\n>> v = [1 4 7 10 13]\nv =\n1 4 7 10 13\nColumn vectors are created in a similar way, however, semicolon (;) must separate the\ncomponents of a column vector,\n>> w = [1;4;7;10;13]\nw =\n1\n4\n7\n10\n13\nOntheotherhand, arow vectorisconvertedtoacolumn vectorusingthetranspose operator.\nThe transpose operation is denoted by an apostrophe or a single quote (\u2019).\n19\n>> w = v\u2019\nw =\n1\n4\n7\n10\n13\nThus, v(1) is the first element of vector v, v(2) its second element, and so forth.\nFurthermore, to access blocks of elements, we use MATLAB\u2019s colon notation (:). For exam-\nple, to access the first three elements of v, we write,\n>> v(1:3)\nans =\n1 4 7\nOr, all elements from the third through the last elements,\n>> v(3,end)\nans =\n7 10 13\nwhere end signifies the last element in the vector. If v is a vector, writing\n>> v(:)\nproduces a column vector, whereas writing\n>> v(1:end)\nproduces a row vector.\n2.5.2 Entering a matrix\nA matrix is an array of numbers. To type a matrix into MATLAB you must\n\u2022 begin with a square bracket, [\n\u2022 separate elements in a row with spaces or commas (,)\n\u2022 use a semicolon (;) to separate rows\n\u2022 end the matrix with another square bracket, ].\n20\nHere is a typical example. To enter a matrix A, such as,\n\uf8ee \uf8f9\n1 2 3\nA = \uf8f0 4 5 6 \uf8fb (2.1)\n7 8 9\ntype,\n>> A = [1 2 3; 4 5 6; 7 8 9]\nMATLAB then displays the 3\u00d73 matrix as follows,\nA =\n1 2 3\n4 5 6\n7 8 9\nNote that the use of semicolons (;) here is different from their use mentioned earlier to\nsuppress output or to write multiple commands in a single line.\nOnce we have entered the matrix, it is automatically stored and remembered in the\nWorkspace. We can refer to it simply as matrix A. We can then view a particular element in\na matrix by specifying its location. We write,\n>> A(2,1)\nans =\n4\nA(2,1) is an element located in the second row and first column. Its value is 4.\n2.5.3 Matrix indexing\nWe select elements in a matrix just as we did for vectors, but now we need two indices.\nThe element of row i and column j of the matrix A is denoted by A(i,j). Thus, A(i,j)\nin MATLAB refers to the element A of matrix A. The first index is the row number and\nij\nthe second index is the column number. For example, A(1,3) is an element of first row and\nthird column. Here, A(1,3)=3.\nCorrecting any entry is easy through indexing. Here we substitute A(3,3)=9 by\nA(3,3)=0. The result is\n>> A(3,3) = 0\nA =\n1 2 3\n4 5 6\n7 8 0\n21\nSingle elements of a matrix are accessed as A(i,j), where i \u2265 1 and j \u2265 1. Zero or negative\nsubscripts are not supported in MATLAB.\n2.5.4 Colon operator\nThe colon operator will prove very useful and understanding how it works is the key to\nefficient and convenient usage of MATLAB. It occurs in several different forms.\nOften we must deal with matrices or vectors that are too large to enter one ele-\nment at a time. For example, suppose we want to enter a vector x consisting of points\n(0,0.1,0.2,0.3,\u00b7\u00b7\u00b7 ,5). We can use the command\n>> x = 0:0.1:5;\nThe row vector has 51 elements.\n2.5.5 Linear spacing\nOn the other hand, there is a command to generate linearly spaced vectors: linspace. It\nis similar to the colon operator (:), but gives direct control over the number of points. For\nexample,\ny = linspace(a,b)\ngenerates a row vector y of 100 points linearly spaced between and including a and b.\ny = linspace(a,b,n)\ngenerates a row vector y of n points linearly spaced between and including a and b. This is\nuseful when we want to divide an interval into a number of subintervals of the same length.\nFor example,\n>> theta = linspace(0,2*pi,101)\ndivides the interval [0,2\u03c0] into 100 equal subintervals, then creating a vector of 101 elements.\n2.5.6 Colon operator in a matrix\nThe colon operator can also be used to pick out a certain row or column. For example, the\nstatement A(m:n,k:l specifies rows m to n and column k to l. Subscript expressions refer\nto portions of a matrix. For example,\n22\n>> A(2,:)\nans =\n4 5 6\nis the second row elements of A.\nThe colon operator can also be used to extract a sub-matrix from a matrix A.\n>> A(:,2:3)\nans =\n2 3\n5 6\n8 0\nA(:,2:3) is a sub-matrix with the last two columns of A.\nA row or a column of a matrix can be deleted by setting it to a null vector, [ ].\n>> A(:,2)=[]\nans =\n1 3\n4 6\n7 0\n2.5.7 Creating a sub-matrix\nTo extract a submatrix B consisting of rows 2 and 3 and columns 1 and 2 of the matrix A,\ndo the following\n>> B = A([2 3],[1 2])\nB =\n4 5\n7 8\nTo interchange rows 1 and 2 of A, use the vector of row indices together with the colon\noperator.\n>> C = A([2 1 3],:)\nC =\n4 5 6\n1 2 3\n7 8 0\nIt is important to note that the colon operator (:) stands for all columns or all rows. To\ncreate a vector version of matrix A, do the following\n23\n>> A(:)\nans =\n1\n2\n3\n4\n5\n6\n7\n8\n0\nThe submatrix comprising the intersection of rows p to q and columns r to s is denoted by\nA(p:q,r:s).\nAs a special case, a colon (:) as the row or column specifier covers all entries in that row or\ncolumn; thus\n\u2022 A(:,j) is the jth column of A, while\n\u2022 A(i,:) is the ith row, and\n\u2022 A(end,:) picks out the last row of A.\nThe keyword end, used in A(end,:), denotes the last index in the specified dimension. Here\nare some examples.\n>> A\nA =\n1 2 3\n4 5 6\n7 8 9\n>> A(2:3,2:3)\nans =\n5 6\n8 9\n>> A(end:-1:1,end)\nans =\n9\n6\n3\n24\n>> A([1 3],[2 3])\nans =\n2 3\n8 9\n2.5.8 Deleting row or column\nTo delete a row or column of a matrix, use the empty vector operator, [ ].\n>> A(3,:) = []\nA =\n1 2 3\n4 5 6\nThird row of matrix A is now deleted. To restore the third row, we use a technique for\ncreating a matrix\n>> A = [A(1,:);A(2,:);[7 8 0]]\nA =\n1 2 3\n4 5 6\n7 8 0\nMatrix A is now restored to its original form.\n2.5.9 Dimension\nTo determine the dimensions of a matrix or vector, use the command size. For example,\n>> size(A)\nans =\n3 3\nmeans 3 rows and 3 columns.\nOr more explicitly with,\n>> [m,n]=size(A)\n25\n2.5.10 Continuation\nIf it is not possible to type the entire input on the same line, use consecutive periods, called\nan ellipsis ..., to signal continuation, then continue the input on the next line.\nB = [4/5 7.23*tan(x) sqrt(6); ...\n1/x^2 0 3/(x*log(x)); ...\nx-7 sqrt(3) x*sin(x)];\nNote that blank spaces around +, \u2212, = signs are optional, but they improve readability.\n2.5.11 Transposing a matrix\nThe transpose operation is denoted by an apostrophe or a single quote (\u2019). It flips a matrix\nabout its main diagonal and it turns a row vector into a column vector. Thus,\n>> A\u2019\nans =\n1 4 7\n2 5 8\n3 6 0\nBy using linear algebra notation, the transpose of m\u00d7n real matrix A is the n\u00d7m matrix\nthat results from interchanging the rows and columns of A. The transpose matrix is denoted\nAT.\n2.5.12 Concatenating matrices\nMatrices can be made up of sub-matrices. Here is an example. First, let\u2019s recall our previous\nmatrix A.\nA =\n1 2 3\n4 5 6\n7 8 9\nThe new matrix B will be,\n>> B = [A 10*A; -A [1 0 0; 0 1 0; 0 0 1]]\nB =\n1 2 3 10 20 30\n26\n4 5 6 40 50 60\n7 8 9 70 80 90\n-1 -2 -3 1 0 0\n-4 -5 -6 0 1 0\n-7 -8 -9 0 0 1\n2.5.13 Matrix generators\nMATLAB provides functions that generates elementary matrices. The matrix of zeros, the\nmatrix of ones, and the identity matrix are returned by the functions zeros, ones, and eye,\nrespectively.\nTable 2.4: Elementary matrices\neye(m,n) Returns an m-by-n matrix with 1 on the main diagonal\neye(n) Returns an n-by-n square identity matrix\nzeros(m,n) Returns an m-by-n matrix of zeros\nones(m,n) Returns an m-by-n matrix of ones\ndiag(A) Extracts the diagonal of matrix A\nrand(m,n) Returns an m-by-n matrix of random numbers\nFor a complete list of elementary matrices and matrix manipulations, type help elmat\nor doc elmat. Here are some examples:\n1. >> b=ones(3,1)\nb =\n1\n1\n1\nEquivalently, we can define b as >> b=[1;1;1]\n2. >> eye(3)\nans =\n1 0 0\n0 1 0\n0 0 1\n3. >> c=zeros(2,3)\nc =\n0 0 0\n27\n0 0 0\nIn addition, it is important to remember that the three elementary operations of ad-\ndition (+), subtraction (\u2212), and multiplication (\u2217) apply also to matrices whenever the\ndimensions are compatible.\nTwo other important matrix generation functions are rand and randn, which generate\nmatrices of (pseudo-)random numbers using the same syntax as eye.\nIn addition, matrices can be constructed in a block form. With C defined by C = [1\n2; 3 4], we may create a matrix D as follows\n>> D = [C zeros(2); ones(2) eye(2)]\nD =\n1 2 0 0\n3 4 0 0\n1 1 1 0\n1 1 0 1\n2.5.14 Special matrices\nMATLAB provides a number of special matrices (see Table 2.5). These matrices have inter-\nestingpropertiesthatmakethemusefulforconstructingexamplesandfortestingalgorithms.\nFor more information, see MATLAB documentation.\nTable 2.5: Special matrices\nhilb Hilbert matrix\ninvhilb Inverse Hilbert matrix\nmagic Magic square\npascal Pascal matrix\ntoeplitz Toeplitz matrix\nvander Vandermonde matrix\nwilkinson Wilkinson\u2019s eigenvalue test matrix\n28\n2.6 Exercises\nNote: Due to the teaching class during this Fall Quarter 2005, the problems are temporarily\nremoved from this section.\n29\nChapter 3\nArray operations and Linear\nequations\n3.1 Array operations\nMATLAB has two different types of arithmetic operations: matrix arithmetic operations\nand array arithmetic operations. We have seen matrix arithmetic operations in the previous\nlab. Now, we are interested in array operations.\n3.1.1 Matrix arithmetic operations\nAs we mentioned earlier, MATLAB allows arithmetic operations: +, \u2212, \u2217, and \u02c6 to be\ncarried out on matrices. Thus,\nA+B or B+A is valid if A and B are of the same size\nA*B is valid if A\u2019s number of column equals B\u2019s number of rows\nA^2 is valid if A is square and equals A*A\n\u03b1*A or A*\u03b1 multiplies each element of A by \u03b1\n3.1.2 Array arithmetic operations\nOn the other hand, array arithmetic operations or array operations for short, are done\nelement-by-element. The period character, ., distinguishes the array operations from the\nmatrix operations. However, since the matrix and array operations are the same for addition\n(+) and subtraction (\u2212), the character pairs (.+) and (.\u2212) are not used. The list of array\noperators is shown below in Table 3.2. If A and B are two matrices of the same size with\nelements A = [a ] and B = [b ], then the command\nij ij\n30\n.* Element-by-element multiplication\n./ Element-by-element division\n.^ Element-by-element exponentiation\nTable 3.1: Array operators\n>> C = A.*B\nproduces another matrix C of the same size with elements c = a b . For example, using\nij ij ij\nthe same 3\u00d73 matrices,\n\uf8ee \uf8f9 \uf8ee \uf8f9\n1 2 3 10 20 30\nA = \uf8f0 4 5 6 \uf8fb, B = \uf8f0 40 50 60 \uf8fb\n7 8 9 70 80 90\nwe have,\n>> C = A.*B\nC =\n10 40 90\n160 250 360\n490 640 810\nTo raise a scalar to a power, we use for example the command 10^2. If we want the\noperation to be applied to each element of a matrix, we use .^2. For example, if we want\nto produce a new matrix whose elements are the square of the elements of the matrix A, we\nenter\n>> A.^2\nans =\n1 4 9\n16 25 36\n49 64 81\nThe relations below summarize the above operations. To simplify, let\u2019s consider two\nvectors U and V with elements U = [u ] and V = [v ].\ni j\nU.\u2217V produces [u v u v ... u v ]\n1 1 2 2 n n\nU./V produces [u /v u /v ... u /v ]\n1 1 2 2 n n\nU.\u02c6V produces [uv1 uv2... uvn]\n1 2 n\n31\nOperation Matrix Array\nAddition + +\nSubtraction \u2212 \u2212\nMultiplication \u2217 .\u2217\nDivision / ./\nLeft division \\ .\\\nExponentiation \u02c6 .\u02c6\nTable 3.2: Summary of matrix and array operations\n3.2 Solving linear equations\nOne of the problems encountered most frequently in scientific computation is the solution of\nsystems of simultaneous linear equations. With matrix notation, a system of simultaneous\nlinear equations is written\nAx = b (3.1)\nwhere there are as many equations as unknown. A is a given square matrix of order n, b is a\ngiven column vector of n components, and x is an unknown column vector of n components.\nIn linear algebra we learn that the solution to Ax = b can be written as x = A\u22121b, where\nA\u22121 is the inverse of A.\nFor example, consider the following system of linear equations\n\uf8f1\n\uf8f2 x+2y +3z = 1\n4x+5y +6z = 1\n\uf8f3\n7x+8y = 1\nThe coefficient matrix A is\n\uf8ee \uf8f9 \uf8ee \uf8f9\n1 2 3 1\nA = \uf8f0 4 5 6 \uf8fb and the vector b = \uf8f0 1 \uf8fb\n7 8 9 1\nWith matrix notation, a system of simultaneous linear equations is written\nAx = b (3.2)\nThis equation can be solved for x using linear algebra. The result is x = A\u22121b.\nThere are typically two ways to solve for x in MATLAB:\n1. The first one is to use the matrix inverse, inv.\n32\n>> A = [1 2 3; 4 5 6; 7 8 0];\n>> b = [1; 1; 1];\n>> x = inv(A)*b\nx =\n-1.0000\n1.0000\n-0.0000\n2. The second one is to use the backslash (\\)operator. The numerical algorithm behind\nthis operator is computationally efficient. This is a numerically reliable way of solving\nsystem of linear equations by using a well-known process of Gaussian elimination.\n>> A = [1 2 3; 4 5 6; 7 8 0];\n>> b = [1; 1; 1];\n>> x = A\\b\nx =\n-1.0000\n1.0000\n-0.0000\nThis problem is at the heart of many problems in scientific computation. Hence it is impor-\ntant that we know how to solve this type of problem efficiently.\nNow, we know how to solve a system of linear equations. In addition to this, we will\nsee some additional details which relate to this particular topic.\n3.2.1 Matrix inverse\nLet\u2019s consider the same matrix A.\n\uf8ee \uf8f9\n1 2 3\nA = \uf8f0 4 5 6 \uf8fb\n7 8 0\nCalculating the inverse of A manually is probably not a pleasant work. Here the hand-\ncalculation of A\u22121 gives as a final result:\n\uf8ee \uf8f9\n\u221216 8 \u22121\n1\nA\u22121 = \uf8f0 14 \u22127 2 \uf8fb\n9\n\u22121 2 \u22121\nIn MATLAB, however, it becomes as simple as the following commands:\n33\n>> A = [1 2 3; 4 5 6; 7 8 0];\n>> inv(A)\nans =\n-1.7778 0.8889 -0.1111\n1.5556 -0.7778 0.2222\n-0.1111 0.2222 -0.1111\nwhich is similar to: \uf8ee \uf8f9\n\u221216 8 \u22121\n1\nA\u22121 = \uf8f0 14 \u22127 2 \uf8fb\n9\n\u22121 2 \u22121\nand the determinant of A is\n>> det(A)\nans =\n27\nFor further details on applied numerical linear algebra, see [10] and [11].\n3.2.2 Matrix functions\nMATLAB provides many matrix functions for various matrix/vector manipulations; see\nTable 3.3 for some of these functions. Use the online help of MATLAB to find how to use\nthese functions.\ndet Determinant\ndiag Diagonal matrices and diagonals of a matrix\neig Eigenvalues and eigenvectors\ninv Matrix inverse\nnorm Matrix and vector norms\nrank Number of linearly independent rows or columns\nTable 3.3: Matrix functions\n3.3 Exercises\nNote: Due to the teaching class during this Fall Quarter 2005, the problems are temporarily\nremoved from this section.\n34\nChapter 4\nIntroduction to programming in\nMATLAB\n4.1 Introduction\nSo far in these lab sessions, all the commands were executed in the Command Window.\nThe problem is that the commands entered in the Command Window cannot be saved\nand executed again for several times. Therefore, a different way of executing repeatedly\ncommands with MATLAB is:\n1. to create a file with a list of commands,\n2. save the file, and\n3. run the file.\nIf needed, corrections or changes can be made to the commands in the file. The files that\nare used for this purpose are called script files or scripts for short.\nThis section covers the following topics:\n\u2022 M-File Scripts\n\u2022 M-File Functions\n4.2 M-File Scripts\nA script file is an external file that contains a sequence of MATLAB statements. Script\nfiles have a filename extension .m and are often called M-files. M-files can be scripts that\nsimply execute a series of MATLAB statements, or they can be functions that can accept\narguments and can produce one or more outputs.\n35\n4.2.1 Examples\nHere are two simple scripts.\nExample 1\nConsider the system of equations:\n\uf8f1\n\uf8f2 x+2y +3z = 1\n3x+3y +4z = 1\n\uf8f3\n2x+3y +3z = 2\nFind the solution x to the system of equations.\nSolution:\n\u2022 Use the MATLAB editor to create a file: File \u2192 New \u2192 M-file.\n\u2022 Enter the following statements in the file:\nA = [1 2 3; 3 3 4; 2 3 3];\nb = [1; 1; 2];\nx = A\\b\n\u2022 Save the file, for example, example1.m.\n\u2022 Run the file, in the command line, by typing:\n>> example1\nx =\n-0.5000\n1.5000\n-0.5000\nWhen execution completes, the variables (A, b, and x) remain in the workspace. To see a\nlisting of them, enter whos at the command prompt.\nNote: The MATLAB editor is both a text editor specialized for creating M-files and a\ngraphical MATLAB debugger. The MATLAB editor has numerous menus for tasks such as\nsaving, viewing, and debugging. Because it performs some simple checks and also uses color\nto differentiate between various elements of codes, this text editor is recommended as the\ntool of choice for writing and editing M-files.\nThere is another way to open the editor:\n36\n>> edit\nor\n>> edit filename.m\nto open filename.m.\nExample 2\nPlot the following cosine functions, y = 2cos(x), y = cos(x), and y = 0.5\u2217cos(x), in the\n1 2 3\ninterval 0 \u2264 x \u2264 2\u03c0. This example has been presented in previous Chapter. Here we put\nthe commands in a file.\n\u2022 Create a file, say example2.m, which contains the following commands:\nx = 0:pi/100:2*pi;\ny1 = 2*cos(x);\ny2 = cos(x);\ny3 = 0.5*cos(x);\nplot(x,y1,\u2019--\u2019,x,y2,\u2019-\u2019,x,y3,\u2019:\u2019)\nxlabel(\u20190 \\leq x \\leq 2\\pi\u2019)\nylabel(\u2019Cosine functions\u2019)\nlegend(\u20192*cos(x)\u2019,\u2019cos(x)\u2019,\u20190.5*cos(x)\u2019)\ntitle(\u2019Typical example of multiple plots\u2019)\naxis([0 2*pi -3 3])\n\u2022 Run the file by typing example2 in the Command Window.\n4.2.2 Script side-effects\nAll variables created in a script file are added to the workspace. This may have undesirable\neffects, because:\n\u2022 Variables already existing in the workspace may be overwritten.\n\u2022 The execution of the script can be affected by the state variables in the workspace.\nAs a result, because scripts have some undesirable side-effects, it is better to code any\ncomplicated applications using rather function M-file.\n37\n4.3 M-File functions\nAs mentioned earlier, functions are programs (or routines) that accept input arguments and\nreturn output arguments. Each M-file function (or function or M-file for short) has its own\narea of workspace, separated from the MATLAB base workspace.\n4.3.1 Anatomy of a M-File function\nThis simple function shows the basic parts of an M-file.\nfunction f = factorial(n) (1)\n% FACTORIAL(N) returns the factorial of N. (2)\n% Compute a factorial value. (3)\nf = prod(1:n); (4)\nThe first line of a function M-file starts with the keyword function. It gives the function\nname and order of arguments. In the case of function factorial, there are up to one output\nargument and one input argument. Table 4.1 summarizes the M-file function.\nAs an example, for n = 5, the result is,\n>> f = factorial(5)\nf =\n120\nTable 4.1: Anatomy of a M-File function\nPart no. M-file element Description\n(1) Function Define the function name, and the\ndefinition number and order of input and\nline output arguments\n(2) H1 line A one line summary description\nof the program, displayed when you\nrequest Help\n(3) Help text A more detailed description of\nthe program\n(4) Function body Program code that performs\nthe actual computations\nBoth functions andscripts can haveall ofthese parts, except forthe function definition\nline which applies to function only.\n38\nIn addition, it is important to note that function name must begin with a letter, and\nmust be no longer than than the maximum of 63 characters. Furthermore, the name of the\ntext file that you save will consist of the function name with the extension .m. Thus, the\nabove example file would be factorial.m.\nTable 4.2 summarizes the differences between scripts and functions.\nTable 4.2: Difference between scripts and functions\nScripts Functions\n- Do not accept input - Can accept input arguments and\narguments or return output return output arguments.\narguments.\n- Store variables in a - Store variables in a workspace\nworkspace that is shared internal to the function.\nwith other scripts\n- Are useful for automating - Are useful for extending the MATLAB\na series of commands language for your application\n39\n4.3.2 Input and output arguments\nAs mentioned above, the input arguments are listed inside parentheses following the function\nname. The output arguments are listed inside the brackets on the left side. They are used\nto transfer the output from the function file. The general form looks like this\nfunction [outputs] = function_name(inputs)\nFunction file can have none, one, or several output arguments. Table 4.3 illustrates some\npossible combinations of input and output arguments.\nTable 4.3: Example of input and output arguments\nfunction C=FtoC(F) One input argument and\none output argument\nfunction area=TrapArea(a,b,h) Three inputs and one output\nfunction [h,d]=motion(v,angle) Two inputs and two outputs\n4.4 Input to a script file\nWhen a script file is executed, the variables that are used in the calculations within the file\nmust have assigned values. The assignment of a value to a variable can be done in three\nways.\n1. The variable is defined in the script file.\n2. The variable is defined in the command prompt.\n3. The variable is entered when the script is executed.\nWe have already seen the two first cases. Here, we will focus our attention on the third one.\nIn this case, the variable is defined in the script file. When the file is executed, the user is\nprompted to assign a value to the variable in the command prompt. This is done by using\nthe input command. Here is an example.\n% This script file calculates the average of points\n% scored in three games.\n% The point from each game are assigned to a variable\n% by using the \u2018input\u2019 command.\ngame1 = input(\u2019Enter the points scored in the first game \u2019);\n40\ngame2 = input(\u2019Enter the points scored in the second game \u2019);\ngame3 = input(\u2019Enter the points scored in the third game \u2019);\naverage = (game1+game2+game3)/3\nThe following shows the command prompt when this script file (saved as example3) is\nexecuted.\n>> example3\n>> Enter the points scored in the first game 15\n>> Enter the points scored in the second game 23\n>> Enter the points scored in the third game 10\naverage =\n16\nThe input command can also be used to assign string to a variable. For more information,\nsee MATLAB documentation.\nAtypicalexampleofM-filefunctionprogrammingcanbefoundinarecentpaperwhich\nrelated to the solution of the ordinary differential equation (ODE) [12].\n4.5 Output commands\nAs discussed before, MATLAB automatically generates a display when commands are exe-\ncuted. In addition to this automatic display, MATLAB has several commands that can be\nused to generate displays or outputs.\nTwo commands that are frequently used to generate output are: disp and fprintf.\nThe main differences between these two commands can be summarized as follows (Table\n4.4).\nTable 4.4: disp and fprintf commands\ndisp . Simple to use.\n. Provide limited control over the appearance of output\nfprintf . Slightly more complicated than disp.\n. Provide total control over the appearance of output\n41\n4.6 Exercises\n1. Lizbuysthreeapples,adozenbananas,andonecantaloupefor$2.36. Bobbuysadozen\napples and two cantaloupe for $5.26. Carol buys two bananas and three cantaloupe\nfor $2.77. How much do single pieces of each fruit cost?\n2. Write a function file that converts temperature in degrees Fahrenheit (\u25e6F) to degrees\nCentigrade (\u25e6C). Use input and fprintf commands to display a mix of text and\nnumbers. Recall the conversion formulation, C = 5/9\u2217(F\u221232).\n3. Write a user-defined MATLAB function, with two input and two output arguments\nthat determines the height in centimeters (cm) and mass in kilograms (kg)of a person\nfrom his height in inches (in.) and weight in pounds (lb).\n(a) Determine in SI units the height and mass of a 5 ft.15 in. person who weight 180\nlb.\n(b) Determine your own height and weight in SI units.\n42\nChapter 5\nControl flow and operators\n5.1 Introduction\nMATLAB is also a programming language. Like other computer programming languages,\nMATLAB has some decision making structures for control of command execution. These\ndecision making or control flow structures include for loops, while loops, and if-else-end\nconstructions. Control flow structures are often used in script M-files and function M-files.\nBy creating a file with the extension .m, we can easily write and run programs. We\ndo not need to compile the program since MATLAB is an interpretative (not compiled)\nlanguage. MATLAB has thousand of functions, and you can add your own using m-files.\nMATLAB provides several tools that can be used to control the flow of a program\n(script or function). In a simple program as shown in the previous Chapter, the commands\nare executed one after the other. Here we introduce the flow control structure that make\npossible to skip commands or to execute specific group of commands.\n5.2 Control flow\nMATLAB has four control flow structures: the if statement, the for loop, the while loop,\nand the switch statement.\n5.2.1 The \u2018\u2018if...end\u2019\u2019 structure\nMATLAB supports the variants of \u201cif\u201d construct.\n\u2022 if ... end\n\u2022 if ... else ... end\n43\n\u2022 if ... elseif ... else ... end\nThe simplest form of the if statement is\nif expression\nstatements\nend\nHere are some examples based on the familiar quadratic formula.\n1. discr = b*b - 4*a*c;\nif discr < 0\ndisp(\u2019Warning: discriminant is negative, roots are\nimaginary\u2019);\nend\n2. discr = b*b - 4*a*c;\nif discr < 0\ndisp(\u2019Warning: discriminant is negative, roots are\nimaginary\u2019);\nelse\ndisp(\u2019Roots are real, but may be repeated\u2019)\nend\n3. discr = b*b - 4*a*c;\nif discr < 0\ndisp(\u2019Warning: discriminant is negative, roots are\nimaginary\u2019);\nelseif discr == 0\ndisp(\u2019Discriminant is zero, roots are repeated\u2019)\nelse\ndisp(\u2019Roots are real\u2019)\nend\nIt should be noted that:\n\u2022 elseif has no space between else and if (one word)\n\u2022 no semicolon (;) is needed at the end of lines containing if, else, end\n\u2022 indentation of if block is not required, but facilitate the reading.\n\u2022 the end statement is required\n44\n5.2.2 Relational and logical operators\nA relational operator compares two numbers by determining whether a comparison is true\nor false. Relational operators are shown in Table 5.1.\nTable 5.1: Relational and logical operators\nOperator Description\n> Greater than\n< Less than\n>= Greater than or equal to\n<= Less than or equal to\n== Equal to\n\u223c= Not equal to\n& AND operator\n| OR operator\n\u223c NOT operator\nNote that the \u201cequal to\u201d relational operator consists of two equal signs (==) (with no space\nbetween them), since = is reserved for the assignment operator.\n5.2.3 The \u2018\u2018for...end\u2019\u2019 loop\nIn the for ... end loop, the execution of a command is repeated at a fixed and predeter-\nmined number of times. The syntax is\nfor variable = expression\nstatements\nend\nUsually, expression is a vector of the form i:s:j. A simple example of for loop is\nfor ii=1:5\nx=ii*ii\nend\nIt is a good idea to indent the loops for readability, especially when they are nested. Note\nthat MATLAB editor does it automatically.\nMultiple for loops can be nested, in which case indentation helps to improve the\nreadability. The following statements form the 5-by-5 symmetric matrix A with (i,j) element\ni/j for j \u2265 i:\n45\nn = 5; A = eye(n);\nfor j=2:n\nfor i=1:j-1\nA(i,j)=i/j;\nA(j,i)=i/j;\nend\nend\n5.2.4 The \u2018\u2018while...end\u2019\u2019 loop\nThis loop is used when the number of passes is not specified. The looping continues until a\nstated condition is satisfied. The while loop has the form:\nwhile expression\nstatements\nend\nThe statements are executed as long as expression is true.\nx = 1\nwhile x <= 10\nx = 3*x\nend\nIt is important to note that if the condition inside the looping is not well defined, the looping\nwill continue indefinitely. If this happens, we can stop the execution by pressing Ctrl-C.\n5.2.5 Other flow structures\n\u2022 The break statement. A while loop can be terminated with the break statement,\nwhich passes control to the first statement after the corresponding end. The break\nstatement can also be used to exit a for loop.\n\u2022 The continue statement can also be used to exit a for loop to pass immediately to\nthe next iteration of the loop, skipping the remaining statements in the loop.\n\u2022 Other control statements include return, continue, switch, etc. For more detail\nabout these commands, consul MATLAB documentation.\n46\n5.2.6 Operator precedence\nWe can build expressions that use any combination of arithmetic, relational, and logical\noperators. Precedence rules determine the order in which MATLAB evaluates an expression.\nWe have already seen this in the \u201cTutorial Lessons\u201d.\nHere we add other operators in the list. The precedence rules for MATLAB are shown\nin this list (Table 5.2), ordered from highest (1) to lowest (9) precedence level. Operators\nare evaluated from left to right.\nTable 5.2: Operator precedence\nPrecedence Operator\n1 Parentheses ()\n2 Transpose (.(cid:48)), power (.\u02c6), matrix power (\u02c6)\n3 Unary plus (+), unary minus (\u2212), logical negation (\u223c)\n4 Multiplication (.\u2217), right division (./), left division (.\\),\nmatrix multiplication (\u2217), matrix right division (/),\nmatrix left division (\\)\n5 Addition (+), subtraction (\u2212)\n6 Colon operator (:)\n7 Less than (<), less than or equal to (\u2264), greater (>),\ngreater than or equal to (\u2265), equal to (==), not equal to (\u223c=)\n8 Element-wise AND, (&)\n9 Element-wise OR, (|)\n5.3 Saving output to a file\nIn addition to displaying output on the screen, the command fprintf can be used for\nwriting the output to a file. The saved data can subsequently be used by MATLAB or other\nsoftwares.\nTo save the results of some computation to a file in a text format requires the following\nsteps:\n1. Open a file using fopen\n2. Write the output using fprintf\n3. Close the file using fclose\nHere is an example (script) of its use.\n47\n% write some variable length strings to a file\nop = fopen(\u2019weekdays.txt\u2019,\u2019wt\u2019);\nfprintf(op,\u2019Sunday\\nMonday\\nTuesday\\nWednesday\\n\u2019);\nfprintf(op,\u2019Thursday\\nFriday\\nSaturday\\n\u2019);\nfclose(op);\nThis file (weekdays.txt) can be opened with any program that can read .txt file.\n5.4 Exercises\nNote: Due to the teaching class during this Fall Quarter 2005, the problems are temporarily\nremoved from this section.\n48\nChapter 6\nDebugging M-files\n6.1 Introduction\nThis section introduces general techniques for finding errors in M-files. Debugging is the\nprocess by which you isolate and fix errors in your program or code.\nDebugging helps to correct two kind of errors:\n\u2022 Syntax errors - For example omitting a parenthesis or misspelling a function name.\n\u2022 Run-time errors - Run-time errors are usually apparent and difficult to track down.\nThey produce unexpected results.\n6.2 Debugging process\nWe can debug the M-files using the Editor/Debugger as well as using debugging functions\nfrom the Command Window. The debugging process consists of\n\u2022 Preparing for debugging\n\u2022 Setting breakpoints\n\u2022 Running an M-file with breakpoints\n\u2022 Stepping through an M-file\n\u2022 Examining values\n\u2022 Correcting problems\n\u2022 Ending debugging\n49\n6.2.1 Preparing for debugging\nHere we use the Editor/Debugger for debugging. Do the following to prepare for debugging:\n\u2022 Open the file\n\u2022 Save changes\n\u2022 Be sure the file you run and any files it calls are in the directories that are on the\nsearch path.\n6.2.2 Setting breakpoints\nSet breakpoints to pause execution of the function, so we can examine where the problem\nmight be. There are three basic types of breakpoints:\n\u2022 A standard breakpoint, which stops at a specified line.\n\u2022 A conditional breakpoint, which stops at a specified line and under specified conditions.\n\u2022 An error breakpoint that stops when it produces the specified type of warning, error,\nNaN, or infinite value.\nYou cannot set breakpoints while MATLAB is busy, for example, running an M-file.\n6.2.3 Running with breakpoints\nAfter setting breakpoints, run the M-file from the Editor/Debugger or from the Command\nWindow. Running the M-file results in the following:\n\u2022 The prompt in the Command Window changes to\nK>>\nindicating that MATLAB is in debug mode.\n\u2022 The program pauses at the first breakpoint. This means that line will be executed\nwhen you continue. The pause is indicated by the green arrow.\n\u2022 In breakpoint, we can examine variable, step through programs, and run other calling\nfunctions.\n50\n6.2.4 Examining values\nWhile the program is paused, we can view the value of any variable currently in the\nworkspace. Examine values when we want to see whether a line of code has produced\nthe expected result or not. If the result is as expected, step to the next line, and continue\nrunning. If the result is not as expected, then that line, or the previous line, contains an\nerror. When we run a program, the current workspace is shown in the Stack field. Use who\nor whos to list the variables in the current workspace.\nViewing values as datatips\nFirst, we position the cursor to the left of a variable on that line. Its current value appears.\nThis is called a datatip, which is like a tooltip for data. If you have trouble getting the\ndatatip to appear, click in the line and then move the cursor next to the variable.\n6.2.5 Correcting and ending debugging\nWhile debugging, we can change the value of a variable to see if the new value produces\nexpectedresults. Whiletheprogramispaused, assignanewvaluetothevariableintheCom-\nmand Window, Workspace browser, or Array Editor. Then continue running and stepping\nthrough the program.\n6.2.6 Ending debugging\nAfter identifying a problem, end the debugging session. It is best to quit debug mode before\nediting an M-file. Otherwise, you can get unexpected results when you run the file. To end\ndebugging, select Exit Debug Mode from the Debug menu.\n6.2.7 Correcting an M-file\nTo correct errors in an M-file,\n\u2022 Quit debugging\n\u2022 Do not make changes to an M-file while MATLAB is in debug mode\n\u2022 Make changes to the M-file\n\u2022 Save the M-file\n\u2022 Clear breakpoints\n51\n\u2022 Run the M-file again to be sure it produces the expected results.\nFor details on debugging process, see MATLAB documentation.\n52\nAppendix A\nSummary of commands\nTable A.1: Arithmetic operators and special characters\nCharacter Description\n+ Addition\n\u2212 Subtraction\n\u2217 Multiplication (scalar and array)\n/ Division (right)\n\u02c6 Power or exponentiation\n: Colon; creates vectors with equally spaced elements\n; Semi-colon; suppresses display; ends row in array\n, Comma; separates array subscripts\n... Continuation of lines\n% Percent; denotes a comment; specifies output format\n(cid:48) Single quote; creates string; specifies matrix transpose\n= Assignment operator\n( ) Parentheses; encloses elements of arrays and input arguments\n[ ] Brackets; encloses matrix elements and output arguments\n53\nTable A.2: Array operators\nCharacter Description\n.\u2217 Array multiplication\n./ Array (right) division\n.\u02c6 Array power\n.\\ Array (left) division\n.(cid:48) Array (nonconjugated) transpose\nTable A.3: Relational and logical operators\nCharacter Description\n< Less than\n\u2264 Less than or equal to\n> Greater than\n\u2265 Greater than or equal to\n== Equal to\n\u223c= Not equal to\n& Logical or element-wise AND\n| Logical or element-wise OR\n&& Short-circuit AND\n|| Short-circuit OR\n54\nTable A.4: Managing workspace and file commands\nCommand Description\ncd Change current directory\nclc Clear the Command Window\nclear (all) Removes all variables from the workspace\nclear x Remove x from the workspace\ncopyfile Copy file or directory\ndelete Delete files\ndir Display directory listing\nexist Check if variables or functions are defined\nhelp Display help for MATLAB functions\nlookfor Search for specified word in all help entries\nmkdir Make new directory\nmovefile Move file or directory\npwd Identify current directory\nrmdir Remove directory\ntype Display contents of file\nwhat List MATLAB files in current directory\nwhich Locate functions and files\nwho Display variables currently in the workspace\nwhos Display information on variables in the workspace\nTable A.5: Predefined variables and math constants\nVariable Description\nans Value of last variable (answer)\neps Floating-point relative accuracy\ni Imaginary unit of a complex number\nInf Infinity (\u221e)\neps Floating-point relative accuracy\nj Imaginary unit of a complex number\nNaN Not a number\npi The number \u03c0 (3.14159...)\n55\nTable A.6: Elementary matrices and arrays\nCommand Description\neye Identity matrix\nlinspace Generate linearly space vectors\nones Create array of all ones\nrand Uniformly distributed random numbers and arrays\nzeros Create array of all zeros\nTable A.7: Arrays and Matrices: Basic information\nCommand Description\ndisp Display text or array\nisempty Determine if input is empty matrix\nisequal Test arrays for equality\nlength Length of vector\nndims Number of dimensions\nnumel Number of elements\nsize Size of matrix\nTable A.8: Arrays and Matrices: operations and manipulation\nCommand Description\ncross Vector cross product\ndiag Diagonal matrices and diagonals of matrix\ndot Vector dot product\nend Indicate last index of array\nfind Find indices of nonzero elements\nkron Kronecker tensor product\nmax Maximum value of array\nmin Minimum value of array\nprod Product of array elements\nreshape Reshape array\nsort Sort array elements\nsum Sum of array elements\nsize Size of matrix\n56\nTable A.9: Arrays and Matrices: matrix analysis and linear equations\nCommand Description\ncond Condition number with respect to inversion\ndet Determinant\ninv Matrix inverse\nlinsolve Solve linear system of equations\nlu LU factorization\nnorm Matrix or vector norm\nnull Null space\north Orthogonalization\nrank Matrix rank\nrref Reduced row echelon form\ntrace Sum of diagonal elements\n57\nAppendix B\nRelease notes for Release 14 with\nService Pack 2\nB.1 Summary of changes\nMATLAB 7 Release 14 with Service Pack 2 (R14SP2) includes several new features. The\nmajor focus of R14SP2 is on improving the quality of the product. This document doesn\u2019t\nattempt to provide a complete specification of every single feature, but instead provides\na brief introduction to each of them. For full details, you should refer to the MATLAB\ndocumentation (Release Notes).\nThe following key points may be relevant:\n1. Spaces before numbers - For example: A* .5, you will typically get a mystifying\nmessage saying that A was previously used as a variable. There are two workarounds:\n(a) Remove all the spaces:\nA*.5\n(b) Or, put a zero in front of the dot:\nA * 0.5\n2. RHS empty matrix - The right-hand side must literally be the empty matrix [ ]. It\ncannot be a variable that has the value [ ], as shown here:\nrhs = [];\nA(:,2) = rhs\n??? Subscripted assignment dimension mismatch\n58\n3. New format option - We can display MATLAB output using two new formats:\nshort eng and long eng.\n\u2022 short eng \u2013 Displays output in engineering format that has at least 5 digits and\na power that is a multiple of three.\n>> format short eng\n>> pi\nans =\n3.1416e+000\n\u2022 long eng \u2013 Displays output in engineering format that has 16 significant digits\nand a power that is a multiple of three.\n>> format long eng\n>> pi\nans =\n3.14159265358979e+000\n4. Help - To get help for a subfunction, use\n>> help function_name>subfunction_name\nIn previous versions, the syntax was\n>> help function_name/subfunction_name\nThis change was introduced in R14 (MATLAB 7.0) but was not documented. Use the\nMathWorks Web site search features to look for the latest information.\n5. Publishing - Publishing to LATEXnow respects the image file type you specify in pref-\nerences rather than always using EPSC2-files.\n\u2022 The Publish image options in Editor/Debugger preferences for Publishing Images\nhave changed slightly. The changes prevent you from choosing invalid formats.\n\u2022 The files created when publishing using cells now have more natural extensions.\nFor example, JPEG-files now have a .jpg instead of a .jpeg extension, and EPSC2-\nfiles now have an .eps instead of an .epsc2 extension.\n\u2022 Notebook will no longer support Microsoft Word 97 starting in the next release\nof MATLAB.\n6. Debugging - Go directly to a subfunction or using the enhanced Go To dialog box.\nClick the Name column header to arrange the list of function alphabetically, or click\nthe Line column header to arrange the list by the position of the functions in the file.\n59\nB.2 Other changes\n1. There is a new command mlint, which will scan an M-file and show inefficiencies in\nthe code. For example, it will tell you if you\u2019ve defined a variable you\u2019ve never used, if\nyou\u2019ve failed to pre-allocate an array, etc. These are common mistakes in EA1 which\nproduce runnable but inefficient code.\n2. Youcancomment-outablockofcodewithoutputting% at the beginning of each line.\nThe format is\n%{\nStuff you want MATLAB to ignore...\n%}\nThe delimiters %{ and %} must appear on lines by themselves, and it may not work\nwith the comments used in functions to interact with the help system (like the H1\nline).\n3. There is a new function linsolve which will solve Ax = b but with the user\u2019s choice of\nalgorithm. This is in addition to left division x = A\\b which uses a default algorithm.\n4. The eps constant now takes an optional argument. eps(x) is the same as the old\neps*abs(x).\n5. You can break an M-file up into named cells (blocks of code), each of which you can\nrun separately. This may be useful for testing/debugging code.\n6. Functions now optionally end with the end keyword. This keyword is mandatory when\nworking with nested functions.\nB.3 Further details\n1. You can dock and un-dock windows from the main window by clicking on an icon.\nThus you can choose to have all Figures, M-files being edited, help browser, command\nwindow, etc. All appear as panes in a single window.\n2. Error messages in the command window resulting from running an M-file now include\na clickable link to the offending line in the editor window containing the M-file.\n3. You can customize figure interactively (labels, line styles, etc.) and then automatically\ngenerate the code which reproduces the customized figure.\n60\n4. feval is no longer needed when working with function handles, but still works for\nbackward compatibility. For example, x=@sin; x(pi) will produce sin(pi) just like\nfeval(x,pi) does, but faster.\n5. You can use function handles to create anonymous functions.\n6. There is support for nested functions, namely, functions defined within the body of\nanother function. This is in addition to sub-functions already available in version 6.5.\n7. There is more support in arithmetic operations for numeric data types other than\ndouble, e.g. single, int8, int16, uint8, uint32, etc.\nFinally, please visit our webpage for other details:\nhttp://computing.mccormick.northwestern.edu/matlab/\n61\nAppendix C\nMain characteristics of MATLAB\nC.1 History\n\u2022 Developed primarily by Cleve Moler in the 1970\u2019s\n\u2022 Derived from FORTRAN subroutines LINPACK and EISPACK, linear and eigenvalue\nsystems.\n\u2022 Developed primarily as an interactive system to access LINPACK and EISPACK.\n\u2022 Gained its popularity through word of mouth, because it was not officially distributed.\n\u2022 Rewritten in C in the 1980\u2019s with more functionality, which include plotting routines.\n\u2022 The MathWorks Inc. was created (1984) to market and continue development of\nMATLAB.\nAccordingtoCleveMoler, threeothermenplayedimportantrolesintheoriginsofMATLAB:\nJ. H. Wilkinson, George Forsythe, and John Todd. It is also interesting to mention the\nauthors of LINPACK: Jack Dongara, Pete Steward, Jim Bunch, and Cleve Moler. Since\nthen another package emerged: LAPACK. LAPACK stands for Linear Algebra Package. It\nhas been designed to supersede LINPACK and EISPACK.\nC.2 Strengths\n\u2022 MATLAB may behave as a calculator or as a programming language\n\u2022 MATLAB combine nicely calculation and graphic plotting.\n\u2022 MATLAB is relatively easy to learn\n62\n\u2022 MATLAB is interpreted (not compiled), errors are easy to fix\n\u2022 MATLAB is optimized to be relatively fast when performing matrix operations\n\u2022 MATLAB does have some object-oriented elements\nC.3 Weaknesses\n\u2022 MATLAB is not a general purpose programming language such as C, C++, or FOR-\nTRAN\n\u2022 MATLAB is designed for scientific computing, and is not well suitable for other appli-\ncations\n\u2022 MATLAB is an interpreted language, slower than a compiled language such as C++\n\u2022 MATLAB commands are specific for MATLAB usage. Most of them do not have a\ndirect equivalent with other programming language commands\nC.4 Competition\n\u2022 One of MATLAB\u2019s competitors is Mathematica, the symbolic computation program.\n\u2022 MATLAB is more convenient for numerical analysis and linear algebra. It is frequently\nused in engineering community.\n\u2022 Mathematica has superior symbolic manipulation, making it popular among physicists.\n\u2022 There are other competitors:\n\u2013 Scilab\n\u2013 GNU Octave\n\u2013 Rlab\n63\nBibliography\n[1] The MathWorks Inc. MATLAB 7.0 (R14SP2). The MathWorks Inc., 2005.\n[2] S. J. Chapman. MATLAB Programming for Engineers. Thomson, 2004.\n[3] C. B. Moler. Numerical Computing with MATLAB. Siam, 2004.\n[4] C. F. Van Loan. Introduction to Scientific Computing. Prentice Hall, 1997.\n[5] D. J. Higham and N. J. Higham. MATLAB Guide. Siam, second edition edition, 2005.\n[6] K. R. Coombes, B. R. Hunt, R. L. Lipsman, J. E. Osborn, and G. J. Stuck. Differential\nEquations with MATLAB. John Wiley and Sons, 2000.\n[7] A. Gilat. MATLAB: An introduction with Applications. John Wiley and Sons, 2004.\n[8] J. Cooper. A MATLAB Companion for Multivariable Calculus. Academic Press, 2001.\n[9] J. C. Polking and D. Arnold. ODE using MATLAB. Prentice Hall, 2004.\n[10] D. Kahaner, C. Moler, and S. Nash. Numerical Methods and Software. Prentice-Hall,\n1989.\n[11] J. W. Demmel. Applied Numerical Linear Algebra. Siam, 1997.\n[12] D. Houcque. Applications of MATLAB: Ordinary Differential Equations. Internal\ncommunication, Northwestern University, pages 1\u201312, 2005.\n64\n",
  "context": "1.4.11 Getting help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n1.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2 Tutorial lessons 2 12",
  "source_file": "resources\\Year 2\\MatLab\\introduction-to-matlab.pdf",
  "line_numbers": [
    28,
    1872
  ]
}
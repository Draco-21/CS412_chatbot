{
  "title": "Assembly Language Programming Lecture Notes - Belal Hashmi",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "grained and this is one of the basic objectives of teaching assembly language programming.",
  "code": "when there are higher level languages one better than the other; C, C++,\nJava, to name just a few, with a neat programming environment and a\nsimple way to write programs. Then why do we need such a freehand with\nthe computer that may be dangerous at times? The answer to this lies in a\nvery simple example. Consider a translator translating from English to\nJapanese. The problem faced by the translator is that every language has its\nown vocabulary and grammar. He may need to translate a word into a\nsentence and destroy the beauty of the topic. And given that we do not know\nii\nJapanese, so we cannot verify that our intent was correctly conveyed or not.\nCompiler is such a translator, just a lot dumber, and having a scarce\nnumber of words in its target language, it is bound to produce a lot of\ngarbage and unnecessary stuff as a result of its ignorance of our program\nlogic. In normal programs such garbage is acceptable and the ease of\nprogramming overrides the loss in efficiency but there are a few situations\nwhere this loss is unbearable.\nThink about a four color picture scanned at 300 dots per inch making\n90000 pixels per square inch. Now a processing on this picture requires\n360000 operations per square inch, one operation for each color of each\npixel. A few extra instructions placed by the translator can cost hours of\nextra time. The only way to optimize this is to do it directly in assembly\nlanguage. But this doesn\u2019t mean that the whole application has to be written\nin assembly language, which is almost never the case. It\u2019s only the\nperformance critical part that is coded in assembly language to gain the few\nextra cycles that matter at that point.\nConsider an arch just like the ones in mosques. It cannot be made of big\nstones alone as that would make the arch wildly jagged, not like the fine arch\nwe are used to see. The fine grains of cement are used to smooth it to the\ndesired level of perfection. This operation of smoothing is optimization. The\ncore structure is built in a higher level language with the big blocks it\nprovides and the corners that need optimization are smoothed with the fine\ngrain of assembly language which allows extreme control.\nAnother use of assembly language is in a class of time critical systems\ncalled real time systems. Real time systems have time bound responses, with\nan upper limit of time on certain operations. For such precise timing\nrequirement, we must keep the instructions in our total control. In higher\nlevel languages we cannot even tell how many computer instructions were\nactually used, but in assembly language we can have precise control over\nthem. Any reasonable sized application or a serious development effort has\nnooks and corners where assembly language is needed. And at these corners\nif there is no assembly language, there can be no optimization and when\nthere is no optimization, there is no beauty. Sometimes a useful application\nbecomes useless just because of the carelessness of not working on these\njagged corners.\nThe third major reason for learning assembly language and a major\nobjective for teaching it is to produce fine grained logic in programmers. Just\nlike big blocks cannot produce an arch, the big thick grained logic learnt in a\nhigher level language cannot produce the beauty and fineness assembly\nlanguage can deliver. Each and every grain of assembly language has a\nmeaning; nothing is presumed (e.g. div and mul for input and out put of\ndecimal number). You have to put together these grains, the minimum\nnumber of them to produce the desired outcome. Just like a \u201cfor\u201d loop in a\nhigher level language is a block construct and has a hundred things hidden\nin it, but using the grains of assembly language we do a similar operation\nwith a number of grains but in the process understand the minute logic\nhidden beside that simple \u201cfor\u201d construct.\nAssembly language cannot be learnt by reading a book or by attending a\ncourse. It is a language that must be tasted and enjoyed. There is no other\nway to learn it. You will need to try every example, observe and verify the\nthings you are told about it, and experiment a lot with the computer. Only\nthen you will know and become able to appreciate how powerful, versatile,\nand simple this language is; the three properties that are hardly ever present\ntogether.\nWhether you program in C/C++ or Java, or in any programming paradigm\nbe it object oriented or declarative, everything has to boil down to the bits\nand bytes of assembly language before the computer can even understand it.\nVirtual University of Pakistan ii\nTable of Contents\nPreface i\nTable of Contents iii\n1 Introduction to Assembly Language 1\n1.1. Basic Computer Architecture 1\n1.2. Registers 3\n1.3. Instruction Groups 5\n1.4. Intel iapx88 Architecture 6\n1.5. History 6\n1.6. Register Architecture 7\n1.7. Our First Program 9\n1.8. Segmented Memory Model 12\n2 Addressing Modes 17\n2.1. Data Declaration 17\n2.2. Direct Addressing 17\n2.3. Size Mismatch Errors 21\n2.4. Register Indirect Addressing 22\n2.5. Register + Offset Addressing 25\n2.6. Segment Association 25\n2.7. Address Wraparound 26\n2.8. Addressing Modes Summary 27\n3 Branching 31\n3.1. Comparison and Conditions 31\n3.2. Conditional Jumps 33\n3.3. Unconditional Jump 36\n3.4. Relative Addressing 37\n3.5. Types of Jump 37\n3.6. Sorting Example 38\n4 Bit Manipulations 43\n4.1. Multiplication Algorithm 43\n4.2. Shifting and Rotations 43\n4.3. Multiplication in Assembly Language 46\n4.4. Extended Operations 47\n4.5. Bitwise Logical Operations 50\n4.6. Masking Operations 51\n5 Subroutines 55\n5.1. Program Flow 55\n5.2. Our First Subroutine 57\n5.3. Stack 59\n5.4. Saving and Restoring Registers 62\n5.5. Parameter Passing Through Stack 64\n5.6. Local Variables 67\n6 Display Memory 71\niv\n6.1. ASCII Codes 71\n6.2. Display Memory Formation 72\n6.3. Hello World in Assembly Language 74\n6.4. Number Printing in Assembly 76\n6.5. Screen Location Calculation 79\n7 String Instructions 83\n7.1. String Processing 83\n7.2. STOS Example \u2013 Clearing the Screen 85\n7.3. LODS Example \u2013 String Printing 86\n7.4. SCAS Example \u2013 String Length 87\n7.5. LES and LDS Example 89\n7.6. MOVS Example \u2013 Screen Scrolling 90\n7.7. CMPS Example \u2013 String Comparison 92\n8 Software Interrupts 95\n8.1. Interrupts 95\n8.2. Hooking an Interrupt 98\n8.3. BIOS and DOS Interrupts 99\n9 Real Time Interrupts and Hardware Interfacing 105\n9.1. Hardware Interrupts 105\n9.2. I/O Ports 106\n9.3. Terminate and Stay Resident 111\n9.4. Programmable Interval Timer 114\n9.5. Parallel Port 116\n10 Debug Interrupts 125\n10.1. Debugger using single step interrupt 125\n10.2. Debugger using breakpoint interrupt 128\n11 Multitasking 131\n11.1. Concepts of Multitasking 131\n11.2. Elaborate Multitasking 133\n11.3. Multitasking Kernel as TSR 135\n12 Video Services 141\n12.1. BIOS Video Services 141\n12.2. DOS Video Services 144\n13 Secondary Storage 147\n13.1. Physical Formation 147\n13.2. Storage Access Using BIOS 148\n13.3. Storage Access using DOS 153\n13.4. Device Drivers 158\n14 Serial Port Programming 163\n14.1. Introduction 163\n14.2. Serial Communication 165\n15 Protected Mode Programming 167\n15.1. Introduction 167\n15.2. 32bit Programming 170\n15.3. VESA Linear Frame Buffer 172\n15.4. Interrupt Handling 174\n16 Interfacing with High Level Languages 179\nVirtual University of Pakistan iv\nTABLE OF CONTENTS v\n16.1. Calling Conventions 179\n16.2. Calling C from Assembly 179\n16.3. Calling Assembly from C 181\n17 Comparison with Other Processors 183\n17.1. Motorolla 68K Processors 183\n17.2. Sun SPARC Processor 184\nVirtual University of Pakistan v\n\n1\nIntroduction to Assembly\nLanguage\n1.1. BASIC COMPUTER ARCHITECTURE\nAddress, Data, and Control Buses\nA computer system comprises of a processor, memory, and I/O devices.\nI/O is used for interfacing with the external world, while memory is the\nprocessor\u2019s internal world. Processor is the core in this picture and is\nresponsible for performing operations. The operation of a computer can be\nfairly described with processor and memory only. I/O will be discussed in a\nlater part of the course. Now the whole working of the computer is\nperforming an operation by the processor on data, which resides in memory.\nThe scenario that the processor executes operations and the memory\ncontains data elements requires a mechanism for the processor to read that\ndata from the memory. \u201cThat data\u201d in the previous sentence much be\nrigorously explained to the memory which is a dumb device. Just like a\npostman, who must be told the precise address on the letter, to inform him\nwhere the destination is located. Another significant point is that if we only\nwant to read the data and not write it, then there must be a mechanism to\ninform the memory that we are interested in reading data and not writing it.\nKey points in the above discussion are:\n\u2022 There must be a mechanism to inform memory that we want to do the\nread operation\n\u2022 There must be a mechanism to inform memory that we want to read\nprecisely which element\n\u2022 There must be a mechanism to transfer that data element from\nmemory to processor\nThe group of bits that the processor uses to inform the memory about\nwhich element to read or write is collectively known as the address bus.\nAnother important bus called the data bus is used to move the data from the\nmemory to the processor in a read operation and from the processor to the\nmemory in a write operation. The third group consists of miscellaneous\nindependent lines used for control purposes. For example, one line of the bus\nis used to inform the memory about whether to do the read operation or the\nwrite operation. These lines are collectively known as the control bus.\nThese three buses are the eyes, nose, and ears of the processor. It uses\nthem in a synchronized manner to perform a meaningful operation. Although\nthe programmer specifies the meaningful operation, but to fulfill it the\nprocessor needs the collaboration of other units and peripherals. And that\ncollaboration is made available using the three buses. This is the very basic\ndescription of a computer and it can be extended on the same lines to I/O\nbut we are leaving it out just for simplicity for the moment.\nThe address bus is unidirectional and address always travels from\nprocessor to memory. This is because memory is a dumb device and cannot\npredict which element the processor at a particular instant of time needs.\nData moves from both, processor to memory and memory to processor, so\nthe data bus is bidirectional. Control bus is special and relatively complex,\nbecause different lines comprising it behave differently. Some take\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ninformation from the processor to a peripheral and some take information\nfrom the peripheral to the processor. There can be certain events outside the\nprocessor that are of its interest. To bring information about these events the\ndata bus cannot be used as it is owned by the processor and will only be\nused when the processor grants permission to use it. Therefore certain\nprocessors provide control lines to bring such information to processor\u2019s\nnotice in the control bus. Knowing these signals in detail is unnecessary but\nthe general idea of the control bus must be conceived in full.\nPROCESSOR MEMORY\nPERIPHERALS\nWe take an example to explain the collaboration of the processor and\nmemory using the address, control, and data buses. Consider that you want\nyour uneducated servant to bring a book from the shelf. You order him to\nbring the fifth book from top of the shelf. All the data movement operations\nare hidden in this one sentence. Such a simple everyday phenomenon seen\nfrom this perspective explains the seemingly complex working of the three\nbuses. We told the servant to \u201cbring a book\u201d and the one which is \u201cfifth from\ntop,\u201d precise location even for the servant who is much more intelligent then\nour dumb memory. The dumb servant follows the steps one by one and the\nbook is in your hand as a result. If however you just asked him for a book or\nyou named the book, your uneducated servant will stand there gazing at you\nand the book will never come in your hand.\nEven in this simplest of all examples, mathematics is there, \u201cfifth from\ntop.\u201d Without a number the servant would not be able to locate the book. He\nis unable to understand your will. Then you tell him to put it with the\nseventh book on the right shelf. Precision is involved and only numbers are\nprecise in this world. One will always be one and two will always be two. So\nwe tell in the form of a number on the address bus which cell is needed out\nof say the 2000 cells in the whole memory.\nA binary number is generated on the address bus, fifth, seventh, eighth,\ntenth; the cell which is needed. So the cell number is placed on the address\nbus. A memory cell is an n-bit location to store data, normally 8-bit also\ncalled a byte. The number of bits in a cell is called the cell width. The two\ndimensions, cell width and number of cells, define the memory completely\njust like the width and depth of a well defines it completely. 200 feet deep by\n15 feet wide and the well is completely described. Similarly for memory we\ndefine two dimensions. The first dimension defines how many parallel bits\nare there in a single memory cell. The memory is called 8-bit or 16-bit for\nthis reason and this is also the word size of the memory. This need not\nmatch the size of a processor word which has other parameters to define it.\nIn general the memory cell cannot be wider than the width of the data bus.\nBest and simplest operation requires the same size of data bus and memory\ncell width.\nVirtual University of Pakistan 2\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nAs we previously discussed that the control bus carries the intent of the\nprocessor that it wants to read or to write. Memory changes its behavior in\nresponse to this signal from the processor. It defines the direction of data\nflow. If processor wants to read but memory wants to write, there will be no\ncommunication or useful flow of information. Both must be synchronized,\nlike a speaker speaks and the listener listens. If both speak simultaneously\nor both listen there will be no communication. This precise synchronization\nbetween the processor and the memory is the responsibility of the control\nbus.\nControl bus is only the mechanism. The responsibility of sending the\nappropriate signals on the control bus to the memory is of the processor.\nSince the memory never wants to listen or to speak of itself. Then why is the\ncontrol bus bidirectional. Again we take the same example of the servant and\nthe book further to elaborate this situation. Consider that the servant went\nto fetch the book just to find that the drawing room door is locked. Now the\nservant can wait there indefinitely keeping us in surprise or come back and\ninform us about the situation so that we can act accordingly. The servant\neven though he was obedient was unable to fulfill our orders so in all his\nobedience, he came back to inform us about the problem. Synchronization is\nstill important, as a result of our orders either we got the desired cell or we\ncame to know that the memory is locked for the moment. Such information\ncannot be transferred via the address or the data bus. For such situations\nwhen peripherals want to talk to the processor when the processor wasn\u2019t\nexpecting them to speak, special lines in the control bus are used. The\ninformation in such signals is usually to indicate the incapability of the\nperipheral to do something for the moment. For these reasons the control\nbus is a bidirectional bus and can carry information from processor to\nmemory as well as from memory to processor.\n1.2. REGISTERS\nThe basic purpose of a computer is to perform operations, and operations\nneed operands. Operands are the data on which we want to perform a certain\noperation. Consider the addition operation; it involves adding two numbers\nto get their sum. We can have precisely one address on the address bus and\nconsequently precisely one element on the data bus. At the very same instant\nthe second operand cannot be brought inside the processor. As soon as the\nsecond is selected, the first operand is no longer there. For this reason there\nare temporary storage places inside the processor called registers. Now one\noperand can be read in a register and added into the other which is read\ndirectly from the memory. Both are made accessible at one instance of time,\none from inside the processor and one from outside on the data bus. The\nresult can be written to at a distinct location as the operation has completed\nand we can access a different memory cell. Sometimes we hold both\noperands in registers for the sake of efficiency as what we can do inside the\nprocessor is undoubtedly faster than if we have to go outside and bring the\nsecond operand.\nRegisters are like a scratch pad ram inside the processor and their\noperation is very much like normal memory cells. They have precise locations\nand remember what is placed inside them. They are used when we need\nmore than one data element inside the processor at one time. The concept of\nregisters will be further elaborated as we progress into writing our first\nprogram.\nMemory is a limited resource but the number of memory cells is large.\nRegisters are relatively very small in number, and are therefore a very scarce\nand precious resource. Registers are more than one in number, so we have to\nprecisely identify or name them. Some manufacturers number their registers\nlike r0, r1, r2, others name them like A, B, C, D etc. Naming is useful since\nthe registers are few in number. This is called the nomenclature of the\nVirtual University of Pakistan 3\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nparticular architecture. Still other manufacturers name their registers\naccording to their function like X stands for an index register. This also\ninforms us that there are special functions of registers as well, some of which\nare closely associated to the particular architecture. For example index\nregisters do not hold data instead they are used to hold the address of data.\nThere are other functions as well and the whole spectrum of register\nfunctionalities is quite large. However most of the details will become clear as\nthe registers of the Intel architecture are discussed in detail.\nAccumulator\nThere is a central register in every processor called the accumulator.\nTraditionally all mathematical and logical operations are performed on the\naccumulator. The word size of a processor is defined by the width of its\naccumulator. A 32bit processor has an accumulator of 32 bits.\nPointer, Index, or Base Register\nThe name varies from manufacturer to manufacturer, but the basic\ndistinguishing property is that it does not hold data but holds the address of\ndata. The rationale can be understood by examining a \u201cfor\u201d loop in a higher\nlevel language, zeroing elements in an array of ten elements located in\nconsecutive memory cells. The location to be zeroed changes every iteration.\nThat is the address where the operation is performed is changing. Index\nregister is used in such a situation to hold the address of the current array\nlocation. Now the value in the index register cannot be treated as data, but it\nis the address of data. In general whenever we need access to a memory\nlocation whose address is not known until runtime we need an index\nregister. Without this register we would have needed to explicitly code each\niteration separately.\nIn newer architectures the distinction between accumulator and index\nregisters has become vague. They have general registers which are more\nversatile and can do both functions. They do have some specialized behaviors\nbut basic operations can be done on all general registers.\nFlags Register or Program Status Word\nThis is a special register in every architecture called the flags register or\nthe program status word. Like the accumulator it is an 8, 16, or 32 bits\nregister but unlike the accumulator it is meaningless as a unit, rather the\nindividual bits carry different meanings. The bits of the accumulator work in\nparallel as a unit and each bit mean the same thing. The bits of the flags\nregister work independently and individually, and combined its value is\nmeaningless.\nAn example of a bit commonly present in the flags register is the carry flag.\nThe carry can be contained in a single bit as in binary arithmetic the carry\ncan only be zero or one. If a 16bit number is added to a 16bit accumulator,\nand the result is of 17 bits the 17th bit is placed in the carry bit of the flags\nregister. Without this 17th bit the answer is incorrect. More examples of flags\nwill be discussed when dealing with the Intel specific register set.\nProgram Counter or Instruction Pointer\nEverything must translate into a binary number for our dumb processor to\nunderstand it, be it an operand or an operation itself. Therefore the\ninstructions themselves must be translated into numbers. For example to\nadd numbers we understand the word \u201cadd.\u201d We translate this word into a\nnumber to make the processor understand it. This number is the actual\ninstruction for the computer. All the objects, inheritance and encapsulation\nconstructs in higher level languages translate down to just a number in\nassembly language in the end. Addition, multiplication, shifting; all big\nVirtual University of Pakistan 4\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nprograms are made using these simple building blocks. A number is at the\nbottom line since this is the only thing a computer can understand.\nA program is defined to be \u201can ordered set of instructions.\u201d Order in this\ndefinition is a key part. Instructions run one after another, first, second,\nthird and so on. Instructions have a positional relationship. The whole logic\ndepends on this positioning. If the computer executes the fifth instructions\nafter the first and not the second, all our logic is gone. The processor should\nensure this ordering of instructions. A special register exists in every\nprocessor called the program counter or the instruction pointer that ensures\nthis ordering. \u201cThe program counter holds the address of the next instruction\nto be executed.\u201d A number is placed in the memory cell pointed to by this\nregister and that number tells the processor which instruction to execute; for\nexample 0xEA, 255, or 152. For the processor 152 might be the add\ninstruction. Just this one number tells it that it has to add, where its\noperands are, and where to store the result. This number is called the\nopcode. The instruction pointer moves from one opcode to the next. This is\nhow our program executes and progresses. One instruction is picked, its\noperands are read and the instruction is executed, then the next instruction\nis picked from the new address in instruction pointer and so on.\nRemembering 152 for the add operation or 153 for the subtract operation\nis difficult. To make a simple way to remember difficult things we associate a\nsymbol to every number. As when we write \u201cadd\u201d everyone understands what\nwe mean by it. Then we need a small program to convert this \u201cadd\u201d of ours to\n152 for the processor. Just a simple search and replace operation to\ntranslate all such symbols to their corresponding opcodes. We have mapped\nthe numeric world of the processor to our symbolic world. \u201cAdd\u201d conveys a\nmeaning to us but the number 152 does not. We can say that add is closer to\nthe programmer\u2019s thinking. This is the basic motive of adding more and more\ntranslation layers up to higher level languages like C++ and Java and Visual\nBasic. These symbols are called instruction mnemonics. Therefore the\nmnemonic \u201cadd a to b\u201d conveys more information to the reader. The dumb\ntranslator that will convert these mnemonics back to the original opcodes is\na key program to be used throughout this course and is called the assembler.\n1.3. INSTRUCTION GROUPS\nUsual opcodes in every processor exist for moving data, arithmetic and\nlogical manipulations etc. However their mnemonics vary depending on the\nwill of the manufacturer. Some manufacturers name the mnemonics for data\nmovement instructions as \u201cmove,\u201d some call it \u201cload\u201d and \u201cstore\u201d and still\nother names are present. But the basic set of instructions is similar in every\nprocessor. A grouping of these instructions makes learning a new processor\nquick and easy. Just the group an instruction belongs tells a lot about the\ninstruction.\nData Movement Instructions\nThese instructions are used to move data from one place to another. These\nplaces can be registers, memory, or even inside peripheral devices. Some\nexamples are:\nmov ax, bx\nlad 1234\nArithmetic and Logic Instructions\nArithmetic instructions like addition, subtraction, multiplication, division\nand Logical instructions like logical and, logical or, logical xor, or\ncomplement are part of this group. Some examples are:\nand ax, 1234\nadd bx, 0534\nadd bx, [1200]\nVirtual University of Pakistan 5\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nThe bracketed form is a complex variation meaning to add the data placed\nat address 1200. Addressing data in memory is a detailed topic and is\ndiscussed in the next chapter.\nProgram Control Instructions\nThe instruction pointer points to the next instruction and instructions run\none after the other with the help of this register. We can say that the\ninstructions are tied with one another. In some situations we don\u2019t want to\nfollow this implied path and want to order the processor to break its flow if\nsome condition becomes true instead of the spatially placed next instruction.\nIn certain other cases we want the processor to first execute a separate block\nof code and then come back to resume processing where it left.\nThese are instructions that control the program execution and flow by\nplaying with the instruction pointer and altering its normal behavior to point\nto the next instruction. Some examples are:\ncmp ax, 0\njne 1234\nWe are changing the program flow to the instruction at 1234 address if the\ncondition that we checked becomes true.\nSpecial Instructions\nAnother group called special instructions works like the special service\ncommandos. They allow changing specific processor behaviors and are used\nto play with it. They are used rarely but are certainly used in any meaningful\nprogram. Some examples are:\ncli\nsti\nWhere cli clears the interrupt flag and sti sets it. Without delving deep into\nit, consider that the cli instruction instructs the processor to close its ears\nfrom the outside world and never listen to what is happening outside,\npossibly to do some very important task at hand, while sti restores normal\nbehavior. Since these instructions change the processor behavior they are\nplaced in the special instructions group.\n1.4. INTEL IAPX88 ARCHITECTURE\nNow we select a specific architecture to discuss these abstract ideas in\nconcrete form. We will be using IBM PC based on Intel architecture because\nof its wide availability, because of free assemblers and debuggers available\nfor it, and because of its wide use in a variety of domains. However the\nconcepts discussed will be applicable on any other architecture as well; just\nthe mnemonics of the particular language will be different.\nTechnically iAPX88 stands for \u201cIntel Advanced Processor Extensions 88.\u201d It\nwas a very successful processor also called 8088 and was used in the very\nfirst IBM PC machines. Our discussion will revolve around 8088 in the first\nhalf of the course while in the second half we will use iAPX386 which is very\nadvanced and powerful processor. 8088 is a 16bit processor with its\naccumulator and all registers of 16 bits. 386 on the other hand, is a 32bit\nprocessor. However it is downward compatible with iAPX88 meaning that all\ncode written for 8088 is valid on the 386. The architecture of a processor\nmeans the organization and functionalities of the registers it contains and\nthe instructions that are valid on the processor. We will discuss the register\narchitecture of 8088 in detail below while its instructions are discussed in\nthe rest of the book at appropriate places.\n1.5. HISTORY\nIntel did release some 4bit processors in the beginning but the first\nmeaningful processor was 8080, an 8bit processor. The processor became\nVirtual University of Pakistan 6\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\npopular due to its simplistic design and versatile architecture. Based on the\nexperience gained from 8080, an advanced version was released as 8085.\nThe processor became widely popular in the engineering community again\ndue to its simple and logical nature.\nIntel introduced the first 16bit processor named 8088 at a time when the\nconcept of personal computer was evolving. With a maximum memory of 64K\non the 8085, the 8088 allowed a whole mega byte. IBM embedded this\nprocessor in their personal computer. The first machines ran at 4.43 MHz; a\nblazing speed at that time. This was the right thing at the right moment. No\none expected this to become the biggest success of computing history. IBM\nPC XT became so popular and successful due to its open architecture and\neasily available information.\nThe success was unexpected for the developers themselves. As when Intel\nintroduced the processor it contained a timer tick count which was valid for\nfive years only. They never anticipated the architecture to stay around for\nmore than five years but the history took a turn and the architecture is there\nat every desk even after 25 years and the tick is to be specially handled every\nnow and then.\n1.6. REGISTER ARCHITECTURE\nThe iAPX88 architecture consists of 14 registers.\nCS SP\nDS BP\nSS SI\nES DI\nAH AL (AX)\nIP BH BL (BX)\nCH CL (CX)\nFLAGS DH DL (DX)\nGeneral Registers (AX, BX, CX, and DX)\nThe registers AX, BX, CX, and DX behave as general purpose registers in\nIntel architecture and do some specific functions in addition to it. X in their\nnames stand for extended meaning 16bit registers. For example AX means\nwe are referring to the extended 16bit \u201cA\u201d register. Its upper and lower byte\nare separately accessible as AH (A high byte) and AL (A low byte). All general\npurpose registers can be accessed as one 16bit register or as two 8bit\nregisters. The two registers AH and AL are part of the big whole AX. Any\nchange in AH or AL is reflected in AX as well. AX is a composite or extended\nregister formed by gluing together the two parts AH and AL.\nThe A of AX stands for Accumulator. Even though all general purpose\nregisters can act as accumulator in most instructions there are some specific\nvariations which can only work on AX which is why it is named the\naccumulator. The B of BX stands for Base because of its role in memory\naddressing as discussed in the next chapter. The C of CX stands for Counter\nas there are certain instructions that work with an automatic count in the\nCX register. The D of DX stands for Destination as it acts as the destination\nin I/O operations. The A, B, C, and D are in letter sequence as well as depict\nsome special functionality of the register.\nVirtual University of Pakistan 7\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nIndex Registers (SI and DI)\nSI and DI stand for source index and destination index respectively. These\nare the index registers of the Intel architecture which hold address of data\nand used in memory access. Being an open and flexible architecture, Intel\nallows many mathematical and logical operations on these registers as well\nlike the general registers. The source and destination are named because of\ntheir implied functionality as the source or the destination in a special class\nof instructions called the string instructions. However their use is not at all\nrestricted to string instructions. SI and DI are 16bit and cannot be used as\n8bit register pairs like AX, BX, CX, and DX.\nInstruction Pointer (IP)\nThis is the special register containing the address of the next instruction to\nbe executed. No mathematics or memory access can be done through this\nregister. It is out of our direct control and is automatically used. Playing with\nit is dangerous and needs special care. Program control instructions change\nthe IP register.\nStack Pointer (SP)\nIt is a memory pointer and is used indirectly by a set of instructions. This\nregister will be explored in the discussion of the system stack.\nBase Pointer (BP)\nIt is also a memory pointer containing the address in a special area of\nmemory called the stack and will be explored alongside SP in the discussion\nof the stack.\nFlags Register\nThe flags register as previously discussed is not meaningful as a unit\nrather it is bit wise significant and accordingly each bit is named separately.\nThe bits not named are unused. The Intel FLAGS register has its bits\norganized as follows:\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nO D I T S Z A P C\nThe individual flags are explained in the following table.\nC Carry When two 16bit numbers are added the answer can be\n17 bits long or when two 8bit numbers are added the\nanswer can be 9 bits long. This extra bit that won\u2019t fit\nin the target register is placed in the carry flag where it\ncan be used and tested.\nP Parity Parity is the number of \u201cone\u201d bits in a binary number.\nParity is either odd or even. This information is\nnormally used in communications to verify the integrity\nof data sent from the sender to the receiver.\nA Auxiliary A number in base 16 is called a hex number and can be\nCarry represented by 4 bits. The collection of 4 bits is called a\nnibble. During addition or subtraction if a carry goes\nfrom one nibble to the next this flag is set. Carry flag is\nfor the carry from the whole addition while auxiliary\ncarry is the carry from the first nibble to the second.\nZ Zero Flag The Zero flag is set if the last mathematical or logical\ninstruction has produced a zero in its destination.\nVirtual University of Pakistan 8\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nS Sign Flag A signed number is represented in its two\u2019s complement\nform in the computer. The most significant bit (MSB) of\na negative number in this representation is 1 and for a\npositive number it is zero. The sign bit of the last\nmathematical or logical operation\u2019s destination is\ncopied into the sign flag.\nT Trap Flag The trap flag has a special role in debugging which will\nbe discussed later.\nI Interrupt Flag It tells whether the processor can be interrupted from\noutside or not. Sometimes the programmer doesn\u2019t\nwant a particular task to be interrupted so the\nInterrupt flag can be zeroed for this time. The\nprogrammer rather than the processor sets this flag\nsince the programmer knows when interruption is okay\nand when it is not. Interruption can be disabled or\nenabled by making this bit zero or one, respectively,\nusing special instructions.\nD Direction Flag Specifically related to string instructions, this flag tells\nwhether the current operation has to be done from\nbottom to top of the block (D=0) or from top to bottom\nof the block (D=1).\nO Overflow Flag The overflow flag is set during signed arithmetic, e.g.\naddition or subtraction, when the sign of the\ndestination changes unexpectedly. The actual process\nsets the overflow flag whenever the carry into the MSB\nis different from the carry out of the MSB\nSegment Registers (CS, DS, SS, and ES)\nThe code segment register, data segment register, stack segment register,\nand the extra segment register are special registers related to the Intel\nsegmented memory model and will be discussed later.\n1.7. OUR FIRST PROGRAM\nThe first program that we will write will only add three numbers. This very\nsimple program will clarify most of the basic concepts of assembly language.\nWe will start with writing our algorithm in English and then moving on to\nconvert it into assembly language.\nEnglish Language Version\n\u201cProgram is an ordered set of instructions for the processor.\u201d Our first\nprogram will be instructions manipulating AX and BX in plain English.\nmove 5 to ax\nmove 10 to bx\nadd bx to ax\nmove 15 to bx\nadd bx to ax\nEven in this simple reflection of thoughts in English, there are some key\nthings to observe. One is the concept of destination as every instruction has\na \u201cto destination\u201d part and there is a source before it as well. For example the\nsecond line has a constant 10 as its source and the register BX as its\ndestination. The key point in giving the first program in English is to convey\nthat the concepts of assembly language are simple but fine. Try to\nunderstand them considering that all above is everyday English that you\nknow very well and every concept will eventually be applicable to assembly\nlanguage.\nVirtual University of Pakistan 9\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nAssembly Language Version\nIntel could have made their assembly language exactly identical to our\nprogram in plain English but they have abbreviated a lot of symbols to avoid\nunnecessarily lengthy program when the meaning could be conveyed with\nless effort. For example Intel has named their move instruction \u201cmov\u201d instead\nof \u201cmove.\u201d Similarly the Intel order of placing source and destination is\nopposite to what we have used in our English program, just a change of\ninterpretation. So the Intel way of writing things is:\noperation destination, source\noperation destination\noperation source\noperation\nThe later three variations are for instructions that have one or both of their\noperands implied or they work on a single or no operand. An implied operand\nmeans that it is always in a particular register say the accumulator, and it\nneed not be mentioned in the instruction. Now we attempt to write our\nprogram in actual assembly language of the iapx88.\nExample 1.1\n001 ; a program to add three numbers using registers\n002 [org 0x0100]\n003 mov ax, 5 ; load first number in ax\n004 mov bx, 10 ; load second number in bx\n005 add ax, bx ; accumulate sum in ax\n006 mov bx, 15 ; load third number in bx\n007 add ax, bx ; accumulate sum in ax\n008\n009 mov ax, 0x4c00 ; terminate program\n010 int 0x21\n001 To start a comment a semicolon is used and the assembler ignores\neverything else on the same line. Comments must be extensively\nused in assembly language programs to make them readable.\n002 Leave the org directive for now as it will be discussed later.\n003 The constant 5 is loaded in one register AX.\n004 The constant 10 is loaded in another register BX.\n005 Register BX is added to register AX and the result is stored in\nregister AX. Register AX should contain 15 by now.\n006 The constant 15 is loaded in the register BX.\n007 Register BX is again added to register AX now producing 15+15=30\nin the AX register. So the program has computed 5+10+15=30.\n008 Vertical spacing must also be used extensively in assembly language\nprograms to separate logical blocks of code.\n009-010 The ending lines are related more to the operating system than to\nassembly language programming. It is a way to inform DOS that our\nprogram has terminated so it can display its command prompt\nagain. The computer may reboot or behave improperly if this\ntermination is not present.\nAssembler, Linker, and Debugger\nWe need an assembler to assemble this program and convert this into\nexecutable binary code. The assembler that we will use during this course is\n\u201cNetwide Assembler\u201d or NASM. It is a free and open source assembler. And\nthe tool that will be most used will be the debugger. We will use a free\ndebugger called \u201cA fullscreen debugger\u201d or AFD. These are the whole set of\nVirtual University of Pakistan 10\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nweapons an assembly language programmer needs for any task whatsoever\nat hand.\nTo assemble we will give the following command to the processor assuming\nthat our input file is named EX01.ASM.\nnasm ex01.asm \u2013o ex01.com \u2013l ex01.lst\nThis will produce two files EX01.COM that is our executable file and\nEX01.LST that is a special listing file that we will explore now. The listing file\nproduced for our example above is shown below with comments removed for\nneatness.\n1\n2 [org 0x0100]\n3 00000000 B80500 mov ax, 5\n4 00000003 BB0A00 mov bx, 10\n5 00000006 01D8 add ax, bx\n6 00000008 BB0F00 mov bx, 15\n7 0000000B 01D8 add ax, bx\n8\n9 0000000D B8004C mov ax, 0x4c00\n10 00000010 CD21 int 0x21\nThe first column in the above listing is offset of the listed instruction in the\noutput file. Next column is the opcode into which our instruction was\ntranslated. In this case this opcode is B8. Whenever we move a constant into\nAX register the opcode B8 will be used. After it 0500 is appended which is\nthe immediate operand to this instruction. An immediate operand is an\noperand which is placed directly inside the instruction. Now as the AX\nregister is a word sized register, and one hexadecimal digit takes 4 bits so 4\nhexadecimal digits make one word or two bytes. Which of the two bytes\nshould be placed first in the instruction, the least significant or the most\nsignificant? Similarly for 32bit numbers either the order can be most\nsignificant, less significant, lesser significant, and least significant called the\nbig-endian order used by Motorola and some other companies or it can be\nleast significant, more significant, more significant, and most significant\ncalled the little-endian order and is used by Intel. The big-endian have the\nargument that it is more natural to read and comprehend while the little-\nendian have the argument that this scheme places the less significant value\nat a lesser address and more significant value at a higher address.\nBecause of this the constant 5 in our instruction was converted into 0500\nwith the least significant byte of 05 first and the most significant byte of 00\nafterwards. When read as a word it is 0005 but when written in memory it\nwill become 0500. As the first instruction is three bytes long, the listing file\nshows that the offset of the next instruction in the file is 3. The opcode BB is\nfor moving a constant into the BX register, and the operand 0A00 is the\nnumber 10 in little-endian byte order. Similarly the offsets and opcodes of\nthe remaining instructions are shown in order. The last instruction is placed\nat offset 0x10 or 16 in decimal. The size of the last instruction is two bytes,\nso the size of the complete COM file becomes 18 bytes. This can be verified\nfrom the directory listing, using the DIR command, that the COM file\nproduced is exactly 18 bytes long.\nNow the program is ready to be run inside the debugger. The debugger\nshows the values of registers, flags, stack, our code, and one or two areas of\nthe system memory as data. Debugger allows us to step our program one\ninstruction at a time and observe its effect on the registers and program\ndata. The details of using the AFD debugger can be seen from the AFD\nmanual.\nAfter loading the program in the debugger observe that the first instruction\nis now at 0100 instead of absolute zero. This is the effect of the org directive\nat the start of our program. The first instruction of a COM file must be at\nVirtual University of Pakistan 11\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\noffset 0100 (decimal 255) as a requirement. Also observe that the debugger is\nshowing your program even though it was provided only the COM file and\nneither of the listing file or the program source. This is because the\ntranslation from mnemonic to opcode is reversible and the debugger mapped\nback from the opcode to the instruction mnemonic. This will become\napparent for instructions that have two mnemonics as the debugger might\nnot show the one that was written in the source file.\nAs a result of program execution either registers or memory will change.\nSince our program yet doesn\u2019t touch memory the only changes will be in the\nregisters. Keenly observe the registers AX, BX, and IP change after every\ninstruction. IP will change after every instruction to point to the next\ninstruction while AX will accumulate the result of our addition.\n1.8. SEGMENTED MEMORY MODEL\nRationale\nIn earlier processors like 8080 and 8085 the linear memory model was\nused to access memory. In linear memory model the whole memory appears\nlike a single array of data. 8080 and 8085 could access a total memory of\n64K using the 16 lines of their address bus. When designing iAPX88 the Intel\ndesigners wanted to remain compatible with 8080 and 8085 however 64K\nwas too small to continue with, for their new processor. To get the best of\nboth worlds they introduced the segmented memory model in 8088.\nThere is also a logical argument in favor of a segmented memory model in\naddition to the issue of compatibility discussed above. We have two logical\nparts of our program, the code and the data, and actually there is a third\npart called the program stack as well, but higher level languages make this\ninvisible to us. These three logical parts of a program should appear as three\ndistinct units in memory, but making this division is not possible in the\nlinear memory model. The segmented memory model does allow this\ndistinction.\nMechanism\nThe segmented memory model allows multiple functional windows into the\nmain memory, a code window, a data window etc. The processor sees code\nfrom the code window and data from the data window. The size of one\nwindow is restricted to 64K. 8085 software fits in just one such window. It\nsees code, data, and stack from this one window, so downward compatibility\nis attained.\nHowever the maximum memory iAPX88 can access is 1MB which can be\naccessed with 20 bits. Compare this with the 64K of 8085 that were accessed\nusing 16 bits. The idea is that the 64K window just discussed can be moved\nanywhere in the whole 1MB. The four segment registers discussed in the\nIntel register architecture are used for this purpose. Therefore four windows\ncan exist at one time. For example one window that is pointed to by the CS\nregister contains the currently executing code.\nTo understand the concept, consider the windows of a building. We say\nthat a particular window is 3 feet above the floor and another one is 20 feet\nabove the floor. The reference point, the floor is the base of the segment\ncalled the datum point in a graph and all measurement is done from that\ndatum point considering it to be zero. So CS holds the zero or the base of\ncode. DS holds the zero of data. Or we can say CS tells how high code from\nthe floor is, and DS tells how high data from the floor is, while SS tells how\nhigh the stack is. One extra segment ES can be used if we need to access two\ndistant areas of memory at the same time that both cannot be seen through\nthe same window. ES also has special role in string instructions. ES is used\nas an extra data segment and cannot be used as an extra code or stack\nsegment.\nVirtual University of Pakistan 12\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nRevisiting the concept again, like the datum point of a graph, the segment\nregisters tell the start of our window which can be opened anywhere in the\nmegabyte of memory available. The window is of a fixed size of 64KB. Base\nand offset are the two key variables in a segmented address. Segment tells\nthe base while offset is added into it. The registers IP, SP, BP, SI, DI, and BX\nall can contain a 16bit offset in them and access memory relative to a\nsegment base.\nThe IP register cannot work alone. It needs the CS register to open a 64K\nwindow in the 1MB memory and then IP works to select code from this\nwindow as offsets. IP works only inside this window and cannot go outside of\nthis 64K in any case. If the window is moved i.e. the CS register is changed,\nIP will change its behavior accordingly and start selecting from the new\nwindow. The IP register always works relatively, relative to the segment base\nstored in the CS register. IP is a 16bit register capable of accessing only 64K\nmemory so how the whole megabyte can contain code anywhere. Again the\nsame concept is there, it can access 64K at one instance of time. As the base\nis changed using the CS register, IP can be made to point anywhere in the\nwhole megabyte. The process is illustrated with the following diagram.\nPhysical Address\n00000\nSegment\nBase\nxxxx0\nOffset Paragraph\n64K Boundary\nFFFFF\nPhysical Address Calculation\nNow for the whole megabyte we need 20 bits while CS and IP are both\n16bit registers. We need a mechanism to make a 20bit number out of the two\n16bit numbers. Consider that the segment value is stored as a 20 bit number\nwith the lower four bits zero and the offset value is stored as another 20 bit\nnumber with the upper four bits zeroed. The two are added to produce a\n20bit absolute address. A carry if generated is dropped without being stored\nanywhere and the phenomenon is called address wraparound. The process is\nexplained with the help of the following diagram.\nVirtual University of Pakistan 13\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n15----------------------------0\n16bit Segment Register 0000 Segment Address\n15----------------------------0\n0000 16bit Logical Address Offset Address\n19-----------------------------------0\n20bit Physical Address\nTherefore memory is determined by a segment-offset pair and not alone by\nany one register which will be an ambiguous reference. Every offset register\nis assigned a default segment register to resolve such ambiguity. For example\nthe program we wrote when loaded into memory had a value of 0100 in IP\nregister and some value say 1DDD in the CS register. Making both 20 bit\nnumbers, the segment base is 1DDD0 and the offset is 00100 and adding\nthem we get the physical memory address of 1DED0 where the opcode\nB80500 is placed.\nParagraph Boundaries\nAs the segment value is a 16bit number and four zero bits are appended to\nthe right to make it a 20bit number, segments can only be defined a 16byte\nboundaries called paragraph boundaries. The first possible segment value is\n0000 meaning a physical base of 00000 and the next possible value of 0001\nmeans a segment base of 00010 or 16 in decimal. Therefore segments can\nonly be defined at 16 byte boundaries.\nOverlapping Segments\nWe can also observe that in the case of our program CS, DS, SS, and ES\nall had the same value in them. This is called overlapping segments so that\nwe can see the same memory from any window. This is the structure of a\nCOM file.\nUsing partially overlapping segments we can produce a number of\nsegment, offset pairs that all access the same memory. For example\n1DDD:0100 and IDED:0000 both point to the same physical memory. To test\nthis we can open a data window at 1DED:0000 in the debugger and change\nthe first three bytes to \u201c90\u201d which is the opcode for NOP (no operation). The\nchange is immediately visible in the code window which is pointed to by CS\ncontaining 1DDD. Similarly IDCD:0200 also points to the same memory\nlocation. Consider this like a portion of wall that three different people on\nthree different floors are seeing through their own windows. One of them\npainted the wall red; it will be changed for all of them though their\nperspective is different. It is the same phenomenon occurring here.\nThe segment, offset pair is called a logical address, while the 20bit address\nis a physical address which is the real thing. Logical addressing is a\nmechanism to access the physical memory. As we have seen three different\nlogical addresses accessed the same physical address.\nVirtual University of Pakistan 14\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n00000\n1DCD0\n1DDD0 Offset\nOffset 0200\n0100\n1DED0\n64K\n64K\nFFFFF\nEXERCISES\n1. How the processor uses the address bus, the data bus, and the\ncontrol bus to communicate with the system memory?\n2. Which of the following are unidirectional and which are bidirectional?\na. Address Bus\nb. Data Bus\nc. Control Bus\n3. What are registers and what are the specific features of the\naccumulator, index registers, program counter, and program status\nword?\n4. What is the size of the accumulator of a 64bit processor?\n5. What is the difference between an instruction mnemonic and its\nopcode?\n6. How are instructions classified into groups?\n7. A combination of 8bits is called a byte. What is the name for 4bits and\nfor 16bits?\n8. What is the maximum memory 8088 can access?\n9. List down the 14 registers of the 8088 architecture and briefly\ndescribe their uses.\n10. What flags are defined in the 8088 FLAGS register? Describe the\nfunction of the zero flag, the carry flag, the sign flag, and the overflow\nflag.\n11. Give the value of the zero flag, the carry flag, the sign flag, and the\noverflow flag after each of the following instructions if AX is initialized\nwith 0x1254 and BX is initialized with 0x0FFF.\na. add ax, 0xEDAB\nb. add ax, bx\nc. add bx, 0xF001\n12. What is the difference between little endian and big endian formats?\nWhich format is used by the Intel 8088 microprocessor?\n13. For each of the following words identify the byte that is stored at lower\nmemory address and the byte that is stored at higher memory address\nin a little endian computer.\na. 1234\nb. ABFC\nc. B100\nd. B800\nVirtual University of Pakistan 15\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n14. What are the contents of memory locations 200, 201, 202, and 203 if\nthe word 1234 is stored at offset 200 and the word 5678 is stored at\noffset 202?\n15. What is the offset at which the first executable instruction of a COM\nfile must be placed?\n16. Why was segmentation originally introduced in 8088 architecture?\n17. Why a segment start cannot start from the physical address 55555.\n18. Calculate the physical memory address generated by the following\nsegment offset pairs.\na. 1DDD:0436\nb. 1234:7920\nc. 74F0:2123\nd. 0000:6727\ne. FFFF:4336\nf. 1080:0100\ng. AB01:FFFF\n19. What are the first and the last physical memory addresses accessible\nusing the following segment values?\na. 1000\nb. 0FFF\nc. 1002\nd. 0001\ne. E000\n20. Write instructions that perform the following operations.\na. Copy BL into CL\nb. Copy DX into AX\nc. Store 0x12 into AL\nd. Store 0x1234 into AX\ne. Store 0xFFFF into AX\n21. Write a program in assembly language that calculates the square of\nsix by adding six to the accumulator six times.\nVirtual University of Pakistan 16\n2\nAddressing Modes\n2.1. DATA DECLARATION\nThe first instruction of our first assembly language program was \u201cmov ax,\n5.\u201d Here MOV was the opcode; AX was the destination operand, while 5 was\nthe source operand. The value of 5 in this case was stored as part of the\ninstruction encoding. In the opcode B80500, B8 was the opcode and 0500\nwas the operand stored immediately afterwards. Such an operand is called\nan immediate operand. It is one of the many types of operands available.\nWriting programs using just the immediate operand type is difficult. Every\nreasonable program needs some data in memory apart from constants.\nConstants cannot be changed, i.e. they cannot appear as the destination\noperand. In fact placing them as destination is meaningless and illegal\naccording to assembly language syntax. Only registers or data placed in\nmemory can be changed. So real data is the one stored in memory, with a\nvery few constants. So there must be a mechanism in assembly language to\nstore and retrieve data from memory.\nTo declare a part of our program as holding data instead of instructions we\nneed a couple of very basic but special assembler directives. The first\ndirective is \u201cdefine byte\u201d written as \u201cdb.\u201d\ndb somevalue\nAs a result a cell in memory will be reserved containing the desired value\nin it and it can be used in a variety of ways. Now we can add variables\ninstead of constants. The other directive is \u201cdefine word\u201d or \u201cdw\u201d with the\nsame syntax as \u201cdb\u201d but reserving a whole word of 16 bits instead of a byte.\nThere are directives to declare a double or a quad word as well but we will\nrestrict ourselves to byte and word declarations for now. For single byte we\nuse db and for two bytes we use dw.\nTo refer to this variable later in the program, we need the address occupied\nby this variable. The assembler is there to help us. We can associate a\nsymbol with any address that we want to remember and use that symbol in\nthe rest of the code. The symbol is there for our own comprehension of code.\nThe assembler will calculate the address of that symbol using our origin\ndirective and calculating the instruction lengths or data declarations in-\nbetween and replace all references to the symbol with the corresponding\naddress. This is just like variables in a higher level language, where the\ncompiler translates them into addresses; just the process is hidden from the\nprogrammer one level further. Such a symbol associated to a point in the\nprogram is called a label and is written as the label name followed by a colon.\n2.2. DIRECT ADDRESSING\nNow we will rewrite our first program such that the numbers 5, 10, and 15\nare stored as memory variables instead of constants and we access them\nfrom there.\nExample 2.1\n001 ; a program to add three numbers using memory variables\n002 [org 0x0100]\n003 mov ax, [num1] ; load first number in ax\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n004 mov bx, [num2] ; load second number in bx\n005 add ax, bx ; accumulate sum in ax\n006 mov bx, [num3] ; load third number in bx\n007 add ax, bx ; accumulate sum in ax\n008 mov [num4], ax ; store sum in num4\n009\n010 mov ax, 0x4c00 ; terminate program\n011 int 0x21\n012\n013 num1: dw 5\n014 num2: dw 10\n015 num3: dw 15\n016 num4: dw 0\n002 Originate our program at 0100. The first executable instruction\nshould be placed at this offset.\n003 The source operand is changed from constant 5 to [num1]. The\nbracket is signaling that the operand is placed in memory at address\nnum1. The value 5 will be loaded in ax even though we did not\nspecified it in our program code, rather the value will be picked from\nmemory. The instruction should be read as \u201cread the contents of\nmemory location num1 in the ax register.\u201d The label num1 is a\nsymbol for us but an address for the processor while the conversion\nis done by the assembler.\n013 The label num1 is defined as a word and the assembler is requested\nto place 5 in that memory location. The colon signals that num1 is a\nlabel and not an instruction.\nUsing the same process to assemble as discussed before we examine the\nlisting file generated as a result with comments removed.\n1\n2 [org 0x0100]\n3 00000000 A1[1700] mov ax, [num1]\n4 00000003 8B1E[1900] mov bx, [num2]\n5 00000007 01D8 add ax, bx\n6 00000009 8B1E[1B00] mov bx, [num3]\n7 0000000D 01D8 add ax, bx\n8 0000000F A3[1D00] mov [num4], ax\n9\n10 00000012 B8004C mov ax, 0x4c00\n11 00000015 CD21 int 0x21\n12\n13 00000017 0500 num1: dw 5\n14 00000019 0A00 num2: dw 10\n15 0000001B 0F00 num3: dw 15\n16 0000001D 0000 num4: dw 0\nThe first instruction of our program has changed from B80500 to A11700.\nThe opcode B8 is used to move constants into AX, while the opcode A1 is\nused when moving data into AX from memory. The immediate operand to our\nnew instruction is 1700 or as a word 0017 (23 decimal) and from the bottom\nof the listing file we can observe that this is the offset of num1. The\nassembler has calculated the offset of num1 and used it to replace references\nto num1 in the whole program. Also the value 0500 can be seen at offset\n0017 in the file. We can say contents of memory location 0017 are 0005 as a\nword. Similarly num2, num3, and num4 are placed at 0019, 001B, and\n001D addresses.\nWhen the program is loaded in the debugger, it is loaded at offset 0100,\nwhich displaces all memory accesses in our program. The instruction\nA11700 is changed to A11701 meaning that our variable is now placed at\n0117 offset. The instruction is shown as mov ax, [0117]. Also the data\nwindow can be used to verify that offset 0117 contains the number 0005.\nVirtual University of Pakistan 18\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExecute the program step by step and examine how the memory is read and\nthe registers are updated, how the instruction pointer moves forward, and\nhow the result is saved back in memory. Also observe inside the debugger\ncode window below the code for termination, that the debugger is\ninterpreting our data as code and showing it as some meaningless\ninstructions. This is because the debugger sees everything as code in the\ncode window and cannot differentiate our declared data from opcodes. It is\nour responsibility that we terminate execution before our data is executed as\ncode.\nAlso observe that our naming of num1, num2, num3, and num4 is no\nlonger there inside the debugger. The debugger is only showing the numbers\n0117, 0119, 011B, and 011D. Our numerical machine can only work with\nnumbers. We used symbols for our ease to label or tag certain positions in\nour program. The assembler converts these symbols into the appropriate\nnumbers automatically. Also observe that the effect of \u201cdw\u201d is to place 5 in\ntwo bytes as 0005. Had we used \u201cdb\u201d this would have been stored as 05 in\none byte.\nGiven the fact that the assembler knows only numbers we can write the\nsame program using a single label. As we know that num2 is two ahead of\nnum1, we can use num1+2 instead of num2 and let the assembler calculate\nthe sum during assembly process.\nExample 2.2\n001 ; a program to add three numbers accessed using a single label\n002 [org 0x0100]\n003 mov ax, [num1] ; load first number in ax\n004 mov bx, [num1+2] ; load second number in bx\n005 add ax, bx ; accumulate sum in ax\n006 mov bx, [num1+4] ; load third number in bx\n007 add ax, bx ; accumulate sum in ax\n008 mov [num1+6], ax ; store sum at num1+6\n009\n010 mov ax, 0x4c00 ; terminate program\n011 int 0x21\n012\n013 num1: dw 5\n014 dw 10\n015 dw 15\n016 dw 0\n004 The second number is read from num1+2. Similarly the third\nnumber is read from num1+4 and the result is accessed at num1+6.\n013-016 The labels num2, num3, and num4 are removed and the data there\nwill be accessed with reference to num1.\nEvery location is accessed with reference to num1 in this example. The\nexpression \u201cnum1+2\u201d comprises of constants only and can be evaluated at\nthe time of assembly. There are no variables involved in this expression. As\nwe open the program inside the debugger we see a verbatim copy of the\nprevious program. There is no difference at all since the assembler catered\nfor the differences during assembly. It calculated 0117+2=0119 while in the\nprevious it directly knew from the value of num2 that it has to write 0119,\nbut the end result is a ditto copy of the previous execution.\nAnother way to declare the above data and produce exactly same results is\nshown in the following example.\nExample 2.3\n001 ; a program to add three numbers accessed using a single label\n002 [org 0x0100]\n003 mov ax, [num1] ; load first number in ax\n004 mov bx, [num1+2] ; load second number in bx\nVirtual University of Pakistan 19\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n005 add ax, bx ; accumulate sum in ax\n006 mov bx, [num1+4] ; load third number in bx\n007 add ax, bx ; accumulate sum in ax\n008 mov [num1+6], ax ; store sum at num1+6\n009\n010 mov ax, 0x4c00 ; terminate program\n011 int 0x21\n012\n013 num1: dw 5, 10, 15, 0\n013 As we do not need to place labels on individual variables we can save\nspace and declare all data on a single line separated by commas.\nThis declaration will declare four words in consecutive memory\nlocations while the address of first one is num1.\nThe method used to access memory in the above examples is called direct\naddressing. In direct addressing the memory address is fixed and is given in\nthe instruction. The actual data used is placed in memory and now that data\ncan be used as the destination operand as well. Also the source and\ndestination operands must have the same size. For example a word defined\nmemory is read in a word sized register. A last observation is that the data\n0500 in memory was corrected to 0005 when read in a register. So registers\ncontain data in proper order as a word.\nA last variation using direct addressing shows that we can directly add a\nmemory variable and a register instead of adding a register into another that\nwe were doing till now.\nExample 2.4\n01 ; a program to add three numbers directly in memory\n02 [org 0x0100]\n03 mov ax, [num1] ; load first number in ax\n04 mov [num1+6], ax ; store first number in result\n05 mov ax, [num1+2] ; load second number in ax\n06 add [num1+6], ax ; add second number to result\n07 mov ax, [num1+4] ; load third number in ax\n08 add [num1+6], ax ; add third number to result\n09\n10 mov ax, 0x4c00 ; terminate program\n11 int 0x21\n12\n13 num1: dw 5, 10, 15, 0\nWe generate the following listing file as a result of the assembly process\ndescribed previously. Comments are again removed.\n1\n2 [org 0x0100]\n3 00000000 A1[1900] mov ax, [num1]\n4 00000003 A3[1F00] mov [num1+6], ax\n5 00000006 A1[1B00] mov ax, [num1+2]\n6 00000009 0106[1F00] add [num1+6], ax\n7 0000000D A1[1D00] mov ax, [num1+4]\n8 00000010 0106[1F00] add [num1+6], ax\n9\n10 00000014 B8004C mov ax, 0x4c00\n11 00000017 CD21 int 0x21\n12\n13 00000019 05000A000F000000 num1: dw 5, 10, 15, 0\nThe opcode of add is changed because the destination is now a memory\nlocation instead of a register. No other significant change is seen in the\nlisting file. Inside the debugger we observe that few opcodes are longer now\nand the location num1 is now translating to 0119 instead of 0117. This is\ndone automatically by the assembler as a result of using labels instead of\nVirtual University of Pakistan 20\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nhard coding addresses. During execution we observe that the word data as it\nis read into a register is read in correct order. The significant change in this\nexample is that the destination of addition is memory. Method to access\nmemory is direct addressing, whether it is the MOV instruction or the ADD\ninstruction.\nThe first two instructions of the last program read a number into AX and\nplaced it at another memory location. A quick thought reveals that the\nfollowing might be a possible single instruction to replace the couple.\nmov [num1+6], [num1] ; ILLEGAL\nHowever this form is illegal and not allowed on the Intel architecture. None\nof the general operations of mov add, sub etc. allow moving data from\nmemory to memory. Only register to register, register to memory, memory to\nregister, constant to memory, and constant to register operations are\nallowed. The other register to constant, memory to constant, and memory to\nmemory are all disallowed. Only string instructions allow moving data from\nmemory to memory and will be discussed in detail later. As a rule one\ninstruction can have at most one operand in brackets, otherwise assembler\nwill give an error.\n2.3. SIZE MISMATCH ERRORS\nIf we change the directive in the last example from DW to DB, the program\nwill still assemble and debug without errors, however the results will not be\nthe same as expected. When the first operand is read 0A05 will be read in the\nregister which was actually two operands place in consecutive byte memory\nlocations. The second number will be read as 000F which is the zero byte of\nnum4 appended to the 15 of num3. The third number will be junk depending\non the current state of the machine. According to our data declaration the\nthird number should be at 0114 but it is accessed at 011D calculated with\nword offsets. This is a logical error of the program. To keep the declarations\nand their access synchronized is the responsibility of the programmer and\nnot the assembler. The assembler allows the programmer to do everything he\nwants to do, and that can possibly run on the processor. The assembler only\nkeeps us from writing illegal instructions which the processor cannot\nexecute. This is the difference between a syntax error and a logic error. So\nthe assembler and debugger have both done what we asked them to do but\nthe programmer asked them to do the wrong chore.\nThe programmer is responsible for accessing the data as word if it was\ndeclared as a word and accessing it as a byte if it was declared as a byte. The\nword case is shown in lot of previous examples. If however the intent is to\ntreat it as a byte the following code shows the appropriate way.\nExample 2.5\n001 ; a program to add three numbers using byte variables\n002 [org 0x0100]\n003 mov al, [num1] ; load first number in al\n004 mov bl, [num1+1] ; load second number in bl\n005 add al, bl ; accumulate sum in al\n006 mov bl, [num1+2] ; load third number in bl\n007 add al, bl ; accumulate sum in al\n008 mov [num1+3], al ; store sum at num1+3\n009\n010 mov ax, 0x4c00 ; terminate program\n011 int 0x21\n012\n013 num1: db 5, 10, 15, 0\n003 The number is read in AL register which is a byte register since the\nmemory location read is also of byte size.\n005 The second number is now placed at num1+1 instead of num1+2\nbecause of byte offsets.\nVirtual University of Pakistan 21\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n013 To declare data db is used instead of dw so that each data declared\noccupies one byte only.\nInside the debugger we observe that the AL register takes appropriate\nvalues and the sum is calculated and stored in num1+3. This time there is\nno alignment or synchronization error. The key thing to understand here is\nthat the processor does not match defines to accesses. It is the programmer\u2019s\nresponsibility. In general assembly language gives a lot of power to the\nprogrammer but power comes with responsibility. Assembly language\nprogramming is not a difficult task but a responsible one.\nIn the above examples, the processor knew the size of the data movement\noperation from the size of the register involved, for example in \u201cmov ax,\n[num1]\u201d memory can be accessed as byte or as word, it has no hard and fast\nsize, but the AX register tells that this operation has to be a word operation.\nSimilarly in \u201cmov al, [num1]\u201d the AL register tells that this operation has to\nbe a byte operation. However in \u201cmov ax, bl\u201d the AX register tells that the\noperation has to be a word operation while BL tells that this has to be a byte\noperation. The assembler will declare that this is an illegal instruction. A 5Kg\nbag cannot fit inside a 1Kg bag and according to Intel a 1Kg cannot also fit in\na 5Kg bag. They must match in size. The instruction \u201cmov [num1], [num2]\u201d is\nillegal as previously discussed not because of data movement size but\nbecause memory to memory moves are not allowed at all.\nThe instruction \u201cmov [num1], 5\u201d is legal but there is no way for the\nprocessor to know the data movement size in this operation. The variable\nnum1 can be treated as a byte or as a word and similarly 5 can be treated as\na byte or as a word. Such instructions are declared ambiguous by the\nassembler. The assembler has no way to guess the intent of the programmer\nas it previously did using the size of the register involved but there is no\nregister involved this time. And memory is a linear array and label is an\naddress in it. There is no size associated with a label. Therefore to resolve its\nambiguity we clearly tell our intent to the assembler in one of the following\nways.\nmov byte [num1], 5\nmov word [num1], 5\n2.4. REGISTER INDIRECT ADDRESSING\nWe have done very elementary data access till now. Assume that the\nnumbers we had were 100 and not just three. This way of adding them will\ncost us 200 instructions. There must be some method to do a task repeatedly\non data placed in consecutive memory cells. The key to this is the need for\nsome register that can hold the address of data. So that we can change the\naddress to access some other cell of memory using the same instruction. In\ndirect addressing mode the memory cell accessed was fixed inside the\ninstruction. There is another method in which the address can be placed in a\nregister so that it can be changed. For the following example we will take 10\ninstead of 100 numbers but the algorithm is extensible to any size.\nThere are four registers in iAPX88 architecture that can hold address of\ndata and they are BX, BP, SI, and DI. There are minute differences in their\nworking which will be discussed later. For the current example, we will use\nthe BX register and we will take just three numbers and extend the concept\nwith more numbers in later examples.\nExample 2.6\n001 ; a program to add three numbers using indirect addressing\n002 [org 0x100]\n003 mov bx, num1 ; point bx to first number\n004 mov ax, [bx] ; load first number in ax\n005 add bx, 2 ; advance bx to second number\nVirtual University of Pakistan 22\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n006 add ax, [bx] ; add second number to ax\n007 add bx, 2 ; advance bx to third number\n008 add ax, [bx] ; add third number to ax\n009 add bx, 2 ; advance bx to result\n010 mov [bx], ax ; store sum at num1+6\n011\n012 mov ax, 0x4c00 ; terminate program\n013 int 0x21\n014\n015 num1: dw 5, 10, 15, 0\n003 Observe that no square brackets around num1 are used this time.\nThe address is loaded in bx and not the contents. Value of num1 is\n0005 and the address is 0117. So BX will now contain 0117.\n004 Brackets are now used around BX. In iapx88 architecture brackets\ncan be used around BX, BP, SI, and DI only. In iapx386 more\nregisters are allowed. The instruction will be read as \u201cmove into ax\nthe contents of the memory location whose address is in bx.\u201d Now\nsince bx contains the address of num1 the contents of num1 are\ntransferred to the ax register. Without square brackets the meaning\nof the instruction would have been totally different.\n005 This instruction is changing the address. Since we have words not\nbytes, we add two to bx so that it points to the next word in memory.\nBX now contains 0119 the address of the second word in memory.\nThis was the mechanism to change addresses that we needed.\nInside the debugger we observe that the first instruction is \u201cmov bx, 011C.\u201d\nA constant is moved into BX. This is because we did not use the square\nbrackets around \u201cnum1.\u201d The address of \u201cnum1\u201d has moved to 011C because\nthe code size has changed due to changed instructions. In the second\ninstruction BX points to 011C and the value read in AX is 0005 which can be\nverified from the data window. After the addition BX points to 011E\ncontaining 000A, our next word, and so on. This way the BX register points\nto our words one after another and we can add them using the same\ninstruction \u201cmov ax, [bx]\u201d without fixing the address of our data in the\ninstructions. We can also subtract from BX to point to previous cells. The\naddress to be accessed is now in total program control.\nOne thing that we needed in our problem to add hundred numbers was the\ncapability to change address. The second thing we need is a way to repeat\nthe same instruction and a way to know that the repetition is done a 100\ntimes, a terminal condition for the repetition. For the task we are introducing\ntwo new instructions that you should read and understand as simple English\nlanguage concepts. For simplicity only 10 numbers are added in this\nexample. The algorithm is extensible to any size.\nExample 2.7\n001 ; a program to add ten numbers\n002 [org 0x0100]\n003 mov bx, num1 ; point bx to first number\n004 mov cx, 10 ; load count of numbers in cx\n005 mov ax, 0 ; initialize sum to zero\n006\n007 l1: add ax, [bx] ; add number to ax\n008 add bx, 2 ; advance bx to next number\n009 sub cx, 1 ; numbers to be added reduced\n010 jnz l1 ; if numbers remain add next\n011\n012 mov [total], ax ; write back sum in memory\n013\n014 mov ax, 0x4c00 ; terminate program\n015 int 0x21\n016\n017 num1: dw 10, 20, 30, 40, 50, 10, 20, 30, 40, 50\nVirtual University of Pakistan 23\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n018 total: dw 0\n006 Labels can be used on code as well. Just like data labels they\nremember the address at which they are used. The assembler does\nnot differentiate between code labels and data labels. The\nprogrammer is responsible for using a data label as data and a code\nlabel as code. The label l1 in this case is the address of the following\ninstruction.\n009 SUB is the counterpart to ADD with the same rules as that of the\nADD instruction.\n010 JNZ stands for \u201cjump if not zero.\u201d NZ is the condition in this\ninstruction. So the instruction is read as \u201cjump to the location l1 if\nthe zero flag is not set.\u201d And revisiting the zero flag definition \u201cthe\nzero flag is set if the last mathematical or logical operation has\nproduced a zero in its destination.\u201d For example \u201cmov ax, 0\u201d will not\nset the zero flag as it is not a mathematical or logical instruction.\nHowever subtraction and addition will set it. Also it is set even when\nthe destination is not a register. Now consider the subtraction\nimmediately preceding it. As long as the CX register is non zero after\nthis subtraction the zero flag will not be set and the jump will be\ntaken. And jump to l1, the processor needs to be told each and\neverything and the destination is an important part of every jump.\nJust like when we ask someone to go, we mention go to this market\nor that house. The processor is much more logical than us and\nneeds the destination in every instruction that asks it to go\nsomewhere. The processor will load l1 in the IP register and resume\nexecution from there. The processor will blindly go to the label we\nmention even if it contains data and not code.\nThe CX register is used as a counter in this example, BX contains the\nchanging address, while AX accumulates the result. We have formed a loop\nin assembly language that executes until its condition remains true. Inside\nthe debugger we can observe that the subtract instruction clears the zero flag\nthe first nine times and sets it on the tenth time. While the jump instruction\nmoves execution to address l1 the first nine times and to the following line\nthe tenth time. The jump instruction breaks program flow.\nThe JNZ instruction is from the program control group and is a conditional\njump, meaning that if the condition NZ is true (ZF=0) it will jump to the\naddress mentioned and otherwise it will progress to the next instruction. It is\na selection between two paths. If the condition is true go right and otherwise\ngo left. Or we can say if the weather is hot, go this way, and if it is cold, go\nthis way. Conditional jump is the most important instruction, as it gives the\nprocessor decision making capability, so it must be given a careful thought.\nSome processors call it branch, probably a more logical name for it, however\nthe functionality is same. Intel chose to name it \u201cjump.\u201d\nAn important thing in the above example is that a register is used to\nreference memory so this form of access is called register indirect memory\naccess. We used the BX register for it and the B in BX and BP stands for\nbase therefore we call register indirect memory access using BX or BP,\n\u201cbased addressing.\u201d Similarly when SI or DI is used we name the method\n\u201cindexed addressing.\u201d They have the same functionality, with minor\ndifferences because of which the two are called base and index. The\ndifferences will be explained later, however for the above example SI or DI\ncould be used as well, but we would name it indexed addressing instead of\nbased addressing.\nVirtual University of Pakistan 24\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n2.5. REGISTER + OFFSET ADDRESSING\nDirect addressing and indirect addressing using a single register are two\nbasic forms of memory access. Another possibility is to use different\ncombinations of direct and indirect references. In the above example we used\nBX to access different array elements which were placed consecutively in\nmemory like an array. We can also place in BX only the array index and not\nthe exact address and form the exact address when we are going to access\nthe actual memory. This way the same register can be used for accessing\ndifferent arrays and also the register can be used for index comparison like\nthe following example does.\nExample 2.8\n001 ; a program to add ten numbers using register + offset addressing\n002 [org 0x0100]\n003 mov bx, 0 ; initialize array index to zero\n004 mov cx, 10 ; load count of numbers in cx\n005 mov ax, 0 ; initialize sum to zero\n006\n007 l1: add ax, [num1+bx] ; add number to ax\n008 add bx, 2 ; advance bx to next index\n009 sub cx, 1 ; numbers to be added reduced\n010 jnz l1 ; if numbers remain add next\n011\n012 mov [total], ax ; write back sum in memory\n013\n014 mov ax, 0x4c00 ; terminate program\n015 int 0x21\n016\n017 num1: dw 10, 20, 30, 40, 50, 10, 20, 30, 40, 50\n018 total: dw 0\n003 This time BX is initialized to zero instead of array base\n007 The format of memory access has changed. The array base is added\nto BX containing array index at the time of memory access.\n008 As the array is of words, BX jumps in steps of two, i.e. 0, 2, 4.\nHigher level languages do appropriate incrementing themselves and\nwe always use sequential array indexes. However in assembly\nlanguage we always calculate in bytes and therefore we need to take\ncare of the size of one array element which in this case is two.\nInside the debugger we observe that the memory access instruction is\nshown as \u201cmov ax, [011F+bx]\u201d and the actual memory accessed is the one\nwhose address is the sum of 011F and the value contained in the BX\nregister. This form of access is of the register indirect family and is called\nbase + offset or index + offset depending on whether BX or BP is used or SI\nor DI is used.\n2.6. SEGMENT ASSOCIATION\nAll the addressing mechanisms in iAPX88 return a number called effective\naddress. For example in base + offset addressing, neither the base nor the\noffset alone tells the desired cell in memory to be accessed. It is only after the\naddition is done that the processor knows which cell to be accessed. This\nnumber which came as the result of addition is called the effective address.\nBut the effective address is just an offset and is meaningless without a\nsegment. Only after the segment is known, we can form the physical address\nthat is needed to access a memory cell.\nWe discussed the segmented memory model of iAPX88 in reasonable detail\nat the end of previous chapter. However during the discussion of addressing\nmodes we have not seen the effect of segments. Segmentation is there and\nit\u2019s all happening relative to a segment base. We saw DS, CS, SS, and ES\nVirtual University of Pakistan 25\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ninside the debugger. Everything is relative to its segment base, even though\nwe have not explicitly explained its functionality. An offset alone is not\ncomplete without a segment. As previously discussed there is a default\nsegment associated to every register which accesses memory. For example\nCS is associated to IP by default; rather it is tied with it. It cannot access\nmemory in any other segment.\nIn case of data, there is a bit relaxation and nothing is tied. Rather there is\na default association which can be overridden. In the case of register indirect\nmemory access, if the register used is one of SI, DI, or BX the default\nsegment is DS. If however the register used is BP the default segment used is\nSS. The stack segment has a very critical and fine use and there is a reason\nwhy BP is attached to SS by default. However these will be discussed in\ndetail in the chapter on stack. IP is tied to CS while SP is tied to SS. The\nassociation of these registers cannot be changed; they are locked with no\noption. Others are not locked and can be changed.\nTo override the association for one instruction of one of the registers BX,\nBP, SI or DI, we use the segment override prefix. For example \u201cmov ax,\n[cs:bx]\u201d associates BX with CS for this one instruction. For the next\ninstruction the default association will come back to act. The processor\nplaces a special byte before the instruction called a prefix, just like prefixes\nand suffixes in English language. No prefix is needed or placed for default\nassociation. For example for CS the byte 2E is placed and for ES the byte 26\nis placed. Opcode has not changed, but the prefix byte has modified the\ndefault association to association with the desired segment register for this\none instruction.\nIn all our examples, we never declared a segment or used it explicitly, but\neverything seemed to work fine. The important thing to note is that CS, DS,\nSS, and ES all had the same value. The value itself is not important but the\nfact that all had the same value is important. All four segment windows\nexactly overlap. Whatever segment register we use the same physical memory\nwill be accessed. That is why everything was working without the mention of\na single segment register. This is the formation of COM files in IBM PC. A\nsingle segment contains code, data, and the stack. This format is operating\nsystem dependant, in our case defined by DOS. And our operating system\ndefines the format of COM files such that all segments have the same value.\nThus the only meaningful thing that remains is the offset.\nFor example if BX=0100, SI=0200, and CS=1000 and the memory access\nunder consideration is [cs:bx+si+0x0700], the effective address formed is\nbx+si+0700 = 0100 + 0200 + 0700 = 0A00. Now multiplying the segment\nvalue by 16 makes it 10000 and adding the effective address 00A00 forms\nthe physical address 10A00.\n2.7. ADDRESS WRAPAROUND\nThere are two types of wraparounds. One is within a single segment and\nthe other is inside the whole physical memory. Segment wraparound occurs\nwhen during the effective address calculation a carry is generated. This carry\nis dropped giving the effect that when we try to access beyond the segment\nlimit, we are actually wrapped around to the first cell in the segment. For\nexample if BX=9100, DS=1500 and the access is [bx+0x7000] we form the\neffective address 9100 + 7000 = 10100. The carry generated is dropped\nforming the actual effective address of 0100. Just like a circle when we\nreached the end we started again from the beginning. An arc at 370 degrees\nis the same as an arc at 10 degrees. We tried to cross the segment boundary\nand it pushed us back to the start. This is called segment wraparound. The\nphysical address in the above example will be 15100.\nThe same can also happen at the time of physical address calculation. For\nexample BX=0100, DS=FFF0 and the access under consideration is\n[bx+0x0100]. The effective address will be 0200 and the physical address will\nVirtual University of Pakistan 26\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nbe 100100. This is a 21bit answer and cannot be sent on the address bus\nwhich is 20 bits wide. The carry is dropped and just like the segment\nwraparound our physical memory has wrapped around at its very top. When\nwe tried to access beyond limits the actual access is made at the very start.\nThis second wraparound is a bit different in newer processor with more\naddress lines but that will be explained in later chapters.\n2.8. ADDRESSING MODES SUMMARY\nThe iAPX88 processor supports seven modes of memory access. Remember\nthat immediate is not an addressing mode but an operand type. Operands\ncan be immediate, register, or memory. If the operand is memory one of the\nseven addressing modes will be used to access it. The memory access\nmechanisms can also be written in the general form \u201cbase + index + offset\u201d\nand we can define the possible addressing modes by saying that any one,\ntwo, or none can be skipped from the general form to form a legal memory\naccess.\nThere are a few common mistakes done in forming a valid memory access.\nPart of a register cannot be used to access memory. Like BX is allowed to\nhold an address but BL or BH are not. Address is 16bit and must be\ncontained in a 16bit register. BX-SI is not possible. The only thing that we\ncan do is addition of a base register with an index register. Any other\noperation is disallowed. BS+BP and SI+DI are both disallowed as we cannot\nhave two base or two index registers in one memory access. One has to be a\nbase register and the other has to be an index register and that is the reason\nof naming them differently.\nDirect\nA fixed offset is given in brackets and the memory at that offset is\naccessed. For example \u201cmov [1234], ax\u201d stores the contents of the AX\nregisters in two bytes starting at address 1234 in the current data segment.\nThe instruction \u201cmov [1234], al\u201d stores the contents of the AL register in the\nbyte at offset 1234.\nBased Register Indirect\nA base register is used in brackets and the actual address accessed\ndepends on the value contained in that register. For example \u201cmov [bx], ax\u201d\nmoves the two byte contents of the AX register to the address contained in\nthe BX register in the current data segment. The instruction \u201cmov [bp], al\u201d\nmoves the one byte content of the AL register to the address contained in the\nBP register in the current stack segment.\nIndexed Register Indirect\nAn index register is used in brackets and the actual address accessed\ndepends on the value contained in that register. For example \u201cmov [si], ax\u201d\nmoves the contents of the AX register to the word starting at address\ncontained in SI in the current data segment. The instruction \u201cmov [di], ax\u201d\nmoves the word contained in AX to the offset stored in DI in the current data\nsegment.\nBased Register Indirect + Offset\nA base register is used with a constant offset in this addressing mode. The\nvalue contained in the base register is added with the constant offset to get\nthe effective address. For example \u201cmov [bx+300], ax\u201d stores the word\ncontained in AX at the offset attained by adding 300 to BX in the current\ndata segment. The instruction \u201cmov [bp+300], ax\u201d stores the word in AX to\nthe offset attained by adding 300 to BP in the current stack segment.\nVirtual University of Pakistan 27\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nIndexed Register Indirect + Offset\nAn index register is used with a constant offset in this addressing mode.\nThe value contained in the index register is added with the constant offset to\nget the effective address. For example \u201cmov [si+300], ax\u201d moves the word\ncontained in AX to the offset attained by adding 300 to SI in the current data\nsegment and the instruction \u201cmov [di+300], al\u201d moves the byte contained in\nAL to the offset attained by adding 300 to DI in the current data segment.\nBase + Index\nOne base and one index register is used in this addressing mode. The\nvalue of the base register and the index register are added together to get the\neffective address. For example \u201cmov [bx+si], ax\u201d moves the word contained in\nthe AX register to offset attained by adding BX and SI in the current data\nsegment. The instruction \u201cmov [bp+di], al\u201d moves the byte contained in AL to\nthe offset attained by adding BP and DI in the current stack segment.\nObserve that the default segment is based on the base register and not on\nthe index register. This is why base registers and index registers are named\nseparately. Other examples are \u201cmov [bx+di], ax\u201d and \u201cmov [bp+si], ax.\u201d This\nmethod can be used to access a two dimensional array such that one\ndimension is in a base register and the other is in an index register.\nBase + Index + Offset\nThis is the most complex addressing method and is relatively infrequently\nused. A base register, an index register, and a constant offset are all used in\nthis addressing mode. The values of the base register, the index register, and\nthe constant offset are all added together to get the effective address. For\nexample \u201cmov [bx+si+300], ax\u201d moves the word contents of the AX register to\nthe word in memory starting at offset attained by adding BX, SI, and 300 in\nthe current data segment. Default segment association is again based on the\nbase register. It might be used with the array base of a two dimensional array\nas the constant offset, one dimension in the base register and the other in\nthe index register. This way all calculation of location of the desired element\nhas been delegated to the processor.\nEXERCISES\n1. What is a label and how does the assembler differentiates between\ncode labels and data labels?\n2. List the seven addressing modes available in the 8088 architecture.\n3. Differentiate between effective address and physical address.\n4. What is the effective address generated by the following\ninstructions? Every instruction is independent of others. Initially\nBX=0x0100, num1=0x1001, [num1]=0x0000, and SI=0x0100\na. mov ax, [bx+12]\nb. mov ax, [bx+num1]\nc. mov ax, [num1+bx]\nd. mov ax, [bx+si]\n5. What is the effective address generated by the following\ncombinations if they are valid. If not give reason. Initially\nBX=0x0100, SI=0x0010, DI=0x0001, BP=0x0200, and SP=0xFFFF\na. bx-si\nb. bx-bp\nc. bx+10\nd. bx-10\ne. bx+sp\nf. bx+di\n6. Identify the problems in the following instructions and correct them\nby replacing them with one or two instruction having the same\neffect.\nVirtual University of Pakistan 28\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\na. mov [02], [ 22]\nb. mov [wordvar], 20\nc. mov bx, al\nd. mov ax, [si+di+100]\n7. What is the function of segment override prefix and what\nchanges it brings to the opcode?\n8. What are the two types of address wraparound? What\nphysical address is accessed with [BX+SI] if FFFF is loaded in\nBX, SI, and DS.\n9. Write instructions to do the following.\na. Copy contents of memory location with offset 0025 in the\ncurrent data segment into AX.\nb. Copy AX into memory location with offset 0FFF in the\ncurrent data segment.\nc. Move contents of memory location with offset 0010 to\nmemory location with offset 002F in the current data\nsegment.\n10. Write a program to calculate the square of 20 by using a loop\nthat adds 20 to the accumulator 20 times.\nVirtual University of Pakistan 29\n\n3\nBranching\n3.1. COMPARISON AND CONDITIONS\nConditional jump was introduced in the last chapter to loop for the\naddition of a fixed number of array elements. The jump was based on the\nzero flag. There are many other conditions possible in a program. For\nexample an operand can be greater than another operand or it can be\nsmaller. We use comparisons and boolean expressions extensively in higher\nlevel languages. They must be available is some form in assembly language,\notherwise they could not possibly be made available in a higher level\nlanguage. In fact they are available in a very fine and purified form.\nThe basic root instruction for all comparisons is CMP standing for\ncompare. The operation of CMP is to subtract the source operand from the\ndestination operand, updating the flags without changing either the source\nor the destination. CMP is one of the key instructions as it introduces the\ncapability of conditional routing in the processor.\nA closer thought reveals that with subtraction we can check many different\nconditions. For example if a larger number is subtracted from a smaller\nnumber then borrow is needed. The carry flag plays the role of borrow during\nthe subtraction operation. And in this condition the carry flag will be set. If\ntwo equal numbers are subtracted the answer is zero and the zero flag will be\nset. Every significant relation between the destination and source is evident\nfrom the sign flag, carry flag, zero flag, and the overflow flag. CMP is\nmeaningless without a conditional jump immediately following it.\nAnother important distinction at this point is the difference between signed\nand unsigned numbers. In unsigned numbers only the magnitude of the\nnumber is important, whereas in signed numbers both the magnitude and\nthe sign are important. For example -2 is greater than -3 but 2 is smaller\nthan 3. The sign has affected our comparisons.\nInside the computer signed numbers are represented in two\u2019s complement\nnotation. In essence a number in this representation is still a number, just\nthat now our interpretation of this number will be signed. Whether we use\njump above and below or we use jump greater or less will convey our\nintention to the processor. The jump above and greater operations at first\nsight seem to be doing the same operation, and similarly below and less\noperations seem to be similar. However for signed numbers JG and JL will\nwork properly and for unsigned JA and JB will work properly and not the\nother way around.\nIt is important to note that at the time of comparison, the intent of the\nprogrammer to treat the numbers as signed or unsigned is not clear. The\nsubtraction in CMP is a normal subtraction. It is only after the comparison,\nduring the conditional jump operation, that the intent is conveyed. At that\ntime with a specific combination of flags checked the intent is satisfied.\nFor example a number 2 is represented in a word as 0002 while the\nnumber -2 is represented as FFFE. In a byte they would be represented as 02\nand FE. Now both have the same magnitude however the different sign has\ncaused very different representation in two\u2019s complement form. Now if the\nintent is to use FFFE or decimal 65534 then the same data would be placed\nin the word as in case of -2. In fact if -2 and 65534 are compared the\nprocessor will set the zero flag signaling that they are exactly equal. As\nregards an unsigned comparison the number 65534 is much greater than 2.\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nSo if a JA is taken after comparing -2 in the destination with 2 in the source\nthe jump will be taken. If however JG is used after the same comparison the\njump will not be taken as it will consider the sign and with the sign -2 is\nsmaller than 2. The key idea is that -2 and 65534 were both stored in\nmemory in the same form. It was the interpretation that treated it as a signed\nor as an unsigned number.\nThe unsigned comparisons see the numbers as 0 being the smallest and\n65535 being the largest with the order that 0 < 1 < 2 \u2026 < 65535. The signed\ncomparisons see the number -32768 which has the same memory\nrepresentation as 32768 as the smallest number and 32767 as the largest\nwith the order -32768 < -32767 < \u2026 < -1 < 0 < 1 < 2 < \u2026 < 32767. All the\nnegative numbers have the same representation as an unsigned number in\nthe range 32768 \u2026 65535 however the signed interpretation of the signed\ncomparisons makes them be treated as negative numbers smaller than zero.\nAll meaningful situations both for signed and unsigned numbers that\noccur after a comparison are detailed in the following table.\nDEST = SRC ZF = 1 When the source is subtracted\nfrom the destination and both are\nequal the result is zero and\ntherefore the zero flag is set. This\nworks for both signed and\nunsigned numbers.\nUDEST < USRC CF = 1 When an unsigned source is\nsubtracted from an unsigned\ndestination and the destination is\nsmaller, borrow is needed which\nsets the carry flag.\nUDEST \u2264 USRC ZF = 1 OR CF = 1 If the zero flag is set, it means\nthat the source and destination\nare equal and if the carry flag is\nset it means a borrow was needed\nin the subtraction and therefore\nthe destination is smaller.\nUDEST \u2265 USRC CF = 0 When an unsigned source is\nsubtracted from an unsigned\ndestination no borrow will be\nneeded either when the operands\nare equal or when the destination\nis greater than the source.\nUDEST > USRC ZF = 0 AND CF = 0 The unsigned source and\ndestination are not equal if the\nzero flag is not set and the\ndestination is not smaller since\nno borrow was taken. Therefore\nthe destination is greater than\nthe source.\nSDEST < SSRC SF \u2260 OF When a signed source is\nsubtracted from a signed\ndestination and the answer is\nnegative with no overflow than\nthe destination is smaller than\nthe source. If however there is an\noverflow meaning that the sign\nhas changed unexpectedly, the\nmeanings are reversed and a\nVirtual University of Pakistan 32\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\npositive number signals that the\ndestination is smaller.\nSDEST \u2264 SSRC ZF = 1 OR SF \u2260 OF If the zero flag is set, it means\nthat the source and destination\nare equal and if the sign and\noverflow flags differ it means that\nthe destination is smaller as\ndescribed above.\nSDEST \u2265 SSRC SF = OF When a signed source is\nsubtracted from a signed\ndestination and the answer is\npositive with no overflow than the\ndestination is greater than the\nsource. When an overflow is there\nsignaling that sign has changed\nunexpectedly, we interpret a\nnegative answer as the signal\nthat the destination is greater.\nSDEST > SSRC ZF = 0 AND SF = OF If the zero flag is not set, it means\nthat the signed operands are not\nequal and if the sign and overflow\nmatch in addition to this it\nmeans that the destination is\ngreater than the source.\n3.2. CONDITIONAL JUMPS\nFor every interesting or meaningful situation of flags, a conditional jump is\nthere. For example JZ and JNZ check the zero flag. If in a comparison both\noperands are same, the result of subtraction will be zero and the zero flag\nwill be set. Thus JZ and JNZ can be used to test equality. That is why there\nare renamed versions JE and JNE read as jump if equal or jump if not equal.\nThey seem more logical in writing but mean exactly the same thing with the\nsame opcode. Many jumps are renamed with two or three names for the\nsame jump, so that the appropriate logic can be conveyed in assembly\nlanguage programs. This renaming is done by Intel and is a standard for\niAPX88. JC and JNC test the carry flag. For example we may need to test\nwhether there was an overflow in the last unsigned addition or subtraction.\nCarry flag will also be set if two unsigned numbers are subtracted and the\nfirst is smaller than the second. Therefore the renamed versions JB, JNAE,\nand JNB, JAE are there standing for jump if below, jump if not above or\nequal, jump if not below, and jump if above or equal respectively. The\noperation of all jumps can be seen from the following table.\nJC Jump if carry CF = 1 This jump is taken if\nJB Jump if below the last arithmetic\nJNAE Jump if not above or equal operation generated a\ncarry or required a\nborrow. After a CMP it\nis taken if the\nunsigned destination is\nsmaller than the\nunsigned source.\nJNC Jump if not carry CF = 0 This jump is taken if\nJNB Jump if not below the last arithmetic\nJAE Jump if above or equal operation did not\nVirtual University of Pakistan 33\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ngenerated a carry or\nrequired a borrow. After\na CMP it is taken if the\nunsigned destination\nis larger or equal to\nthe unsigned source.\nJE Jump if equal ZF = 1 This jump is taken if\nJZ Jump if zero the last arithmetic\noperation produced a\nzero in its destination.\nAfter a CMP it is taken\nif both operands were\nequal.\nJNE Jump if not equal ZF = 0 This jump is taken if\nJNZ Jump if not zero the last arithmetic\noperation did not\nproduce a zero in its\ndestination. After a\nCMP it is taken if both\noperands were\ndifferent.\nJA Jump if above ZF = 0 AND This jump is taken\nJNBE Jump if not below or equal CF = 0 after a CMP if the\nunsigned destination is\nlarger than the\nunsigned source.\nJNA Jump if not above ZF = 1 OR This jump is taken\nJBE Jump if below or equal CF = 1 after a CMP if the\nunsigned destination is\nsmaller than or equal\nto the unsigned\nsource.\nJL Jump if less SF \u2260 OF This jump is taken\nJNGE Jump if not greater or equal after a CMP if the\nsigned destination is\nsmaller than the\nsigned source.\nJNL Jump if not less SF = OF This jump is taken\nJGE Jump if greater or equal after a CMP if the\nsigned destination is\nlarger than or equal to\nthe signed source.\nJG Jump if greater ZF = 0 AND This jump is taken\nJNLE Jump if not less or equal SF = OF after a CMP if the\nsigned destination is\nlarger than the signed\nsource.\nJNG Jump if not greater ZF = 1 OR This jump is taken\nJLE Jump if less or equal SF \u2260 OF after a CMP if the\nsigned destination is\nsmaller than or equal\nto the signed\nsource.\nVirtual University of Pakistan 34\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nJO Jump if overflow. OF = 1 This jump is taken if\nthe last arithmetic\noperation changed the\nsign unexpectedly.\nJNO Jump if not overflow OF = 0 This jump is taken if\nthe last arithmetic\noperation did not\nchange the sign\nunexpectedly.\nJS Jump if sign SF = 1 This jump is taken if\nthe last arithmetic\noperation produced a\nnegative number in its\ndestination.\nJNS Jump if not sign SF = 0 This jump is taken if\nthe last arithmetic\noperation produced a\npositive number in its\ndestination.\nJP Jump if parity PF = 1 This jump is taken if\nJPE Jump if even parity the last arithmetic\noperation produced a\nnumber in its\ndestination that has\neven parity.\nJNP Jump if not parity PF = 0 This jump is taken if\nJPO Jump if odd parity the last arithmetic\noperation produced a\nnumber in its\ndestination that has\nodd parity.\nJCXZ Jump if CX is zero CX = 0 This jump is taken if\nthe CX register is zero.\nThe CMP instruction sets the flags reflecting the relation of the destination\nto the source. This is important as when we say jump if above, then what is\nabove what. The destination is above the source or the source is above the\ndestination.\nThe JA and JB instructions are related to unsigned numbers. That is our\ninterpretation for the destination and source operands is unsigned. The 16th\nbit holds data and not the sign. In the JL and JG instructions standing for\njump if lower and jump if greater respectively, the interpretation is signed.\nThe 16th bit holds the sign and not the data. The difference between them\nwill be made clear as an elaborate example will be given to explain the\ndifference.\nOne jump is special that it is not dependant on any flag. It is JCXZ, jump\nif the CX register is zero. This is because of the special treatment of the CX\nregister as a counter. This jump is regardless of the zero flag. There is no\ncounterpart or not form of this instruction.\nThe adding numbers example of the last chapter can be a little simplified\nusing the compare instruction on the BX register and eliminating the need\nfor a separate counter as below.\nVirtual University of Pakistan 35\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 3.1\n001 ; a program to add ten numbers without a separate counter\n002 [org 0x0100]\n003 mov bx, 0 ; initialize array index to zero\n004 mov ax, 0 ; initialize sum to zero\n005\n006 l1: add ax, [num1+bx] ; add number to ax\n007 add bx, 2 ; advance bx to next index\n008 cmp bx, 20 ; are we beyond the last index\n009 jne l1 ; if not add next number\n010\n011 mov [total], ax ; write back sum in memory\n012\n013 mov ax, 0x4c00 ; terminate program\n014 int 0x21\n015\n016 num1: dw 10, 20, 30, 40, 50, 10, 20, 30, 40, 50\n017 total: dw 0\n006 The format of memory access is still base + offset.\n008 BX is used as the array index as well as the counter. The offset of\n11th number will be 20, so as soon as BX becomes 20 just after the\n10th number has been added, the addition is stopped.\n009 The jump is displayed as JNZ in the debugger even though we have\nwritten JNE in our example. This is because it is a renamed jump\nwith the same opcode as JNZ and the debugger has no way of\nknowing the mnemonic that we used after looking just at the\nopcode. Also every code and data reference that we used till now is\nseen in the opcode as well. However for the jump instruction we see\nan operand of F2 in the opcode and not 0116. This will be discussed\nin detail with unconditional jumps. It is actually a short relative\njump and the operand is stored in the form of positive or negative\noffset from this instruction.\nWith conditional branching in hand, there are just a few small things left\nin assembly language that fills some gaps. Now there is just imagination and\nthe skill to conceive programs that can make you write any program.\n3.3. UNCONDITIONAL JUMP\nTill now we have been placing data at the end of code. There is no such\nrestriction and we can define data anywhere in the code. Taking the previous\nexample, if we place data at the start of code instead of at the end and we\nload our program in the debugger. We can see our data placed at the start\nbut the debugger is intending to start execution at our data. The COM file\ndefinition said that the first executable instruction is at offset 0100 but we\nhave placed data there instead of code. So the debugger will try to interpret\nthat data as code and showed whatever it could make up out of those\nopcodes.\nWe introduce a new instruction called JMP. It is the unconditional jump\nthat executes regardless of the state of all flags. So we write an unconditional\njump as the very first instruction of our program and jump to the next\ninstruction that follows our data declarations. This time 0100 contains a\nvalid first instruction of our program.\nExample 3.2\n001 ; a program to add ten numbers without a separate counter\n002 [org 0x0100]\n003 jmp start ; unconditionally jump over data\n004\n005 num1: dw 10, 20, 30, 40, 50, 10, 20, 30, 40, 50\n006 total: dw 0\nVirtual University of Pakistan 36\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n007\n008 start: mov bx, 0 ; initialize array index to zero\n009 mov ax, 0 ; initialize sum to zero\n010\n011 l1: add ax, [num1+bx] ; add number to ax\n012 add bx, 2 ; advance bx to next index\n013 cmp bx, 20 ; are we beyond the last index\n014 jne l1 ; if not add next number\n015\n016 mov [total], ax ; write back sum in memory\n017\n018 mov ax, 0x4c00 ; terminate program\n019 int 0x21\n003 JMP jumps over the data declarations to the start label and\nexecution resumes from there.\n3.4. RELATIVE ADDRESSING\nInside the debugger the instruction is shown as JMP 0119 and the location\n0119 contains the original first instruction of the logic of our program. This\njump is unconditional, it will always be taken. Now looking at the opcode we\nsee F21600 where F2 is the opcode and 1600 is the operand to it. 1600 is\n0016 in proper word order. 0119 is not given as a parameter rather 0016 is\ngiven.\nThis is position relative addressing in contrast to absolute addressing. It is\nnot telling the exact address rather it is telling how much forward or\nbackward to go from the current position of IP in the current code segment.\nSo the instruction means to add 0016 to the IP register. At the time of\nexecution of the first instruction at 0100 IP was pointing to the next\ninstruction at 0103, so after adding 16 it became 0119, the desired target\nlocation. The mechanism is important to know, however all calculations in\nthis mechanism are done by the assembler and by the processor. We just use\na label with the JMP instruction and are ensured that the instruction at the\ntarget label will be the one to be executed.\n3.5. TYPES OF JUMP\nThe three types of jump, near, short, and far, differ in the size of\ninstruction and the range of memory they can jump to with the smallest\nshort form of two bytes and a range of just 256 bytes to the far form of five\nbytes and a range covering the whole memory.\nShort Jump\nEB Disp\nNear Jump\nE9 Disp Low Disp High\nFar Jump\nEA IP Low IP High CS Low CS High\nNear Jump\nWhen the relative address stored with the instruction is in 16 bits as in the\nlast example the jump is called a near jump. Using a near jump we can jump\nanywhere within a segment. If we add a large number it will wrap around to\nVirtual University of Pakistan 37\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nthe lower part. A negative number actually is a large number and works this\nway using the wraparound behavior.\nShort Jump\nIf the offset is stored in a single byte as in 75F2 with the opcode 75 and\noperand F2, the jump is called a short jump. F2 is added to IP as a signed\nbyte. If the byte is negative the complement is negated from IP otherwise the\nbyte is added. Unconditional jumps can be short, near, and far. The far type\nis yet to be discussed. Conditional jumps can only be short. A short jump\ncan go +127 bytes ahead in code and -128 bytes backwards and no more.\nThis is the limitation of a byte in singed representation.\nFar Jump\nFar jump is not position relative but is absolute. Both segment and offset\nmust be given to a far jump. The previous two jumps were used to jump\nwithin a segment. Sometimes we may need to go from one code segment to\nanother, and near and short jumps cannot take us there. Far jump must be\nused and a two byte segment and a two byte offset are given to it. It loads CS\nwith the segment part and IP with the offset part. Execution therefore resumes\nfrom that location in physical memory. The three instructions that have a far\nform are JMP, CALL, and RET, are related to program control. Far capability\nmakes intra segment control possible.\n3.6. SORTING EXAMPLE\nMoving ahead from our example of adding numbers we progress to a\nprogram that can sort a list of numbers using the tools that we have\naccumulated till now. Sorting can be ascending or descending like if the\nlargest number comes at the top, followed by a smaller number and so on till\nthe smallest number the sort will be called descending. The other order\nstarting with the smallest number and ending at the largest is called\nascending sort. This is a common problem and many algorithms have been\ndeveloped to solve it. One simple algorithm is the bubble sort algorithm.\nIn this algorithm we compare consecutive numbers. If they are in required\norder e.g. if it is a descending sort and the first is larger then the second,\nthen we leave them as it is and if they are not in order, we swap them. Then\nwe do the same process for the next two numbers and so on till the last two\nare compared and possibly swapped.\nA complete iteration is called a pass over the array. We need N passes at\nleast in the simplest algorithm if N is the number of elements to be sorted. A\nfiner algorithm is to check if any swap was done in this pass and stop as\nsoon as a pass goes without a swap. The array is now sorted as every pair of\nelements is in order.\nFor example if our list of numbers is 60, 55, 45, and 58 and we want to\nsort them in ascending order, the first comparison will be of 60 and 55 and\nas the order will be reversed to 55 and 60. The next comparison will be of 60\nand 45 and again the two will be swapped. The next comparison of 60 and 58\nwill also cause a swap. At the end of first pass the numbers will be in order\nof 55, 45, 58, and 60. Observe that the largest number has bubbled down to\nthe bottom. Just like a bubble at bottom of water. In the next pass 55 and 45\nwill be swapped. 55 and 58 will not be swapped and 58 and 60 will also not\nbe swapped. In the next pass there will be no swap as the elements are in\norder i.e. 45, 55, 58, and 60. The passes will be stopped as the last pass did\nnot cause any swap. The application of bubble sort on these numbers is\nfurther explained with the following illustration.\nVirtual University of Pakistan 38\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nState of Data Swap Done Swap Flag\nPass 1 Off\n60 55 45 58 Yes On\n55 60 45 58 Yes On\n55 45 60 58 Yes On\nPass 2 Off\n55 45 58 60 Yes On\n45 55 58 60 No On\n45 55 58 60 No On\nPass 3 Off\n45 55 58 60 No Off\n45 55 58 60 No Off\n45 55 58 60 No Off\nNo more passes since swap flag is Off\nExample 3.3\n001 ; sorting a list of ten numbers using bubble sort\n002 [org 0x0100]\n003 jmp start\n004\n005 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n006 swap: db 0\n007\n008 start: mov bx, 0 ; initialize array index to zero\n009 mov byte [swap], 0 ; rest swap flag to no swaps\n010\n011 loop1: mov ax, [data+bx] ; load number in ax\n012 cmp ax, [data+bx+2] ; compare with next number\n013 jbe noswap ; no swap if already in order\n014\n015 mov dx, [data+bx+2] ; load second element in dx\n016 mov [data+bx+2], ax ; store first number in second\n017 mov [data+bx], dx ; store second number in first\n018 mov byte [swap], 1 ; flag that a swap has been done\n019\n020 noswap: add bx, 2 ; advance bx to next index\n021 cmp bx, 18 ; are we at last index\n022 jne loop1 ; if not compare next two\n023\n024 cmp byte [swap], 1 ; check if a swap has been done\n025 je start ; if yes make another pass\n026\n027 mov ax, 0x4c00 ; terminate program\n028 int 0x21\nVirtual University of Pakistan 39\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n003 The jump instruction is placed to skip over data.\n006 The swap flag can be stored in a register but as an example it is\nstored in memory and also to extend the concept at a later stage.\n011-012 One element is read in AX and it is compared with the next element\nbecause memory to memory comparisons are not allowed.\n013 If the JBE is changed to JB, not only the unnecessary swap on equal\nwill be performed, there will be a major algorithmic flaw due to a\nlogical error as in the case of equal elements the algorithm will never\nstop. JBE won\u2019t swap in the case of equal elements.\n015-017 The swap is done using DX and AX registers in such a way that the\nvalues are crossed. The code uses the information that one of the\nelements is already in the AX register.\n021 This time BX is compared with 18 instead of 20 even though the\nnumber of elements is same. This is because we pick an element\nand compare it with the next element. When we pick the 9th element\nwe compare it with the next element and this is the last comparison,\nsince if we pick the 10th element we will compare it with the 11th\nelement and there is no 11th element in our case.\n024-025 If a swap is done we repeat the whole process for possible more\nswaps.\nInside the debugger we observe that the JBE is changed to JNA due to the\nsame reason as discussed for JNE and JNZ. The passes change the data in\nthe same manner as we presented in our illustration above. If JBE in the\ncode is changed to JAE the sort will change from ascending to descending.\nFor signed numbers we can use JLE and JGE respectively for ascending and\ndescending sort.\nTo clarify the difference of signed and unsigned jumps we change the data\narray in the last program to include some negative numbers as well. When\nJBE will be used on this data, i.e. with unsigned interpretation of the data\nand an ascending sort, the negative numbers will come at the end after the\nlargest positive number. However JLE will bring the negative numbers at the\nvery start of the list to bring them in proper ascending order according to a\nsigned interpretation, even though they are large in magnitude. The data\nused is shown as below.\ndata: dw 60, 55, 45, 50, -40, -35, 25, 30, 10, 0\nThis data includes some signed numbers as well. The JBE instruction will\ntreat this data as an unsigned number and will cater only for the magnitude\nignoring the sign. If the program is loaded in the debugger, the numbers will\nappear in their hexadecimal equivalent. The two numbers -40 and -35 are\nespecially important as they are represented as FFD8 and FFDD. This data is\nnot telling whether it is signed or unsigned. Our interpretation will decide\nwhether it is a very large unsigned number or a signed number in two\u2019s\ncomplement form.\nIf the sorting algorithm is applied on the above data with JBE as the\ncomparison instruction to sort in ascending order with unsigned\ninterpretation, observe the comparisons of the two numbers FFD8 and\nFFDD. For example it will decide that FFDD > FFD8 since the first is larger\nin magnitude. At the end of sorting FFDD will be at the end of the list being\ndeclared the largest number and FFD8 will precede it to be the second\nlargest.\nIf however the comparison instruction is changed to JLE and sorting is\ndone on the same data it works similarly except on the two numbers FFDD\nand FFD8. This time JLE declares them to be smaller than every other\nnumber and also declares FFDD < FFD8. At the end of sorting, FFDD is\nVirtual University of Pakistan 40\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ndeclared to be the smallest number followed by FFD8 and then 0000. This is\nin contrast to the last example where JBE was used. This happened because\nJLE interpreted our data as signed numbers, and as a signed number FFDD\nhas its sign bit on signaling that it is a negative number in two\u2019s complement\nform which is smaller than 0000 and every positive number. However JBE\ndid not give any significance to the sign bit and included it in the magnitude.\nTherefore it declared the negative numbers to be the largest numbers.\nIf the required interpretation was of signed numbers the result produced\nby JLE is correct and if the required interpretation was of unsigned numbers\nthe result produced by JBE is correct. This is the very difference between\nsigned and unsigned integers in higher level languages, where the compiler\ntakes the responsibility of making the appropriate jump depending on the\ntype of integer used. But it is only at this level that we can understand the\nactual mechanism going on. In assembly language, use of proper jump is the\nresponsibility of the programmer, to convey the intentions to use the data as\nsigned or as unsigned.\nThe remaining possibilities of signed descending sort and unsigned\ndescending sort can be done on the same lines and are left as an exercise.\nOther conditional jumps work in the same manner and can be studied from\nthe reference at the end. Several will be discussed in more detail when they\nare used in subsequent chapters.\nEXERCISES\n1. Which registers are changed by the CMP instruction?\n2. What are the different types of jumps available? Describe position\nrelative addressing.\n3. If AX=8FFF and BX=0FFF and \u201ccmp ax, bx\u201d is executed, which of the\nfollowing jumps will be taken? Each part is independent of others. Also\ngive the value of Z, S, and C flags.\na. jg greater\nb. jl smaller\nc. ja above\nd. jb below\n4. Write a program to find the maximum number and the minimum\nnumber from an array of ten numbers.\n5. Write a program to search a particular element from an array using\nbinary search. If the element is found set AX to one and otherwise to\nzero.\n6. Write a program to calculate the factorial of a number where factorial\nis defined as:\nfactorial(x) = x*(x-1)*(x-2)*...*1\nfactorial(0) = 1\nVirtual University of Pakistan 41\n\n4\nBit Manipulations\n4.1. MULTIPLICATION ALGORITHM\nWith the important capability of decision making in our repertoire we move\non to the discussion of an algorithm, which will help us uncover an\nimportant set of instructions in our processor used for bit manipulations.\nMultiplication is a common process that we use, and we were trained to do\nin early schooling. Remember multiplying by a digit and then putting a cross\nand then multiplying with the next digit and putting two crosses and so on\nand summing the intermediate results in the end. Very familiar process but\nwe never saw the process as an algorithm, and we need to see it as an\nalgorithm to convey it to the processor.\nTo highlight the important thing in the algorithm we revise it on two 4bit\nbinary numbers. The numbers are 1101 i.e. 13 and 0101 i.e. 5. The answer\nshould be 65 or in binary 01000001. Observe that the answer is twice as\nlong as the multiplier and the multiplicand. The multiplication is shown in\nthe following figure.\n1101 = 13\n0101 = 5\n-----\n1101\n0000x\n1101xx\n0000xxx\n--------\n01000001 = 65\nWe take the first digit of the multiplier and multiply it with the\nmultiplicand. As the digit is one the answer is the multiplicand itself. So we\nplace the multiplicand below the bar. Before multiplying with the next digit a\ncross is placed at the right most place on the next line and the result is\nplaced shifted one digit left. However since the digit is zero, the result is zero.\nNext digit is one, multiplying with which, the answer is 1101. We put two\ncrosses on the next line at the right most positions and place the result there\nshifted two places to the left. The fourth digit is zero, so the answer 0000 is\nplaced with three crosses to its right.\nObserve the beauty of binary base, as no real multiplication is needed at\nthe digit level. If the digit is 0 the answer is 0 and if the digit is 1 the answer\nis the multiplicand itself. Also observe that for every next digit in the\nmultiplier the answer is written shifted one more place to the left. No shifting\nfor the first digit, once for the second, twice for the third and thrice for the\nfourth one. Adding all the intermediate answers the result is 01000001=65\nas desired. Crosses are treated as zero in this addition.\nBefore formulating the algorithm for this problem, we need some more\ninstructions that can shift a number so that we use this instruction for our\nmultiplicand shifting and also some way to check the bits of the multiplier\none by one.\n4.2. SHIFTING AND ROTATIONS\nThe set of shifting and rotation instructions is one of the most useful set in\nany processor\u2019s instruction set. They simplify really complex tasks to a very\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nneat and concise algorithm. The following shifting and rotation operations\nare available in our processor.\nShift Logical Right (SHR)\nThe shift logical right operation inserts a zero from the left and moves\nevery bit one position to the right and copies the rightmost bit in the carry\nflag. Imagine that there is a pipe filled to capacity with eight balls. The pipe is\nopen from both ends and there is a basket at the right end to hold anything\ndropping from there. The operation of shift logical right is to force a white\nball from the left end. The operation is depicted in the following illustration.\n0 1 0 1 1 0 1 0 0 C\nWhite balls represent zero bits while black balls represent one bits. Sixteen\nbit shifting is done the same way with a pipe of double capacity.\nShift Logical Left (SHL) / Shift Arithmetic Left (SAL)\nThe shift logical left operation is the exact opposite of shift logical right. In\nthis operation the zero bit is inserted from the right and every bit moves one\nposition to its left with the most significant bit dropping into the carry flag.\nShift arithmetic left is just another name for shift logical left. The operation is\nagain exemplified with the following illustration of ball and pipes.\nC 1 0 1 1 0 1 0 0 0\nShift Arithmetic Right (SAR)\nA signed number holds the sign in its most significant bit. If this bit was\none a logical right shifting will change the sign of this number because of\ninsertion of a zero from the left. The sign of a signed number should not\nchange because of shifting.\nThe operation of shift arithmetic right is therefore to shift every bit one\nplace to the right with a copy of the most significant bit left at the most\nsignificant place. The bit dropped from the right is caught in the carry\nbasket. The sign bit is retained in this operation. The operation is further\nillustrated below.\n1 0 1 1 0 1 0 0 C\nThe left shifting operation is basically multiplication by 2 while the right\nshifting operation is division by two. However for signed numbers division by\ntwo can be accomplished by using shift arithmetic right and not shift logical\nright. The left shift operation is equivalent to multiplication except when an\nimportant bit is dropped from the left. The overflow flag will signal this\ncondition if it occurs and can be checked with JO. For division by 2 of a\nsigned number logical right shifting will give a wrong answer for a negative\nnumber as the zero inserted from the left will change its sign. To retain the\nsign flag and still effectively divide by two the shift arithmetic right\ninstruction must be used on signed numbers.\nVirtual University of Pakistan 44\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nRotate Right (ROR)\nIn the rotate right operation every bit moves one position to the right and\nthe bit dropped from the right is inserted at the left. This bit is also copied\ninto the carry flag. The operation can be understood by imagining that the\npipe used for shifting has been molded such that both ends coincide. Now\nwhen the first ball is forced to move forward, every ball moves one step\nforward with the last ball entering the pipe from its other end occupying the\nfirst ball\u2019s old position. The carry basket takes a snapshot of this ball leaving\none end of the pipe and entering from the other.\n1 0 1 1 0 1 0 0 C\nRotate Left (ROL)\nIn the operation of rotate left instruction, the most significant bit is copied\nto the carry flag and is inserted from the right, causing every bit to move one\nposition to the left. It is the reverse of the rotate right instruction. Rotation\ncan be of eight or sixteen bits. The following illustration will make the\nconcept clear using the same pipe and balls example.\nC 1 0 1 1 0 1 0 0\nRotate Through Carry Right (RCR)\nIn the rotate through carry right instruction, the carry flag is inserted from\nthe left, every bit moves one position to the right, and the right most bit is\ndropped in the carry flag. Effectively this is a nine bit or a seventeen bit\nrotation instead of the eight or sixteen bit rotation as in the case of simple\nrotations.\nImagine the circular molded pipe as used in the simple rotations but this\ntime the carry position is part of the circle between the two ends of the pipe.\nPushing the carry ball from the left causes every ball to move one step to its\nright and the right most bit occupying the carry place. The idea is further\nillustrated below.\n1 0 1 1 0 1 0 0 C\nRotate Through Carry Left (RCL)\nThe exact opposite of rotate through carry right instruction is the rotate\nthrough carry left instruction. In its operation the carry flag is inserted from\nthe right causing every bit to move one location to its left and the most\nsignificant bit occupying the carry flag. The concept is illustrated below in\nthe same manner as in the last example.\nC 1 0 1 1 0 1 0 0\nVirtual University of Pakistan 45\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n4.3. MULTIPLICATION IN ASSEMBLY LANGUAGE\nIn the multiplication algorithm discussed above we revised the way we\nmultiplied number in lower classes, and gave an example of that method on\nbinary numbers. We make a simple modification to the traditional algorithm\nbefore we proceed to formulate it in assembly language.\nIn the traditional algorithm we calculate all intermediate answers and then\nsum them to get the final answer. If we add every intermediate answer to\naccumulate the result, the result will be same in the end, except that we do\nnot have to remember a lot of intermediate answers during the whole\nmultiplication. The multiplication with the new algorithm is shown below.\n1101 = 13 Accumulated Result\n0101 = 5\n----- 0 (Initial Value)\n1101 = 13 0 + 13 = 13\n0000x = 0 13 + 0 = 13\n1101xx = 52 13 + 52 = 65\n0000xxx = 0 65 + 0 = 65 (Answer)\nWe try to identify steps of our algorithm. First we set the result to zero.\nThen we check the right most bit of multiplier. If it is one add the\nmultiplicand to the result, and if it is zero perform no addition. Left shift the\nmultiplicand before the next bit of multiplier is tested. The left shifting of the\nmultiplicand is performed regardless of the value of the multiplier\u2019s right\nmost bit. Just like the crosses in traditional multiplication are always placed\nto mark the ones, tens, thousands, etc. places. Then check the next bit and if\nit is one add the shifted value of the multiplicand to the result. Repeat for as\nmany digits as there are in the multiplier, 4 in our example. Formulating the\nsteps of the algorithm we get:\n\u2022 Shift the multiplier to the right.\n\u2022 If CF=1 add the multiplicand to the result.\n\u2022 Shift the multiplicand to the left.\n\u2022 Repeat the algorithm 4 times.\nFor an 8bit multiplication the algorithm will be repeated 8 times and for a\nsixteen bit multiplication it will be repeated 16 times, whatever the size of the\nmultiplier is.\nThe algorithm uses the fact that shifting right forces the right most bit to\ndrop in the carry flag. If we test the carry flag using JC we are effectively\ntesting the right most bit of the multiplier. Another shifting will cause the\nnext bit to drop in the next iteration and so on. So our task of checking bits\none by one is satisfied using the shift operation. There are many other\nmethods to do this bit testing as well, however we exemplify one of the\nmethods in this example.\nIn the first iteration there is no shifting just like there is no cross in\ntraditional multiplication in the first pass. Therefore we placed the left\nshifting of the multiplicand after the addition step. However the right shifting\nof multiplier must be before the addition as the addition step\u2019s execution\ndepends upon its result.\nWe introduce an assembly language program to perform this 4bit\nmultiplication. The algorithm is extensible to more bits but there are a few\ncomplications, which are left to be discussed later. For now we do a 4bit\nmultiplication to keep the algorithm simple.\nExample 4.1\n01 ; 4bit multiplication algorithm\n02 [org 0x100]\n03 jmp start\n04\n05 multiplicand: db 13 ; 4bit multiplicand (8bit space)\n06 multiplier: db 5 ; 4bit multiplier\nVirtual University of Pakistan 46\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n07 result: db 0 ; 8bit result\n08\n09 start: mov cl, 4 ; initialize bit count to four\n10 mov bl, [multiplicand] ; load multiplicand in bl\n11 mov dl, [multiplier] ; load multiplier in dl\n12\n13 checkbit: shr dl, 1 ; move right most bit in carry\n14 jnc skip ; skip addition if bit is zero\n15\n16 add [result], bl ; accumulate result\n17\n18 skip: shl bl, 1 ; shift multiplicand left\n19 dec cl ; decrement bit count\n20 jnz checkbit ; repeat if bits left\n21\n22 mov ax, 0x4c00 ; terminate program\n23 int 0x21\n04-06 The numbers to be multiplied are constants for now. The\nmultiplication is four bit so the answer is stored in an 8bit register.\nIf the operands were 8bit the answer would be 16bit and if the\n07 operands were 16bit the answer would be 32bit. Since eight bits can\nfit in a byte we have used 4bit multiplication as our first example.\nSince addition by zero means nothing we skip the addition step if\n14-16 the rightmost bit of the multiplier is zero. If the jump is not taken\nthe shifted value of the multiplicand is added to the result.\nThe multiplicand is left shifted in every iteration regardless of the\n18\nmultiplier bit.\nDEC is a new instruction but its operation should be immediately\n19\nunderstandable with the knowledge gained till now. It simply\nsubtracts one from its single operand.\nThe JNZ instruction causes the algorithm to repeat till any bits of\n20\nthe multiplier are left\nInside the debugger observe the working of the SHR and SHL instructions.\nThe SHR instruction is effectively dividing its operand by two and the\nremainder is stored in the carry flag from where we test it. The SHL\ninstruction is multiplying its operand by two so that it is added at one place\nmore towards the left in the result.\n4.4. EXTENDED OPERATIONS\nWe performed a 4bit multiplication to explain the algorithm however the\nreal advantage of the computer is when we ask it to multiply large numbers,\nNumbers whose multiplication takes real time. If we have an 8bit number we\ncan do the multiplication in word registers, but are we limited to word\noperations? What if we want to multiply 32bit or even larger numbers? We\nare certainly not limited. Assembly language only provides us the basic\nbuilding blocks. We build a plaza out of these blocks, or a building, or a\nclassic piece of architecture is only dependant upon our imagination. With\nour logic we can extend these algorithms as much as we want.\nOur next example will be multiplication of 16bit numbers to produce a\n32bit answer. However for a 32bit answer we need a way to shift a 32bit\nnumber and a way to add 32bit numbers. We cannot depend on 16bit\nshifting as we have 16 significant bits in our multiplicand and shifting any\nbit towards the left may drop a valuable bit causing a totally wrong result. A\nvaluable bit means any bit that is one. Dropping a zero bit doesn\u2019t cause any\ndifference. So we place the 16it number in 32bit space with the upper 16 bits\nzeroed so that the sixteen shift operations don\u2019t cause any valuable bit to\ndrop. Even though the numbers were 16bit we need 32bit operations to\nmultiply correctly.\nTo clarify this necessity, we take example of a number 40000 or 9C40 in\nhexadecimal. In binary it is represented as 1001110001000000. To multiply\nVirtual University of Pakistan 47\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nby two we shift it one place to the left. The answer we get is\n0011100010000000 and the left most one is dropped in the carry flag. The\nanswer should be the 17bit number 0x13880 but it is 0x3880, which are\n14464 in decimal instead of the expected 80000. We should be careful of this\nsituation whenever shifting is used.\nExtended Shifting\nUsing our basic shifting and rotation instructions we can effectively shift a\n32bit number in memory word by word. We cannot shift the whole number\nat once since our architecture is limited to word operations. The algorithm\nwe use consists of just two instructions and we name it extended shifting.\nnum1: dd 40000\nshl word [num1], 1\nrcl word [num1+2], 1\nThe DD directive reserves a 32bit space in memory, however the value we\nplaced there will fit in 16bits. So we can safely shift the number left 16 times.\nThe least significant word is accessible at num1 and the most significant\nword is accessible at num1+2.\nThe two instructions are carefully crafted such that the first one shifts the\nlower word towards the left and the most significant bit of that word is\ndropped in carry. With the next instruction we push that dropped bit into the\nleast significant bit of the next word effectively joining the two 16bit words.\nThe final carry after the second instruction will be the most significant bit of\nthe higher word, which for this number will always be zero.\nThe following illustration will clarify the concept. The pipe on the right\ncontains the lower half and the pipe on the left contains the upper half. The\nfirst instruction forced a zero from the right into the lower half and the left\nmost bit is saved in carry, and from there it is pushed into the upper half\nand the upper half is shifted as well.\nStep 1 (cid:198) C 1 0 1 1 0 1 0 0 0\nC 1 0 1 1 0 1 0 0 (cid:197) Step 2\nFor shifting right the exact opposite is done however care must be taken to\nshift right the upper half first and then rotate through carry right the lower\nhalf for obvious reasons. The instructions to do this are.\nnum1: dd 40000\nshr word [num1+2], 1\nrcr word [num1], 1\nThe same logic has worked. The shift placed the least significant bit of the\nupper half in the carry flag and it was pushed from right into the lower half.\nFor a singed shift we would have used the shift arithmetic right instruction\ninstead of the shift logical right instruction.\nThe extension we have done is not limited to 32bits. We can shift a number\nof any size say 1024 bits. The second instruction will be repeated a number\nof times and we can achieve the desired effect. Using two simple instructions\nwe have increased the capability of the operation to effectively an unlimited\nnumber of bits. The actual limit is the available memory as even the segment\nlimit can be catered with a little thought.\nExtended Addition and Subtraction\nWe also needed 32bit addition for multiplication of 16bit numbers. The\nidea of extension is same here. However we need to introduce a new\ninstruction at this place. The instruction is ADC or \u201cadd with carry.\u201d Normal\naddition has two operands and the second operand is added to the first\nVirtual University of Pakistan 48\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\noperand. However ADC has three operands. The third implied operand is the\ncarry flag. The ADC instruction is specifically placed for extending the\ncapability of ADD. Numbers of any size can be added using a proper\ncombination of ADD and ADC. All basic building blocks are provided for the\nassembly language programmer, and the programmer can extend its\ncapabilities as much as needed by using these fine instructions in\nappropriate combinations.\nFurther clarifying the operation of ADC, consider an instruction \u201cADC AX,\nBX.\u201d Normal addition would have just added BX to AX, however ADC first\nadds the carry flag to AX and then adds BX to AX. Therefore the last carry is\nalso included in the result.\nThe algorithm should be apparent by now. The lower halves of the two\nnumbers to be added are first added with a normal addition. For the upper\nhalves a normal addition would lose track of a possible carry from the lower\nhalves and the answer would be wrong. If a carry was generated it should go\nto the upper half. Therefore the upper halves are added with an addition with\ncarry instruction.\nSince one operand must be in register, ax is used to read the lower and\nupper halves of the source one by one. The destination is directly updated.\nThe set of instructions goes here.\ndest: dd 40000\nsrc: dd 80000\nmov ax, [src]\nadd word [dest], ax\nmov ax, [src+2]\nadc word [dest+2], ax\nTo further extend it more addition with carries will be used. However the\ncarry from last addition will be wasted as there will always be a size limit\nwhere the results and the numbers are stored. This carry will remain in the\ncarry flag to be tested for a possible overflow.\nFor subtraction the same logic will be used and just like addition with\ncarry there is an instruction to subtract with borrows called SBB. Borrow in\nthe name means the carry flag and is used just for clarity. Or we can say\nthat the carry flag holds the carry for addition instructions and the borrow\nfor subtraction instructions. Also the carry is generated at the 17th bit and\nthe borrow is also taken from the 17th bit. Also there is no single instruction\nthat needs borrow and carry in their independent meanings at the same\ntime. Therefore it is logical to use the same flag for both tasks.\nWe extend subtraction with a very similar algorithm. The lower halves\nmust be subtracted normally while the upper halves must be subtracted with\na subtract with borrow instruction so that if the lower halves needed a\nborrow, a one is subtracted from the upper halves. The algorithm is as\nunder.\ndest: dd 40000\nsrc: dd 80000\nmov ax, [src]\nsub word [dest], ax\nmov ax, [src+2]\nsbb word [dest+2], ax\nExtended Multiplication\nWe use extended shifting and extended addition to formulate our algorithm\nto do extended multiplication. The multiplier is still stored in 16bits since we\nonly need to check its bits one by one. The multiplicand however cannot be\nstored in 16bits otherwise on left shifting its significant bits might get lost.\nTherefore it has to be stored in 32bits and the shifting and addition used to\naccumulate the result must be 32bits as well.\nExample 4.2\nVirtual University of Pakistan 49\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n01 ; 16bit multiplication\n02 [org 0x0100]\n03 jmp start\n04\n05 multiplicand: dd 1300 ; 16bit multiplicand 32bit space\n06 multiplier: dw 500 ; 16bit multiplier\n07 result: dd 0 ; 32bit result\n08\n09 start: mov cl, 16 ; initialize bit count to 16\n10 mov dx, [multiplier] ; load multiplier in dx\n11\n12 checkbit: shr dx, 1 ; move right most bit in carry\n13 jnc skip ; skip addition if bit is zero\n14\n15 mov ax, [multiplicand]\n16 add [result], ax ; add less significant word\n17 mov ax, [multiplicand+2]\n18 adc [result+2], ax ; add more significant word\n19\n20 skip: shl word [multiplicand], 1\n21 rcl word [multiplicand+2], 1 ; shift multiplicand left\n22 dec cl ; decrement bit count\n23 jnz checkbit ; repeat if bits left\n24\n25 mov ax, 0x4c00 ; terminate program\n26 int 0x21\n05-07 The multiplicand and the result are stored in 32bit space while\nthe multiplier is stored as a word.\n10 The multiplier is loaded in DX where it will be shifted bit by bit. It\ncan be directly shifted in memory as well.\n15-18 The multiplicand is added to the result using extended 32bit\naddition.\n20-21 The multiplicand is shifted left as a 32bit number using extended\nshifting operation.\nThe multiplicand will occupy the space from 0103-0106, the multiplier will\noccupy space from 0107-0108 and the result will occupy the space from\n0109-010C. Inside the debugger observe the changes in these memory\nlocations during the course of the algorithm. The extended shifting and\naddition operations provide the same effect as would be provided if there\nwere 32bit addition and shifting operations available in the instruction set.\nAt the end of the algorithm the result memory locations contain the value\n0009EB10 which is 65000 in decimal; the desired answer. Also observe that\nthe number 00000514 which is 1300 in decimal, our multiplicand, has\nbecome 05140000 after being left shifted 16 times. Our extended shifting has\ngiven the same result as if a 32bit number is left shifted 16 times as a unit.\nThere are many other important applications of the shifting and rotation\noperations in addition to this example of the multiplication algorithm. More\nexamples will come in coming chapters.\n4.5. BITWISE LOGICAL OPERATIONS\nThe 8088 processor provides us with a few logical operations that operate\nat the bit level. The logical operations are the same as discussed in computer\nlogic design; however our perspective will be a little different. The four basic\noperations are AND, OR, XOR, and NOT.\nThe important thing about these operations is that they are bitwise. This\nmeans that if \u201cand ax, bx\u201d instruction is given, then the operation of AND is\napplied on corresponding bits of AX and BX. There are 16 AND operations as\na result; one for every bit of AX. Bit 0 of AX will be set if both its original\nvalue and Bit 0 of BX are set, bit 1 will be set if both its original value and\nBit 1 of BX are set, and so on for the remaining bits. These operations are\nconducted in parallel on the sixteen bits. Similarly the operations of other\nlogical operations are bitwise as well.\nVirtual University of Pakistan 50\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nAND operation\nAND performs the logical bitwise and of the two X Y X and Y\noperands (byte or word) and returns the result to the\n0 0 0\ndestination operand. A bit in the result is set if both\n0 1 0\ncorresponding bits of the original operands are set;\n1 0 0\notherwise the bit is cleared as shown in the truth table.\n1 1 1\nExamples are \u201cand ax, bx\u201d and \u201cand byte [mem], 5.\u201d All\npossibilities that are legal for addition are also legal for the AND operation.\nThe different thing is the bitwise behavior of this operation.\nOR operation\nOR performs the logical bitwise \u201cinclusive or\u201d of the two\nX Y X or Y\noperands (byte or word) and returns the result to the\n0 0 0\ndestination operand. A bit in the result is set if either or\n0 1 1\nboth corresponding bits in the original operands are set\n1 0 1\notherwise the result bit is cleared as shown in the truth\n1 1 1\ntable. Examples are \u201cor ax, bx\u201d and \u201cor byte [mem], 5.\u201d\nXOR operation\nXOR (Exclusive Or) performs the logical bitwise\nX Y X xor Y\n\u201cexclusive or\u201d of the two operands and returns the result\n0 0 0\nto the destination operand. A bit in the result is set if the\n0 1 1\ncorresponding bits of the original operands contain\n1 0 1\nopposite values (one is set, the other is cleared) otherwise\n1 1 0\nthe result bit is cleared as shown in the truth table. XOR\nis a very important operation due to the property that it is a reversible\noperation. It is used in many cryptography algorithms, image processing, and\nin drawing operations. Examples are \u201cxor ax, bx\u201d and \u201cxor byte [mem], 5.\u201d\nNOT operation\nNOT inverts the bits (forms the one\u2019s complement) of the byte or word\noperand. Unlike the other logical operations, this is a single operand\ninstruction, and is not purely a logical operation in the sense the others are,\nbut it is still traditionally counted in the same set. Examples are \u201cnot ax\u201d and\n\u201cnot byte [mem]\u201d.\n4.6. MASKING OPERATIONS\nSelective Bit Clearing\nAnother use of AND is to make selective bits zero in its destination\noperand. The source operand is loaded with a mask containing one at\npositions which are retain their old value and zero at positions which are to\nbe zeroed. The effect of applying this operation on the destination with mask\nin the source is to clear the desired bits. This operation is called masking.\nFor example if the lower nibble is to be cleared then the operation can be\napplied with F0 in the source. The upper nibble will retain its old value and\nthe lower nibble will be cleared.\nSelective Bit Setting\nThe OR operation can be used as a masking operation to set selective bits. The\nbits in the mask are cleared at positions which are to retain their values, and\nare set at positions which are to be set. For example to set the lower nibble of\nthe destination operand, the operation should be applied with a mask of 0F\nin the source. The upper nibble will retain its value and the lower nibble will\nbe set as a result.\nVirtual University of Pakistan 51\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nSelective Bit Inversion\nXOR can also be used as a masking operation to invert selective bits. The\nbits in the mask are cleared at positions, which are to retain their values,\nand are set at positions, which are to be inverted. For example to invert the\nlower nibble of the destination operand, the operand should be applied with\na mask of 0F in the source. The upper nibble will retain its value and the\nlower nibble will be set as a result. Compare this with NOT which inverts\neverything. XOR on the other hand allows inverting selective bits.\nSelective Bit Testing\nAND can be used to check whether particular bits of a number are set or\nnot. Previously we used shifting and JC to test bits one by one. Now we\nintroduce another way to test bits, which is more powerful in the sense that\nany bit can be tested anytime and not necessarily in order. AND can be\napplied on a destination with a 1-bit in the desired position and a source,\nwhich is to be checked. If the destination is zero as a result, which can be\nchecked with a JZ instruction, the bit at the desired position in the source\nwas clear.\nHowever the AND operation destroys the destination mask, which might be\nneeded later as well. Therefore Intel provided us with another instruction\nanalogous to CMP, which is non-destructive subtraction. This is the TEST\ninstruction and is a non-destructive AND operation. It doesn\u2019t change the\ndestination and only sets the flags according to the AND operation. By\nchecking the flags, we can see if the desired bit was set or cleared.\nWe change our multiplication algorithm to use selective bit testing instead\nof checking bits one by one using the shifting operations.\nExample 4.3\n01 ; 16bit multiplication using test for bit testing\n02 [org 0x0100]\n03 jmp start\n04\n05 multiplicand: dd 1300 ; 16bit multiplicand 32bit space\n06 multiplier: dw 500 ; 16bit multiplier\n07 result: dd 0 ; 32bit result\n08\n09 start: mov cl, 16 ; initialize bit count to 16\n10 mov bx, 1 ; initialize bit mask\n11\n12 checkbit: test bx, [multiplier] ; test right most bit\n13 jz skip ; skip addition if bit is zero\n14\n15 mov ax, [multiplicand]\n16 add [result], ax ; add less significant word\n17 mov ax, [multiplicand+2]\n18 adc [result+2], ax ; add more significant word\n19\n20 skip: shl word [multiplicand], 1\n21 rcl word [multiplicand+2], 1 ; shift multiplicand left\n22 shl bx, 1 ; shift mask towards next bit\n23 dec cl ; decrement bit count\n24 jnz checkbit ; repeat if bits left\n25\n26 mov ax, 0x4c00 ; terminate program\n27 int 0x21\n12 The test instruction is used for bit testing. BX holds the mask and in\nevery next iteration it is shifting left, as our concerned bit is now the\nnext bit.\n22-24 We can do without counting in this example. We can stop as soon as\nour mask in BX becomes zero. These are the small tricks that\nassembly allows us to do and optimize our code as a result.\nVirtual University of Pakistan 52\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nInside the debugger observe that both the memory location and the mask in\nBX do not change as a result of TEST instruction. Also observe how our\nmask is shifting towards the left so that the next TEST instruction tests the\nnext bit. In the end we get the same result of 0009EB10 as in the previous\nexample.\nEXERCISES\n1. Write a program to swap every pair of bits in the AX register.\n2. Give the value of the AX register and the carry flag after each of the\nfollowing instructions.\nstc\nmov ax, <your rollnumber>\nadc ah, <first character of your name>\ncmc\nxor ah, al\nmov cl, 4\nshr al, cl\nrcr ah, cl\n3. Write a program to swap the nibbles in each byte of the AX register.\n4. Calculate the number of one bits in BX and complement an equal\nnumber of least significant bits in AX.\nHINT: Use the XOR instruction\n5. Write a program to multiply two 32bit numbers and store the answer\nin a 64bit location.\n6. Declare a 32byte buffer containing random data. Consider for this\nproblem that the bits in these 32 bytes are numbered from 0 to 255.\nDeclare another byte that contains the starting bit number. Write a\nprogram to copy the byte starting at this starting bit number in the AX\nregister. Be careful that the starting bit number may not be a multiple\nof 8 and therefore the bits of the desired byte will be split into two\nbytes.\n7. AX contains a number between 0-15. Write code to complement the\ncorresponding bit in BX. For example if AX contains 6; complement the\n6th bit of BX.\n8. AX contains a non-zero number. Count the number of ones in it and\nstore the result back in AX. Repeat the process on the result (AX) until\nAX contains one. Calculate in BX the number of iterations it took to\nmake AX one. For example BX should contain 2 in the following case:\nAX = 1100 0101 1010 0011 (input \u2013 8 ones)\nAX = 0000 0000 0000 1000 (after first iteration \u2013 1 one)\nAX = 0000 0000 0000 0001 (after second iteration \u2013 1 one) STOP\nVirtual University of Pakistan 53\n\n5\nSubroutines\n5.1. PROGRAM FLOW\nTill now we have accumulated the very basic tools of assembly language\nprogramming. A very important weapon in our arsenal is the conditional\njump instruction. During the course of last two chapters we used these tools\nto write two very useful algorithms of sorting and multiplication. The\nmultiplication algorithm is useful even though there is a MUL instruction in\nthe 8088 instruction set, which can multiply 8bit and 16bit operands. This is\nbecause of the extensibility of our algorithm, as it is not limited to 16bits and\ncan do 32bit or 64bit multiplication with minor changes.\nBoth of these algorithms will be used a number of times in any program of\na reasonable size and complexity. An application does not only need to\nmultiply at a single point in code; it multiplies at a number of places. If\nmultiplication or sorting is needed at 100 places in code, copying it 100\ntimes is a totally infeasible solution. Maintaining such a code is an\nimpossible task.\nThe straightforward solution to this problem using the concepts we have\nacquainted till now is to write the code at one place with a label, and\nwhenever we need to sort we jump to this label. But there is problem with\nthis logic, and the problem is that after sorting is complete how the processor\nwill know where to go back. The immediate answer is to jump back to a label\nfollowing the jump to bubble sort. But we have jumped to bubble sort from\n100 places in code. Which of the 100 positions in code should we jump\nback? Jump back at the first invocation, but jump has a single fixed target.\nHow will the second invocation work? The second jump to bubble sort will\nnever have control back at the next line.\nInstruction are tied to one another forming an execution thread, just like a\nknitted thread where pieces of cotton of different sizes are twisted together to\nform a thread. This thread of execution is our program. The jump instruction\nbreaks this thread permanently, making a permanent diversion, like a turn\non a highway. The conditional jump selects one of the two possible\ndirections, like right or left turn on a road. So there is no concept of\nreturning.\nHowever there are roundabouts on roads as well that take us back from\nwhere we started after having traveled on the boundary of the round. This is\nthe concept of a temporary diversion. Two or more permanent diversions can\ntake us back from where we started, just like two or more road turns can\ntake us back to the starting point, but they are still permanent diversions in\ntheir nature.\nWe need some way to implement the concept of temporary diversion in\nassembly language. We want to create a roundabout of bubble sort, another\nroundabout of our multiplication algorithm, so that we can enter into the\nroundabout whenever we need it and return back to wherever we left from\nafter completing the round.\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nProgram\nBubble Sort\nSwap\nKey point in the above discussion is returning to where we left from, like a\nloop in a knitted thread. Diversion should be temporary and not permanent.\nThe code of bubble sort written at one place, multiply at another, and we\ntemporarily divert to that place, thus avoiding a repetition of code at a 100\nplaces.\nCALL and RET\nIn every processor, instructions are available to divert temporarily and to\ndivert permanently. The instructions for permanent diversion in 8088 are the\njump instructions, while the instruction for temporary diversion is the CALL\ninstruction. The word call must be familiar to the readers from subroutine\ncall in higher level languages. The CALL instruction allows temporary\ndiversion and therefore reusability of code. Now we can place the code for\nbubble sort at one place and reuse it again and again. This was not possible\nwith permanent diversion. Actually the 8088 permanent diversion\nmechanism can be tricked to achieve temporary diversion. However it is not\npossible without getting into a lot of trouble. The key idea in doing it this way\nis to use the jump instruction form that takes a register as argument.\nTherefore this is not impossible but this is not the way it is done.\nThe natural way to do this is to use the CALL instruction followed by a\nlabel, just like JMP is followed by a label. Execution will divert to the code\nfollowing the label. Till now the operation has been similar to the JMP\ninstruction. When the subroutine completes we need to return. The RET\ninstruction is used for this purpose. The word return holds in its meaning\nthat we are to return from where we came and need no explicit destination.\nTherefore RET takes no arguments and transfers control back to the\ninstruction following the CALL that took us in this subroutine. The actual\ntechnical process that informs RET where to return will be discussed later\nafter we have discussed the system stack.\nCALL takes a label as argument and execution starts from that label, until\nthe RET instruction is encountered and it takes execution back to the\ninstruction following the CALL. Both the instructions are commonly used as\na pair, however technically they are independent in their operation. The RET\nworks regardless of the CALL and the CALL works regardless of the RET. If\nyou CALL a subroutine it will not complain if there is no RET present and\nsimilarly if you RET without being called it won\u2019t complain. It is a logical pair\nand is used as a pair in every decent code. However sometimes we play tricks\nwith the processor and we use CALL or RET alone. This will become clear\nwhen we need to play such tricks in later chapters.\nVirtual University of Pakistan 56\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nParameters\nWe intend to write the bubble sort code at one place and CALL it whenever\nneeded. An immediately visible problem is that whenever we call this\nsubroutine it will sort the same array in the same order. However in a real\napplication we will need to sort various arrays of various sizes. We might\nsometimes need an ascending sort and descending at other times. Similarly\nour data may be signed or unsigned. Such pieces of information that may\nchange from invocation to invocation and should be passed from the caller to\nthe subroutine are called parameters.\nThere must be some way of passing these parameters to the subroutine.\nRevising the subroutine temporary flow breakage mechanism, the most\nstraightforward way is to use registers. The CALL mechanism breaks the\nthread of execution and does not change registers, except IP which must\nchange for processor to start executing at another place, and SP whose\nchange will be discussed in detail later. Any of the other registers can hold\nparameters for the subroutine.\n5.2. OUR FIRST SUBROUTINE\nNow we want to modify the bubble sort code so that it works as a\nsubroutine. We place a label at the start of bubble sort code, which works as\nthe anchor point and will be used in the CALL instruction to call the\nsubroutine. We also place a RET at the end of the algorithm to return from\nwhere we called the subroutine.\nExample 5.1\n01 ; bubble sort algorithm as a subroutine\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 swap: db 0\n07\n08 bubblesort: dec cx ; last element not compared\n09 shl cx, 1 ; turn into byte count\n10\n11 mainloop: mov si, 0 ; initialize array index to zero\n12 mov byte [swap], 0 ; reset swap flag to no swaps\n13\n14 innerloop: mov ax, [bx+si] ; load number in ax\n15 cmp ax, [bx+si+2] ; compare with next number\n16 jbe noswap ; no swap if already in order\n17\n18 mov dx, [bx+si+2] ; load second element in dx\n19 mov [bx+si], dx ; store first number in second\n20 mov [bx+si+2], ax ; store second number in first\n21 mov byte [swap], 1 ; flag that a swap has been done\n22\n23 noswap: add si, 2 ; advance si to next index\n24 cmp si, cx ; are we at last index\n25 jne innerloop ; if not compare next two\n26\n27 cmp byte [swap], 1 ; check if a swap has been done\n28 je mainloop ; if yes make another pass\n29\n30 ret ; go back to where we came from\n31\n32 start: mov bx, data ; send start of array in bx\n33 mov cx, 10 ; send count of elements in cx\n34 call bubblesort ; call our subroutine\n35\n36 mov ax, 0x4c00 ; terminate program\n37 int 0x21\n08-09 The routine has received the count of elements in CX. Since it makes\none less comparison than the number of elements it decrements it.\nThen it multiplies it by two since this a word array and each element\nVirtual University of Pakistan 57\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ntakes two bytes. Left shifting has been used to multiply by two.\n14 Base+index+offset addressing has been used. BX holds the start of\narray, SI the offset into it and an offset of 2 when the next element is\nto be read. BX can be directly changed but then a separate counter\nwould be needed, as SI is directly compared with CX in our case.\n32-37 The code starting from the start label is our main program\nanalogous to the main in the C language. BX and CX hold our\nparameters for the bubblesort subroutine and the CALL is made to\ninvoke the subroutine.\nInside the debugger we observe the same unsigned data that we are so\nused to now. The number 0103 is passed via BX to the subroutine which is\nthe start of our data and the number 000A via CX which is the number of\nelements in our data. If we step over the CALL instruction we see our data\nsorted in a single step and we are at the termination instructions. The\nprocessor has jumped to the bubblesort routine, executed it to completion,\nand returned back from it but the process was hidden due to the step over\ncommand. If however we trace into the CALL instruction, we land at the first\ninstruction of our routine. At the end of the routine, when the RET\ninstruction is executed, we immediately land back to our termination\ninstructions, to be precise the instruction following the CALL.\nAlso observe that with the CALL instruction SP is decremented by two from\nFFFE to FFFC, and the stack windows shows 0150 at its top. As the RET is\nexecuted SP is recovered and the 0150 is also removed from the stack. Match\nit with the address of the instruction following the CALL which is 0150 as\nwell. The 0150 removed from the stack by the RET instruction has been\nloaded into the IP register thereby resuming execution from address 0150.\nCALL placed where to return on the stack for the RET instruction. The stack\nis automatically used with the CALL and RET instructions. Stack will be\nexplained in detail later, however the idea is that the one who is departing\nstores the address to return at a known place. This is the place using which\nCALL and RET coordinate. How this placed is actually used by the CALL and\nRET instructions will be described after the stack is discussed.\nAfter emphasizing reusability so much, it is time for another example\nwhich uses the same bubblesort routine on two different arrays of different\nsizes.\nExample 5.2\n01 ; bubble sort subroutine called twice\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 data2: dw 328, 329, 898, 8923, 8293, 2345, 10, 877, 355, 98\n07 dw 888, 533, 2000, 1020, 30, 200, 761, 167, 90, 5\n08 swap: db 0\n09\n10 bubblesort: dec cx ; last element not compared\n11 shl cx, 1 ; turn into byte count\n12\n13 mainloop: mov si, 0 ; initialize array index to zero\n14 mov byte [swap], 0 ; reset swap flag to no swaps\n15\n16 innerloop: mov ax, [bx+si] ; load number in ax\n17 cmp ax, [bx+si+2] ; compare with next number\n18 jbe noswap ; no swap if already in order\n19\n20 mov dx, [bx+si+2] ; load second element in dx\n21 mov [bx+si], dx ; store first number in second\n22 mov [bx+si+2], ax ; store second number in first\n23 mov byte [swap], 1 ; flag that a swap has been done\n24\n25 noswap: add si, 2 ; advance si to next index\nVirtual University of Pakistan 58\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n26 cmp si, cx ; are we at last index\n27 jne innerloop ; if not compare next two\n28\n29 cmp byte [swap], 1 ; check if a swap has been done\n30 je mainloop ; if yes make another pass\n31\n32 ret ; go back to where we came from\n33\n34 start: mov bx, data ; send start of array in bx\n35 mov cx, 10 ; send count of elements in cx\n36 call bubblesort ; call our subroutine\n37\n38 mov bx, data2 ; send start of array in bx\n39 mov cx, 20 ; send count of elements in cx\n40 call bubblesort ; call our subroutine again\n41\n42 mov ax, 0x4c00 ; terminate program\n43 int 0x21\n05-07 There are two different data arrays declared. One of 10 elements and\nthe other of 20 elements. The second array is declared on two lines,\nwhere the second line is continuation of the first. No additional label\nis needed since they are situated consecutively in memory.\n34-40 The other change is in the main where the bubblesort subroutine is\ncalled twice, once on the first array and once on the second.\nInside the debugger observe that stepping over the first call, the first array\nis sorted and stepping over the second call the second array is sorted. If\nhowever we step in SP is decremented and the stack holds 0178 which is the\naddress of the instruction following the call. The RET consumes that 0178\nand restores SP. The next CALL places 0181 on the stack and SP is again\ndecremented. The RET consumes this number and execution resumes from\nthe instruction at 0181. This is the coordinated function of CALL and RET\nusing the stack.\nIn both of the above examples, there is a shortcoming. The subroutine to\nsort the elements is destroying the registers AX, CX, DX, and SI. That means\nthat the caller of this routine has to make sure that it does not hold any\nimportant data in these registers before calling this function, because after\nthe call has returned the registers will be containing meaningless data for the\ncaller. With a program containing thousands of subroutines expecting the\ncaller to remember the set of modified registers for each subroutine is\nunrealistic and unreasonable. Also registers are limited in number, and\nrestricting the caller on the use of register will make the caller\u2019s job very\ntough. This shortcoming will be removed using the very important system\nstack.\n5.3. STACK\nStack is a data structure that behaves in a first in last out manner. It can\ncontain many elements and there is only one way in and out of the container.\nWhen an element is inserted it sits on top of all other elements and when an\nelement is removed the one sitting at top of all others is removed first. To\nvisualize the structure consider a test tube and put some balls in it. The\nsecond ball will come above the first and the third will come above the\nsecond. When a ball is taken out only the one at the top can be removed. The\noperation of placing an element on top of the stack is called pushing the\nelement and the operation of removing an element from the top of the stack\nis called popping the element. The last thing pushed is popped out first; the\nlast in first out behavior.\nWe can peek at any ball inside the test tube but we cannot remove it\nwithout removing every ball on top of it. Similarly we can read any element\nfrom the stack but cannot remove it without removing everything above it.\nThe stack operations of pushing and popping only work at the top of the\nVirtual University of Pakistan 59\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nstack. This top of stack is contained in the SP register. The physical address\nof the stack is obtained by the SS:SP combination. The stack segment\nregisters tells where the stack is located and the stack pointer marks the top\nof stack inside this segment.\nWhenever an element is pushed on the stack SP is decremented by two as\nthe 8088 stack works on word sized elements. Single bytes cannot be pushed\nor popped from the stack. Also it is a decrementing stack. Another possibility\nis an incrementing stack. A decrementing stack moves from higher addresses\nto lower addresses as elements are added in it while an incrementing stack\nmoves from lower addresses to higher addresses as elements are added.\nThere is no special reason or argument in favor of one or another, and more\nor less depends on the choice of the designers. Another processor 8051 by\nthe same manufacturer has an incrementing stack while 8088 has a\ndecrementing one.\nMemory is like a shelf numbered as zero at the top and the maximum at\nthe bottom. If a decrementing stack starts at shelf 5, the first item is placed\nin shelf 5, the next item is placed in shelf 4, the next in shelf 3 and so on.\nThe operations of placing items on the stack and removing them from there\nare called push and pop. The push operation copies its operand on the stack,\nwhile the pop operation makes a copy from the top of the stack into its\noperand. When an item is pushed on a decrementing stack, the top of the\nstack is first decremented and the element is then copied into this space.\nWith a pop the element at the top of the stack is copied into the pop operand\nand the top of stack is incremented afterwards.\nThe basic use of the stack is to save things and recover from there when\nneeded. For example we discussed the shortcoming in our last example that\nit destroyed the caller\u2019s registers, and the callers are not supposed to\nremember which registers are destroyed by the thousand routines they use.\nUsing the stack the subroutine can save the caller\u2019s value of the registers on\nthe stack, and recover them from there before returning. Meanwhile the\nsubroutine can freely use the registers. From the caller\u2019s point of view if the\nregisters contain the same value before and after the call, it doesn\u2019t matter if\nthe subroutine used them meanwhile.\nSimilarly during the CALL operation, the current value of the instruction\npointer is automatically saved on the stack, and the destination of CALL is\nloaded in the instruction pointer. Execution therefore resumes from the\ndestination of CALL. When the RET instruction is executed, it recovers the\nvalue of the instruction pointer from the stack. The next instruction executed\nis therefore the one following the CALL. Observe how playing with the\ninstruction pointer affects the program flow.\nThere is a form of the RET instruction called \u201cRET n\u201d where n is a numeric\nargument. After performing the operation of RET, it further increments the\nstack pointer by this number, i.e. SP is first incremented by two and then by\nn. Its function will become clear when parameter passing is discussed.\nNow we describe the operation of the stack in CALL and RET with an\nexample. The top of stack stored in the stack pointer is initialized at 2000.\nThe space above SP is considered empty and free. When the stack pointer is\ndecremented by two, we took a word from the empty space and can use it for\nour purpose. The unit of stack operations is a word. Some instructions push\nmultiple words; however byte pushes cannot be made. Now the value 017B is\nstored in the word reserved on the stack. The RET will copy this value in the\ninstruction pointer and increment the stack pointer by two making it 2000\nagain, thereby reverting the operation of CALL.\nThis is how CALL and RET behave for near calls. There is also a far version\nof these functions when the target routine is in another segment. This\nversion of CALL takes a segment offset pair just like the far jump instruction.\nThe CALL will push both the segment and the offset on the stack in this\ncase, followed by loading CS and IP with the values given in the instruction.\nVirtual University of Pakistan 60\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nThe corresponding instruction RETF will pop the offset in the instruction\npointer followed by popping the segment in the code segment register.\nApart from CALL and RET, the operations that use the stack are PUSH and\nPOP. Two other operations that will be discussed later are INT and IRET.\nRegarding the stack, the operation of PUSH is similar to CALL however with\na register other than the instruction pointer. For example \u201cpush ax\u201d will push\nthe current value of the AX register on the stack. The operation of PUSH is\nshown below.\nSP (cid:197) SP \u2013 2\n[SP] (cid:197) AX\nThe operation of POP is the reverse of this. A copy of the element at the top\nof the stack is made in the operand, and the top of the stack is incremented\nafterwards. The operation of \u201cpop ax\u201d is shown below.\nAX (cid:197) [SP]\nSP (cid:197) SP + 2\nMaking corresponding PUSH and POP operations is the responsibility of\nthe programmer. If \u201cpush ax\u201d is followed by \u201cpop dx\u201d effectively copying the\nvalue of the AX register in the DX register, the processor won\u2019t complain.\nWhether this sequence is logically correct or not should be ensured by the\nprogrammer. For example when PUSH and POP are used to save and restore\nregisters from the stack, order must be correct so that the saved value of AX\nis reloaded in the AX register and not any other register. For this the order of\nPOP operations need to be the reverse of the order of PUSH operations.\nNow we consider another example that is similar to the previous examples,\nhowever the code to swap the two elements has been extracted into another\nsubroutine, so that the formation of stack can be observed during nested\nsubroutine calls.\nExample 5.3\n01 ; bubble sort subroutine using swap subroutine\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 data2: dw 328, 329, 898, 8923, 8293, 2345, 10, 877, 355, 98\n07 dw 888, 533, 2000, 1020, 30, 200, 761, 167, 90, 5\n08 swapflag: db 0\n09\n10 swap: mov ax, [bx+si] ; load first number in ax\n11 xchg ax, [bx+si+2] ; exchange with second number\n12 mov [bx+si], ax ; store second number in first\n13 ret ; go back to where we came from\n14\n15 bubblesort: dec cx ; last element not compared\n16 shl cx, 1 ; turn into byte count\n17\n18 mainloop: mov si, 0 ; initialize array index to zero\n19 mov byte [swapflag], 0 ; reset swap flag to no swaps\n20\n21 innerloop: mov ax, [bx+si] ; load number in ax\n22 cmp ax, [bx+si+2] ; compare with next number\n23 jbe noswap ; no swap if already in order\n24\n25 call swap ; swaps two elements\n26 mov byte [swapflag], 1 ; flag that a swap has been done\n27\n28 noswap: add si, 2 ; advance si to next index\n29 cmp si, cx ; are we at last index\n30 jne innerloop ; if not compare next two\n31\n32 cmp byte [swapflag], 1 ; check if a swap has been done\n33 je mainloop ; if yes make another pass\n34 ret ; go back to where we came from\n35\n36 start: mov bx, data ; send start of array in bx\n37 mov cx, 10 ; send count of elements in cx\nVirtual University of Pakistan 61\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n38 call bubblesort ; call our subroutine\n39\n40 mov bx, data2 ; send start of array in bx\n41 mov cx, 20 ; send count of elements in cx\n42 call bubblesort ; call our subroutine again\n43\n44 mov ax, 0x4c00 ; terminate program\n45 int 0x21\n11 A new instruction XCHG has been introduced. The instruction\nswaps its source and its destination operands however at most one\nof the operands could be in memory, so the other has to be loaded in\na register. The instruction has reduced the code size by one\ninstruction.\n13 The RET at the end of swap makes it a subroutine.\nInside the debugger observe the use of stack by CALL and RET\ninstructions, especially the nested CALL.\n5.4. SAVING AND RESTORING REGISTERS\nThe subroutines we wrote till now have been destroying certain registers\nand our calling code has been carefully written to not use those registers.\nHowever this cannot be remembered for a good number of subroutines.\nTherefore our subroutines need to implement some mechanism of retaining\nthe callers\u2019 value of any registers used.\nThe trick is to use the PUSH and POP operations and save the callers\u2019\nvalue on the stack and recover it from there on return. Our swap subroutine\ndestroyed the AX register while the bubblesort subroutine destroyed AX, CX,\nand SI. BX was not modified in the subroutine. It had the same value at\nentry and at exit; it was only used by the subroutine. Our next example\nimproves on the previous version by saving and restoring any registers that it\nwill modify using the PUSH and POP operations.\nExample 5.4\n01 ; bubble sort and swap subroutines saving and restoring registers\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 data2: dw 328, 329, 898, 8923, 8293, 2345, 10, 877, 355, 98\n07 dw 888, 533, 2000, 1020, 30, 200, 761, 167, 90, 5\n08 swapflag: db 0\n09\n10 swap: push ax ; save old value of ax\n11\n12 mov ax, [bx+si] ; load first number in ax\n13 xchg ax, [bx+si+2] ; exchange with second number\n14 mov [bx+si], ax ; store second number in first\n15\n16 pop ax ; restore old value of ax\n17 ret ; go back to where we came from\n18\n19 bubblesort: push ax ; save old value of ax\n20 push cx ; save old value of cx\n21 push si ; save old value of si\n22\n23 dec cx ; last element not compared\n24 shl cx, 1 ; turn into byte count\n25\n26 mainloop: mov si, 0 ; initialize array index to zero\n27 mov byte [swapflag], 0 ; reset swap flag to no swaps\n28\n29 innerloop: mov ax, [bx+si] ; load number in ax\n30 cmp ax, [bx+si+2] ; compare with next number\n31 jbe noswap ; no swap if already in order\n32\nVirtual University of Pakistan 62\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n33 call swap ; swaps two elements\n34 mov byte [swapflag], 1 ; flag that a swap has been done\n35\n36 noswap: add si, 2 ; advance si to next index\n37 cmp si, cx ; are we at last index\n38 jne innerloop ; if not compare next two\n39\n40 cmp byte [swapflag], 1 ; check if a swap has been done\n41 je mainloop ; if yes make another pass\n42\n43 pop si ; restore old value of si\n44 pop cx ; restore old value of cx\n45 pop ax ; restore old value of ax\n46 ret ; go back to where we came from\n47\n48 start: mov bx, data ; send start of array in bx\n49 mov cx, 10 ; send count of elements in cx\n50 call bubblesort ; call our subroutine\n51\n52 mov bx, data2 ; send start of array in bx\n53 mov cx, 20 ; send count of elements in cx\n54 call bubblesort ; call our subroutine again\n55\n56 mov ax, 0x4c00 ; terminate program\n57 int 0x21\n19-21 When multiple registers are pushed, order is very important. If AX,\nCX, and SI are pushed in this order, they must be popped in the\nreverse order of SI, CX, and AX. This is again because the stack\nbehaves in a Last In First Out manner.\nInside the debugger we can observe that the registers before and after the\nCALL operation are exactly identical. Effectively the caller can assume the\nregisters are untouched. By tracing into the subroutines we can observe how\ntheir value is saved on the stack by the PUSH instructions and recovered\nfrom their before exit. Saving and restoring registers this way in subroutines\nis a standard way and must be followed.\nPUSH\nPUSH decrements SP (the stack pointer) by two and then transfers a word\nfrom the source operand to the top of stack now pointed to by SP. PUSH\noften is used to place parameters on the stack before calling a procedure;\nmore generally, it is the basic means of storing temporary data on the stack.\nPOP\nPOP transfers the word at the current top of stack (pointed to by SP) to the\ndestination operand and then increments SP by two to point to the new top\nof stack. POP can be used to move temporary variables from the stack to\nregisters or memory.\nObserve that the operand of PUSH is called a source operand since the\ndata is moving to the stack from the operand, while the operand of POP is\ncalled destination since data is moving from the stack to the operand.\nCALL\nCALL activates an out-of-line procedure, saving information on the stack to\npermit a RET (return) instruction in the procedure to transfer control back to\nthe instruction following the CALL. For an intra segment direct CALL, SP is\ndecremented by two and IP is pushed onto the stack. The target procedure\u2019s\nrelative displacement from the CALL instruction is then added to the\ninstruction pointer. For an inter segment direct CALL, SP is decremented by\ntwo, and CS is pushed onto the stack. CS is replaced by the segment word\ncontained in the instruction. SP again is decremented by two. IP is pushed\nonto the stack and replaced by the offset word in the instruction.\nVirtual University of Pakistan 63\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nThe out-of-line procedure is the temporary division, the concept of\nroundabout that we discussed. Near calls are also called intra segment calls,\nwhile far calls are called inter-segment calls. There are also versions that are\ncalled indirect calls; however they will be discuss later when they are used.\nRET\nRET (Return) transfers control from a procedure back to the instruction\nfollowing the CALL that activated the procedure. RET pops the word at the\ntop of the stack (pointed to by register SP) into the instruction pointer and\nincrements SP by two. If RETF (inter segment RET) is used the word at the\ntop of the stack is popped into the IP register and SP is incremented by two.\nThe word at the new top of stack is popped into the CS register, and SP is\nagain incremented by two. If an optional pop value has been specified, RET\nadds that value to SP. This feature may be used to discard parameters\npushed onto the stack before the execution of the CALL instruction.\n5.5. PARAMETER PASSING THROUGH STACK\nDue to the limited number of registers, parameter passing by registers is\nconstrained in two ways. The maximum parameters a subroutine can receive\nare seven when all the general registers are used. Also, with the subroutines\nare themselves limited in their use of registers, and this limited increases\nwhen the subroutine has to make a nested call thereby using certain\nregisters as its parameters. Due to this, parameter passing by registers is not\nexpandable and generalizable. However this is the fastest mechanism\navailable for passing parameters and is used where speed is important.\nConsidering stack as an alternate, we observe that whatever data is placed\nthere, it stays there, and across function calls as well. For example the\nbubble sort subroutine needs an array address and the count of elements. If\nwe place both of these on the stack, and call the subroutine afterwards, it\nwill stay there. The subroutine is invoked with its return address on top of\nthe stack and its parameters beneath it.\nTo access the arguments from the stack, the immediate idea that strikes is\nto pop them off the stack. And this is the only possibility using the given set\nof information. However the first thing popped off the stack would be the\nreturn address and not the arguments. This is because the arguments were\nfirst pushed on the stack and the subroutine was called afterwards. The\narguments cannot be popped without first popping the return address. If a\nheaving thing falls on someone\u2019s leg, the heavy thing is removed first and the\nleg is not pulled out to reduce the damage. Same is the case with our\nparameters on which the return address has fallen.\nTo handle this using PUSH and POP, we must first pop the return address\nin a register, then pop the operands, and push the return address back on\nthe stack so that RET will function normally. However so much effort doesn\u2019t\nseem to pay back the price. Processor designers should have provided a\nlogical and neat way to perform this operation. They did provided a way and\ninfact we will do this without introducing any new instruction.\nRecall that the default segment association of the BP register is the stack\nsegment and the reason for this association had been deferred for now. The\nreason is to peek inside the stack using the BP register and read the\nparameters without removing them and without touching the stack pointer.\nThe stack pointer could not be used for this purpose, as it cannot be used in\nan effective address. It is automatically used as a pointer and cannot be\nexplicitly used. Also the stack pointer is a dynamic pointer and sometimes\nchanges without telling us in the background. It is just that whenever we\ntouch it, it is where we expect it to be. The base pointer is provided as a\nreplacement of the stack pointer so that we can peek inside the stack\nwithout modifying the structure of the stack.\nVirtual University of Pakistan 64\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nWhen the bubble sort subroutine is called, the stack pointer is pointing to\nthe return address. Two bytes below it is the second parameter and four\nbytes below is the first parameter. The stack pointer is a reference point to\nthese parameters. If the value of SP is captured in BP, then the return\naddress is located at [bp+0], the second parameter is at [bp+2], and the first\nparameter is at [bp+4]. This is because SP and BP both had the same value\nand they both defaulted to the same segment, the stack segment.\nThis copying of SP into BP is like taking a snapshot or like freezing the\nstack at that moment. Even if more pushes are made on the stack\ndecrementing the stack pointer, our reference point will not change. The\nparameters will still be accessible at the same offsets from the base pointer.\nIf however the stack pointer increments beyond the base pointer, the\nreferences will become invalid. The base pointer will act as the datum point\nto access our parameters. However we have destroyed the original value of\nBP in the process, and this will cause problems in nested calls where both\nthe outer and the inner subroutines need to access their own parameters.\nThe outer subroutine will have its base pointer destroyed after the call and\nwill be unable to access its parameters.\nTo solve both of these problems, we reach at the standard way of accessing\nparameters on the stack. The first two instructions of any subroutines\naccessing its parameters from the stack are given below.\npush bp\nmov bp, sp\nAs a result our datum point has shifted by a word. Now the old value of BP\nwill be contained in [bp] and the return address will be at [bp+2]. The second\nparameters will be [bp+4] while the first one will be at [bp+6]. We give an\nexample of bubble sort subroutine using this standard way of argument\npassing through stack.\nExample 5.5\n01 ; bubble sort subroutine taking parameters from stack\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 data2: dw 328, 329, 898, 8923, 8293, 2345, 10, 877, 355, 98\n07 dw 888, 533, 2000, 1020, 30, 200, 761, 167, 90, 5\n08 swapflag: db 0\n09\n10 bubblesort: push bp ; save old value of bp\n11 mov bp, sp ; make bp our reference point\n12 push ax ; save old value of ax\n13 push bx ; save old value of bx\n14 push cx ; save old value of cx\n15 push si ; save old value of si\n16\n17 mov bx, [bp+6] ; load start of array in bx\n18 mov cx, [bp+4] ; load count of elements in cx\n19 dec cx ; last element not compared\n20 shl cx, 1 ; turn into byte count\n21\n22 mainloop: mov si, 0 ; initialize array index to zero\n23 mov byte [swapflag], 0 ; reset swap flag to no swaps\n24\n25 innerloop: mov ax, [bx+si] ; load number in ax\n26 cmp ax, [bx+si+2] ; compare with next number\n27 jbe noswap ; no swap if already in order\n28\n29 xchg ax, [bx+si+2] ; exchange ax with second number\n30 mov [bx+si], ax ; store second number in first\n31 mov byte [swapflag], 1 ; flag that a swap has been done\n32\n33 noswap: add si, 2 ; advance si to next index\n34 cmp si, cx ; are we at last index\n35 jne innerloop ; if not compare next two\n36\nVirtual University of Pakistan 65\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n37 cmp byte [swapflag], 1 ; check if a swap has been done\n38 je mainloop ; if yes make another pass\n39\n40 pop si ; restore old value of si\n41 pop cx ; restore old value of cx\n42 pop bx ; restore old value of bx\n43 pop ax ; restore old value of ax\n44 pop bp ; restore old value of bp\n45 ret 4 ; go back and remove two params\n46\n47 start: mov ax, data\n48 push ax ; place start of array on stack\n49 mov ax, 10\n50 push ax ; place element count on stack\n51 call bubblesort ; call our subroutine\n52\n53 mov ax, data2\n54 push ax ; place start of array on stack\n55 mov ax, 20\n56 push ax ; place element count on stack\n57 call bubblesort ; call our subroutine again\n58\n59 mov ax, 0x4c00 ; terminate program\n60 int 0x21\n11 The value of the stack pointer is captured in the base pointer. With\nfurther pushes SP will change but BP will not and therefore we will\nread parameters from bp+4 and bp+6.\n45 The form of RET that takes an argument is used causing four to be\nadded to SP after the return address has been popped in the\ninstruction pointer. This will effectively discard the parameters that\nare still there on the stack.\n47-50 We push the address of the array we want to sort followed by the\ncount of elements. As immediate cannot be directly pushed in the\n8088 architecture, we first load it in the AX register and then push\nthe AX register on the stack.\nInside the debugger, concentrate on the operation of BP and the stack. The\nparameters are placed on the stack by the caller, the subroutine accesses\nthem using the base pointer, and the special form of RET removes them\nwithout any extra instruction. The value of stack pointer of FFF6 is turned\ninto FFFE by the RET instruction. This was the value in SP before any of the\nparameters was pushed.\nStack Clearing by Caller or Callee\nParameters pushed for a subroutine are a waste after the subroutine has\nreturned. They have to be cleared from the stack. Either of the caller and the\ncallee can take the responsibility of clearing them from there. If the callee\nhas to clear the stack it cannot do this easily unless RET n exists. That is\nwhy most general processors have this instruction. Stack clearing by the\ncaller needs an extra instruction on behalf of the caller after every call made\nto the subroutine, unnecessarily increasing instructions in the program. If\nthere are thousand calls to a subroutine the code to clear the stack is\nrepeated a thousand times. Therefore the prevalent convention in most high\nlevel languages is stack clearing by the callee; even though the other\nconvention is still used in some languages.\nIf RET n is not available, stack clearing by the callee is a complicated\nprocess. It will have to save the return address in a register, then remove the\nparameters, and then place back the return address so that RET will\nfunction. When this instruction was introduced in processors, only then high\nlevel language designers switched to stack clearing by the callee. This is also\nexactly why RET n adds n to SP after performing the operation of RET. The\nother way around would be totally useless for our purpose. Consider the\nstack condition at the time of RET and this will become clear why this will be\nVirtual University of Pakistan 66\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nuseless. Also observe that RET n has discarded the arguments rather than\npopping them as they were no longer of any use either of the caller or the\ncallee.\nThe strong argument in favour of callee cleared stacks is that the\narguments were placed on the stack for the subroutine, the caller did not\nneeded them for itself, so the subroutine is responsible for removing them.\nRemoving the arguments is important as if the stack is not cleared or is\npartially cleared the stack will eventually become full, SP will reach 0, and\nthereafter wraparound producing unexpected results. This is called stack\noverflow. Therefore clearing anything placed on the stack is very important.\n5.6. LOCAL VARIABLES\nAnother important role of the stack is in the creation of local variables that\nare only needed while the subroutine is in execution and not afterwards.\nThey should not take permanent space like global variables. Local variables\nshould be created when the subroutine is called and discarded afterwards.\nSo that the spaced used by them can be reused for the local variables of\nanother subroutine. They only have meaning inside the subroutine and no\nmeaning outside it.\nThe most convenient place to store these variables is the stack. We need\nsome special manipulation of the stack for this task. We need to produce a\ngap in the stack for our variables. This is explained with the help of the\nswapflag in the bubble sort example.\nThe swapflag we have declared as a word occupying space permanently is\nonly needed by the bubble sort subroutine and should be a local variable.\nActually the variable was introduced with the intent of making it a local\nvariable at this time. The stack pointer will be decremented by an extra two\nbytes thereby producing a gap in which a word can reside. This gap will be\nused for our temporary, local, or automatic variable; however we name it. We\ncan decrement it as much as we want producing the desired space, however\nthe decrement must be by an even number, as the unit of stack operation is\na word. In our case we needed just one word. Also the most convenient\nposition for this gap is immediately after saving the value of SP in BP. So that\nthe same base pointer can be used to access the local variables as well; this\ntime using negative offsets. The standard way to start a subroutine which\nneeds to access parameters and has local variables is as under.\npush bp\nmov bp, sp\nsub sp, 2\nThe gap could have been created with a dummy push, but the subtraction\nmakes it clear that the value pushed is not important and the gap will be\nused for our local variable. Also gap of any size can be created in a single\ninstruction with subtraction. The parameters can still be accessed at bp+4\nand bp+6 and the swapflag can be accessed at bp-2. The subtraction in SP\nwas after taking the snapshot; therefore BP is above the parameters but\nbelow the local variables. The parameters are therefore accessed using\npositive offsets from BP and the local variables are accessed using negative\noffsets.\nWe modify the bubble sort subroutine to use a local variable to store the\nswap flag. The swap flag remembered whether a swap has been done in a\nparticular iteration of bubble sort.\nExample 5.6\n01 ; bubble sort subroutine using a local variable\n02 [org 0x0100]\n03 jmp start\n04\n05 data: dw 60, 55, 45, 50, 40, 35, 25, 30, 10, 0\n06 data2: dw 328, 329, 898, 8923, 8293, 2345, 10, 877, 355, 98\nVirtual University of Pakistan 67\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n07 dw 888, 533, 2000, 1020, 30, 200, 761, 167, 90, 5\n08\n09 bubblesort: push bp ; save old value of bp\n10 mov bp, sp ; make bp our reference point\n11 sub sp, 2 ; make two byte space on stack\n12 push ax ; save old value of ax\n13 push bx ; save old value of bx\n14 push cx ; save old value of cx\n15 push si ; save old value of si\n16\n17 mov bx, [bp+6] ; load start of array in bx\n18 mov cx, [bp+4] ; load count of elements in cx\n19 dec cx ; last element not compared\n20 shl cx, 1 ; turn into byte count\n21\n22 mainloop: mov si, 0 ; initialize array index to zero\n23 mov word [bp-2], 0 ; reset swap flag to no swaps\n24\n25 innerloop: mov ax, [bx+si] ; load number in ax\n26 cmp ax, [bx+si+2] ; compare with next number\n27 jbe noswap ; no swap if already in order\n28\n29 xchg ax, [bx+si+2] ; exchange ax with second number\n30 mov [bx+si], ax ; store second number in first\n31 mov word [bp-2], 1 ; flag that a swap has been done\n32\n33 noswap: add si, 2 ; advance si to next index\n34 cmp si, cx ; are we at last index\n35 jne innerloop ; if not compare next two\n36\n37 cmp word [bp-2], 1 ; check if a swap has been done\n38 je mainloop ; if yes make another pass\n39\n40 pop si ; restore old value of si\n41 pop cx ; restore old value of cx\n42 pop bx ; restore old value of bx\n43 pop ax ; restore old value of ax\n44 mov sp, bp ; remove space created on stack\n45 pop bp ; restore old value of bp\n46 ret 4 ; go back and remove two params\n47\n48 start: mov ax, data\n49 push ax ; place start of array on stack\n50 mov ax, 10\n51 push ax ; place element count on stack\n52 call bubblesort ; call our subroutine\n53\n54 mov ax, data2\n55 push ax ; place start of array on stack\n56 mov ax, 20\n57 push ax ; place element count on stack\n58 call bubblesort ; call our subroutine again\n59\n60 mov ax, 0x4c00 ; terminate program\n61 int 0x21\n11 A word gap has been created for swap flag. This is equivalent to a\ndummy push. The registers are pushed above this gap.\n23 The swapflag is accessed with [bp-2]. The parameters are accessed\nin the same manner as the last examples.\n44 We are removing the hole that we created. The hole is removed by\nrestoring the value of SP that it had at the time of snapshot or at the\nvalue it had before the local variable was created. This can be\nreplaced with \u201cadd sp, 2\u201d however the one used in the code is\npreferred since it does not require to remember how much space for\nlocal variables was allocated in the start. After this operation SP\npoints to the old value of BP from where we can proceed as usual.\nWe needed memory to store the swap flag. The fact that it is in the stack\nsegment or the data segment doesn\u2019t bother us. This will just change the\naddressing scheme.\nVirtual University of Pakistan 68\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nEXERCISES\n1. Replace the following valid instruction with a single instruction that\nhas the same effect. Don\u2019t consider the effect on flags.\npush word L1\njmp L2\nL1:\n2. Replace the following invalid instructions with a single instruction\nthat has the same effect.\na. pop ip\nb. mov ip, L5\nc. sub sp, 2\nmov [ss:sp], ax\nd. mov ax, [ss:sp]\nadd sp, 2\ne. add sp, 6\nmov ip, [ss:sp-6]\n3. Write a recursive function to calculate the Fibonacci of a number.\nThe number is passed as a parameter via the stack and the\ncalculated Fibonacci number is returned in the AX register. A local\nvariable should be used to store the return value from the first\nrecursive call. Fibonacci function is defined as follows:\nFibonacci(0) = 0\nFibonacci(1) = 1\nFibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)\n4. Write the above Fibonacci function iteratively.\nHINT: Use two registers to hold the current and the previous\nFibonacci numbers in a loop.\n5. Write a function switch_stack meant to change the current stack and\nwill be called as below. The function should destroy no registers.\npush word [new_stack_segment]\npush word [new_stack_offset]\ncall switch_stack\n6. Write a function \u201caddtoset\u201d that takes offset of a function and\nremembers this offset in an array that can hold a maximum of 8\noffsets. It does nothing if there are already eight offsets in the set.\nWrite another function \u201ccallset\u201d that makes a call to all functions in\nthe set one by one.\n7. Do the above exercise such that \u201ccallset\u201d does not use a CALL or a\nJMP to invoke the functions.\nHINT: Setup the stack appropriately such that the RET will execute\nthe first function, its RET execute the next and so on till the last RET\nreturns to the caller of \u201ccallset.\u201d\n8. Make an array of 0x80 bytes and treat it as one of 0x400 bits. Write\na function myalloc that takes one argument, the number of bits. It\nfinds that many consecutive zero bits in the array, makes them one,\nand returns in AX the index of the first bit. Write another function\nmyfree that takes two arguments, index of a bit in the array, and the\nnumber of bits. It makes that many consecutive bits zero, whatever\ntheir previous values are, starting from the index in the first\nargument.\n9. [Circular Queue] Write functions to implement circular queues.\nDeclare 16x32 words of data for 16 queues numbered from 0 to 15.\nEach queue has a front index, a rear index and 30 locations for data\ntotaling to 32 words. Declare another word variable whose 16 bits\ncorrespond to the 16 queues and a 1 bit signals that the\ncorresponding queue is used and a 0 bit signals that it is free. Write\na function \u201cqcreate\u201d that returns a queue number after finding a free\nqueue or -1 if it failed. Write a function \u201cqdestroy\u201d that marks the\nqueue as free. Write two other functions \u201cqadd\u201d and \u201cqremove\u201d that\nVirtual University of Pakistan 69\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncan add and remove items from the circular queue. The two\nfunctions return 0 if they failed and 1 otherwise.\n10. [Linked List] Declare 1024 nodes of four bytes each. The first 2 bytes\nwill be used for data and the next 2 bytes for storing the offset of\nanother node. Also declare a word variable \u201cfirstfree\u201d to store the\noffset of the first free node. Write the following five functions:\na. \u201cinit\u201d chains all 1024 nodes into a list with offset of first\nnode in firstfree, offset of the second node in the later two\nbytes of the first node and so on. The later two bytes of the\nlast node contains zero.\nb. \u201ccreatelist\u201d returns the offset of the node stored in firstfree\nthrough AX. It sets firstfree to the offset stored in the later\ntwo bytes of that node, and it sets the later two bytes of that\nnode to zero.\nc. \u201cinsertafter\u201d takes two parameters, the offset of a node and\na word data. It removes one node from freelist just like\n\u201ccreatelist\u201d and inserts it after the said node and updates\nthe new node\u2019s data part.\nd. \u201cdeleteafter\u201d takes a node as its parameter and removes the\nnode immediately after it in the linked list if there is one.\ne. \u201cdeletelist\u201d takes a node as its parameters and traverses the\nlinked list starting at this node and removes all nodes from\nit and add them back to the free list.\nVirtual University of Pakistan 70\n6\nDisplay Memory\nThe debugger gives a very close vision of the processor. That is why every\nprogram written till now was executed inside the debugger. Also the\ndebugger is a very useful tool in assembly language program development,\nsince many bugs only become visible when each instruction is independently\nmonitored the way the debugger allows us to do. We will now be using the\ndisplay screen in character mode, the way DOS uses this screen. The way we\nwill access this screen is specific to the IBM PC.\n6.1. ASCII CODES\nThe computer listens, sees, and speaks in numbers. Even a character is a\nnumber inside the computer. For example the keyboard is labeled with\ncharacters however when we press \u2018A\u2019, a specific number is transferred from\nthe keyboard to the computer. Our program interprets that number as the\ncharacter \u2018A\u2019. When the same number comes on display, the Video Graphics\nAdapter (VGA) in our computer shows the shape of \u2018A\u2019. Even the shape is\nstored in binary numbers with a one bit representing a pixel on the screen\nthat is turned on and a zero bit representing a pixel that is not glowing. This\nexample is considering a white on black display and no colors. This is the\nway a shape is drawn on the screen. The interpretation of \u2018A\u2019 is performed by\nthe VGA card, while the monitor or CRT (cathode ray tube) only glows the\npixels on and turns them off. The keyboard has a key labeled \u2018A\u2019 and\npressing it the screen shows \u2018A\u2019 but all that happened inside was in\nnumbers.\nAn \u2018A\u2019 on any computer and any operating system is an \u2018A\u2019 on every other\ncomputer and operating system. This is because a standard numeric\nrepresentation of all commonly used characters has been developed. This is\ncalled the ASCII code, where ASCII stands for American Standard Code for\nInformation Interchange. The name depicts that this is a code that allows the\ninterchange of information; \u2018A\u2019 written on one computer will remain an \u2018A\u2019 on\nanother. The ASCII table lists all defined characters and symbols and their\nstandardized numbers. All ASCII based computers use the same code. There\nare few other standards like EBCDIC and gray codes, but ASCII has become\nthe most prevalent standard and is used for Internet communication as well.\nIt has become the de facto standard for global communication. The character\nmode displays of our computer use the ASCII standard. Some newer\noperating systems use a new standard Unicode but it is not relevant to us in\nthe current discussion.\nStandard ASCII has 128 characters with numbers assigned from 0 to 127.\nWhen IBM PC was introduced, they extended the standard ASCII and defined\n128 more characters. Thus extending the total number of symbols from 128\nto 256 numbered from 0 to 255 fitting in an 8-bit byte. The newer characters\nwere used for line drawing, window corners, and some non-English\ncharacters. The need for these characters was never felt on teletype\nterminals, but with the advent of IBM PC and its full screen display, these\nsemi-graphics characters were the need of the day. Keep in mind that at that\ntime there was no graphics mode available.\nThe extended ASCII code is just a de facto industry standard but it is not\ndefined by an organization like the standard ASCII. Printers, displays, and all\nother peripherals related to the IBM PC understand the ASCII code. If the\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncode for \u2018A\u2019 is sent to the printer, the printer will print the shape of \u2018A\u2019, if it is\nsent to the display, the VGA card will form the shape of \u2018A\u2019 on the CRT. If it is\nsent to another computer via the serial port, the other computer will\nunderstand that this is an \u2018A\u2019.\nThe important thing to observe in the ASCII table is the contiguous\narrangement of the uppercase alphabets (41-5A), the lowercase alphabets\n(61-7A), and the numbers (30-39). This helps in certain operations with\nASCII, for example converting the case of characters by adding or subtracting\n0x20 from it. It also helps in converting a digit into its ASCII representation\nby adding 0x30 to it.\n6.2. DISPLAY MEMORY FORMATION\nWe will explore the working of the display with ASCII codes, since it is our\nimmediately accessible hardware. When 0x40 is sent to the VGA card, it will\nturn pixels on and off in such a way that a visual representation of \u2018A\u2019\nappears on the screen. It has no reality, just an interpretation. In later\nchapters we will program the VGA controller to display a new shape when\nthe ASCII of \u2018A\u2019 is received by it.\nThe video device is seen by the computer as a memory area containing the\nASCII codes that are currently displayed on the screen and a set of I/O ports\ncontrolling things like the resolution, the cursor height, and the cursor\nposition. The VGA memory is seen by the computer just like its own memory.\nThere is no difference; rather the computer doesn\u2019t differentiate, as it is\naccessible on the same bus as the system memory. Therefore if that\nappropriate block of the screen is cleared, the screen will be cleared. If the\nASCII of \u2018A\u2019 is placed somewhere in that block, the shape of \u2018A\u2019 will appear on\nthe screen at a corresponding place.\nThis correspondence must be defined as the memory is a single\ndimensional space while the screen is two dimensional having 80 rows and\n25 columns. The memory is linearly mapped on this two dimensional space,\njust like a two dimensional is mapped in linear memory. There is one word\nper character in which a byte is needed for the ASCII code and the other byte\nis used for the character\u2019s attributes discussed later. Now the first 80 words\nwill correspond to the first row of the screen and the next 80 words will\ncorrespond to the next row. By making the memory on the video controller\naccessible to the processor via the system bus, the processor is now in\ncontrol of what is displayed on the screen.\nThe three important things that we discussed are.\n\u2022 One screen location corresponds to a word in the video memory\n\u2022 The video controller memory is accessible to the processor like its\nown memory.\n\u2022 ASCII code of a character placed at a cell in the VGA memory will\ncause the corresponding ASCII shape to be displayed on the\ncorresponding screen location.\nDisplay Memory Base Address\nThe memory at which the video controller\u2019s memory is mapped must be a\nstandard, so that the program can be written in a video card independent\nmanner. Otherwise if different vendors map their video memory at different\nplaces in the address space, as was the problem in the start, writing software\nwas a headache. BIOS vendors had a problem of dealing with various card\nvendors. The IBM PC text mode color display is now fixed so that system\nsoftware can work uniformly. It was fixed at the physical memory location of\nB8000. The first byte at this location contains the ASCII for the character\ndisplayed at the top left of the video screen. Dropping the zero we can load\nthe rest in a segment register to access the video memory. If we do something\nin this memory, the effect can be seen on the screen. For example we can\nVirtual University of Pakistan 72\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nwrite a virus that makes any character we write drop to the bottom of the\nscreen.\nAttribute Byte\nThe second byte in the word designated for one screen location holds the\nforeground and background colors for the character. This is called its video\nattribute. So the pair of the ASCII code in one byte and the attribute in the\nsecond byte makes the word that corresponds to one location on the screen.\nThe lower address contains the code while the higher one contains the\nattribute. The attribute byte as detailed below has the RGB for the\nforeground and the background. It has an intensity bit for the foreground\ncolor as well thus making 16 possible colors of the foreground and 8 possible\ncolors for the background. When bit 7 is set the character keeps on blinking\non the screen. This bit has some more interpretations like background\nintensity that has to be activated in the video controller through its I/O\nports.\n7 6 5 4 3 2 1 0\n7 \u2013 Blinking of foreground character\n6 \u2013 Red component of background color\n5 \u2013 Green component of background color\n4 \u2013 Blue component of background color\n3 \u2013 Intensity component of foreground color\n2 \u2013 Red component of foreground color\n1 \u2013 Green component of foreground color\n0 \u2013 Blue component of foreground color\nDisplay Examples\nBoth DS and ES can be used to access the video memory. However we\ncommonly keep DS for accessing our data, and load ES with the segment of\nvideo memory. Loading a segment register with an immediate operand is not\nallowed in the 8088 architecture. We therefore load the segment register via a\ngeneral purpose register. Other methods are loading from a memory location\nand a combination of push and pop.\nmov ax, 0xb800\nmov es, ax\nThis operation has opened a window to the video memory. Now the\nfollowing instruction will print an \u2018A\u2019 on the top left of the screen in white\ncolor on black background.\nmov word [es:0], 0x0741\nThe segment override is used since ES is pointing to the video memory.\nSince the first word is written to, the character will appear at the top left of\nthe screen. The 41 that goes in the lower byte is the ASCII code for \u2018A\u2019. The\n07 that goes in the higher byte is the attribute with I=0, R=1, G=1, B=1 for\nthe foreground, meaning white color in low intensity and R=0, G=0, B=0 for\nthe background meaning black color and the most significant bit cleared so\nthat there is no blinking. Now consider the following instruction.\nmov word [es:160], 0x1230\nThis is displayed 80 words after the start and there are 80 characters in\none screen row. Therefore this is displayed on the first column of the second\nline. The ASCII code used is 30, which represents a \u20180\u2019 while the attribute\nbyte is 12 meaning green color on blue background.\nWe take our first example to clear the screen.\nExample 6.1\nVirtual University of Pakistan 73\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n01 ; clear the screen\n02 [org 0x0100]\n03 mov ax, 0xb800 ; load video base in ax\n04 mov es, ax ; point es to video base\n05 mov di, 0 ; point di to top left column\n06\n07 nextchar: mov word [es:di], 0x0720 ; clear next char on screen\n08 add di, 2 ; move to next screen location\n09 cmp di, 4000 ; has the whole screen cleared\n10 jne nextchar ; if no clear next position\n11\n12 mov ax, 0x4c00 ; terminate program\n13 int 0x21\n07 The code for space is 20 while 07 is the normal attribute of low\nintensity white on black with no blinking. Even to clear the screen or\nput a blank on a location there is a numeric code.\n08 DI is incremented twice since each screen location corresponds to\ntwo byte in video memory.\n09 DI is compared with 80*25*2=4000. The last word location that\ncorresponds to the screen is 3998.\nInside the debugger the operation of clearing the screen cannot be\nobserved since the debugger overwrites whatever is displayed on the screen.\nDirectly executing the COM file from the command prompt*, we can see that\nthe screen is cleared. The command prompt that reappeared is printed after\nthe termination of our application. This is the first application that can be\ndirectly executed to see some output on the screen.\n6.3. HELLO WORLD IN ASSEMBLY LANGUAGE\nTo declare a character in assembly language, we store its ASCII code in a\nbyte. The assembler provides us with another syntax that doesn\u2019t forces us to\nremember the ASCII code. The assembler also provides a syntax that\nsimplifies declaration of consecutive characters, usually called a string. The\nthree ways used below are identical in their meaning.\ndb 0x61, 0x62, 0x63\ndb 'a', 'b', 'c'\ndb 'abc'\nWhen characters are stored in any high level or low level language the\nactual thing stored in a byte is their ASCII code. The only thing the language\nhelps in is a simplified declaration.\nTraditionally the first program in higher level languages is to print \u201chello\nworld\u201d on the screen. However due to the highly granular nature of assembly\nlanguage, we are only now able to write it in assembly language. In writing\nthis program, we make a generic routine that can print any string on the\nscreen.\nExample 6.2\n01 ; hello world in assembly\n02 [org 0x0100]\n03 jmp start\n04\n05 message: db 'hello world' ; string to be printed\n06 length: dw 11 ; length of the string\n07\n08 ; subroutine to clear the screen\n09 clrscr: push es\n10 push ax\n11 push di\n* Remember that if this example is run in a DOS window on some newer\noperating systems, a full screen DOS application must be run before this\nprogram so that screen access is enabled.\nVirtual University of Pakistan 74\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n12\n13 mov ax, 0xb800\n14 mov es, ax ; point es to video base\n15 mov di, 0 ; point di to top left column\n16\n17 nextloc: mov word [es:di], 0x0720 ; clear next char on screen\n18 add di, 2 ; move to next screen location\n19 cmp di, 4000 ; has the whole screen cleared\n20 jne nextloc ; if no clear next position\n21\n22 pop di\n23 pop ax\n24 pop es\n25 ret\n26\n27 ; subroutine to print a string at top left of screen\n28 ; takes address of string and its length as parameters\n29 printstr: push bp\n30 mov bp, sp\n31 push es\n32 push ax\n33 push cx\n34 push si\n35 push di\n36\n37 mov ax, 0xb800\n38 mov es, ax ; point es to video base\n39 mov di, 0 ; point di to top left column\n40 mov si, [bp+6] ; point si to string\n41 mov cx, [bp+4] ; load length of string in cx\n42 mov ah, 0x07 ; normal attribute fixed in al\n43\n44 nextchar: mov al, [si] ; load next char of string\n45 mov [es:di], ax ; show this char on screen\n46 add di, 2 ; move to next screen location\n47 add si, 1 ; move to next char in string\n48 loop nextchar ; repeat the operation cx times\n49\n50 pop di\n51 pop si\n52 pop cx\n53 pop ax\n54 pop es\n55 pop bp\n56 ret 4\n57\n58 start: call clrscr ; call the clrscr subroutine\n59\n60 mov ax, message\n61 push ax ; push address of message\n62 push word [length] ; push message length\n63 call printstr ; call the printstr subroutine\n64\n65 mov ax, 0x4c00 ; terminate program\n66 int 0x21\n05-06 The string definition syntax discussed above is used to declare a\nstring \u201chello world\u201d of 11 bytes and the length is stored in a separate\nvariable.\n09-25 The code to clear the screen from the last example is written in the\nform of a subroutine. Since the subroutine had no parameters, only\nmodified registers are saved and restored from the stack.\n29-35 The standard subroutine format with parameters received via stack\nand all registers saved and restored is used.\n37-42\nES is initialized to point to the video memory via the AX register.\nTwo pointer registers are used; SI to point to the string and DI to\npoint to the top left location of the screen. CX is loaded with the\nlength of the string. Normal attribute of low intensity white on black\nwith no blinking is loaded in the AH register.\n44-45\nThe next character from the string is loaded into AL. Now AH holds\nthe attribute and AL the ASCII code of the character. This pair is\nVirtual University of Pakistan 75\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nwritten on the video memory using DI with the segment override\n46-47 prefix for ES to access the video memory segment.\nThe string pointer is incremented by one while the video memory\npointer is incremented by two since one char corresponds to a word\n48 on the screen.\nThe loop instruction used is equivalent to a combination of \u201cdec cx\u201d\n50-56 and \u201cjnz nextchar.\u201d The loop is executed CX times.\nThe registers pushed on the stack are recovered in opposite order\nand the \u201cret 4\u201d instruction removes the two parameters placed on\nthe stack.\n62\nMemory can be directly pushed on the stack.\nWhen the program is executed, screen is cleared and the greetings is\ndisplayed on the top left of the screen. This screen location and the attribute\nused were hard coded in the program and can also be made variable. Then\nwe will be able to print anywhere on the screen.\n6.4. NUMBER PRINTING IN ASSEMBLY\nAnother problem related to the display is printing numbers. Every high\nlevel language allows some simple way to print numbers on the screen. As we\nhave seen, everything on the screen is a pair of ASCII code and its attribute\nand a number is a raw binary number and not a collection of ASCII codes.\nFor example a 10 is stored as a 10 and not as the ASCII code of 1 followed by\nthe ASCII code of 0. If this 10 is stored in a screen location, the output will\nbe meaningless, as the character associate to ASCII code 10 will be shown on\nthe screen. So there is a process that converts a number in its ASCII\nrepresentation. This process works for any number in any base. We will\ndiscuss our examples with respect to the decimal base and later observe the\neffect of changing to different bases.\nNumber Printing Algorithm\nThe key idea is to divide the number by the base number, 10 in the case of\ndecimal. The remainder can be from 0-9 and is the right most digit of the\noriginal number. The remaining digits fall in the quotient. The remainder can\nbe easily converted into its ASCII equivalent and printed on the screen. The\nother digits can be printed in a similar manner by dividing the quotient again\nby 10 to separate the next digit and so on.\nHowever the problem with this approach is that the first digit printed is the\nright most one. For example 253 will be printed as 352. The remainder after\nfirst division was 3, after second division was 5 and after the third division\nwas 2. We have to somehow correct the order so that the actual number 253\nis displayed, and the trick is to use the stack since the stack is a Last In\nFirst Out structure so if 3, 5, and 2 are pushed on it, 2, 5, and 3 will come\nout in this order. The steps of our algorithm are outlined below.\n\u2022 Divide the number by base (10 in case of decimal)\n\u2022 The remainder is its right most digit\n\u2022 Convert the digit to its ASCII representation (Add 0x30 to the\nremainder in case of decimal)\n\u2022 Save this digit on stack\n\u2022 If the quotient is non-zero repeat the whole process to get the next\ndigit, otherwise stop\n\u2022 Pop digits one by one and print on screen left to right\nDIV Instruction\nThe division used in the process is integer division and not floating point\ndivision. Integer division gives an integer quotient and an integer remainder.\nA division algorithm is now needed. Fortunately or unfortunately there is a\nVirtual University of Pakistan 76\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nDIV instruction available in the 8088 processor. There are two forms of the\nDIV instruction. The first form divides a 32bit number in DX:AX by its 16bit\noperand and stores the 16bit quotient in AX and the 16bit remainder in DX.\nThe second form divides a 16bit number in AX by its 8bit operand and stores\nthe 8bit quotient in AL and the 8bit remainder in AH. For example \u201cDIV BL\u201d\nhas an 8bit operand, so the implied dividend is 16bit and is stored in the AX\nregister and \u201cDIV BX\u201d has a 16bit operand, so the implied dividend is 32bit\nand is therefore stored in the concatenation of the DX and AX registers. The\nhigher word is stored in DX and the lower word in AX.\nIf a large number is divided by a very small number it is possible that the\nquotient is larger than the space provided for it in the implied destination. In\nthis case an interrupt is automatically generated and the program is usually\nterminated as a result. This is called a divide overflow error; just like the\ncalculator shows an \u2013E\u2013 when the result cannot be displayed. This interrupt\nwill be discussed later in the discussion of interrupts.\nDIV (divide) performs an unsigned division of the accumulator (and its\nextension) by the source operand. If the source operand is a byte, it is\ndivided into the two-byte dividend assumed to be in registers AL and AH. The\nbyte quotient is returned in AL, and the byte remainder is returned in AH. If\nthe source operand is a word, it is divided into the two-word dividend in\nregisters AX and DX. The word quotient is returned in AX, and the word\nremainder is returned in DX. If the quotient exceeds the capacity of its\ndestination register (FF for byte source, FFFF for word source), as when\ndivision by zero is attempted, a type 0 interrupt is generated, and the\nquotient and remainder are undefined.\nNumber Printing Example\nThe next example introduces a subroutine that can print a number\nreceived as its only argument at the top left of the screen using the algorithm\njust discussed.\nExample 6.3\n001 ; number printing algorithm\n002 [org 0x0100]\n003 jmp start\n004\n005-022 ;;;;; COPY LINES 008-025 FROM EXAMPLE 6.2 (clrscr) ;;;;;\n023\n024 ; subroutine to print a number at top left of screen\n025 ; takes the number to be printed as its parameter\n026 printnum: push bp\n027 mov bp, sp\n028 push es\n029 push ax\n030 push bx\n031 push cx\n032 push dx\n033 push di\n034\n035 mov ax, 0xb800\n036 mov es, ax ; point es to video base\n037 mov ax, [bp+4] ; load number in ax\n038 mov bx, 10 ; use base 10 for division\n039 mov cx, 0 ; initialize count of digits\n040\n041 nextdigit: mov dx, 0 ; zero upper half of dividend\n042 div bx ; divide by 10\n043 add dl, 0x30 ; convert digit into ascii value\n044 push dx ; save ascii value on stack\n045 inc cx ; increment count of values\n046 cmp ax, 0 ; is the quotient zero\n047 jnz nextdigit ; if no divide it again\n048\n049 mov di, 0 ; point di to top left column\n050\nVirtual University of Pakistan 77\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n051 nextpos: pop dx ; remove a digit from the stack\n052 mov dh, 0x07 ; use normal attribute\n053 mov [es:di], dx ; print char on screen\n054 add di, 2 ; move to next screen location\n055 loop nextpos ; repeat for all digits on stack\n056\n057 pop di\n058 pop dx\n059 pop cx\n060 pop bx\n061 pop ax\n062 pop es\n063 pop bp\n064 ret 2\n065\n066 start: call clrscr ; call the clrscr subroutine\n067\n068 mov ax, 4529\n069 push ax ; place number on stack\n070 call printnum ; call the printnum subroutine\n071\n072 mov ax, 0x4c00 ; terminate program\n073 int 0x21\n026-033 The registers are saved as an essential practice. The only parameter\nreceived is the number to be printed.\n035-039 ES is initialized to video memory. AX holds the number to be\nprinted. BX is the desired base, and can be loaded from a parameter.\nCX holds the number of digits pushed on the stack. This count is\ninitialized to zero, incremented with every digit pushed and is used\nwhen the digits are popped one by one.\n041-042 DX must be zeroed as our dividend is in AX and we want a 32bit\ndivision. After the division AX holds the quotient and DX holds the\nremainder. Actually the remainder is only in DL since the remainder\ncan be from 0 to 9.\n043-045 The remainder is converted into its ASCII representation and saved\non the stack. The count of digits on the stack is incremented as well.\n046-047 If the quotient is zero, all digits have been saved on the stack and if\nit is non-zero, we have to repeat the process to print the next digit.\n049 DI is initialized to point to the top left of the screen, called the cursor\nhome. If the screen location is to become a parameter, the value\nloaded in DI will change.\n051-053 A digit is popped off the stack, the attribute byte is appended to it\nand it is displayed on the screen.\n054-055 The next screen location is two bytes ahead so DI is incremented by\ntwo. The process is repeated CX times which holds the number of\ndigits pushed on the stack.\n057-064 We pop the registers pushed and \u201cret 2\u201d to discard the only\nparameter on the stack.\n066-070 The main program clears the screen and calls the printnum\nsubroutine to print 4529 on the top left of the screen.\nWhen the program is executed 4529 is printed on the top left of the screen.\nThis algorithm is versatile in that the base number can be changed and the\nprinting will be in the desired base. For example if \u201cmov bx, 10\u201d is changed to\n\u201cmov bx, 2\u201d the output will be in binary as 001000110110001. Similarly\nchanging it to \u201cmov bx, 8\u201d outputs the number in octal as 10661. Printing it\nin hexadecimal is a bit tricky, as the ASCII codes for A-F do not consecutively\nstart after the codes for 0-9. Inside the debugger observe the working of the\nalgorithm is just as described in the above illustration. The digits are\nVirtual University of Pakistan 78\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nseparated one by one and saved on the stack. From bottom to top, the stack\nholds 0034, 0035, 0032, and 0039 after the first loop is completed. The next\nloop pops them one by one and routes them to the screen.\n6.5. SCREEN LOCATION CALCULATION\nUntil now our algorithms used a fixed attribute and displayed at a fixed\nscreen location. We will change that to use any position on the screen and\nany attribute. For mapping from the two dimensional coordinate system of\nthe screen to the one dimensional memory, we need to multiply the row\nnumber by 80 since there are 80 columns per row and add the column\nnumber to it and again multiply by two since there are 2 bytes for each\ncharacter.\nFor this purpose the multiplication routine written previously can be used.\nHowever we introduce an instruction of the 8088 microprocessor at this time\nthat can multiply 8bit or 16bit numbers.\nMUL Instruction\nMUL (multiply) performs an unsigned multiplication of the source operand\nand the accumulator. If the source operand is a byte, then it is multiplied by\nregister AL and the double-length result is returned in AH and AL. If the\nsource operand is a word, then it is multiplied by register AX, and the\ndouble-length result is returned in registers DX and AX.\nString Printing at Desired Location\nWe modify the string printing program to take the x-position, the y-\nposition, and the attribute as parameters. The desired location on the screen\ncan be calculated with the following formulae.\nlocation = ( hypos * 80 + epos ) * 2\nExample 6.4\n01 ; hello world at desired screen location\n02 [org 0x0100]\n03 jmp start\n04\n05 message: db 'hello world' ; string to be printed\n06 length: dw 11 ; length of the string\n07\n08-25 ;;;;; COPY LINES 008-025 FROM EXAMPLE 6.2 (clrscr) ;;;;;\n26\n27 ; subroutine to print a string at top left of screen\n28 ; takes x position, y position, string attribute, address of string\n29 ; and its length as parameters\n30 printstr: push bp\n31 mov bp, sp\n32 push es\n33 push ax\n34 push cx\n35 push si\n36 push di\n37\n38 mov ax, 0xb800\n39 mov es, ax ; point es to video base\n40 mov al, 80 ; load al with columns per row\n41 mull byte [bp+10] ; multiply with y position\n42 add ax, [bp+12] ; add x position\n43 shl ax, 1 ; turn into byte offset\n44 mov dial ; point di to required location\n45 mov si, [bp+6] ; point si to string\n46 mov cx, [bp+4] ; load length of string in cx\n47 mov ah, [bp+8] ; load attribute in ah\n48\n49 nextchar: mov al, [si] ; load next char of string\n50 mov [es:di], ax ; show this char on screen\n51 add di, 2 ; move to next screen location\nVirtual University of Pakistan 79\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n52 add si, 1 ; move to next char in string\n53 loop nextchar ; repeat the operation cx times\n54\n55 pop di\n56 pop si\n57 pop cx\n58 pop ax\n59 pop es\n60 pop bp\n61 ret 10\n62\n63 start: call clrscr ; call the clrscr subroutine\n64\n65 mov ax, 30\n66 push ax ; push x position\n67 mov ax, 20\n68 push ax ; push y position\n69 mov ax, 1 ; blue on black attribute\n70 push ax ; push attribute\n71 mov ax, message\n72 push ax ; push address of message\n73 push word [length] ; push message length\n74 call printstr ; call the printstr subroutine\n75\n76 mov ax, 0x4c00 ; terminate program\n77 int 0x21\n41 Push and pop operations always operate on words; however data\ncan be read as a word or as a byte. For example we read the lower\nbyte of the parameter y-position in this case.\n43 Shifting is used for multiplication by two, which should always be\nthe case when multiplication or division by a power of two is desired.\n61 The subroutine had 5 parameters so \u201cret 10\u201d is used.\n65-74 The main program pushes 30 as x-position, 20 as y-position\nmeaning 30th column on 20th row. It pushes 1 as the attribute\nmeaning low intensity blue on black with no blinking.\nWhen the program is executed hello world is displayed at the desired\nscreen location in the desired color. The x-position, y-position, and attribute\nparameters can be changed and their effect be seen on the screen. The\nimportant difference in this example is the use of MUL instruction and the\ncalculation of screen location given the x and y positions.\nEXERCISES\n1. Replace the following valid instruction with a single instruction that\nhas the same effect. Don\u2019t consider the effect on flags.\ndec cx\njnz L3\n2. Write an infinite loop that shows two asterisks moving from right and\nleft centers of the screen to the middle and then back. Use two empty\nnested loops with large counters to introduce some delay so that the\nmovement is noticeable.\n3. Write a function \u201cprintaddr\u201d that takes two parameters, the segment\nand offset parts of an address, via the stack. The function should\nprint the physical address corresponding to the segment offset pair\npassed at the top left of the screen. The address should be printed in\nhex and will therefore occupy exactly five columns. For example,\npassing 5600 and 7800 as parameters should result in 5D800\nprinted at the top left of the screen.\n4. Write code that treats an array of 500 bytes as one of 4000 bits and\nfor each blank position on the screen (i.e. space) sets the\ncorresponding bit to zero and the rest to one.\nVirtual University of Pakistan 80\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n5. Write a function \u201cdrawrect\u201d that takes four parameters via the stack.\nThe parameters are top, left, bottom, and right in this order. The\nfunction should display a rectangle on the screen using the\ncharacters + - and |.\nVirtual University of Pakistan 81\n\n7\nString Instructions\n7.1. STRING PROCESSING\nTill now very simple instructions of the 8088 microprocessor have been\nintroduced. In this chapter we will discuss a bit more powerful instructions\nthat can process blocks of data in one go. They are called block processing or\nstring instructions. This is the appropriate place to discuss these\ninstructions as we have just introduced a block of memory, which is the\nvideo memory. The vision of this memory for the processor is just a block of\nmemory starting at a special address. For example the clear screen operation\ninitializes this whole block to 0720.\nThere are just 5 block processing instructions in 8088. In the primitive\nform, the instructions themselves operate on a single cell of memory at one\ntime. However a special prefix repeats the instruction in hardware called the\nREP prefix. The REP prefix allows these instructions to operate on a number\nof data elements in one instruction. This is not like a loop; rather this\nrepetition is hard coded in the processor. The five instructions are STOS,\nLODS, CMPS, SCAS, and MOVS called store string, load string, compare\nstring, scan string, and move string respectively. MOVS is the instruction\nthat allows memory to memory moves, as was discussed in the exceptions to\nthe memory to memory movement rules. String instructions are complex\ninstruction in that they perform a number of tasks against one instruction.\nAnd with the REP prefix they perform the task of a complex loop in one\ninstruction. This causes drastic speed improvements in operations on large\nblocks of memory. The reduction in code size and the improvement in speed\nare the two reasons why these instructions were introduced in the 8088\nprocessor.\nThere are a number of common things in these instructions. Firstly they\nall work on a block of data. DI and SI are used to access memory. SI and DI\nare called source index and destination index because of string instructions.\nWhenever an instruction needs a memory source, DS:SI holds the pointer to\nit. An override is possible that can change the association from DS but the\ndefault is DS. Whenever a string instruction needs a memory destination,\nES:DI holds the pointer to it. No override is possible in this case. Whenever a\nbyte register is needed, AL holds the value. Whenever a word register is used\nAX holds the value. For example STOS stores a register in memory so AL or\nAX is the register used and ES:DI points to the destination. The LODS\ninstruction loads from memory to register so the source is pointed to by\nDS:SI and the register used is AL or AX.\nString instructions work on a block of data. A block has a start and an\nend. The instructions can work from the start towards the end and from the\nend towards the start. In fact they can work in both directions, and they\nmust be allowed to work in both directions otherwise certain operations with\noverlapping blocks become impossible. This problem is discussed in detail\nlater. The direction of movement is controlled with the Direction Flag (DF) in\nthe flags register. If this flag is cleared the direction is from lower addresses\ntowards higher addresses and if this flag is set the direction is from higher\naddresses to lower addresses. If DF is cleared, this is called the auto-\nincrement mode of string instruction, and if DF is set, this is called the auto-\ndecrement mode. There are two instructions to set and clear the direction\nflag.\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncld ; clear direction flag\nstd ; set direction flag\nEvery string instruction has two variants; a byte variant and a word\nvariant. For example the two variants of STOS are STOSB and STOSW.\nSimilarly the variants for the other string instructions are attained by\nappending a B or a W to the instruction name. The operation of each of the\nstring instructions and each of the repetition prefixes is discussed below.\nSTOS\nSTOS transfers a byte or word from register AL or AX to the string element\naddressed by ES:DI and updates DI to point to the next location. STOS is\noften used to clear a block of memory or fill it with a constant.\nThe implied source will always be in AL or AX. If DF is clear, DI will be\nincremented by one or two depending of whether STOSB or STOSW is used.\nIf DF is set DI will be decremented by one or two depending of whether\nSTOSB or STOSW is used. If REP is used before this instruction, the process\nwill be repeated CX times. CX is called the counter register because of the\nspecial treatment given to it in the LOOP and JCXZ instructions and the REP\nset of prefixes. So if REP is used with STOS the whole block of memory will\nbe filled with a constant value. REP will always decrement CX like the LOOP\ninstruction and this cannot be changed with the direction flag. It is also\nindependent of whether the byte or the word variant is used. It always\ndecrements by one; therefore CX has count of repetitions and not the count\nof bytes.\nLODS\nLODS transfers a byte or word from the source location DS:SI to AL or AX\nand updates SI to point to the next location. LODS is generally used in a loop\nand not with the REP prefix since the value previously loaded in the register\nis overwritten if the instruction is repeated and only the last value of the\nblock remains in the register.\nSCAS\nSCAS compares a source byte or word in register AL or AX with the\ndestination string element addressed by ES:DI and updates the flags. DI is\nupdated to point to the next location. SCAS is often used to locate equality or\nin-equality in a string through the use of an appropriate prefix.\nSCAS is a bit different from the other instructions. This is more like the\nCMP instruction in that it does subtraction of its operands. The prefixes\nREPE (repeat while equal) and REPNE (repeat while not equal) are used with\nthis instruction. The instruction is used to locate a byte in AL in the block of\nmemory. When the first equality or inequality is encountered; both have\nuses. For example this instruction can be used to search for a 0 in a null\nterminated string to calculate the length of the string. In this form REPNE\nwill be used to repeat while the null is not there.\nMOVS\nMOVS transfers a byte or word from the source location DS:SI to the\ndestination ES:DI and updates SI and DI to point to the next locations.\nMOVS is used to move a block of memory. The DF is important in the case of\noverlapping blocks. For example when the source and destination blocks\noverlap and the source is below the destination copy must be done upwards\nwhile if the destination is below the source copy must be done downwards.\nWe cannot perform both these copy operations properly if the direction flag\nwas not provided. If the source is below the destination and an upwards copy\nis used the source to be copied is destroyed. If however the copy is done\ndownwards the portion of source destroyed is the one that has already been\nVirtual University of Pakistan 84\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncopied. Therefore we need the control of the direction flag to handle this\nproblem. This problem is further detailed in a later example.\nCMPS\nCMPS subtracts the source location DS:SI from the destination location\nES:DI. Source and Destination are unaffected. SI and DI are updated\naccordingly. CMPS compares two blocks of memory for equality or inequality\nof the block. It subtracts byte by byte or word by word. If used with a REPE\nor a REPNE prefix is repeats as long as the blocks are same or as long as\nthey are different. For example it can be used for find a substring. A\nsubstring is a string that is contained in another string. For example \u201chas\u201d is\ncontained in \u201cMary has a little lamp.\u201d Using CMPS we can do the operation of\na complex loop in a single instruction. Only the REPE and REPNE prefixes\nare meaningful with this instruction.\nREP Prefix\nREP repeats the following string instruction CX times. The use of CX is\nimplied with the REP prefix. The decrement in CX doesn\u2019t affect any flags and\nthe jump is also independent of the flags, just like JCXZ.\nREPE and REPNE Prefixes\nREPE or REPZ repeat the following string instruction while the zero flag is\nset and REPNE or REPNZ repeat the following instruction while the zero flag\nis not set. REPE or REPNE are used with the SCAS or CMPS instructions.\nThe other string instructions have nothing to do with the condition since\nthey are performing no comparison. Also the initial state of flags before the\nstring instruction does not affect the operation. The most complex operation\nof the string instruction is with these prefixes.\n7.2. STOS EXAMPLE \u2013 CLEARING THE SCREEN\nWe take the example of clearing the screen and observe that how simple\nand fast this operation is with the string instructions. Even if there are three\ninstructions in a loop they have to be fetched and decoded with every\niteration and the time of three instructions is multiplied by the number of\niterations of the loop. In the case of string instructions, many operations are\nshort circuited. The instruction is fetched and decoded once and only the\nexecution is repeated CX times. That is why string instructions are so\nefficient in their operation. The program to clear the screen places 0720 on\nthe 2000 words on the screen.\nExample 7.1\n001 ; clear screen using string instructions\n002 [org 0x0100]\n003 jmp start\n004\n005 ; subroutine to clear the screen\n006 clrscr: push es\n007 push ax\n008 push cx\n009 push di\n010\n011 mov ax, 0xb800\n012 mov es, ax ; point es to video base\n013 xor di, di ; point di to top left column\n014 mov ax, 0x0720 ; space char in normal attribute\n015 mov cx, 2000 ; number of screen locations\n016\n017 cld ; auto increment mode\n018 rep stosw ; clear the whole screen\n019\n020 pop di\nVirtual University of Pakistan 85\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n021 pop cx\n022 pop ax\n023 pop es\n024 ret\n025\n026 start: call clrscr ; call clrscr subroutine\n027\n028 mov ax, 0x4c00 ; terminate program\n029 int 0x21\n013 A space efficient way to zero a 16bit register is to XOR it with itself.\nRemember that exclusive or results in a zero whenever the bits at\nthe source and at the destination are same. This instruction takes\njust two bytes compared to \u201cmov di, 0\u201d which would take three. This\nis a standard way to zero a 16bit register.\nInside the debugger the operation of the string instruction can be\nmonitored. The trace into command can be used to monitor every repetition\nof the string instruction. However screen will not be cleared inside the\ndebugger as the debugger overwrites its display on the screen so CX\ndecrements with every iteration, DI increments by 2. The first access is made\nat B800:0000 and the second at B800:0002 and so on. A complex and\ninefficient loop is replaced with a fast and simple instruction that does the\nsame operation many times faster.\n7.3. LODS EXAMPLE \u2013 STRING PRINTING\nThe use of LODS with the REP prefix is not meaningful as only the last\nvalue loaded will remain in the register. It is normally used in a loop paired\nwith a STOS instruction to do some block processing. We use LODS to pick\nthe data, do the processing, and then use STOS to put it back or at some\nother place. For example in string printing, we will use LODS to read a\ncharacter of the string, attach the attribute byte to it, and use STOS to write\nit on the video memory.\nThe following example will print the string using string instructions.\nExample 7.2\n001 ; hello world printing using string instructions\n002 [org 0x0100]\n003 jmp start\n004\n005 message: db 'hello world' ; string to be printed\n006 length: dw 11 ; length of string\n007\n008-027 ;;;;; COPY LINES 005-024 FROM EXAMPLE 7.1 (clrscr) ;;;;;\n028\n029 ; subroutine to print a string\n030 ; takes the x position, y position, attribute, address of string and\n031 ; its length as parameters\n032 printstr: push bp\n033 mov bp, sp\n034 push es\n035 push ax\n036 push cx\n037 push si\n038 push di\n039\n040 mov ax, 0xb800\n041 mov es, ax ; point es to video base\n042 mov al, 80 ; load al with columns per row\n043 mul byte [bp+10] ; multiply with y position\n044 add ax, [bp+12] ; add x position\n045 shl ax, 1 ; turn into byte offset\n046 mov di,ax ; point di to required location\n047 mov si, [bp+6] ; point si to string\n048 mov cx, [bp+4] ; load length of string in cx\n049 mov ah, [bp+8] ; load attribute in ah\nVirtual University of Pakistan 86\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n050\n051 cld ; auto increment mode\n052 nextchar: lodsb ; load next char in al\n053 stosw ; print char/attribute pair\n054 loop nextchar ; repeat for the whole string\n055\n056 pop di\n057 pop si\n058 pop cx\n059 pop ax\n060 pop es\n061 pop bp\n062 ret 10\n063\n064 start: call clrscr ; call the clrscr subroutine\n065\n066 mov ax, 30\n067 push ax ; push x position\n068 mov ax, 20\n069 push ax ; push y position\n070 mov ax, 1 ; blue on black attribute\n071 push ax ; push attribute\n072 mov ax, message\n073 push ax ; push address of message\n074 push word [length] ; push message length\n075 call printstr ; call the printstr subroutine\n076\n077 mov ax, 0x4c00 ; terminate program\n078 int 0x21\n051 Both operations are in auto increment mode.\n052-053 DS is automatically initialized to our segment. ES points to video\nmemory. SI points to the address of our string. DI points to the\nscreen location. AH holds the attribute. Whenever we read a\ncharacter from the string in AL, the attribute byte is implicitly\nattached and the pair is present in AX. The same effect could not be\nachieved with a REP prefix as the REP will repeat LODS and then\nstart repeating STOS, but we need to alternate them.\n054 CX holds the length of the string. Therefore LOOP repeats for each\ncharacter of the string.\nInside the debugger we observe how LODS and STOS alternate and CX is\nonly used by the LOOP instruction. In the original code there were four\ninstructions inside the loop; now there are only two. This is how string\ninstructions help in reducing code size.\n7.4. SCAS EXAMPLE \u2013 STRING LENGTH\nMany higher level languages do not explicitly store string length; rather\nthey use a null character, a character with an ASCII code of zero, to signal\nthe end of a string. In assembly language programs, it is also easier to store\na zero at the end of the string, instead of calculating the length of string,\nwhich is very difficult process for longer strings. So we delegate length\ncalculation to the processor and modify our string printing subroutine to\ntake a null terminated string and no length. We use SCASB with REPNE and\na zero in AL to find a zero byte in the string. In CX we load the maximum\npossible size, which is 64K bytes. However actual strings will be much\nsmaller. An important thing regarding SCAS and CMPS is that if they stop\ndue to equality or inequality, the index registers have already incremented.\nTherefore when SCAS will stop DI would be pointing past the null character.\nExample 7.3\n001 ; hello world printing with a null terminated string\n002 [org 0x0100]\nVirtual University of Pakistan 87\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n003 jmp start\n004\n005 message: db 'hello world', 0 ; null terminated string\n006\n007-026 ;;;;; COPY LINES 005-024 FROM EXAMPLE 7.1 (clrscr) ;;;;;\n027\n028 ; subroutine to print a string\n029 ; takes the x position, y position, attribute, and address of a null\n030 ; terminated string as parameters\n031 printstr: push bp\n032 mov bp, sp\n033 push es\n034 push ax\n035 push cx\n036 push si\n037 push di\n038\n039 push ds\n040 pop es ; load ds in es\n041 mov di, [bp+4] ; point di to string\n042 mov cx, 0xffff ; load maximum number in cx\n043 xor al, al ; load a zero in al\n044 repne scasb ; find zero in the string\n045 mov ax, 0xffff ; load maximum number in ax\n046 sub ax, cx ; find change in cx\n047 dec ax ; exclude null from length\n048 jz exit ; no printing if string is empty\n049\n050 mov cx, ax ; load string length in cx\n051 mov ax, 0xb800\n052 mov es, ax ; point es to video base\n053 mov al, 80 ; load al with columns per row\n054 mul byte [bp+8] ; multiply with y position\n055 add ax, [bp+10] ; add x position\n056 shl ax, 1 ; turn into byte offset\n057 mov di,ax ; point di to required location\n058 mov si, [bp+4] ; point si to string\n059 mov ah, [bp+6] ; load attribute in ah\n060\n061 cld ; auto increment mode\n062 nextchar: lodsb ; load next char in al\n063 stosw ; print char/attribute pair\n064 loop nextchar ; repeat for the whole string\n065\n066 exit: pop di\n067 pop si\n068 pop cx\n069 pop ax\n070 pop es\n071 pop bp\n072 ret 8\n073\n074 start: call clrscr ; call the clrscr subroutine\n075\n076 mov ax, 30\n077 push ax ; push x position\n078 mov ax, 20\n079 push ax ; push y position\n080 mov ax, 1 ; blue on black attribute\n081 push ax ; push attribute\n082 mov ax, message\n083 push ax ; push address of message\n084 call printstr ; call the printstr subroutine\n085\n086 mov ax, 0x4c00 ; terminate program\nint 0x21\n039-040 Another way to load a segment register is to use a combination of\npush and pop. The processor doesn\u2019t match pushes and pops. ES is\nequalized to DS in this pair of instructions.\nInside the debugger observe the working of the code for length calculation\nafter SCASB has completed its operation.\nVirtual University of Pakistan 88\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nLES and LDS Instructions\nSince the string instructions need their source and destination in the form\nof a segment offset pair, there are two special instructions that load a\nsegment register and a general purpose register from two consecutive\nmemory locations. LES loads ES while LDS loads DS. Both these instructions\nhave two parameters, one is the general purpose register to be loaded and\nthe other is the memory location from which to load these registers. The\nmajor application of these instructions is when a subroutine receives a\nsegment offset pair as an argument and the pair is to be loaded in a segment\nand an offset register. According to Intel rules of significance the word at\nhigher address is loaded in the segment register while the word at lower\naddress is loaded in the offset register. As parameters segment should be\npushed first so that it ends up at a higher address and the offset should be\npushed afterwards. When loading the lower address will be given. For\nexample \u201clds si, [bp+4]\u201d will load SI from BP+4 and DS from BP+6.\n7.5. LES AND LDS EXAMPLE\nWe modify the string length calculation subroutine to take the segment\nand offset of the string and use the LES instruction to load that segment\noffset pair in ES and DI.\nExample 7.4\n001 ; hello world printing with length calculation subroutine\n002 [org 0x0100]\n003 jmp start\n004\n005 message: db 'hello world', 0 ; null terminated string\n006\n007-026 ;;;;; COPY LINES 005-024 FROM EXAMPLE 7.1 (clrscr) ;;;;;\n027\n028 ; subroutine to calculate the length of a string\n029 ; takes the segment and offset of a string as parameters\n030 strlen: push bp\n031 mov bp,sp\n032 push es\n033 push cx\n034 push di\n035\n036 les di, [bp+4] ; point es:di to string\n037 mov cx, 0xffff ; load maximum number in cx\n038 xor al, al ; load a zero in al\n039 repne scasb ; find zero in the string\n040 mov ax, 0xffff ; load maximum number in ax\n041 sub ax, cx ; find change in cx\n042 dec ax ; exclude null from length\n043\n044 pop di\n045 pop cx\n046 pop es\n047 pop bp\n048 ret 4\n049\n050 ; subroutine to print a string\n051 ; takes the x position, y position, attribute, and address of a null\n052 ; terminated string as parameters\n053 printstr: push bp\n054 mov bp, sp\n055 push es\n056 push ax\n057 push cx\n058 push si\n059 push di\n060\n061 push ds ; push segment of string\n062 mov ax, [bp+4]\n063 push ax ; push offset of string\n064 call strlen ; calculate string length\nVirtual University of Pakistan 89\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n065 cmp ax, 0 ; is the string empty\n066 jz exit ; no printing if string is empty\n067 mov cx, ax ; save length in cx\n068\n069 mov ax, 0xb800\n070 mov es, ax ; point es to video base\n071 mov al, 80 ; load al with columns per row\n072 mul byte [bp+8] ; multiply with y position\n073 add ax, [bp+10] ; add x position\n074 shl ax, 1 ; turn into byte offset\n075 mov di,ax ; point di to required location\n076 mov si, [bp+4] ; point si to string\n077 mov ah, [bp+6] ; load attribute in ah\n078\n079 cld ; auto increment mode\n080 nextchar: lodsb ; load next char in al\n081 stosw ; print char/attribute pair\n082 loop nextchar ; repeat for the whole string\n083\n084 exit: pop di\n085 pop si\n086 pop cx\n087 pop ax\n088 pop es\n089 pop bp\n090 ret 8\n091\n092 start: call clrscr ; call the clrscr subroutine\n093\n094 mov ax, 30\n095 push ax ; push x position\n096 mov ax, 20\n097 push ax ; push y position\n098 mov ax, 0x71 ; blue on white attribute\n099 push ax ; push attribute\n100 mov ax, message\n101 push ax ; push address of message\n102 call printstr ; call the printstr subroutine\n103\n104 mov ax, 0x4c00 ; terminate program\n105 int 0x21\n036 The LES instruction is used to load the DI register from BP+4 and\nthe ES register from BP+6.\n065 The convention to return a value from a subroutine is to use the AX\nregister. That is why AX is not saved and restored in the subroutine.\nInside the debugger observe that the segment register is pushed followed\nby the offset. The higher address FFE6 contains the segment and the lower\naddress FFE4 contains the offset. This is because we have a decrementing\nstack. Then observe the loading of ES and DI from the stack.\n7.6. MOVS EXAMPLE \u2013 SCREEN SCROLLING\nMOVS has the two forms MOVSB and MOVSW. REP allows the instruction\nto be repeated CX times allowing blocks of memory to be copied. We will\nperform this copy of the video screen.\nScrolling is the process when all the lines on the screen move one or more\nlines towards the top of towards the bottom and the new line that appears on\nthe top or the bottom is cleared. Scrolling is a process on which string\nmovement is naturally applicable. REP with MOVS will utilize the full\nprocessor power to do the scrolling in minimum time.\nIn this example we want to scroll a variable number of lines given as\nargument. Therefore we have to calculate the source address, which is 160\ntimes the number of lines to clear. The destination address is 0, which is the\ntop left of the screen. The lines that scroll up are discarded so the source\npointer is placed after them. An equal number of lines at the bottom are\ncleared. These lines have actually been copied above.\nVirtual University of Pakistan 90\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 7.5\n001 ; scroll up the screen\n002 [org 0x0100]\n003 jmp start\n004\n005 ; subroutine to scroll up the screen\n006 ; take the number of lines to scroll as parameter\n007 scrollup: push bp\n008 mov bp,sp\n009 push ax\n010 push cx\n011 push si\n012 push di\n013 push es\n014 push ds\n015\n016 mov ax, 80 ; load chars per row in ax\n017 mul byte [bp+4] ; calculate source position\n018 mov si, ax ; load source position in si\n019 push si ; save position for later use\n020 shl si, 1 ; convert to byte offset\n021 mov cx, 2000 ; number of screen locations\n022 sub cx, ax ; count of words to move\n023 mov ax, 0xb800\n024 mov es, ax ; point es to video base\n025 mov ds, ax ; point ds to video base\n026 xor di, di ; point di to top left column\n027 cld ; set auto increment mode\n028 rep movsw ; scroll up\n029 mov ax, 0x0720 ; space in normal attribute\n030 pop cx ; count of positions to clear\n031 rep stosw ; clear the scrolled space\n032\n033 pop ds\n034 pop es\n035 pop di\n036 pop si\n037 pop cx\n038 pop ax\n039 pop bp\n040 ret 2\n041\n042 start: mov ax,5\n043 push ax ; push number of lines to scroll\n044 call scrollup ; call the scroll up subroutine\n045\n046 mov ax, 0x4c00 ; terminate program\n047 int 0x21\nThe beauty of this example is that the two memory blocks are overlapping.\nIf the source and destination in the above algorithm are swapped in an\nexpectation to scroll down the result is strange. For example if 5 lines were to\nscroll down, the top five lines of the screen are repeated on the whole screen.\nThis is where the use of the direction flag comes in.\nWhen the source is five lines below the destination, the first five lines are\ncopied on the first five lines of the destination. However the next five lines to\nbe copied from the source have been destroyed in the process; because they\nwere the same as the first five lines of the destination. The same is the\nproblem with every set of five lines as the source is destroyed during the\nprevious copy. In this situation we must go from bottom of the screen\ntowards the top. Now the last five lines are copied to the last five lines of the\ndestination. The next five lines are copied to next five lines of the destination\ndestroying the last five lines of source; but now these lines are no longer\nneeded and have been previously copied. Therefore the copy will be\nappropriately done in this case.\nWe give an example of scrolling down with this consideration. Now we have\nto calculate the end of the block instead of the start.\nVirtual University of Pakistan 91\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 7.6\n001 ; scroll down the screen\n002 [org 0x0100]\n003 jmp start\n004\n005 ; subroutine to scrolls down the screen\n006 ; take the number of lines to scroll as parameter\n007 scrolldown: push bp\n008 mov bp,sp\n009 push ax\n010 push cx\n011 push si\n012 push di\n013 push es\n014 push ds\n015\n016 mov ax, 80 ; load chars per row in ax\n017 mul byte [bp+4] ; calculate source position\n018 push ax ; save position for later use\n019 shl ax, 1 ; convert to byte offset\n020 mov si, 3998 ; last location on the screen\n021 sub si, ax ; load source position in si\n022 mov cx, 2000 ; number of screen locations\n023 sub cx, ax ; count of words to move\n024 mov ax, 0xb800\n025 mov es, ax ; point es to video base\n026 mov ds, ax ; point ds to video base\n027 mov di, 3998 ; point di to lower right column\n028 std ; set auto decrement mode\n029 rep movsw ; scroll up\n030 mov ax, 0x0720 ; space in normal attribute\n031 pop cx ; count of positions to clear\n032 rep stosw ; clear the scrolled space\n033\n034 pop ds\n035 pop es\n036 pop di\n037 pop si\n038 pop cx\n039 pop ax\n040 pop bp\n041 ret 2\n042\n043 start: mov ax,5\n044 push ax ; push number of lines to scroll\n045 call scrolldown ; call scroll down subroutine\n046\n047 mov ax, 0x4c00 ; terminate program\n048 int 0x21\n7.7. CMPS EXAMPLE \u2013 STRING COMPARISON\nFor the last string instruction, we take string comparison as an example.\nThe subroutine will take two segment offset pairs containing the address of\nthe two null terminated strings. The subroutine will return 0 if the strings\nare different and 1 if they are same. The AX register will be used to hold the\nreturn value.\nExample 7.7\n001 ; comparing null terminated strings\n002 [org 0x0100]\n003 jmp start\n004\n005 msg1: db 'hello world', 0\n006 msg2: db 'hello WORLD', 0\n007 msg3: db 'hello world', 0\n008\n009-031 ;;;;; COPY LINES 028-050 FROM EXAMPLE 7.4 (strlen) ;;;;;\n032\n033 ; subroutine to compare two strings\n034 ; takes segment and offset pairs of two strings to compare\nVirtual University of Pakistan 92\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n035 ; returns 1 in ax if they match and 0 other wise\n036 strcmp: push bp\n037 mov bp,sp\n038 push cx\n039 push si\n040 push di\n041 push es\n042 push ds\n043\n044 lds si, [bp+4] ; point ds:si to first string\n045 les di, [bp+8] ; point es:di to second string\n046\n047 push ds ; push segment of first string\n048 push si ; push offset of first string\n049 call strlen ; calculate string length\n050 mov cx, ax ; save length in cx\n051\n052 push es ; push segment of second string\n053 push di ; push offset of second string\n054 call strlen ; calculate string length\n055 cmp cx, ax ; compare length of both strings\n056 jne exitfalse ; return 0 if they are unequal\n057\n058 mov ax, 1 ; store 1 in ax to be returned\n059 repe cmpsb ; compare both strings\n060 jcxz exitsimple ; are they successfully compared\n061\n062 exitfalse: mov ax, 0 ; store 0 to mark unequal\n063\n064 exitsimple: pop ds\n065 pop es\n066 pop di\n067 pop si\n068 pop cx\n069 pop bp\n070 ret 8\n071\n072 start: push ds ; push segment of first string\n073 mov ax, msg1\n074 push ax ; push offset of first string\n075 push ds ; push segment of second string\n076 mov ax, msg2\n077 push ax ; push offset of second string\n078 call strcmp ; call strcmp subroutine\n079\n080 push ds ; push segment of first string\n081 mov ax, msg1\n082 push ax ; push offset of first string\n083 push ds ; push segment of third string\n084 mov ax, msg3\n085 push ax ; push offset of third string\n086 call strcmp ; call strcmp subroutine\n087\n088 mov ax, 0x4c00 ; terminate program\n089 int 0x21\n005-007 Three strings are declared out of which two are equal and one is\ndifferent.\n044-045 LDS and LES are used to load the pointers to the two strings in\nDS:SI and ES:DI.\n070 Since there are 4 parameters to the subroutine \u201cret 8\u201d is used.\nInside the debugger we observe that REPE is shown as REP. This is\nbecause REP and REPE are represented with the same prefix byte. When\nused with STOS, LODS, and MOVS it functions as REP and when used with\nSCAS and CMPS it functions as REPE.\nEXERCISES\n1. Write code to find the byte in AL in the whole megabyte of memory\nsuch that each memory location is compared to AL only once.\nVirtual University of Pakistan 93\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n2. Write a far procedure to reverse an array of 64k words such that the\nfirst element becomes the last and the last becomes the first and so\non. For example if the first word contained 0102h, this value is\nswapped with the last word. The next word is swapped with the\nsecond last word and so on. The routine will be passed two\nparameters through the stack; the segment and offset of the first\nelement of the array.\n3. Write a near procedure to copy a given area on the screen at the\ncenter of the screen without using a temporary array. The routine will\nbe passed top, left, bottom, and right in that order through the stack.\nThe parameters passed will always be within range the height will be\nodd and the width will be even so that it can be exactly centered.\n4. Write code to find two segments in the whole memory that are exactly\nthe same. In other words find two distinct values which if loaded in\nES and DS then for every value of SI [DS:SI]=[ES:SI].\n5. Write a function writechar that takes two parameters. The first\nparameter is the character to write and the second is the address of a\nmemory area containing top, left, bottom, right, current row, current\ncolumn, normal attribute, and cursor attribute in 8 consecutive\nbytes. These define a virtual window on the screen.\nThe function writes the passed character at (current row, current\ncolumn) using the normal attribute. It then increments current\ncolumn, If current column goes outside the window, it makes it zero\nand increments current row. If current row gets out of window, it\nscrolls the window one line up, and blanks out the new line in the\nwindow. In the end, it sets the attribute of the new (current row,\ncurrent column) to cursor attribute.\n6. Write a function \u201cstrcpy\u201d that takes the address of two parameters via\nstack, the one pushed first is source and the second is the\ndestination. The function should copy the source on the destination\nincluding the null character assuming that sufficient space is\nreserved starting at destination.\nVirtual University of Pakistan 94\n8\nSoftware Interrupts\n8.1. INTERRUPTS\nInterrupts in reality are events that occurred outside the processor and the\nprocessor must be informed about them. Interrupts are asynchronous and\nunpredictable. Asynchronous means that the interrupts occur, independent\nof the working of the processor, i.e. independent of the instruction currently\nexecuting. Synchronous events are those that occur side by side with\nanother activity. Interrupts must be asynchronous as they are generated by\nthe external world which is unaware of the happenings inside the processor.\nTrue interrupts that occur in real time are asynchronous with the execution.\nAlso it is unpredictable at which time an interrupt will come. The two\nconcepts of being unpredictable and asynchronous are overlapping.\nUnpredictable means the time at which an interrupt will come cannot be\npredicted, while asynchronous means that the interrupt has nothing to do\nwith the currently executing instruction and the current state of the\nprocessor.\nThe 8088 processor divides interrupts into two classes. Software interrupts\nand hardware interrupts. Hardware interrupts are the real interrupts\ngenerated by the external world as discussed above. Software interrupts on\nthe contrary are not generated from outside the processor. They just provide\nan extended far call mechanism. Far call allows us to jump anywhere in the\nwhole megabyte of memory. To return from the target we place both the\nsegment and offset on the stack. Software interrupts show a similar\nbehavior. It however pushes one more thing before both the segment and\noffset and that is the FLAGS register. Just like the far call loads new values\nin CS and IP, the interrupt call loads new values in CS, IP, and FLAGS.\nTherefore the only way to retain the value of original FLAGS register is to\npush and pop as part of interrupt call and return instructions. Pushing and\npopping inside the routine will not work as the routine started with an\nalready tampered value.\nThe discussion of real time interrupts is deferred till the next chapter. They\nplay the critical part in control applications where external hardware must\nbe control and events and changes therein must be appropriately responded\nby the processor. To generate an interrupt the INT instruction is used. The\nroutine that executes in response to an INT instruction is called the interrupt\nservice routine (ISR) or the interrupt handler. Taking example from real time\ninterrupts the routine to instruct an external hardware to close the valve of a\nboiler in response to an interrupt from the pressure sensor is an interrupt\nroutine.\nThe software interrupt mechanism in 8088 uses vectored interrupts\nmeaning that the address of the interrupt routine is not directly mentioned\nin an interrupt call, rather the address is lookup up from a table. 8088\nprovides a mechanism for mapping interrupts to interrupt handlers.\nIntroducing a new entry in this mapping table is called hooking an interrupt.\nSyntax of the INT instruction is very simple. It takes a single byte\nargument varying from 0-255. This is the interrupt number informing the\nprocessor, which interrupt is currently of interest. This number correlates to\nthe interrupt handler routine by a routing or vectoring mechanism. A few\ninterrupt numbers in the start are reserved and we generally do not use\nthem. They are related to the processor working. For example INT 0 is the\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ndivide by zero interrupt. A list of all reserved interrupts is given later. Such\ninterrupts are programmed in the hardware to generate the designated\ninterrupt when the specified condition arises. The remaining interrupts are\nprovided by the processor for our use. Some of these were reserved by the\nIBM PC designers to interface user programs with system software like DOS\nand BIOS. This was the logical choice for them as interrupts provided a very\nflexible architecture. The remaining interrupts are totally free for use in user\nsoftware.\nThe correlation process from the interrupt number to the interrupt handler\nuses a table called interrupt vector table. Its location is fixed to physical\nmemory address zero. Each entry of the table is four bytes long containing\nthe segment and offset of the interrupt routine for the corresponding\ninterrupt number. The first two bytes in the entry contain the offset and the\nnext two bytes contain the segment. The little endian rule of putting the more\nsignificant part (segment) at a higher address is seen here as well.\nMathematically offset of the interrupt n will be at nx4 while the segment will\nbe at nx4+2. One entry in this table is called a vector. If the vector is changed\nfor interrupt 0 then INT 0 will take execution to the new handler whose\naddress is now placed at those four bytes. INT 1 vector occupies location 4,\n5, 6, and 7 and similarly vector for INT 2 occupies locations 8, 9, 10, and 11.\nAs the table is located in RAM it can be changed anytime. Immediately after\nchanging it the interrupt mapping is changed and now the interrupt will\nresult in execution of the new routine. This indirection gives the mechanism\nextreme flexibility.\nThe operation of interrupt is same whether it is the result of an INT\ninstruction (software interrupt) or it is generated by an external hardware\nwhich passes the interrupt number by a different mechanism. The currently\nexecuting instruction is completed, the current value of FLAGS is pushed on\nthe stack, then the current code segment is pushed, then the offset of the\nnext instruction is pushed. After this it automatically clears the trap flag and\nthe interrupt flag to disallow further interrupts until the current routine\nfinishes. After this it loads the word at nx4 in IP and the word at nx4+2 in CS\nif interrupt n was generated. As soon as these values are loaded in CS and IP\nexecution goes to the start of the interrupt handler. When the handler\nfinishes its work it uses the IRET instruction to return to the caller. IRET\npops IP, then CS, and then FLAGS. The original value of IF and TF is\nrestored which re-enables further interrupts. IF and TF will be discussed in\ndetail in the discussion of real time interrupts. We have discussed three\nthings till now.\n1. The INT and IRET instruction format and syntax\n2. The formation of IVT (interrupt vector table)\n3. Operation of the processor when an interrupt in generated\nJust as discussed in the subroutines chapter, the processor will not match\ninterrupt calls to interrupt returns. If a RETF is used in the end of an ISR the\nprocessor will still return to the caller but the FLAGS will remain on the\nstack which will destroy the expectations of the caller with the stack. If we\nknow what we are doing we may use such different combination of\ninstructions. Generally we will use IRET to return from an interrupt routine.\nApart from indirection the software interrupt mechanism is similar to CALL\nand RET. Indirection is the major difference.\nThe operation of INT can be written as:\n\u2022 sp \u2190 sp-2\n\u2022 [sp] \u2190 flag\n\u2022 sp \u2190 sp-2\n\u2022 if \u2190 0\n\u2022 tf \u2190 0\n\u2022 [sp] \u2190 cs\n\u2022 sp \u2190 sp-2\n\u2022 [sp] \u2190 ip\nVirtual University of Pakistan 96\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n\u2022 ip \u2190 [0:N*4]\n\u2022 cs \u2190 [0:N*4+2]\nThe operation of IRET can be written as:\n\u2022 ip \u2190 [sp]\n\u2022 sp \u2190 sp+2\n\u2022 cs \u2190 [sp]\n\u2022 sp \u2190 sp+2\n\u2022 flag \u2190 [sp]\n\u2022 sp \u2190 sp+2\nThe above is the microcode description of INT and IRET. To obey an\nassembly language instruction the processor breaks it down into small\noperations. By reading the microcode of an instruction its working can be\ncompletely understood.\nThe interrupt mechanism we have studied is an extended far call\nmechanism. It pushes FLAGS in addition to CS and IP and it loads CS and IP\nwith a special mechanism of indirection. It is just like the table of contents\nthat is located at a fixed position and allows going directly to chapter 3, to\nchapter 4 etc. If this association is changed in the table of contents the\ndirection of the reader changes. For example if Chapter 2 starts at page 220\nwhile 240 is written in the table of contents, the reader will go to page 240\nand not 220. The table of contents entry is a vector to point to map the\nchapter number to page number. IVT has 256 chapters and the interrupt\nmechanism looks up the appropriate chapter number to reach the desired\npage to find the interrupt routine.\nAnother important similarity is that table of contents is always placed at\nthe start of the book, a well known place. Its physical position is fixed. If\nsome publishers put it at some place, others at another place, the reader will\nbe unable to find the desired chapter. Similarly in 8088 the physical memory\naddress zero is fixed for the IVT and it occupies exactly a kilobyte of memory\nas the 256x4=1K where 256 is the number of possible interrupt vectors while\nthe size of one vector is 4 bytes.\nInterrupts introduce temporary breakage in the program flow, sometimes\nprogrammed (software interrupts) and un-programmed at other times\n(hardware interrupts). By hooking interrupts various system functionalities\ncan be controlled. The interrupts reserved by the processor and having\nspecial functions in 8088 are listed below:\n\u2022 INT 0, Division by zero\nMeaning the quotient did not fit in the destination register. This is a bit\ndifferent as this interrupt does not return to the next instruction,\nrather it returns to the same instruction that generated it, a DIV\ninstruction of course. Here INT 0 is automatically generated by a DIV\nwhen a specific situation arises, there is no INT 0 instruction.\n\u2022 INT 1, Trap, Single step Interrupt\nThis interrupt is used in debugging with the trap flag. If the trap flag is\nset the Single Step Interrupt is generated after every instruction. By\nhooking this interrupt a debugger can get control after every\ninstruction and display the registers etc. 8088 was the first processor\nthat has this ability to support debugging.\n\u2022 INT 2, NMI-Non Maskable Interrupt\nReal interrupts come from outside the processor. INT 0 is not real as it\nis generated from inside. For real interrupts there are two pins in the\nprocessor, the INT pin and the NMI pin. The processor can be directed\nto listen or not to listen to the INT pin. Consider a recording studio,\nwhen the recording is going on, doors are closed so that no\ninterruption occurs, and when there is a break, the doors are opened\nso that if someone is waiting outside can come it. However if there is an\nurgency like fire outside then the door must be broken and the\nrecording must not be catered for. For such situations is the NMI pin\nVirtual University of Pakistan 97\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nwhich informs about fatal hardware failures in the system and is tied\nto interrupt 2. INT pin can be masked but NMI cannot be masked.\n\u2022 INT 3, Debug Interrupt\nThe only special thing about this interrupt is that it has a single byte\nopcode and not a two byte combination where the second byte tells the\ninterrupt number. This allows it to replace any instruction whatsoever.\nIt is also used by the debugger and will be discussed in detail with the\ndebugger working.\n\u2022 INT 4, Arithmetic Overflow, change of sign bit\nThe overflow flag is set if the sign bit unexpectedly changes as a result\nof a mathematical or logical instruction. However the overflow flag\nsignals a real overflow only if the numbers in question are treated as\nsigned numbers. So this interrupt is not automatically generated but\nas a result of a special instruction INTO (interrupt on overflow) if the\noverflow flag is set. Otherwise the INTO instruction behaves like a NOP\n(no operation).\nThese are the five interrupts reserved by Intel and are generally not used in\nour operations.\n8.2. HOOKING AN INTERRUPT\nTo hook an interrupt we change the vector corresponding to that interrupt.\nAs soon as the interrupt vector changes, that interrupt will be routed to the\nnew handler. Our first example is with the divide by zero interrupt. The\nnormal system defined behavior in response to divide by zero is to display an\nerror message and terminate the program. We will change it to display our\nown message.\nExample 8.1\n001 ; hooking divide by zero interrupt\n002 [org 0x0100]\n003 jmp start\n004\n005 message: db 'You divided something by zero.', 0\n006\n007-029 ;;;;; COPY LINES 028-050 FROM EXAMPLE 7.4 (strlen) ;;;;;\n030-049 ;;;;; COPY LINES 005-024 FROM EXAMPLE 7.1 (clrscr) ;;;;;\n050-090 ;;;;; COPY LINES 050-090 FROM EXAMPLE 7.4 (printstr) ;;;;;\n091\n092 ; divide by zero interrupt handler\n093 myisrfor0: push ax ; push all regs\n094 push bx\n095 push cx\n096 push dx\n097 push si\n098 push di\n099 push bp\n100 push ds\n101 push es\n102\n103 push cs\n104 pop ds ; point ds to our data segment\n105\n106 call clrscr ; clear the screen\n107 mov ax, 30\n108 push ax ; push x position\n109 mov ax, 20\n110 push ax ; push y position\n111 mov ax, 0x71 ; white on blue attribute\n112 push ax ; push attribute\n113 mov ax, message\n114 push ax ; push offset of message\n115 call printstr ; print message\n116\n117 pop es\n118 pop ds\n119 pop bp\nVirtual University of Pakistan 98\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n120 pop di\n121 pop si\n123 pop dx\n124 pop cx\n125 pop bx\n126 pop ax\n127 iret ; return from interrupt\n128\n129 ; subroutine to generate a divide by zero interrupt\n130 genint0: mov ax, 0x8432 ; load a big number in ax\n131 mov bl, 2 ; use a very small divisor\n132 div bl ; interrupt 0 will be generated\n133 ret\n134\n135 start: xor ax, ax\n136 mov es, ax ; load zero in es\n137 mov word [es:0*4], myisrfor0 ; store offset at n*4\n138 mov [es:0*4+2], cs ; store segment at n*4+2\n139 call genint0 ; generate interrupt 0\n140\n141 mov ax, 0x4c00 ; terminate program\n142 int 0x21\n93-101 We often push all registers in an interrupt service routine just to be\nsure that no unintentional modification to any register is made.\nSince any code may be interrupted an unintentional modification\nwill be hard to debug\n103-104 Since interrupt can be called from anywhere we are not sure about\nthe value in DS so we reset it to our code segment.\nWhen this program is executed our desired message will be shown instead\nof the default message and the computer will hang thereafter. The first thing\nto observe is that there is no INT 0 call anywhere in the code. INT 0 was\ninvoked automatically by an internal mechanism of the processor as a result\nof the DIV instruction producing a result that cannot fit in the destination\nregister. Just by changing the vector we have changed the response of the\nsystem to divide overflow situations.\nHowever the system stuck instead of returning to the next instruction.\nThis is because divide overflow is a special type of interrupt that returns to\nthe same instruction instead of the next instruction. This is why the default\nhandler forcefully terminates the program instead of returning. Now the IRET\nwill take control back to the DIV instruction which will again generate the\nsame interrupt. So the computer is stuck in an infinite loop.\n8.3. BIOS AND DOS INTERRUPTS\nIn IBM PC there are certain interrupts designated for user programs to\ncommunicate with system software to access various standard services like\naccess to the floppy drive, hard drive, vga, clock etc. If the programmer does\nnot use these services he has to understand the hardware details like which\nparticular controller is used and how it works. To avoid this and provide\ninteroperability a software interface to basic hardware devices is provided\nexcept in very early computers. Since the manufacturer knows the hardware\nit burns the software to control its hardware in ROM. Such software is called\nfirmware and access to this firmware is provided through specified\ninterrupts.\nThis basic interface to the hardware is called BIOS (basic input output\nservices). When the computer is switched on, BIOS gets the control at a\nspecified address. The messages at boot time on the screen giving BIOS\nversion, detecting different hardware are from this code. BIOS has the\nresponsibility of testing the basic hardware including video, keyboard, floppy\ndrive, hard drive etc and a special program to bootstrap. Bootstrap means to\nload OS from hard disk and from there OS takes control and proceeds to load\nits components and display a command prompt in the end. There are two\nVirtual University of Pakistan 99\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nimportant programs; BIOS and OS. OS services are high level and build upon\nthe BIOS services. BIOS services are very low level. A level further lower is\nonly directly controlling the hardware. BIOS services provide a hardware\nindependent layer above the hardware and OS services provide another\nhigher level layer over the BIOS services. We have practiced direct hardware\naccess with the video device directly without using BIOS or DOS. The layer of\nBIOS provides services like display a character, clear the screen, etc. All\nthese layers are optional in that we can skip to whatever lower layer we want.\nThe most logical way to provide access to firmware is to use the interrupt\nmechanism. Specific services are provided at specific interrupts. CALL could\nalso have been used but in that case every manufacturer would be required\nto place specific routines at specific addresses, which is not a flexible\nmechanism. Interrupts provide standard interrupt number for the caller and\nflexibility to place the interrupt routine anywhere in the memory for the\nmanufacturer. Now for the programmer it is decided that video services will\nbe provided at INT 10 but the actual address of the video services can and do\nvary on computers from different manufacturers. Any computer that is IBM\ncompatible must make the video services accessible through INT 10.\nSimilarly keyboard services are available at INT 16 and this is standard in\nevery IBM compatible. Manufacturers place the code wherever they want and\nthe services are exported through this interrupt.\nBIOS exports its various services through different interrupts. Keyboard\nservices are exported through INT 16, parallel port services through INT 17\nand similarly others through different interrupts. DOS has a single entry\npoint through INT 21 just like a pin hole camera, this single entry points\nleads to a number of DOS services. So how one interrupt provides a number\nof different services. A concept of service number is used here which is a\ndefecto standard in providing multiple services through an interrupt. INT 10\nis for video services and each of character printing service, screen clearing\nservice, cursor movement service etc. has a service number associated to it.\nSo we say INT 10 service 0 is used for this purpose and INT 10 service 1 is\nused for that purpose etc. Service numbers for different standard services are\nalso fixed for every IBM compatible. The concept of exported services through\ninterrupts is expanded with the service numbering scheme.\nThe service number is usually given in the AH register. Sometimes these\n256 services seem less. For example DOS exports thousands of services. So\nwill be often seen an extension to a level further with sub-services. For\nexamples INT 10 character generator services are all provided through a\nsingle service number and the services are distinguished with a sub-service\nnumber.\nThe finally selected service would need some arguments for it to work. In\ninterrupts arguments are usually not given through stack, rather registers\nare used. The BIOS and DOS specifications list which register contains\nwhich argument for a particular service of a particular interrupt.\nWe will touch some important BIOS and DOS services and not cover it\ncompletely neither is it possible to cover it in this space. A very\ncomprehensive reference of interrupts is the Ralph Brown List. It is just a\nreference and not to be studied from end to end. All interrupts cannot be\nremembered and there is no need to remember them.\nThe service number is almost always in AH while the sub-service number\nis in AL or BL and sometimes in other registers. The documentation of the\nservice we are using will list which register should hold what when the\ninterrupt is invoked for that particular service.\nOur first target using BIOS is video so let us proceed to our first program\nthat uses INT 10 service 13 to print a string on the screen. BIOS will work\neven if the video memory is not at B8000 (a very old video card) since BIOS\nknows everything about the hardware and is hardware specific.\nVirtual University of Pakistan 100\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 8.2\n001 ; print string using bios service\n002 [org 0x0100]\n003 jmp start\n004 message: db 'Hello World'\n005\n006 start: mov ah, 0x13 ; service 13 - print string\n007 mov al, 1 ; subservice 01 \u2013 update cursor\n008 mov bh, 0 ; output on page 0\n009 mov bl, 7 ; normal attrib\n010 mov dx, 0x0A03 ; row 10 column 3\n011 mov cx, 11 ; length of string\n012 push cs\n013 pop es ; segment of string\n014 mov bp, message ; offset of string\n015 int 0x10 ; call BIOS video service\n016\n017 mov ax, 0x4c00 ; terminate program\n018 int 0x21\n007 The sub-service are versions of printstring that update and do not\nupdate the cursor after printing the string etc.\n008 Text video screen is in the form of pages which can be upto 32. At\none time one page is visible which is by default the zeroth page\nunless we change it.\nWhen we execute it the string is printed and the cursor is updated as well.\nWith direct access to video memory we had no control over the cursor. To\ncontrol cursor a different mechanism to access the hardware was needed.\nOur next example uses the keyboard service to read a key. The\ncombination of keyboard and video services is used in almost every program\nthat we see and use. We will wait for four key presses; clear the screen after\nthe first, and draw different strings after the next key presses and exiting\nafter the last. We will use INT 16 service 1 for this purpose. This is a blocking\nservice so it does not return until a key has been pressed. We also used the\nblinking attribute in this example.\nVirtual University of Pakistan 101\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 8.3\n001 ; print string and keyboard wait using BIOS services\n002 [org 0x100]\n003 jmp start\n004\n005 msg1: db 'hello world', 0\n006 msg2: db 'hello world again', 0\n007 msg3: db 'hello world again and again', 0\n008\n009-028 ;;;;; COPY LINES 005-024 FROM EXAMPLE 7.1 (clrscr) ;;;;;\n029-069 ;;;;; COPY LINES 050-090 FROM EXAMPLE 7.4 (printstr) ;;;;;\n070-092 ;;;;; COPY LINES 028-050 FROM EXAMPLE 7.4 (strlen) ;;;;;\n093\n094 start: mov ah, 0x10 ; service 10 \u2013 vga attributes\n095 mov al, 03 ; subservice 3 \u2013 toggle blinking\n096 mov bl, 01 ; enable blinking bit\n097 int 0x10 ; call BIOS video service\n098\n099 mov ah, 0 ; service 0 \u2013 get keystroke\n100 int 0x16 ; call BIOS keyboard service\n101\n102 call clrscr ; clear the screen\n103\n104 mov ah, 0 ; service 0 \u2013 get keystroke\n105 int 0x16 ; call BIOS keyboard service\n106\n107 mov ax, 0\n108 push ax ; push x position\n109 mov ax, 0\n110 push ax ; push y position\n111 mov ax, 1 ; blue on black\n112 push ax ; push attribute\n113 mov ax, msg1\n114 push ax ; push offset of string\n115 call printstr ; print the string\n116\n117 mov ah, 0 ; service 0 \u2013 get keystroke\n118 int 0x16 ; call BIOS keyboard service\n119\n120 mov ax, 0\n121 push ax ; push x position\n123 mov ax, 0\n124 push ax ; push y position\n125 mov ax, 0x71 ; blue on white\n126 push ax ; push attribute\n127 mov ax, msg2\n128 push ax ; push offset of string\n129 call printstr ; print the string\n130\n131 mov ah, 0 ; service 0 \u2013 get keystroke\n132 int 0x16 ; call BIOS keyboard service\n133\n134 mov ax, 0\n135 push ax ; push x position\n136 mov ax, 0\n137 push ax ; push y position\n138 mov ax, 0xF4 ; red on white blinking\n139 push ax ; push attribute\n140 mov ax, msg3\n141 push ax ; push offset of string\n142 call printstr ; print the string\n143\n144 mov ah, 0 ; service 0 \u2013 get keystroke\n145 int 0x16 ; call BIOS keyboard service\n146\n147 mov ax, 0x4c00 ; terminate program\n148 int 0x21\n099-100 This service has no parameters so only the service number is\ninitialized in AH. This is the only service so there is no sub-service\nnumber as well. The ASCII code of the char pressed is returned in\nAL after this service.\nVirtual University of Pakistan 102\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nEXERCISES\n1. Write a TSR that forces a program to exit when it tries to become a\nTSR using INT 21h/Service 31h by converting its call into INT\n21h/Service 4Ch.\n2. Write a function to clear the screen whose only parameter is always\nzero. The function is hooked at interrupt 80h and may also be called\ndirectly both as a near call and as a far call. The function should\ndetect how it is called and return appropriately. It is provided that the\ndirection flag will be set before the function is called.\n3. Write a function that takes three parameters, the interrupt number\n(N) and the segment and offset of an interrupt handler XISR. The\narguments are pushed in the order N, XISR\u2019s offset and XISR\u2019s\nsegment. It is known that the first two instructions of XISR are\nPUSHF and CALL 0:0 followed by the rest of the interrupt handler.\nPUSHF instruction is of one byte and far call is of 5 bytes with the\nfirst byte being the op-code, the next two containing the target offset\nand the last two containing the target segment. The function should\nhook XISR at interrupt N and chain it to the interrupt handler\npreviously hooked at N by manipulating the call 0:0 instruction\nplaced near the start of XISR.\n4. Write a TSR that provide the circular queue services via interrupt\n0x80 using the code written in Exercise 5.XX. The interrupt\nprocedure should call one of qcreate, qdestroy, qempty, qadd,\nqremove, and uninstall based on the value in AH. The uninstall\nfunction should restore the old interrupt 0x80 handler and remove\nthe TSR from memory.\nVirtual University of Pakistan 103\n\n9\nReal Time Interrupts and\nHardware Interfacing\n9.1. HARDWARE INTERRUPTS\nThe same mechanism as discussed in the previous chapter is used for real\ninterrupts that are generated by external hardware. However there is a single\npin outside the processor called the INT pin that is used by external\nhardware to generate interrupts. The detailed operation that happens outside\nthe process when an interrupt is generated is complex and only a simplified\nview will be discussed here; the view that is relevant to an assembly language\nprogrammer. There are many external devices that need the processor\u2019s\nattention like the keyboard, hard disk, floppy disk, sound card. All of them\nneed real time interrupts at some point in their operation. For example if a\nprogram is busy in some calculations for three minutes the key strokes that\nare hit meanwhile should not be wasted. Therefore when a key is pressed,\nthe INT signal is sent, an interrupt generated and the interrupt handler\nstores the key for later use. Similarly when the printer is busy printing we\ncannot send it more data. As soon as it gets free from the previous job it\ninterrupts the processor to inform that it is free now. There are many other\nexamples where the processor needs to be informed of an external event. If\nthe processor actively monitors all devices instead of being automatically\ninterrupted then it there won\u2019t be any time to do meaningful work.\nSince there are many devices generating interrupts and there is only one\npin going inside the processor and one pin cannot be technically derived by\nmore than one source a controller is used in between called the\nProgrammable Interrupt Controller (PIC). It has eight input signals and one\noutput signal. It assigns priorities to its eight input pins from 0 to 7 so that if\nmore than one interrupt comes at the same times, the highest priority one is\nforwarded and the rest are held till that is serviced. The rest are forwarded\none by one according to priority after the highest priority one is completed.\nThe original IBM XT computer had one PIC so there were 8 possible interrupt\nsources. However IBM AT and later computers have two PIC totaling 16\npossible interrupt sources. They are arrange is a special cascade master\nslave arrangement so that only one output signal comes towards the\nprocessor. However we will concentrate on the first interrupt controller only.\nThe priority can be understood with the following example. Consider eight\nparallel switches which are all closed and connected to form the output\nsignal. When a signal comes on one of the switches, it is passed on to the\noutput and this switch and all below it are opened so that no further signals\ncan pass through it. The higher priority switches are still closed and the\nsignal on them can be forwarded. When the processor signals that it is\nfinished with the processing the switches are closed again and any waiting\ninterrupts may be forwarded. The way the processor signals ending of the\ninterrupt service routine is by using a special mechanism discussed later.\nThe eight input signals to the PIC are called Interrupt Requests (IRQ). The\neight lines are called IRQ 0 to IRQ 7. These are the input lines of the 8451.\u2020\nFor example IRQ 0 is derived by a timer device. The timer device keeps\n\u2020 8259 is the technical number of the PIC.\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ngenerating interrupts with a specified frequency. IRQ 1 is derived by the\nkeyboard when generates an interrupts when a key is pressed or released.\nIRQ 2 is the cascading interrupt connected to the output of the second 8451\nin the machine. IRQ 3 is connected to serial port COM 2 while IRQ 4 is\nconnected to serial port COM 1. IRQ 5 is used by the sound card or the\nnetwork card or the modem. An IRQ conflict means that two devices in the\nsystem want to use the same IRQ line. IRQ 6 is used by the floppy disk drive\nwhile IRQ 7 is used by the parallel port.\nEach IRQ is mapped to a specific interrupt in the system. This is called the\nIRQ to INT mapping. IRQ 0 to IRQ 7 are consecutively mapped on interrupts\n8 to F. This mapping is done by the PIC and not the processor. The actual\nmechanism fetches one instruction from the PIC whenever the INT pin is\nsignaled instead of the memory. We can program the PIC to generate a\ndifferent set of interrupts on the same interrupt requests. From the\nperspective of an assembly language programmer an IRQ 0 is translated into\nan INT 8 without any such instruction in the program and that\u2019s all.\nTherefore an IRQ 0, the highest priority interrupt, is generated by the timer\nchip at a precise frequency and the handler at INT 8 is invoked which\nupdates the system time. A key press generates IRQ 1 and the INT 9 handler\nis invoked which stores this key. To handler the timer and keyboard\ninterrupts one can replace the vectors corresponding to interrupt 8 and 9\nrespectively. For example if the timer interrupt is replaced and the floppy is\naccessed by some program, the floppy motor and its light will remain on for\never as in the normal case it is turned off by the timer interrupt after two\nseconds in anticipation that another floppy access might be needed\notherwise the time motor takes to speed up will be needed again.\u2021\nWe have seen that an interrupt request from a device enters the PIC as an\nIRQ, from there it reaches the INT pin of the processor, the processor\nreceives the interrupt number from the PIC, generates the designated\ninterrupt, and finally the interrupt handler gain control and can do whatever\nis desired. At the end of servicing the interrupt the handler should inform the\nPIC that it is completed so that lower priority interrupts can be sent from the\nPIC. This signal is called an End Of Interrupt (EOI) signal and is sent\nthrough the I/O ports of the interrupt controller.\n9.2. I/O PORTS\nThere are hundreds of peripheral devices in the system, PIC is one\nexample. The processor needs to communicate with them, give and take data\nfrom them, otherwise their presence is meaningless. Memory has a totally\ndifferent purpose. It contains the program to be executed and its data. It\ndoes not control any hardware. For communicating with peripheral devices\nthe processor uses I/O ports. There are only two operations with the external\nworld possible, read or write. Similarly with I/O ports the processor can read\nor write an I/O port. When an I/O port is read or written to, the operation is\nnot as simple as it happens in memory. Some hardware changes it\nfunctionality or performs some operation as a result.\nIBM PC has separate memory address space and peripheral address space.\nSome processors use memory mapped I/O in which case designated memory\ncells work as ports for specific devices. In case of Intel a special pin on the\ncontrol bus signals whether the current read or write is from the memory\naddress space or from the peripheral address space. The same address and\ndata buses are used to select a port and to read or write data from that port.\nHowever with I/O only the lower 16 bits of the address bus are used meaning\nthat there are a total of 65536 possible I/O ports. Now keyboard has special\n\u2021 The programs discussed from now onwards in the book must be executed\nin pure DOS and not in a DOS window so that we are in total control of the\nPIC and other devices.\nVirtual University of Pakistan 106\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nI/O ports designated to it, PIC has others, DMA, sound card, network card,\neach has some ports.\nIf the two address spaces are differentiated in hardware, they must also\nhave special instructions to select the other address space. We have the IN\nand OUT instructions to read or write from the peripheral address space.\nWhen MOV is given the processor selects the memory address space, when\nIN is given the processor selects the peripheral address space.\nIN and OUT instructions\nThe IN and OUT instructions have a byte form and a word form but the\nbyte form is almost always used. The source register in OUT and destination\nregister in IN is AL or AX depending on which form is used. The port number\ncan be directly given in the instruction if it fits in a byte otherwise it has to\nbe given in the DX register. Port numbers for specific devices are fixed by the\nIBM standard. For example 20 and 21 are for PIC, 60 to 64 for Keyboard, 378\nfor the parallel port etc. A few example of IN and OUT are below:\nin al, 0x21\nmov dx, 0x378\nin al, dx\nout 0x21, al\nmov dx, 0x378\nout dx, al\nPIC Ports\nProgrammable interrupt controller has two ports 20 and 21. Port 20 is the\ncontrol port while port 21 is the interrupt mask register which can be used\nfor selectively enabling or disabling interrupts. Each of the bits at port 21\ncorresponds to one of the IRQ lines. We first write a small program to disable\nthe keyboard using this port. As we know that the keyboard IRQ is 1, we\nplace a 1 bit at its corresponding position. A 0 bit will enable an interrupt\nand a 1 bit disables it. As soon as we write it on the port keyboard interrupts\nwill stop arriving and the keyboard will effectively be disabled. Even Ctrl-Alt-\nDel would not work; the reset power button has to be used.\nExample 9.1\n001 ; disable keyboard interrupt in PIC mask register\n002 [org 0x0100]\n003 in al, 0x21 ; read interrupt mask register\n004 or al, 2 ; set bit for IRQ2\n005 out 0x21, al ; write back mask register\n006\n007 mov ax, 0x4c00 ; terminate program\n008 int 0x21\nAfter this three line mini program is executed the computer will not\nunderstand anything else. Its ears are closed. No keystrokes are making their\nway to the processor. Ports always make something happen on the system. A\nproperly designed system can launch a missile on writing a bit on some port.\nMemory is simple in that it is all that it is. In ports every bit has a meaning\nthat changes something in the system.\nAs we previously discussed every interrupt handler invoked because\nof an IRQ must signal an EOI otherwise lower priority interrupts will\nremain disabled.\nKeyboard Controller\nWe will go in further details of the keyboard and its relation to the\ncomputer. We will not discuss how the keyboard communicates with the\nkeyboard controller in the computer rather we will discuss how the keyboard\nVirtual University of Pakistan 107\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncontroller communicates with the processor. Keyboard is a collection of\nlabeled buttons and every button is designated a number (not the ASCII\ncode). This number is sent to the processor whenever the key is pressed.\nFrom this number called the scan code the processor understands which key\nwas pressed. For each key the scan code comes twice, once for the key press\nand once for the key release. Both are scan codes and differ in one bit only.\nThe lower seven bits contain the key number while the most significant bit is\nclear in the press code and set in the release code. The IBM PC standard\ngives a table of the scan codes of all keys.\nIf we press Shift-A resulting in a capital A on the screen, the controller has\nsent the press code of Shift, the press code of A, the release code of A, the\nrelease code of Shift and the interrupt handler has understood that this\nsequence should result in the ASCII code of \u2018A\u2019. The \u2018A\u2019 key always produces\nthe same scan code whether or not shift is pressed. It is the interrupt\nhandler\u2019s job to remember that the press code of Shift has come and release\ncode has not yet come and therefore to change the meaning of the following\nkey presses. Even the caps lock key works the same way.\nAn interesting thing is that the two shift keys on the left and right side of\nthe keyboard produce different scan codes. The standard way implemented\nin BIOS is to treat that similarly. That\u2019s why we always think of them as\nidentical. If we leave BIOS and talk directly with the hardware we can\ndifferentiate between left and right shift keys with their scan code. Now this\nscan code is available from the keyboard data port which is 60. The keyboard\ngenerates IRQ 1 whenever a key is pressed so if we hook INT 9 and inside it\nread port 60 we can tell which of the shift keys was hit. Our first program\nwill do precisely this. It will output an L if the left shift key was pressed and\nR if the right one was pressed. The hooking method is the same as done in\nthe previous chapter.\nExample 9.2\n001 ; differentiate left and right shift keys with scancodes\n002 [org 0x0100]\n003 jmp start\n004\n005 ; keyboard interrupt service routine\n006 kbisr: push ax\n007 push es\n008\n009 mov ax, 0xb800\n010 mov es, ax ; point es to video memory\n011\n012 in al, 0x60 ; read a char from keyboard port\n013 cmp al, 0x2a ; is the key left shift\n014 jne nextcmp ; no, try next comparison\n015\n016 mov byte [es:0], 'L' ; yes, print L at top left\n017 jmp nomatch ; leave interrupt routine\n018\n019 nextcmp: cmp al, 0x36 ; is the key right shift\n020 jne nomatch ; no, leave interrupt routine\n021\n022 mov byte [es:0], 'R' ; yes, print R at top left\n023\n024 nomatch: mov al, 0x20\n025 out 0x20, al ; send EOI to PIC\n026\n027 pop es\n028 pop ax\n029 iret\n030\n031 start: xor ax, ax\n032 mov es, ax ; point es to IVT base\n033 cli ; disable interrupts\n034 mov word [es:9*4], kbisr ; store offset at n*4\n035 mov [es:9*4+2], cs ; store segment at n*4+2\n036 sti ; enable interrupts\nVirtual University of Pakistan 108\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n037\n038 l1: jmp l1 ; infinite loop\n033-036 CLI clears the interrupt flag to disable the interrupt system\ncompletely. The processor closes its ears and does not care about\nthe state of the INT pin. Interrupt hooking is done in two\ninstructions, placing the segment and placing the offset. If an\ninterrupt comes in between and the vector is in an indeterminate\nstate, the system will go to a junk address and eventually crash. So\nwe stop all interruptions while changing a real time interrupt vector.\nWe set the interrupt flag afterwards to renewable interrupts.\n038 The program hangs in an infinite loop. The only activity can be\ncaused by a real time interrupt. The kbisr routine is not called from\nanywhere; it is only automatically invoked as a result of IRQ 1.\nWhen the program is executed the left and right shift keys can be\ndistinguished with the L or R on the screen. As no action was taken for the\nrest of the keys, they are effectively disabled and the computer has to be\nrebooted. To check that the keyboard is actually disabled we change the\nprogram and add the INT 16 service 0 at the end to wait for an Esc key press.\nAs soon as Esc is pressed we want to terminate our program.\nExample 9.3\n001 ; attempt to terminate program with Esc that hooks keyboard interrupt\n002 [org 0x0100]\n003 jmp start\n004\n005-029 ;;;;; COPY LINES 005-029 FROM EXAMPLE 9.2 (kbisr) ;;;;;\n030\n031 start: xor ax, ax\n032 mov es, ax ; point es to IVT base\n033 cli ; disable interrupts\n034 mov word [es:9*4], kbisr ; store offset at n*4\n035 mov [es:9*4+2], cs ; store segment at n*4+2\n036 sti ; enable interrupts\n037\n038 l1: mov ah, 0 ; service 0 \u2013 get keystroke\n039 int 0x16 ; call BIOS keyboard service\n040\n041 cmp al, 27 ; is the Esc key pressed\n042 jne l1 ; if no, check for next key\n043\n044 mov ax, 0x4c00 ; terminate program\n045 int 0x21\nWhen the program is executed the behavior is same. Esc does not work.\nThis is because the original IRQ 1 handler was written by BIOS that read the\nscan code, converted into an ASCII code and stored in the keyboard buffer.\nThe BIOS INT 16 read the key from there and gives in AL. When we hooked\nthe keyboard interrupt BIOS is no longer in control, it has no information, it\nwill always see the empty buffer and INT 16 will never return.\nInterrupt Chaining\nWe can transfer control to the original BIOS ISR in the end of our routine.\nThis way the normal functioning of INT 16 can work as well. We can retrieve\nthe address of the BIOS routine by saving the values in vector 9 before\nhooking our routine. In the end of our routine we will jump to this address\nusing a special indirect form of the JMP FAR instruction.\nExample 9.4\nVirtual University of Pakistan 109\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n001 ; another attempt to terminate program with Esc that hooks\n002 ; keyboard interrupt\n003 [org 0x100]\n004 jmp start\n005\n006 oldisr: dd 0 ; space for saving old isr\n007\n008 ; keyboard interrupt service routine\n009 kbisr: push ax\n010 push es\n011\n012 mov ax, 0xb800\n013 mov es, ax ; point es to video memory\n014\n015 in al, 0x60 ; read a char from keyboard port\n016 cmp al, 0x2a ; is the key left shift\n017 jne nextcmp ; no, try next comparison\n018\n019 mov byte [es:0], 'L' ; yes, print L at top left\n020 jmp nomatch ; leave interrupt routine\n021\n022 nextcmp: cmp al, 0x36 ; is the key right shift\n023 jne nomatch ; no, leave interrupt routine\n024\n025 mov byte [es:0], 'R' ; yes, print R at top left\n026\n027 nomatch: ; mov al, 0x20\n028 ; out 0x20, al\n029\n030 pop es\n031 pop ax\n032 jmp far [cs:oldisr] ; call the original ISR\n033 ; iret\n034\n035 start: xor ax, ax\n036 mov es, ax ; point es to IVT base\n037 mov ax, [es:9*4]\n038 mov [oldisr], ax ; save offset of old routine\n039 mov ax, [es:9*4+2]\n040 mov [oldisr+2], ax ; save segment of old routine\n041 cli ; disable interrupts\n042 mov word [es:9*4], kbisr ; store offset at n*4\n043 mov [es:9*4+2], cs ; store segment at n*4+2\n044 sti ; enable interrupts\n045\n046 l1: mov ah, 0 ; service 0 \u2013 get keystroke\n047 int 0x16 ; call BIOS keyboard service\n048\n049 cmp al, 27 ; is the Esc key pressed\n050 jne l1 ; if no, check for next key\n051\n052 mov ax, 0x4c00 ; terminate program\n053 int 0x21\n027-028 EOI is no longer needed as the original BIOS routine will have it at\nits end.\n033 IRET has been removed and an unconditional jump is introduced. At\ntime of JMP the stack has the exact formation as was when the\ninterrupt came. So the original BIOS routine\u2019s IRET will take control\nto the interrupted program. We have been careful in restoring every\nregister we modified and retained the stack in the same form as it\nwas at the time of entry into the routine.\nWhen the program is executed L and R are printed as desired and Esc\nterminates the program as well. Normal commands like DIR work now and\nshift keys still show L and R as our routine did even after the termination of\nour program. Now start some application like the editor, it open well but as\nsoon as a key is pressed the computer crashes.\nActually our hooking and chaining was fine. When Esc was pressed we\nsignaled DOS that our program has terminated. DOS will take all our\nVirtual University of Pakistan 110\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nmemory as a result. The routine is still in memory and functioning but the\nmemory is free according to DOS. As soon as we load EDIT the same memory\nis allocated to EDIT and our routine as overwritten. Now when a key is\npressed our routine\u2019s address is in the vector but at that address some new\ncode is placed that is not intended to be an interrupt handler. That may be\ndata or some part of the EDIT program. This results in crashing the\ncomputer.\nUnhooking Interrupt\nWe now add the interrupt restoring part to our program. This code resets\nthe interrupt vector to the value it had before the start of our program.\nExample 9.5\n001 ; terminate program with Esc that hooks keyboard interrupt\n002 [org 0x100]\n003 jmp start\n004\n005 oldisr: dd 0 ; space for saving old isr\n006\n007-032 ;;;;; COPY LINES 005-029 FROM EXAMPLE 9.4 (kbisr) ;;;;;\n033\n034 start: xor ax, ax\n035 mov es, ax ; point es to IVT base\n036 mov ax, [es:9*4]\n037 mov [oldisr], ax ; save offset of old routine\n038 mov ax, [es:9*4+2]\n039 mov [oldisr+2], ax ; save segment of old routine\n040 cli ; disable interrupts\n041 mov word [es:9*4], kbisr ; store offset at n*4\n042 mov [es:9*4+2], cs ; store segment at n*4+2\n043 sti ; enable interrupts\n044\n045 l1: mov ah, 0 ; service 0 \u2013 get keystroke\n046 int 0x16 ; call BIOS keyboard service\n047\n048 cmp al, 27 ; is the Esc key pressed\n049 jne l1 ; if no, check for next key\n050\n051 mov ax, [oldisr] ; read old offset in ax\n052 mov bx, [oldisr+2] ; read old segment in bx\n053 cli ; disable interrupts\n054 mov [es:9*4], ax ; restore old offset from ax\n055 mov [es:9*4+2], bx ; restore old segment from bx\n056 sti ; enable interrupts\n057\n058 mov ax, 0x4c00 ; terminate program\n059 int 0x21\n9.3. TERMINATE AND STAY RESIDENT\nWe change the display to show L only while the left shift is pressed and R\nonly while the right shift is pressed to show the use of the release codes. We\nalso changed that shift keys are not forwarded to BIOS. The effect will be\nvisible with A and Shift-A both producing small \u2018a\u2019 but caps lock will work.\nThere is one major difference from all the programs we have been writing\ntill now. The termination is done using INT 21 service 31 instead of INT 21\nservice 4C. The effect is that even after termination the program is there and\nis legally there.\nExample 9.6\n001 ; TSR to show status of shift keys on top left of screen\n002 [org 0x0100]\n003 jmp start\n004\n005 oldisr: dd 0 ; space for saving old isr\n006\nVirtual University of Pakistan 111\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n007 ; keyboard interrupt service routine\n008 kbisr: push ax\n009 push es\n010\n011 mov ax, 0xb800\n012 mov es, ax ; point es to video memory\n013\n014 in al, 0x60 ; read a char from keyboard port\n015 cmp al, 0x2a ; has the left shift pressed\n016 jne nextcmp ; no, try next comparison\n017\n018 mov byte [es:0], 'L' ; yes, print L at first column\n019 jmp exit ; leave interrupt routine\n020\n021 nextcmp: cmp al, 0x36 ; has the right shift pressed\n022 jne nextcmp2 ; no, try next comparison\n023\n024 mov byte [es:0], 'R' ; yes, print R at second column\n025 jmp exit ; leave interrupt routine\n026\n027 nextcmp2: cmp al, 0xaa ; has the left shift released\n028 jne nextcmp3 ; no, try next comparison\n029\n030 mov byte [es:0], ' ' ; yes, clear the first column\n031 jmp exit ; leave interrupt routine\n032\n033 nextcmp3: cmp al, 0xb6 ; has the right shift released\n034 jne nomatch ; no, chain to old ISR\n035\n036 mov byte [es:2], ' ' ; yes, clear the second column\n037 jmp exit ; leave interrupt routine\n038\n039 nomatch: pop es\n040 pop ax\n041 jmp far [cs:oldisr] ; call the original ISR\n042\n043 exit: mov al, 0x20\n044 out 0x20, al ; send EOI to PIC\n045\n046 pop es\n047 pop ax\n048 iret ; return from interrupt\n049\n050 start: xor ax, ax\n051 mov es, ax ; point es to IVT base\n052 mov ax, [es:9*4]\n053 mov [oldisr], ax ; save offset of old routine\n054 mov ax, [es:9*4+2]\n055 mov [oldisr+2], ax ; save segment of old routine\n056 cli ; disable interrupts\n057 mov word [es:9*4], kbisr ; store offset at n*4\n058 mov [es:9*4+2], cs ; store segment at n*4+2\n059 sti ; enable interrupts\n060\n061 mov dx, start ; end of resident portion\n062 add dx, 15 ; round up to next para\n063 mov cl, 4\n064 shr dx, cl ; number of paras\n065 mov ax, 0x3100 ; terminate and stay resident\n066 int 0x21\nWhen this program is executed the command prompt immediately comes.\nDIR can be seen. EDIT can run and keypresses do not result in a crash. And\nwith all that left and right shift keys shown L and R on top left of the screen\nwhile they are pressed but the shift keys do not work as usual since we did\nnot forwarded the key to BIOS. This is selective chaining.\nVirtual University of Pakistan 112\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nTo understand Terminate\nand Stay Resident (TSR) 0\nIVT\nprograms the DOS memory\nformation and allocation\nBIOS Data Area, DOS Data\nprocedure must be\nArea, IO.SYS, MSDOS.SYS,\nunderstood. At physical\nDevice Drivers\naddress zero is the interrupt\nvector table. Then are the\nCOMMAND.COM\nBIOS data area, DOS data\narea, IO.SYS, MSDOS.SYS and\nother device drivers. In the end\nTransient Program Area (TPA)\nthere is COMMAND.COM\ncommand interpreter. The\nremaining space is called the\ntransient program area as\nprograms are loaded and\nexecuted in this area and the\nspace reclaimed on their exit.\nA freemem pointer in DOS\npoints where the free memory\n640K\nbegins. When DOS loads a\nprogram the freemem pointer is moved to the end of memory, all the\navailable space is allocated to it, and when it exits the freemem pointer\ncomes back to its original place thereby reclaiming all space. This action is\ninitiated by the DOS service 4C.\nThe second method to legally terminate a program and give control back to\nDOS is using the service 31. Control is still taken back but the memory\nreleasing part is modified. A portion of the allocated memory can be retained.\nSo the difference in the two methods is that the freemem pointer goes back to\nthe original place or a designated number of bytes ahead of that old position.\nRemember that our program crashed because the interrupt routine was\noverwritten. If we can tell DOS not to reclaim the memory of the interrupt\nroutine, then it will not crash. In the last program we have told DOS to make\na number of bytes resident. It becomes a part of the operation system, an\nextension to it. Just like DOSKEY\u00a7 is an extension to the operation system.\nThe number of paragraphs to reserve is given in the DX register. Paragraph\nis a unit just like byte, word, and double word. A paragraph is 16 bytes.\nTherefore we can reserve in multiple of 16 bytes. We write TSRs in such a\nway that the initialization code and data is located at the end as it is not\nnecessary to make it resident and therefore to save space.\nTo calculate the number of paragraphs a label is placed after the last line\nthat is to be made resident. The value of that label is the number of bytes\nneeded to be made resident. A simple division by 16 will not give the correct\nnumber of paras as we want our answer to be rounded up and not down. For\nexample 100 bytes should need 7 pages but division gives 6 and a remainder\nof 4. A standard technique to get rounded up integer division is to add\ndivisor-1 to the dividend and then divide. So we add 15 to the number of\nbytes and then divide by 16. We use shifting for division as the divisor is a\npower of 2. We use a form of SHR that places the count in the CL register so\nthat we can shift by 4 in just two instructions instead of 4 if we shift one by\none.\nIn our program anything after start label is not needed after the program\nhas become a TSR. We can observe that our program has become a part of\nDOS by giving the following command.\nmem /c\n\u00a7 DOSKEY is a TSR that shows the previous commands on the command\nprompt with up and down arrows and allows editing of the command\nVirtual University of Pakistan 113\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nThis command displays all currently loaded drivers and the current state\nof memory. We will be able to see our program in the list of DOS drivers.\n9.4. PROGRAMMABLE INTERVAL TIMER\nAnother very important peripheral device is the Programmable Interval\nTimer (PIT), the chip numbered 8254. This chip has a precise input\nfrequency of 1.19318 MHz. This frequency is fixed regardless of the processor\nclock. Inside the chip is a 16bit divisor which divides this input frequency\nand the output is connected to the IRQ 0 line of the PIC. The special number\n0 if placed in the divisor means a divisor of 65536 and not 0. The standard\ndivisor is 0 unless we change it. Therefore by default IRQ 0 is generated\n1193180/65536=18.2 times per second. This is called the timer tick. There is\nan interval of about 55ms between two timer ticks. The system time is\nmaintained with the timer interrupt. This is the highest priority interrupt\nand breaks whatever is executing. Time can be maintained with this\ninterrupt as this frequency is very precise and is part of the IBM standard.\nWhen writing a TSR we give control back to DOS so TSR activation,\nreactivation and action is solely interrupt based, whether this is a hardware\ninterrupt or a software one. Control is never given back; it must be caught,\njust like we caught control by hooking the keyboard interrupt. Our next\nexample will hook the timer interrupt and display a tick count on the screen.\nExample 9.7\n001 ; display a tick count on the top right of screen\n002 [org 0x0100]\n003 jmp start\n004\n005 tickcount: dw 0\n006\n007 ; subroutine to print a number at top left of screen\n008 ; takes the number to be printed as its parameter\n009 printnum: push bp\n010 mov bp, sp\n011 push es\n012 push ax\n013 push bx\n014 push cx\n015 push dx\n016 push di\n017\n018 mov ax, 0xb800\n019 mov es, ax ; point es to video base\n020 mov ax, [bp+4] ; load number in ax\n021 mov bx, 10 ; use base 10 for division\n022 mov cx, 0 ; initialize count of digits\n023\n024 nextdigit: mov dx, 0 ; zero upper half of dividend\n025 div bx ; divide by 10\n026 add dl, 0x30 ; convert digit into ascii value\n027 push dx ; save ascii value on stack\n028 inc cx ; increment count of values\n029 cmp ax, 0 ; is the quotient zero\n030 jnz nextdigit ; if no divide it again\n031\n032 mov di, 140 ; point di to 70th column\n033\n034 nextpos: pop dx ; remove a digit from the stack\n035 mov dh, 0x07 ; use normal attribute\n036 mov [es:di], dx ; print char on screen\n037 add di, 2 ; move to next screen location\n038 loop nextpos ; repeat for all digits on stack\n039\n040 pop di\n041 pop dx\n042 pop cx\n043 pop bx\n044 pop ax\nVirtual University of Pakistan 114\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n045 pop es\n046 pop bp\n047 ret 2\n048\n049 ; timer interrupt service routine\n050 timer: push ax\n051\n052 inc word [cs:tickcount]; increment tick count\n053 push word [cs:tickcount]\n054 call printnum ; print tick count\n055\n056 mov al, 0x20\n057 out 0x20, al ; end of interrupt\n058\n059 pop ax\n060 iret ; return from interrupt\n061\n062 start: xor ax, ax\n063 mov es, ax ; point es to IVT base\n064 cli ; disable interrupts\n065 mov word [es:8*4], timer; store offset at n*4\n066 mov [es:8*4+2], cs ; store segment at n*4+2\n067 sti ; enable interrupts\n068\n069 mov dx, start ; end of resident portion\n070 add dx, 15 ; round up to next para\n071 mov cl, 4\n072 shr dx, cl ; number of paras\n073 mov ax, 0x3100 ; terminate and stay resident\n074 int 0x21\nWhen we execute the program the counter starts on the screen. Whatever\nwe do, take directory, open EDIT, the debugger etc. the counter remains\nrunning on the screen. No one is giving control to the program; the program\nis getting executed as a result of timer generating INT 8 after every 55ms.\nOur next example will hook both the keyboard and timer interrupts. When\nthe shift key is pressed the tick count starts incrementing and as soon as the\nshift key is released the tick count stops. Both interrupt handlers are\ncommunicating through a common variable. The keyboard interrupt sets this\nvariable while the timer interrupts modifies its behavior according to this\nvariable.\nExample 9.8\n001 ; display a tick count while the left shift key is down\n002 [org 0x0100]\n003 jmp start\n004\n005 seconds: dw 0\n006 timerflag: dw 0\n007 oldkb: dd 0\n008\n009-049 ;;;;; COPY LINES 007-047 FROM EXAMPLE 9.7 (printnum) ;;;;;\n050\n051 ; keyboard interrupt service routine\n052 kbisr: push ax\n053\n054 in al, 0x60 ; read char from keyboard port\n055 cmp al, 0x2a ; has the left shift pressed\n056 jne nextcmp ; no, try next comparison\n057\n058 cmp word [cs:timerflag], 1; is the flag already set\n059 je exit ; yes, leave the ISR\n060\n061 mov word [cs:timerflag], 1; set flag to start printing\n062 jmp exit ; leave the ISR\n063\n064 nextcmp: cmp al, 0xaa ; has the left shift released\n065 jne nomatch ; no, chain to old ISR\n066\n067 mov word [cs:timerflag], 0; reset flag to stop printing\nVirtual University of Pakistan 115\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n068 jmp exit ; leave the interrupt routine\n069\n070 nomatch: pop ax\n071 jmp far [cs:oldkb] ; call original ISR\n072\n073 exit: mov al, 0x20\n074 out 0x20, al ; send EOI to PIC\n075\n076 pop ax\n077 iret ; return from interrupt\n078\n079 ; timer interrupt service routine\n080 timer: push ax\n081\n082 cmp word [cs:timerflag], 1 ; is the printing flag set\n083 jne skipall ; no, leave the ISR\n084\n085 inc word [cs:seconds] ; increment tick count\n086 push word [cs:seconds]\n087 call printnum ; print tick count\n088\n089 skipall: mov al, 0x20\n090 out 0x20, al ; send EOI to PIC\n091\n092 pop ax\n093 iret ; return from interrupt\n094\n095 start: xor ax, ax\n096 mov es, ax ; point es to IVT base\n097 mov ax, [es:9*4]\n098 mov [oldkb], ax ; save offset of old routine\n099 mov ax, [es:9*4+2]\n100 mov [oldkb+2], ax ; save segment of old routine\n101 cli ; disable interrupts\n102 mov word [es:9*4], kbisr ; store offset at n*4\n103 mov [es:9*4+2], cs ; store segment at n*4+2\n104 mov word [es:8*4], timer ; store offset at n*4\n105 mov [es:8*4+2], cs ; store segment at n*4+\n106 sti ; enable interrupts\n107\n108 mov dx, start ; end of resident portion\n109 add dx, 15 ; round up to next para\n110 mov cl, 4\n111 shr dx, cl ; number of paras\n112 mov ax, 0x3100 ; terminate and stay resident\n113 int 0x21\n006 This flag is one when the timer interrupt should increment and zero\nwhen it should not.\n058-059 As the keyboard controller repeatedly generates the press code if the\nrelease code does not come in a specified time, we have placed a\ncheck to not repeatedly set it to one.\n058 Another way to access TSR data is using the CS override instead of\ninitializing DS. It is common mistake not to initialize DS and also\nnot put in CS override in a real time interrupt handler.\nWhen we execute the program and the shift key is pressed, the counter\nstarts incrementing. When the key is released the counter stops. When it is\npressed again the counter resumes counting. As this is made as a TSR any\nother program can be loaded and will work properly alongside the TSR.\n9.5. PARALLEL PORT\nComputers can control external hardware through various external ports\nlike the parallel port, the serial port, and the new additions USB and\nFireWire. Using this, computers can be used to control almost anything. For\nour examples we will use the parallel port. The parallel port has two views,\nthe connector that the external world sees and the parallel port controller\nVirtual University of Pakistan 116\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nports through which the processor communicates with the device connected\nto the parallel port.\nThe parallel port connector is a 25pin connector called DB-25. Different\npins of this connector have different meanings. Some are meaningful only\nwith the printer**. This is a bidirectional port so there are some pins to take\ndata from the processor to the parallel port and others to take data from the\nparallel port to the processor. Important pins for our use are the data pins\nfrom pin 2 to pin 9 that take data from the processor to the device. Pin 10,\nthe ACK pin, is normally used by the printer to acknowledge the receipt of\ndata and show the willingness to receive more data. Signaling this pin\ngenerates IRQ 7 if enabled in the PIC and in the parallel port controller. Pin\n18-25 are ground and must be connected to the external circuit ground to\nprovide the common reference point otherwise they won\u2019t understand each\nother voltage levels. Like the datum point in a graph this is the datum point\nof an electrical circuit. The remaining pins are not of our concern in these\nexamples.\nThis is the external view of the parallel port. The processor cannot see\nthese pins. The processor uses the I/O ports of the parallel port controller.\nThe first parallel port LPT1\u2020\u2020 has ports designated from 378 to 37A. The first\nport 378 is the data port. If we use the OUT instruction on this port, 1 bits\nresult in a 5V signal on the corresponding pin and a 0 bits result in a 0V\nsignal on the corresponding pin.\nPort 37A is the control port. Our interest is with bit 4 of this port which\nenables the IRQ 7 triggering by the ACK pin. We have attached a circuit that\nconnects 8 LEDs with the parallel port pins. The following examples sends\nthe scancode of the key pressed to the parallel port so that it is visible on\nLEDs.\nExample 9.9\n001 ; show scancode on external LEDs connected through parallel port\n002 [org 0x0100]\n003 jmp start\n004\n005 oldisr: dd 0 ; space for saving old ISR\n006\n007 ; keyboard interrupt service routine\n008 kbisr: push ax\n009 push dx\n010\n011 in al, 0x60 ; read char from keyboard port\n012 mov dx, 0x378\n013 out dx, al ; write char to parallel port\n014\n015 pop ax\n016 pop dx\n017 jmp far [cs:oldisr] ; call original ISR\n018\n019 start: xor ax, ax\n020 mov es, ax ; point es to IVT base\n021 mov ax, [es:9*4]\n022 mov [oldisr], ax ; save offset of old routine\n023 mov ax, [es:9*4+2]\n024 mov [oldisr+2], ax ; save segment of old routine\n025 cli ; disable interrupts\n026 mov word [es:9*4], kbisr ; store offset at n*4\n027 mov [es:9*4+2], cs ; store segment at n*4+2\n028 sti ; enable interrupts\n029\n030 mov dx, start ; end of resident portion\n031 add dx, 15 ; round up to next para\n** The parallel port is most commonly used with the printer. However some\nnew printers have started using the USB port.\n\u2020\u2020 Older computer had more than one parallel port named LPT2 and having\nports from 278-27A.\nVirtual University of Pakistan 117\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n032 mov cl, 4\n033 shr dx, cl ; number of paras\n034 mov ax, 0x3100 ; terminate and stay resident\n035 int 0x21\nThe following example uses the same LED circuit and sends data such that\nLEDs switch on and off turn by turn so that it looks like light is moving back\nand forth.\nExample 9.10\n001 ; show lights moving back and forth on external LEDs\n002 [org 0x0100]\n003 jmp start\n004\n005 signal: db 1 ; current state of lights\n006 direction: db 0 ; current direction of motion\n007\n008 ; timer interrupt service routine\n009 timer: push ax\n010 push dx\n011 push ds\n012\n013 push cs\n014 pop ds ; initialize ds to data segment\n015\n016 cmp byte [direction], 1; are moving in right direction\n017 je moveright ; yes, go to shift right code\n018\n019 shl byte [signal], 1 ; shift left state of lights\n020 jnc output ; no jump to change direction\n021\n022 mov byte [direction], 1; change direction to right\n023 mov byte [signal], 0x80; turn on left most light\n024 jmp output ; proceed to send signal\n025\n026 moveright: shr byte [signal], 1 ; shift right state of lights\n027 jnc output ; no jump to change direction\n028\n029 mov byte [direction], 0; change direction to left\n030 mov byte [signal], 1 ; turn on right most light\n031\n032 output: mov al, [signal] ; load lights state in al\n033 mov dx, 0x378 ; parallel port data port\n034 out dx, al ; send light state of port\n035\n036 mov al, 0x20\n037 out 0x20, al ; send EOI on PIC\n038\n039 pop ds\n040 pop dx\n041 pop ax\n042 iret ; return from interrupt\n043\n044 start: xor ax, ax\n045 mov es, ax ; point es to IVT base\n046 cli ; disable interrupts\n047 mov word [es:8*4], timer ; store offset at n*4\n048 mov [es:8*4+2], cs ; store segment at n*4+2\n049 sti ; enable interrupts\n050\n051 mov dx, start ; end of resident portion\n052 add dx, 15 ; round up to next para\n053 mov cl, 4\n054 shr dx, cl ; number of paras\n055 mov ax, 0x3100 ; terminate and stay resident\n056 int 0x21\nWe will now use the parallel port to control a slightly complicated circuit.\nThis time we will also use the parallel port interrupt. We are using a 220 V\nbulb with AC input. AC current is 50Hz sine wave. We have made our circuit\nsuch that it triggers the parallel port interrupt whenever the since wave\nVirtual University of Pakistan 118\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\ncrosses zero. We have control of passing the AC current to the bulb. We\ncontrol it such that in every cycle only a fixed percentage of time the current\npasses on to the bulb. Using this we can control the intensity or glow of the\nbulb.\nOur first example will slowly turn on the bulb by increasing the power\nprovided using the mechanism just described.\nExample 9.11\n001 ; slowly turn on a bulb by gradually increasing the power provided\n002 [org 0x0100]\n003 jmp start\n004\n005 flag: db 0 ; next time turn on or turn off\n006 stop: db 0 ; flag to terminate the program\n007 divider: dw 11000 ; divider for minimum intensity\n008 oldtimer: dd 0 ; space for saving old isr\n009\n010 ; timer interrupt service routine\n011 timer: push ax\n012 push dx\n013\n014 cmp byte [cs:flag], 0 ; are we here to turn off\n015 je switchoff ; yes, go to turn off code\n016\n017 switchon: mov al, 1\n018 mov dx, 0x378\n019 out dx, al ; no, turn the bulb on\n020\n021 mov ax, 0x0100\n022 out 0x40, al ; set timer divisor LSB to 0\n023 mov al, ah\n024 out 0x40, al ; set timer divisor MSB to 1\n025 mov byte [cs:flag], 0 ; flag next timer to switch off\n026 jmp exit ; leave the interrupt routine\n027\n028 switchoff: xor ax, ax\n029 mov dx, 0x378\n030 out dx, al ; turn the bulb off\n031\n032 exit: mov al, 0x20\n033 out 0x20, al ; send EOI to PIC\n034\n035 pop dx\n036 pop ax\n037 iret ; return from interrupt\n038\n039 ; parallel port interrupt service routine\n040 parallel: push ax\n041\n042 mov al, 0x30 ; set timer to one shot mode\n043 out 0x43, al\n044\n045 cmp word [cs:divider], 100; is the current divisor 100\n046 je stopit ; yes, stop\n047\n048 sub word [cs:divider], 10; decrease the divisor by 10\n049 mov ax, [cs:divider]\n050 out 0x40, al ; load divisor LSB in timer\n051 mov al, ah\n052 out 0x40, al ; load divisor MSB in timer\n053 mov byte [cs:flag], 1 ; flag next timer to switch on\n054\n055 mov al, 0x20\n056 out 0x20, al ; send EOI to PIC\n057 pop ax\n058 iret ; return from interrupt\n059\n060 stopit: mov byte [stop], 1 ; flag to terminate the program\n061 mov al, 0x20\n062 out 0x20, al ; send EOI to PIC\n063 pop ax\n064 iret ; return from interrupt\n065\nVirtual University of Pakistan 119\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n066 start: xor ax, ax\n067 mov es, ax ; point es to IVT base\n068 mov ax, [es:0x08*4]\n069 mov [oldtimer], ax ; save offset of old routine\n070 mov ax, [es:0x08*4+2]\n071 mov [oldtimer+2], ax ; save segment of old routine\n072 cli ; disable interrupts\n073 mov word [es:0x08*4], timer ; store offset at n*4\n074 mov [es:0x08*4+2], cs ; store segment at n*4+2\n075 mov word [es:0x0F*4], parallel ; store offset at n*4\n076 mov [es:0x0F*4+2], cs ; store segment at n*4+2\n077 sti ; enable interrupts\n078\n079 mov dx, 0x37A\n080 in al, dx ; parallel port control register\n081 or al, 0x10 ; turn interrupt enable bit on\n082 out dx, al ; write back register\n083\n084 in al, 0x21 ; read interrupt mask register\n085 and al, 0x7F ; enable IRQ7 for parallel port\n086 out 0x21, al ; write back register\n087\n088 recheck: cmp byte [stop], 1 ; is the termination flag set\n089 jne recheck ; no, check again\n090\n091 mov dx, 0x37A\n092 in al, dx ; parallel port control register\n093 and al, 0xEF ; turn interrupt enable bit off\n094 out dx, al ; write back register\n095\n096 in al, 0x21 ; read interrupt mask register\n097 or al, 0x80 ; disable IRQ7 for parallel port\n098 out 0x21, al ; write back regsiter\n099\n100 cli ; disable interrupts\n101 mov ax, [oldtimer] ; read old timer ISR offset\n102 mov [es:0x08*4], ax ; restore old timer ISR offset\n103 mov ax, [oldtimer+2] ; read old timer ISR segment\n104 mov [es:0x08*4+2], ax ; restore old timer ISR segment\n105 sti ; enable interrupts\n106\n107 mov ax, 0x4c00 ; terminate program\n108 int 0x21\nThe next example is simply the opposite of the previous. It slowly turns the\nbulb off from maximum glow to no glow.\nExample 9.12\n001 ; slowly turn off a bulb by gradually decreasing the power provided\n002 [org 0x0100]\n003 jmp start\n004\n005 flag: db 0 ; next time turn on or turn off\n006 stop: db 0 ; flag to terminate the program\n007 divider: dw 0 ; divider for maximum intensity\n008 oldtimer: dd 0 ; space for saving old isr\n009\n010-037 ;;;;; COPY LINES 009-036 FROM EXAMPLE 9.11 (timer) ;;;;;\n038\n039 ; parallel port interrupt service routine\n040 parallel: push ax\n041\n042 mov al, 0x30 ; set timer to one shot mode\n043 out 0x43, al\n044\n045 cmp word [cs:divider], 11000; current divisor is 11000\n046 je stopit ; yes, stop\n047\n048 add word [cs:divider], 10; increase the divisor by 10\n049 mov ax, [cs:divider]\n050 out 0x40, al ; load divisor LSB in timer\n051 mov al, ah\n052 out 0x40, al ; load divisor MSB in timer\nVirtual University of Pakistan 120\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n053 mov byte [cs:flag], 1 ; flag next timer to switch on\n054\n055 mov al, 0x20\n056 out 0x20, al ; send EOI to PIC\n057 pop ax\n058 iret ; return from interrupt\n059\n060 stopit: mov byte [stop], 1 ; flag to terminate the program\n061 mov al, 0x20\n062 out 0x20, al ; send EOI to PIC\n063 pop ax\n064 iret ; return from interrupt\n065\n066 start: xor ax, ax\n067 mov es, ax ; point es to IVT base\n068 mov ax, [es:0x08*4]\n069 mov [oldtimer], ax ; save offset of old routine\n070 mov ax, [es:0x08*4+2]\n071 mov [oldtimer+2], ax ; save segment of old routine\n072 cli ; disable interrupts\n073 mov word [es:0x08*4], timer ; store offset at n*4\n074 mov [es:0x08*4+2], cs ; store segment at n*4+2\n075 mov word [es:0x0F*4], parallel ; store offset at n*4\n076 mov [es:0x0F*4+2], cs ; store segment at n*4+2\n077 sti ; enable interrupts\n078\n079 mov dx, 0x37A\n080 in al, dx ; parallel port control register\n081 or al, 0x10 ; turn interrupt enable bit on\n082 out dx, al ; write back register\n083\n084 in al, 0x21 ; read interrupt mask register\n085 and al, 0x7F ; enable IRQ7 for parallel port\n086 out 0x21, al ; write back register\n087\n088 recheck: cmp byte [stop], 1 ; is the termination flag set\n089 jne recheck ; no, check again\n090\n091 mov dx, 0x37A\n092 in al, dx ; parallel port control register\n093 and al, 0xEF ; turn interrupt enable bit off\n094 out dx, al ; write back register\n095\n096 in al, 0x21 ; read interrupt mask register\n097 or al, 0x80 ; disable IRQ7 for parallel port\n098 out 0x21, al ; write back regsiter\n099\n100 cli ; disable interrupts\n101 mov ax, [oldtimer] ; read old timer ISR offset\n102 mov [es:0x08*4], ax ; restore old timer ISR offset\n103 mov ax, [oldtimer+2] ; read old timer ISR segment\n104 mov [es:0x08*4+2], ax ; restore old timer ISR segment\n105 sti ; enable interrupts\n106\n107 mov ax, 0x4c00 ; terminate program\n108 int 0x21\nThis example is a mix of the previous two. Here we can increase the bulb\nintensity with F11 and decrease it with F12.\nExample 9.13\n001 ; control external bulb intensity with F11 and F12\n002 [org 0x0100]\n003 jmp start\n004\n005 flag: db 0 ; next time turn on or turn off\n006 divider: dw 100 ; initial timer divider\n007 oldkb: dd 0 ; space for saving old ISR\n008\n009-036 ;;;;; COPY LINES 009-036 FROM EXAMPLE 9.11 (timer) ;;;;;\n037\n038 ; keyboard interrupt service routine\n039 kbisr: push ax\nVirtual University of Pakistan 121\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n040\n041 in al, 0x60\n042 cmp al, 0x57\n043 jne nextcmp\n044 cmp word [cs:divider], 11000\n045 je exitkb\n046 add word [cs:divider], 100\n047 jmp exitkb\n048\n049 nextcmp: cmp al, 0x58\n050 jne chain\n051 cmp word [cs:divider], 100\n052 je exitkb\n053 sub word [cs:divider], 100\n054 jmp exitkb\n055\n056 exitkb: mov al, 0x20\n057 out 0x20, al\n058\n059 pop ax\n060 iret\n061\n062 chain: pop ax\n063 jmp far [cs:oldkb]\n064\n065 ; parallel port interrupt service routine\n066 parallel: push ax\n067\n068 mov al, 0x30 ; set timer to one shot mode\n069 out 0x43, al\n070\n071 mov ax, [cs:divider]\n072 out 0x40, al ; load divisor LSB in timer\n073 mov al, ah\n074 out 0x40, al ; load divisor MSB in timer\n075 mov byte [cs:flag], 1 ; flag next timer to switch on\n076\n077 mov al, 0x20\n078 out 0x20, al ; send EOI to PIC\n079 pop ax\n080 iret ; return from interrupt\n081\n082 start: xor ax, ax\n083 mov es, ax ; point es to IVT base\n084 mov ax, [es:0x09*4]\n085 mov [oldkb], ax ; save offset of old routine\n086 mov ax, [es:0x09*4+2]\n087 mov [oldkb+2], ax ; save segment of old routine\n088 cli ; disable interrupts\n089 mov word [es:0x08*4], timer ; store offset at n*4\n090 mov [es:0x08*4+2], cs ; store segment at n*4+2\n091 mov word [es:0x09*4], kbisr ; store offset at n*4\n092 mov [es:0x09*4+2], cs ; store segment at n*4+2\n093 mov word [es:0x0F*4], parallel ; store offset at n*4\n094 mov [es:0x0F*4+2], cs ; store segment at n*4+2\n095 sti ; enable interrupts\n096\n097 mov dx, 0x37A\n098 in al, dx ; parallel port control register\n099 or al, 0x10 ; turn interrupt enable bit on\n100 out dx, al ; write back register\n101\n102 in al, 0x21 ; read interrupt mask register\n103 and al, 0x7F ; enable IRQ7 for parallel port\n104 out 0x21, al ; write back register\n105\n106 mov dx, start ; end of resident portion\n107 add dx, 15 ; round up to next para\n108 mov cl, 4\n109 shr dx, cl ; number of paras\n110 mov ax, 0x3100 ; terminate and stay resident\n111 int 0x21\nVirtual University of Pakistan 122\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nEXERCISES\n1. Suggest a reason for the following. The statements are all true.\na. We should disable interrupts while hooking interrupt 8h. I.e.\nwhile placing its segment and offset in the interrupt vector\ntable.\nb. We need not do this for interrupt 80h.\nc. We need not do this when hooking interrupt 8h from inside\nthe interrupt handler of interrupt 80h.\nd. We should disable interrupts while we are changing the stack\n(SS and SP).\ne. EOI is not sent from an interrupt handler which does\ninterrupt chaining.\nf. If no EOI is sent from interrupt 9h and no chaining is done,\ninterrupt 8h still comes if the interrupt flag is on.\ng. After getting the size in bytes by putting a label at the end of a\nCOM TSR, 0fh is added before dividing by 10h.\nh. Interrupts are disabled but divide by zero interrupt still\ncomes.\n2. If no hardware interrupts are coming, what are all possible reasons?\n3. Write a program to make an asterisks travel the border of the screen,\nfrom upper left to upper right to lower right to lower left and back to\nupper left indefinitely, making each movement after one second.\n4. [Musical Arrow] Write a TSR to make an arrow travel the border of the\nscreen from top left to top right to bottom right to bottom left and\nback to top left at the speed of 36.4 locations per second. The arrow\nshould not destroy the data beneath it and should be restored as\nsoon as the arrow moves forward.\nThe arrow head should point in the direction of movement using the\ncharacters > V < and ^. The journey should be accompanied by a\ndifferent tone from the pc speaker for each side of the screen. Do\ninterrupt chaining so that running the TSR 10 times produces 10\narrows traveling at different locations.\nHINT: At the start you will need to reprogram channel 0 for 36.4\ninterrupts per second, double the normal. You will have to reprogram\nchannel 2 at every direction change, though you can enable the\nspeaker once at the very start.\n5. In the above TSR hook the keyboard interrupt as well and check if 'q'\nis pressed. If not chain to the old interrupt, if yes restore everything\nand remove the TSR from memory. The effect should be that pressing\n'q' removes one moving arrow. If you do interrupt chaining when\npressing 'q' as well, it will remove all arrows at once.\n6. Write a TSR to rotate the screen (scroll up and copy the old top most\nline to the bottom) while F10 is pressed. The screen will keep rotating\nwhile F10 is pressed at 18.2 rows per second. As soon as F10 is\nreleased the rotation should stop and the original screen restored. A\nsecondary buffer of only 160 bytes (one line of screen) can be used.\n7. Write a TSR that hooks software interrupt 0x80 and the timer\ninterrupt. The software interrupt is called by other programs with the\naddress of a far function in ES:DI and the number of timer ticks after\nwhich to call back that function in CX. The interrupt records this\ninformation and returns to the caller. The function will actually be\ncalled by the timer interrupt after the desired number of ticks. The\nmaximum number of functions and their ticks can be fixed to 8.\n8. Write a TSR to clear the screen when CTRL key is pressed and restore it\nwhen it is released.\n9. Write a TSR to disable all writes to the hard disk when F10 is pressed and re-\nenable when pressed again like a toggle.\nVirtual University of Pakistan 123\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nHINT: To write to the hard disk programs call the BIOS service INT 0x13 with\nAH=3.\n10. Write a keyboard interrupt handler that disables the timer interrupt\n(no timer interrupt should come) while Q is pressed. It should be re-\nenabled as soon as Q is released.\n11. Write a TSR to calculate the current typing speed of the user. Current\ntyping speed is the number of characters typed by the user in the last\nfive seconds. The speed should be represented by printing asterisks\nat the right border (80th column) of the screen starting from the\nupper right to the lower right corner (growing downwards). Draw n\nasterisks if the user typed n characters in the last five seconds. The\ncount should be updated every second.\n12. Write a TSR to show a clock in the upper right corner of the screen in\nthe format HH:MM:SS.DD where HH is hours in 24 hour format, MM\nis minutes, SS is seconds and DD is hundredth of second. The clock\nshould beep twice for one second each time with half a second\ninterval in between at the start of every minute at a frequency of your\nchoice.\nHINT: IBM PC uses a Real Time Clock (RTC) chip to keep track of time\nwhile switched off. It provides clock and calendar functions through\nits two I/O ports 70h and 71h. It is used as follows:\nmov al, <command>\nout 0x70, al ; command byte written at first port\njmp D1 ; waste one instruction time\nD1: in al, 0x71 ; result of command is in AL now\nFollowing are few commands\n00 Get current second\n02 Get current minute\n04 Get current hour\nAll numbers returned by RTC are in BCD. E.g. if it is 6:30 the second\nand third command will return 0x30 and 0x06 respectively in al.\nVirtual University of Pakistan 124\n10\nDebug Interrupts\n10.1. DEBUGGER USING SINGLE STEP INTERRUPT\nThe use of the trap flag has been deferred till now. The three flags not used\nfor mathematical operations are the direction flag, the interrupt flag and the\ntrap flag. The direction and interrupt flags have been previously discussed.\nIf the the trap flag is set, the after every instruction a type 1 interrupt will\nbe automatically generated. When the IVT and reserved interrupts were\ndiscussed this was named as the single step interrupt. This is like the divide\nby zero interrupt which was never explicitly invoked but it came itself. The\nsingle step interrupt behaves in the same manner.\nThe debugger is made using this interrupt. It allows one instruction to be\nexecuted and then return control to us. It has its display code and its code to\nwait for the key in the INT 1 handler. Therefore after every instruction the\nvalues of all registers are shown and the debugger waits for a key. Another\ninterrupt used by the debugger is the break point interrupt INT 3. Apart from\nsingle stepping debugger has the breakpoint feature. INT 3 is used for this\nfeature. INT 3 has a single byte opcode so it can replace any instruction. To\nput a breakpoint the instruction is replaced with INT 3 opcode and restored\nin the INT 3 handler. The INT 3 opcode is placed again by a single step\ninterrupt that is set up for this purpose after the replaced instruction has\nbeen executed.\nThere is no instruction to set or clear the trap flag like there are\ninstructions for the interrupt and direction flags. We use two special\ninstructions PUSHF and POPF to push and pop the flag from the stack. We\nuse PUSHF to place flags on the stack, change TF in this image on the stack\nand then reload into the flags register with POPF. The single step interrupt\nwill come after the first instruction after POPF. The interrupt mechanism\nautomatically clears IF and TF otherwise there would an infinite recursion of\nthe single step interrupt. The TF is set in the flags on the stack so another\ninterrupt will comes after one more instruction is executed after the return of\nthe interrupt.\nThe following example is a very elementary debugger using the trap flag\nand the single step interrupt.\nExample 10.1\n001 ; single stepping using the trap flag and single step interrupt\n002 [org 0x0100]\n003 jmp start\n004\n005 flag: db 0 ; flag whether a key pressed\n006 oldisr: dd 0 ; space for saving old ISR\n007 names: db 'FL =CS =IP =BP =AX =BX =CX =DX =SI =DI =DS =ES ='\n008\n009-026 ;;;;; COPY LINES 008-025 FROM EXAMPLE 6.2 (clrscr) ;;;;;\n027\n028 ; subroutine to print a number on screen\n029 ; takes the row no, column no, and number to be printed as parameters\n030 printnum: push bp\n031 mov bp, sp\n032 push es\n033 push ax\n034 push bx\n035 push cx\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n036 push dx\n037 push di\n038\n039 mov di, 80 ; load di with columns per row\n040 mov ax, [bp+8] ; load ax with row number\n041 mul di ; multiply with columns per row\n042 mov di, ax ; save result in di\n043 add di, [bp+6] ; add column number\n044 shl di, 1 ; turn into byte count\n045 add di, 8 ; to end of number location\n046\n047 mov ax, 0xb800\n048 mov es, ax ; point es to video base\n049 mov ax, [bp+4] ; load number in ax\n050 mov bx, 16 ; use base 16 for division\n051 mov cx, 4 ; initialize count of digits\n052\n053 nextdigit: mov dx, 0 ; zero upper half of dividend\n054 div bx ; divide by 10\n055 add dl, 0x30 ; convert digit into ascii value\n056 cmp dl, 0x39 ; is the digit an alphabet\n057 jbe skipalpha ; no, skip addition\n058 add dl, 7 ; yes, make in alphabet code\n059 skipalpha: mov dh, 0x07 ; attach normal attribute\n060 mov [es:di], dx ; print char on screen\n061 sub di, 2 ; to previous screen location\n062 loop nextdigit ; if no divide it again\n063\n064 pop di\n065 pop dx\n066 pop cx\n067 pop bx\n068 pop ax\n069 pop es\n070 pop bp\n071 ret 6\n072\n073 ; subroutine to print a string\n074 ; takes row no, column no, address of string, and its length\n075 ; as parameters\n076 printstr: push bp\n077 mov bp, sp\n078 push es\n079 push ax\n080 push bx\n081 push cx\n082 push dx\n083 push si\n084 push di\n085\n086 mov ax, 0xb800\n087 mov es, ax ; point es to video base\n088\n089 mov di, 80 ; load di with columns per row\n090 mov ax, [bp+10] ; load ax with row number\n091 mul di ; multiply with columns per row\n092 mov di, ax ; save result in di\n093 add di, [bp+8] ; add column number\n094 shl di, 1 ; turn into byte count\n095\n096 mov si, [bp+6] ; string to be printed\n097 mov cx, [bp+4] ; length of string\n098 mov ah, 0x07 ; normal attribute is fixed\n099\n100 nextchar: mov al, [si] ; load next char of string\n101 mov [es:di], ax ; show next char on screen\n102 add di, 2 ; move to next screen location\n103 add si, 1 ; move to next char\n104 loop nextchar ; repeat the operation cx times\n105\n106 pop di\n107 pop si\n108 pop dx\n109 pop cx\n110 pop bx\n111 pop ax\nVirtual University of Pakistan 126\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n112 pop es\n113 pop bp\n114 ret 8\n115\n116 ; keyboard interrupt service routine\n117 kbisr: push ax\n118\n119 in al, 0x60 ; read a char from keyboard port\n120 test al, 0x80 ; is it a press code\n121 jnz skipflag ; no, leave the interrupt\n123 add byte [cs:flag], al ; yes, set flag to proceed\n124\n125 skipflag: mov al, 0x20\n126 out 0x20, al\n127 pop ax\n128 iret\n129\n130 ; single step interrupt service routine\n131 trapisr: push bp\n132 mov bp, sp ; to read cs, ip and flags\n133 push ax\n134 push bx\n135 push cx\n136 push dx\n137 push si\n138 push di\n139 push ds\n140 push es\n141\n142 sti ; waiting for keyboard interrupt\n143 push cs\n144 pop ds ; initialize ds to data segment\n145\n146 mov byte [flag], 0 ; set flag to wait for key\n147 call clrscr ; clear the screen\n148\n149 mov si, 6 ; first register is at bp+6\n150 mov cx, 12 ; total 12 registers to print\n151 mov ax, 0 ; start from row 0\n152 mov bx, 5 ; print at column 5\n153\n154 l3: push ax ; row number\n155 push bx ; column number\n156 mov dx, [bp+si]\n157 push dx ; number to be printed\n158 call printnum ; print the number\n159 sub si, 2 ; point to next register\n160 inc ax ; next row number\n161 loop l3 ; repeat for the 12 registers\n162\n163 mov ax, 0 ; start from row 0\n164 mov bx, 0 ; start from column 0\n165 mov cx, 12 ; total 12 register names\n166 mov si, 4 ; each name length is 4 chars\n167 mov dx, names ; offset of first name in dx\n168\n169 l1: push ax ; row number\n170 push bx ; column number\n171 push dx ; offset of string\n172 push si ; length of string\n173 call printstr ; print the string\n174 add dx, 4 ; point to start of next string\n175 inc ax ; new row number\n176 loop l1 ; repeat for 12 register names\n177\n178 keywait: cmp byte [flag], 0 ; has a key been pressed\n179 je keywait ; no, check again\n180\n181 pop es\n182 pop ds\n183 pop di\n184 pop si\n185 pop dx\n186 pop cx\n187 pop bx\n188 pop ax\nVirtual University of Pakistan 127\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n189 pop bp\n190 iret\n191\n192 start: xor ax, ax\n193 mov es, ax ; point es to IVT base\n194 mov ax, [es:9*4]\n195 mov [oldisr], ax ; save offset of old routine\n196 mov ax, [es:9*4+2]\n197 mov [oldisr+2], ax ; save segment of old routine\n198 mov word [es:1*4], trapisr ; store offset at n*4\n199 mov [es:1*4+2], cs ; store segment at n*4+2\n200 cli ; disable interrupts\n201 mov word [es:9*4], kbisr ; store offset at n*4\n202 mov [es:9*4+2], cs ; store segment at n*4+2\n203 sti ; enable interrupts\n204\n205 pushf ; save flags on stack\n206 pop ax ; copy flags in ax\n207 or ax, 0x100 ; set bit corresponding to TF\n208 push ax ; save ax on stack\n209 popf ; reload into flags register\n210\n211 ; the trap flag bit is on now, INT 1 will come after next instruction\n212 ; sample code to check the working of our elementary debugger\n213 mov ax, 0\n214 mov bx, 0x10\n215 mov cx, 0x20\n216 mov dx, 0x40\n217\n218 l2: inc ax\n219 add bx, 2\n220 dec cx\n221 sub dx, 2\n222 jmp l2\n10.2. DEBUGGER USING BREAKPOINT INTERRUPT\nWe now write a debugger using INT 3. This debugger stops at the same\npoint every time where the breakpoint has been set up unlike the previous\none which stopped at every instruction. The single step interrupt in this\nexample is used only to restore the breakpoint interrupt which was removed\nby the breakpoint interrupt handler temporarily so that the original\ninstruction can be executed.\nExample 10.2\n001 ; elementary debugger using breakpoint interrupt\n002 [org 0x0100]\n003 jmp start\n004\n005 flag: db 0 ; flag whether a key pressed\n006 oldisr: dd 0 ; space for saving old ISR\n007 names: db 'FL =CS =IP =BP =AX =BX =CX =DX =SI =DI =DS =ES ='\n008 opcode: db 0\n009 opcodepos: dw 0\n010\n011-028 ;;;;; COPY LINES 008-025 FROM EXAMPLE 6.2 (clrscr) ;;;;;\n029-072 ;;;;; COPY LINES 028-071 FROM EXAMPLE 10.1 (printnum) ;;;;;\n073-114 ;;;;; COPY LINES 073-114 FROM EXAMPLE 10.1 (printstr) ;;;;;\n115-127 ;;;;; COPY LINES 116-128 FROM EXAMPLE 10.1 (kbisr) ;;;;;\n128\n129 ; single step interrupt service routine\n130 trapisr: push bp\n131 mov bp, sp\n132 push ax\n133 push di\n134 push ds\n135 push es\n136\n137 push cs\n138 pop ds ; initialize ds to data segment\nVirtual University of Pakistan 128\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n139\n140 mov ax, [bp+4]\n141 mov es, ax ; load interrupted segment in es\n142 mov di, [opcodepos] ; load saved opcode position\n143 mov byte [es:di], 0xCC ; reset the opcode to INT3\n144 and word [bp+6], 0xFEFF; clear TF in flags on stack\n145\n146 pop es\n147 pop ds\n148 pop di\n149 pop ax\n150 pop bp\n151 iret\n152\n153 ; breakpoint interrupt service routine\n154 debugisr: push bp\n155 mov bp, sp ; to read cs, ip and flags\n156 push ax\n157 push bx\n158 push cx\n159 push dx\n160 push si\n161 push di\n162 push ds\n163 push es\n164\n165 sti ; waiting for keyboard interrupt\n166 push cs\n167 pop ds ; initialize ds to data segment\n168\n169 mov ax, [bp+4]\n170 mov es, ax ; load interrupted segment in es\n171 dec word [bp+2] ; decrement the return address\n172 mov di, [bp+2] ; read the return address in di\n173 mov word [opcodepos], di ; remember the return position\n174 mov al, [opcode] ; load the original opcode\n175 mov [es:di], al ; restore original opcode there\n176\n177 mov byte [flag], 0 ; set flag to wait for key\n178 call clrscr ; clear the screen\n179\n180 mov si, 6 ; first register is at bp+6\n181 mov cx, 12 ; total 12 registers to print\n182 mov ax, 0 ; start from row 0\n183 mov bx, 5 ; print at column 5\n184\n185 l3: push ax ; row number\n186 push bx ; column number\n187 mov dx, [bp+si]\n188 push dx ; number to be printed\n189 call printnum ; print the number\n190 sub si, 2 ; point to next register\n191 inc ax ; next row number\n192 loop l3 ; repeat for the 12 registers\n193\n194 mov ax, 0 ; start from row 0\n195 mov bx, 0 ; start from column 0\n196 mov cx, 12 ; total 12 register names\n197 mov si, 4 ; each name length is 4 chars\n198 mov dx, names ; offset of first name in dx\n199\n200 l1: push ax ; row number\n201 push bx ; column number\n202 push dx ; offset of string\n203 push si ; length of string\n204 call printstr ; print the string\n205 add dx, 4 ; point to start of next string\n206 inc ax ; new row number\n207 loop l1 ; repeat for 12 register names\n208\n209 or word [bp+6], 0x0100 ; set TF in flags image on stack\n210\n211 keywait: cmp byte [flag], 0 ; has a key been pressed\n212 je keywait ; no, check again\n213\n214 pop es\nVirtual University of Pakistan 129\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n215 pop ds\n216 pop di\n217 pop si\n218 pop dx\n219 pop cx\n220 pop bx\n221 pop ax\n222 pop bp\n223 iret\n224\n225 start: xor ax, ax\n226 mov es, ax ; point es to IVT base\n227 mov word [es:1*4], trapisr ; store offset at n*4\n228 mov [es:1*4+2], cs ; store segment at n*4+2\n229 mov word [es:3*4], debugisr ; store offset at n*4\n230 mov [es:3*4+2], cs ; store segment at n*4+2\n231 cli ; disable interrupts\n232 mov word [es:9*4], kbisr ; store offset at n*4\n233 mov [es:9*4+2], cs ; store segment at n*4+2\n234 sti ; enable interrupts\n235\n236 mov si, l2 ; load breakpoint position in si\n237 mov al, [cs:si] ; read opcode at that position\n238 mov [opcode], al ; save opcode for later use\n239 mov byte [cs:si], 0xCC ; change opcode to INT3\n240\n241 ; breakpoint is set now, INT3 will come at l2 on every iteration\n242 ; sample code to check the working of our elementary debugger\n243 mov ax, 0\n244 mov bx, 0x10\n245 mov cx, 0x20\n246 mov dx, 0x40\n247\n248 l2: inc ax\n249 add bx, 2\n250 dec cx\n251 sub dx, 2\n252 jmp l2\nVirtual University of Pakistan 130\n11\nMultitasking\n11.1. CONCEPTS OF MULTITASKING\nTo experience the power of assembly language we introduce how to\nimplement multitasking. We observed in the debugger that our thread of\ninstructions was broken by the debugger; it got the control, used all\nregisters, displayed an elaborate interface, waited for the key, and then\nrestored processor state to what was immediately before interruption. Our\nprogram resumed as if nothing happened. The program execution was in the\nsame logical flow.\nIf we have two different programs A and B. Program A is broken, its state\nsaved, and returned to B instead of A. By looking at the instruction set, we\ncan immediately say that nothing can stop us from doing that. IRET will\nreturn to whatever CS and IP it finds on the stack. Now B is interrupted\nsomehow, its state saved, and we return back to A. A will have no way of\nknowing that it was interrupted as its entire environment has been restored.\nIt never knew the debugger took control when it was debugged. It sill has no\nway of gaining this knowledge. If this work of breaking and restoring\nprograms is done at high speed the user will feel that all the programs are\nrunning at the same time where actually they are being switched to and forth\nat high speed.\nIn essence multitasking is simple, even though we have to be extremely\ncareful when implementing it. The environment of a program in the very\nsimple case is all its registers and stack. We will deal with stack later. Now to\nget control from the program without the program knowing about it, we can\nuse the IRQ 0 highest priority interrupt that is periodically coming to the\nprocessor.\nNow we present a very basic example of multitasking. We have two\nsubroutines written in assembly language. All the techniques discussed here\nare applicable to code written in higher level languages as well. However the\ncode to control this multitasking cannot be easily written in a higher level\nlanguage so we write it in assembly language. The two subroutines rotate\nbars by changing characters at the two corners of the screen and have\ninfinite loops. By hooking the timer interrupt and saving and restoring the\nregisters of the tasks one by one, it appears that both tasks are running\nsimultaneously.\nExample 11.1\n001 ; elementary multitasking of two threads\n002 [org 0x0100]\n003 jmp start\n004\n005 ; ax,bx,ip,cs,flags storage area\n006 taskstates: dw 0, 0, 0, 0, 0 ; task0 regs\n007 dw 0, 0, 0, 0, 0 ; task1 regs\n008 dw 0, 0, 0, 0, 0 ; task2 regs\n009\n010 current: db 0 ; index of current task\n011 chars: db '\\|/-' ; shapes to form a bar\n012\n013 ; one task to be multitasked\n014 taskone: mov al, [chars+bx] ; read the next shape\n015 mov [es:0], al ; write at top left of screen\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n016 inc bx ; increment to next shape\n017 and bx, 3 ; taking modulus by 4\n018 jmp taskone ; infinite task\n019\n020 ; second task to be multitasked\n021 tasktwo: mov al, [chars+bx] ; read the next shape\n022 mov [es:158], al ; write at top right of screen\n023 inc bx ; increment to next shape\n024 and bx, 3 ; taking modulus by 4\n025 jmp tasktwo ; infinite task\n026\n027 ; timer interrupt service routine\n028 timer: push ax\n029 push bx\n030\n031 mov bl, [cs:current] ; read index of current task\n032 mov ax, 10 ; space used by one task\n033 mul bl ; multiply to get start of task\n034 mov bx, ax ; load start of task in bx\n035\n036 pop ax ; read original value of bx\n037 mov [cs:taskstates+bx+2], ax ; space for current task\n038 pop ax ; read original value of ax\n039 mov [cs:taskstates+bx+0], ax ; space for current task\n040 pop ax ; read original value of ip\n041 mov [cs:taskstates+bx+4], ax ; space for current task\n042 pop ax ; read original value of cs\n043 mov [cs:taskstates+bx+6], ax ; space for current task\n044 pop ax ; read original value of flags\n045 mov [cs:taskstates+bx+8], ax ; space for current task\n046\n047 inc byte [cs:current] ; update current task index\n048 cmp byte [cs:current], 3 ; is task index out of range\n049 jne skipreset ; no, proceed\n050 mov byte [cs:current], 0 ; yes, reset to task 0\n051\n052 skipreset: mov bl, [cs:current] ; read index of current task\n053 mov ax, 10 ; space used by one task\n054 mul bl ; multiply to get start of task\n055 mov bx, ax ; load start of task in bx\n056\n057 mov al, 0x20\n058 out 0x20, al ; send EOI to PIC\n059\n060 push word [cs:taskstates+bx+8] ; flags of new task\n061 push word [cs:taskstates+bx+6] ; cs of new task\n062 push word [cs:taskstates+bx+4] ; ip of new task\n063 mov ax, [cs:taskstates+bx+0] ; ax of new task\n064 mov bx, [cs:taskstates+bx+2] ; bx of new task\n065 iret ; return to new task\n066\n067 start: mov word [taskstates+10+4], taskone ; initialize ip\n068 mov [taskstates+10+6], cs ; initialize cs\n069 mov word [taskstates+10+8], 0x0200 ; initialize flags\n070 mov word [taskstates+20+4], tasktwo ; initialize ip\n071 mov [taskstates+20+6], cs ; initialize cs\n072 mov word [taskstates+20+8], 0x0200 ; initialize flags\n073 mov word [current], 0 ; set current task index\n074\n075 xor ax, ax\n076 mov es, ax ; point es to IVT base\n077 cli\n078 mov word [es:8*4], timer\n079 mov [es:8*4+2], cs ; hook timer interrupt\n080 mov ax, 0xb800\n081 mov es, ax ; point es to video base\n082 xor bx, bx ; initialize bx for tasks\n083 sti\n084\n085 jmp $ ; infinite loop\nThe space where all registers of a task are stored is called the process\ncontrol block or PCB. Actual PCB contains a few more things that are not\nVirtual University of Pakistan 132\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nrelevant to us now. INT 08 that is saving and restoring the registers is called\nthe scheduler and the whole event is called a context switch.\n11.2. ELABORATE MULTITASKING\nIn our next example we will save all 14 registers and the stack as well. 28\nbytes are needed by these registers in the PCB. We add some more space to\nmake the size 32, a power of 2 for easy calculations. One of these words is\nused to form a linked list of the PCBs so that strict ordering of active PCBs is\nnot necessary. Also in this example we have given every thread its own stack.\nNow threads can have function calls, parameters and local variables etc.\nAnother important change in this example is that the creation of threads is\nnow dynamic. The thread registration code initializes the PCB, and adds it to\nthe linked list so that the scheduler will give it a turn.\nExample 11.2\n001 ; multitasking and dynamic thread registration\n002 [org 0x0100]\n003 jmp start\n004\n005 ; PCB layout:\n006 ; ax,bx,cx,dx,si,di,bp,sp,ip,cs,ds,ss,es,flags,next,dummy\n007 ; 0, 2, 4, 6, 8,10,12,14,16,18,20,22,24, 26 , 28 , 30\n008\n009 pcb: times 32*16 dw 0 ; space for 32 PCBs\n010 stack: times 32*256 dw 0 ; space for 32 512 byte stacks\n011 nextpcb: dw 1 ; index of next free pcb\n012 current: dw 0 ; index of current pcb\n013 lineno: dw 0 ; line number for next thread\n014-057\n058 ;;;;; COPY LINES 028-071 FROM EXAMPLE 10.1 (printnum) ;;;;;\n059\n060 ; mytask subroutine to be run as a thread\n061 ; takes line number as parameter\n062 mytask: push bp\n063 mov bp, sp\n064 sub sp, 2 ; thread local variable\n065 push ax\n066 push bx\n067\n068 mov ax, [bp+4] ; load line number parameter\n069 mov bx, 70 ; use column number 70\n070 mov word [bp-2], 0 ; initialize local variable\n071\n072 printagain: push ax ; line number\n073 push bx ; column number\n074 push word [bp-2] ; number to be printed\n075 call printnum ; print the number\n076 inc word [bp-2] ; increment the local variable\n077 jmp printagain ; infinitely print\n078\n079 pop bx\n080 pop ax\n081 mov sp, bp\n082 pop bp\n083 ret\n084\n085 ; subroutine to register a new thread\n086 ; takes the segment, offset, of the thread routine and a parameter\n087 ; for the target thread subroutine\n088 initpcb: push bp\n089 mov bp, sp\n090 push ax\n091 push bx\n092 push cx\n093 push si\n094\n095 mov bx, [nextpcb] ; read next available pcb index\n096 cmp bx, 32 ; are all PCBs used\n097 je exit ; yes, exit\n098\nVirtual University of Pakistan 133\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n099 mov cl, 5\n100 shl bx, cl ; multiply by 32 for pcb start\n101\n102 mov ax, [bp+8] ; read segment parameter\n103 mov [pcb+bx+18], ax ; save in pcb space for cs\n104 mov ax, [bp+6] ; read offset parameter\n105 mov [pcb+bx+16], ax ; save in pcb space for ip\n106\n107 mov [pcb+bx+22], ds ; set stack to our segment\n108 mov si, [nextpcb] ; read this pcb index\n109 mov cl, 9\n110 shl si, cl ; multiply by 512\n111 add si, 256*2+stack ; end of stack for this thread\n112 mov ax, [bp+4] ; read parameter for subroutine\n113 sub si, 2 ; decrement thread stack pointer\n114 mov [si], ax ; pushing param on thread stack\n115 sub si, 2 ; space for return address\n116 mov [pcb+bx+14], si ; save si in pcb space for sp\n117\n118 mov word [pcb+bx+26], 0x0200 ; initialize thread flags\n119 mov ax, [pcb+28] ; read next of 0th thread in ax\n120 mov [pcb+bx+28], ax ; set as next of new thread\n121 mov ax, [nextpcb] ; read new thread index\n123 mov [pcb+28], ax ; set as next of 0th thread\n124 inc word [nextpcb] ; this pcb is now used\n125\n126 exit: pop si\n127 pop cx\n128 pop bx\n129 pop ax\n130 pop bp\n131 ret 6\n132\n133 ; timer interrupt service routine\n134 timer: push ds\n135 push bx\n136\n137 push cs\n138 pop ds ; initialize ds to data segment\n139\n140 mov bx, [current] ; read index of current in bx\n141 shl bx, 1\n142 shl bx, 1\n143 shl bx, 1\n144 shl bx, 1\n145 shl bx, 1 ; multiply by 32 for pcb start\n146 mov [pcb+bx+0], ax ; save ax in current pcb\n147 mov [pcb+bx+4], cx ; save cx in current pcb\n148 mov [pcb+bx+6], dx ; save dx in current pcb\n149 mov [pcb+bx+8], si ; save si in current pcb\n150 mov [pcb+bx+10], di ; save di in current pcb\n151 mov [pcb+bx+12], bp ; save bp in current pcb\n152 mov [pcb+bx+24], es ; save es in current pcb\n153\n154 pop ax ; read original bx from stack\n155 mov [pcb+bx+2], ax ; save bx in current pcb\n156 pop ax ; read original ds from stack\n157 mov [pcb+bx+20], ax ; save ds in current pcb\n158 pop ax ; read original ip from stack\n159 mov [pcb+bx+16], ax ; save ip in current pcb\n160 pop ax ; read original cs from stack\n161 mov [pcb+bx+18], ax ; save cs in current pcb\n162 pop ax ; read original flags from stack\n163 mov [pcb+bx+26], ax ; save cs in current pcb\n164 mov [pcb+bx+22], ss ; save ss in current pcb\n165 mov [pcb+bx+14], sp ; save sp in current pcb\n166\n167 mov bx, [pcb+bx+28] ; read next pcb of this pcb\n168 mov [current], bx ; update current to new pcb\n169 mov cl, 5\n170 shl bx, cl ; multiply by 32 for pcb start\n171\n172 mov cx, [pcb+bx+4] ; read cx of new process\n173 mov dx, [pcb+bx+6] ; read dx of new process\n174 mov si, [pcb+bx+8] ; read si of new process\n175 mov di, [pcb+bx+10] ; read diof new process\nVirtual University of Pakistan 134\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n176 mov bp, [pcb+bx+12] ; read bp of new process\n177 mov es, [pcb+bx+24] ; read es of new process\n178 mov ss, [pcb+bx+22] ; read ss of new process\n179 mov sp, [pcb+bx+14] ; read sp of new process\n180\n181 push word [pcb+bx+26] ; push flags of new process\n182 push word [pcb+bx+18] ; push cs of new process\n183 push word [pcb+bx+16] ; push ip of new process\n184 push word [pcb+bx+20] ; push ds of new process\n185\n186 mov al, 0x20\n187 out 0x20, al ; send EOI to PIC\n188\n189 mov ax, [pcb+bx+0] ; read ax of new process\n190 mov bx, [pcb+bx+2] ; read bx of new process\n191 pop ds ; read ds of new process\n192 iret ; return to new process\n193\n194 start: xor ax, ax\n195 mov es, ax ; point es to IVT base\n196\n197 cli\n198 mov word [es:8*4], timer\n199 mov [es:8*4+2], cs ; hook timer interrupt\n200 sti\n201\n202 nextkey: xor ah, ah ; service 0 \u2013 get keystroke\n203 int 0x16 ; bios keyboard services\n204\n205 push cs ; use current code segment\n206 mov ax, mytask\n207 push ax ; use mytask as offset\n208 push word [lineno] ; thread parameter\n209 call initpcb ; register the thread\n210\n211 inc word [lineno] ; update line number\n212 jmp nextkey ; wait for next keypress\nWhen the program is executed the threads display the numbers\nindependently. However as keys are pressed and new threads are registered,\nthere is an obvious slowdown in the speed of multitasking. To improve that,\nwe can change the timer interrupt frequency. The following can be used to\nset to an approximately 1ms interval.\nmov ax, 1100\nout 0x40, al\nmov al, ah\nout 0x40, al\nThis makes the threads look faster. However the only real change is that\nthe timer interrupt is now coming more frequently.\n11.3. MULTITASKING KERNEL AS TSR\nThe above examples had the multitasking code and the multitasked code\nin one program. Now we separate the multitasking kernel into a TSR so that\nit becomes an operation system extension. We hook a software interrupt for\nthe purpose of registering a new thread.\nExample 11.3\n001 ; multitasking kernel as a TSR\n002 [org 0x0100]\n003 jmp start\n004\n005 ; PCB layout:\n006 ; ax,bx,cx,dx,si,di,bp,sp,ip,cs,ds,ss,es,flags,next,dummy\n007 ; 0, 2, 4, 6, 8,10,12,14,16,18,20,22,24, 26 , 28 , 30\n008\n009 pcb: times 32*16 dw 0 ; space for 32 PCBs\nVirtual University of Pakistan 135\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n010 stack: times 32*256 dw 0 ; space for 32 512 byte stacks\n011 nextpcb: dw 1 ; index of next free pcb\n012 current: dw 0 ; index of current pcb\n013\n014-073 ;;;;; COPY LINES 133-192 FROM EXAMPLE 11.2 (timer) ;;;;;\n074\n075 ; software interrupt to register a new thread\n076 ; takes parameter block in ds:si\n077 ; parameter block has cs, ip, ds, es, and param in this order\n078 initpcb: push ax\n079 push bx\n080 push cx\n081 push di\n082\n083 mov bx, [cs:nextpcb] ; read next available pcb index\n084 cmp bx, 32 ; are all PCBs used\n085 je exit ; yes, exit\n086\n087 mov cl, 5\n088 shl bx, cl ; multiply by 32 for pcb start\n089\n090 mov ax, [si+0] ; read code segment parameter\n091 mov [cs:pcb+bx+18], ax ; save in pcb space for cs\n092 mov ax, [si+2] ; read offset parameter\n093 mov [cs:pcb+bx+16], ax ; save in pcb space for ip\n094 mov ax, [si+4] ; read data segment parameter\n095 mov [cs:pcb+bx+20], ax ; save in pcb space for ds\n096 mov ax, [si+6] ; read extra segment parameter\n097 mov [cs:pcb+bx+24], ax ; save in pcb space for es\n098\n099 mov [cs:pcb+bx+22], cs ; set stack to our segment\n100 mov di, [cs:nextpcb] ; read this pcb index\n101 mov cl, 9\n102 shl di, cl ; multiply by 512\n103 add di, 256*2+stack ; end of stack for this thread\n104 mov ax, [si+8] ; read parameter for subroutine\n105 sub di, 2 ; decrement thread stack pointer\n106 mov [cs:di], ax ; pushing param on thread stack\n107 sub di, 4 ; space for far return address\n108 mov [cs:pcb+bx+14], di ; save di in pcb space for sp\n109\n110 mov word [cs:pcb+bx+26], 0x0200 ; initialize flags\n111 mov ax, [cs:pcb+28] ; read next of 0th thread in ax\n112 mov [cs:pcb+bx+28], ax ; set as next of new thread\n113 mov ax, [cs:nextpcb] ; read new thread index\n114 mov [cs:pcb+28], ax ; set as next of 0th thread\n115 inc word [cs:nextpcb] ; this pcb is now used\n116\n117 exit: pop di\n118 pop cx\n119 pop bx\n120 pop ax\n121 iret\n123\n124 start: xor ax, ax\n125 mov es, ax ; point es to IVT base\n126\n127 mov word [es:0x80*4], initpcb\n128 mov [es:0x80*4+2], cs ; hook software int 80\n129 cli\n130 mov word [es:0x08*4], timer\n131 mov [es:0x08*4+2], cs ; hook timer interrupt\n132 sti\n133\n134 mov dx, start\n135 add dx, 15\n136 mov cl, 4\n137 shr dx, cl\n138\n139 mov ax, 0x3100 ; terminate and stay resident\n140 int 0x21\nThe second part of our example is a simple program that has the threads\nto be registered with the multitasking kernel using its exported services.\nVirtual University of Pakistan 136\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 11.4\n001 ; multitasking TSR caller\n002 [org 0x0100]\n003 jmp start\n004\n005 ; parameter block layout:\n006 ; cs,ip,ds,es,param\n007 ; 0, 2, 4, 6, 8\n008\n009 paramblock: times 5 dw 0 ; space for parameters\n010 lineno: dw 0 ; line number for next thread\n011\n012-055 ;;;;; COPY LINES 028-071 FROM EXAMPLE 10.1 (printnum) ;;;;;\n056\n057 ; subroutine to be run as a thread\n058 ; takes line number as parameter\n059 mytask: push bp\n060 mov bp, sp\n061 sub sp, 2 ; thread local variable\n062 push ax\n063 push bx\n064\n065 mov ax, [bp+4] ; load line number parameter\n066 mov bx, 70 ; use column number 70\n067 mov word [bp-2], 0 ; initialize local variable\n068\n069 printagain: push ax ; line number\n070 push bx ; column number\n071 push word [bp-2] ; number to be printed\n072 call printnum ; print the number\n073 inc word [bp-2] ; increment the local variable\n074 jmp printagain ; infinitely print\n075\n076 pop bx\n077 pop ax\n078 mov sp, bp\n079 pop bp\n080 retf\n081\n082 start: mov ah, 0 ; service 0 \u2013 get keystroke\n083 int 0x16 ; bios keyboard services\n084\n085 mov [paramblock+0], cs ; code segment parameter\n086 mov word [paramblock+2], mytask ; offset parameter\n087 mov [paramblock+4], ds ; data segment parameter\n088 mov [paramblock+6], es ; extra segment parameter\n089 mov ax, [lineno]\n090 mov [paramblock+8], ax ; parameter for thread\n091 mov si, paramblock ; address of param block in si\n092 int 0x80 ; multitasking kernel interrupt\n093\n094 inc word [lineno] ; update line number\n095 jmp start ; wait for next key\nWe introduce yet another use of the multitasking kernel with this new\nexample. In this example three different sort of routines are multitasked by\nthe same kernel instead of repeatedly registering the same routine.\nExample 11.5\n001 ; another multitasking TSR caller\n002 [org 0x0100]\n003 jmp start\n004\n005 ; parameter block layout:\n006 ; cs,ip,ds,es,param\n007 ; 0, 2, 4, 6, 8\n008\n009 paramblock: times 5 dw 0 ; space for parameters\n010 lineno: dw 0 ; line number for next thread\n011 chars: db '\\|/-' ; chracters for rotating bar\n012 message: db 'moving hello' ; moving string\n013 message2: db ' ' ; to erase previous string\nVirtual University of Pakistan 137\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n014 messagelen: dw 12 ; length of above strings\n015\n016-059 ;;;;; COPY LINES 028-071 FROM EXAMPLE 10.1 (printnum) ;;;;;\n060-101 ;;;;; COPY LINES 073-114 FROM EXAMPLE 10.1 (printstr) ;;;;;\n102\n103 ; subroutine to run as first thread\n104 mytask: push bp\n105 mov bp, sp\n106 sub sp, 2 ; thread local variable\n107 push ax\n108 push bx\n109\n110 xor ax, ax ; use line number 0\n111 mov bx, 70 ; use column number 70\n112 mov word [bp-2], 0 ; initialize local variable\n113\n114 printagain: push ax ; line number\n115 push bx ; column number\n116 push word [bp-2] ; number to be printed\n117 call printnum ; print the number\n118 inc word [bp-2] ; increment the local variable\n119 jmp printagain ; infinitely print\n120\n121 pop bx\n123 pop ax\n124 mov sp, bp\n125 pop bp\n126 retf\n127\n128 ; subroutine to run as second thread\n129 mytask2: push ax\n130 push bx\n131 push es\n132\n133 mov ax, 0xb800\n134 mov es, ax ; point es to video base\n135 xor bx, bx ; initialize to use first shape\n136\n137 rotateagain: mov al, [chars+bx] ; read current shape\n138 mov [es:40], al ; print at specified place\n139 inc bx ; update to next shape\n140 and bx, 3 ; take modulus with 4\n141 jmp rotateagain ; repeat infinitely\n142\n143 pop es\n144 pop bx\n145 pop ax\n146 retf\n147\n148 ; subroutine to run as third thread\n149 mytask3: push bp\n150 mov bp, sp\n151 sub sp, 2 ; thread local variable\n152 push ax\n153 push bx\n154 push cx\n155\n156 mov word [bp-2], 0 ; initialize line number to 0\n157\n158 nextline: push word [bp-2] ; line number\n159 mov bx, 50\n160 push bx ; column number 50\n161 mov ax, message\n162 push ax ; offset of string\n163 push word [messagelen] ; length of string\n164 call printstr ; print the string\n165\n166 mov cx, 0x100\n167 waithere: push cx ; save outer loop counter\n168 mov cx, 0xffff\n169 loop $ ; repeat ffff times\n170 pop cx ; restore outer loop counter\n171 loop waithere ; repeat 0x100 times\n172\n173 push word [bp-2] ; line number\n174 mov bx, 50 ; column number 50\nVirtual University of Pakistan 138\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n175 push bx\n176 mov ax, message2\n177 push ax ; offset of blank string\n178 push word [messagelen] ; length of string\n179 call printstr ; print the string\n180\n181 inc word [bp-2] ; update line number\n182 cmp word [bp-2], 25 ; is this the last line\n183 jne skipreset ; no, proceed to draw\n184 mov word [bp-2], 0 ; yes, reset line number to 0\n185\n186 skipreset: jmp nextline ; proceed with next drawing\n187\n188 pop cx\n189 pop bx\n190 pop ax\n191 mov sp, bp\n192 pop bp\n193 retf\n194\n195 start: mov [paramblock+0], cs ; code segment parameter\n196 mov word [paramblock+2], mytask ; offset parameter\n197 mov [paramblock+4], ds ; data segment parameter\n198 mov [paramblock+6], es ; extra segment parameter\n199 mov word [paramblock+8], 0 ; parameter for thread\n200 mov si, paramblock ; address of param block in si\n201 int 0x80 ; multitasking kernel interrupt\n202\n203 mov [paramblock+0], cs ; code segment parameter\n204 mov word [paramblock+2], mytask2 ; offset parameter\n205 mov [paramblock+4], ds ; data segment parameter\n206 mov [paramblock+6], es ; extra segment parameter\n207 mov word [paramblock+8], 0 ; parameter for thread\n208 mov si, paramblock ; address of param block in si\n209 int 0x80 ; multitasking kernel interrupt\n210\n211 mov [paramblock+0], cs ; code segment parameter\n212 mov word [paramblock+2], mytask3 ; offset parameter\n213 mov [paramblock+4], ds ; data segment parameter\n214 mov [paramblock+6], es ; extra segment parameter\n215 mov word [paramblock+8], 0 ; parameter for thread\n216 mov si, paramblock ; address of param block in si\n217 int 0x80 ; multitasking kernel interrupt\n218\n219 jmp $\nEXERCISES\n1. Change the multitasking kernel such that a new two byte variable is\nintroduced in the PCB. This variable contains the number of turns\nthis process should be given. For example if the first PCB contains 20\nin this variable, the switch to second process should occur after 20\ntimer interrupts (approx one second at default speed) and similarly\nthe switch from second to third process should occur after the\nnumber given in the second process\u2019s PCB.\n2. Change the scheduler of the multitasking kernel to enque the current\nprocess index a ready queue, and dequeue the next process index\nfrom it, and assign it to current. Therefore the next field of the PCB is\nno longer used. Use queue functions from Exercise 5.XX.\n3. Add a function in the multitasking kernel to fork the current process\nthrough a software interrupt. Fork should allocate a new PCB and\ncopy values of all registers of the caller\u2019s PCB to the new PCB. It\nshould allocate a stack and change SS, SP appropriately in the new\nPCB. It has to copy the caller\u2019s stack on the newly allocated stack. It\nwill set AX in the new PCB to 0 and in the old PB to 1 so that both\nthreads can identify which is the creator and which is the created\nprocess and can act accordingly.\nVirtual University of Pakistan 139\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n4. Add a function in the multitasking kernel accessible via a software\ninterrupt that allows the current process to terminate itself.\n5. Create a queue in the multitasking kernel called kbQ. This queue\ninitially empty will contain characters typed by the user. Hook the\nkeyboard interrupt for getting user keys. Convert the scan code to\nASCII if the key is from a-z or 0-9 and enque it in kbQ. Ignore all\nother scan codes. Write a function checkkey accessible via a software\ninterrupt that returns the process in AX a value removed from the\nqueue. It waits if there is no key in the queue. Be aware of enabling\ninterrupts if you wait here.\n6. Modify the multitasking kernel such that the initial process displays\nat the last line of the screen whatever is typed by the user and clears\nthat line on enter. If the user types quit followed by enter restore\neverything to normal as it was before the multitasking kernel was\nthere. If the user types start followed by enter, start one more rotating\nbar on the screen. The first rotating bar should appear in the upper\nleft, the next in the second column, then third and so on. The bar\ncolor should be white. The user can type the commands \u2018white\u2019, \u2018red\u2019,\nand \u2018green\u2019 to change the color of new bars.\nVirtual University of Pakistan 140\n12\nVideo Services\n12.1. BIOS VIDEO SERVICES\nThe Basic Input Output System (BIOS) provides services for video,\nkeyboard, serial port, parallel port, time etc. The video services are exported\nvia INT 10. We will discuss some very simple services. Video services are\nclassified into two broad categories; graphics mode services and text mode\nservices. In graphics mode a location in video memory corresponds to a dot\non the screen. In text mode this relation is not straightforward. The video\nmemory holds the ASCII of the character to be shown and the actual shape is\nread from a font definition stored elsewhere in memory. We first present a list\nof common video services used in text mode.\nINT 10 - VIDEO - SET VIDEO MODE\nAH = 00h\nAL = desired video mode\nSome common video modes include 40x25 text mode (mode 0), 80x25 text\nmode (mode 2), 80x50 text mode (mode 3), and 320x200 graphics mode\n(mode D).\nINT 10 - VIDEO - SET TEXT-MODE CURSOR SHAPE\nAH = 01h\nCH = cursor start and options\nCL = bottom scan line containing cursor (bits 0-4)\nINT 10 - VIDEO - SET CURSOR POSITION\nAH = 02h\nBH = page number\n0-3 in modes 2&3\n0-7 in modes 0&1\n0 in graphics modes\nDH = row (00h is top)\nDL = column (00h is left)\nINT 10 - VIDEO - SCROLL UP WINDOW\nAH = 06h\nAL = number of lines by which to scroll up (00h = clear entire window)\nBH = attribute used to write blank lines at bottom of window\nCH, CL = row, column of window's upper left corner\nDH, DL = row, column of window's lower right corner\nINT 10 - VIDEO - SCROLL DOWN WINDOW\nAH = 07h\nAL = number of lines by which to scroll down (00h=clear entire window)\nBH = attribute used to write blank lines at top of window\nCH, CL = row, column of window's upper left corner\nDH, DL = row, column of window's lower right corner\nINT 10 - VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION\nAH = 09h\nAL = character to display\nBH = page number\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nBL = attribute (text mode) or color (graphics mode)\nCX = number of times to write character\nINT 10 - VIDEO - WRITE CHARACTER ONLY AT CURSOR POSITION\nAH = 0Ah\nAL = character to display\nBH = page number\nBL = attribute (text mode) or color (graphics mode)\nCX = number of times to write character\nINT 10 - VIDEO - WRITE STRING\nAH = 13h\nAL = write mode\nbit 0: update cursor after writing\nbit 1: string contains alternating characters and attributes\nbits 2-7: reserved (0)\nBH = page number\nBL = attribute if string contains only characters\nCX = number of characters in string\nDH, DL = row, column at which to start writing\nES:BP -> string to write\nChargen Services\nIn our first example we will read the font definition in memory and change\nit to include a set of all on pixels in the last line showing an effect of\nunderline on all character including space. An 8x16 font is stored in 16\nbytes. A sample character and the corresponding 16 values stored in the font\ninformation are shown for the character \u2018A\u2019. We\nstart with two services from the chargen subset\nof video services that we are going to use.\nINT 10 - VIDEO - GET FONT INFORMATION\nAX = 1130h\nBH = pointer specifier\nReturn:\nES:BP = specified pointer\nCX = bytes/character of on-screen font\nDL = highest character row on screen\nINT 10 - TEXT-MODE CHARGEN\nAX = 1110h\nES:BP -> user table\nCX = count of patterns to store\nDX = character offset into map 2 block\nBL = block to load in map 2\nBH = number of bytes per character pattern\nWe will use 6 as the pointer specifier which means the 8x16 font stored in\nROM.\nExample 12.1\n001 ; put underlines on screen font\n002 [org 0x0100]\n003 jmp start\n004\n005 font: times 256*16 db 0 ; space for font\n006\n007 start: mov ax, 0x1130 ; service 11/30 \u2013 get font info\n008 mov bx, 0x0600 ; ROM 8x16 font\n009 int 0x10 ; bios video services\n010\n011 mov si, bp ; point si to rom font data\n012 mov di, font ; point di to space for font\nVirtual University of Pakistan 142\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n013 mov cx, 256*16 ; font size\n014 push ds\n015 push es\n016 pop ds ; ds:si to rom font data\n017 pop es ; es:di to space for font\n018 cld ; auto increment mode\n019 rep movsb ; copy font\n020\n021 push cs\n022 pop ds ; restore ds to data segment\n023\n024 mov si, font-1 ; point si before first char\n025 mov cx, 0x100 ; total 256 characters\n026 change: add si, 16 ; one character has 16 bytes\n027 mov byte [si], 0xFF ; change last line to all ones\n028 loop change ; repeat for each character\n029\n030 mov bp, font ; es:bp points to new font\n031 mov bx, 0x1000 ; bytes per char & block number\n032 mov cx, 0x100 ; number of characters to change\n033 xor dx, dx ; first character to change\n034 mov ax, 0x1110 ; service 11/10 \u2013 load user font\n035 int 0x10 ; bios video services\n036\n037 mov ax, 0x4c00 ; terminate program\n038 int 0x21\nOur second example is similar to the last example however in this case we\nare doing something funny on the screen. We are reversing the shapes of all\nthe characters on the screen.\nExample 12.2\n001 ; reverse each character of screen font\n002 [org 0x0100]\n003 jmp start\n004\n005 font: times 256*16 db 0 ; space for font\n006\n007 start: mov ax, 0x1130 ; service 11/30 \u2013 get font info\n008 mov bx, 0x0600 ; ROM 8x16 font\n009 int 0x10 ; bios video services\n010\n011 mov si, bp ; point si to rom font data\n012 mov di, font ; point di to space for font\n013 mov cx, 256*16 ; font size\n014 push ds\n015 push es\n016 pop ds ; ds:si to rom font data\n017 pop es ; es:di to space for font\n018 cld ; auto increment mode\n019 rep movsb ; copy font\n020\n021 push cs\n022 pop ds ; restore ds to data segment\n023\n024 mov si, font ; point si to start of font\n025 change: mov al, [si] ; read one byte\n026 mov cx, 8\n027 inner: shl al, 1 ; shift left with MSB in carry\n028 rcr bl, 1 ; rotate right using carry\n029 loop inner ; repeat eight times\n030 mov [si], bl ; write back reversed byte\n031 inc si ; next byte of font\n032 cmp si, font+256*16 ; is whole font reversed\n033 jne change ; no, reverse next byte\n034\n035 mov bp, font ; es:bp points to new font\n036 mov bx, 0x1000 ; bytes per char & block number\n037 mov cx, 0x100 ; number of characters to change\n038 xor dx, dx ; first character to change\n039 mov ax, 0x1110 ; service 11/10 \u2013 load user font\n040 int 0x10 ; bios video services\n041\nVirtual University of Pakistan 143\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n042 mov ax, 0x4c00 ; terminate program\n043 int 0x21\nGraphics Mode Services\nWe will take an example of using graphics mode video services as well. We\nwill draw a line across the screen using the following service.\nINT 10 - VIDEO - WRITE GRAPHICS PIXEL\nAH = 0Ch\nBH = page number\nAL = pixel color\nCX = column\nDX = row\nExample 12.3\n001 ; draw line in graphics mode\n002 [org 0x0100]\n003 mov ax, 0x000D ; set 320x200 graphics mode\n004 int 0x10 ; bios video services\n005\n006 mov ax, 0x0C07 ; put pixel in white color\n007 xor bx, bx ; page number 0\n008 mov cx, 200 ; x position 200\n009 mov dx, 200 ; y position 200\n010\n011 l1: int 0x10 ; bios video services\n012 dec dx ; decrease y position\n013 loop l1 ; decrease x position and repeat\n014\n015 mov ah, 0 ; service 0 \u2013 get keystroke\n016 int 0x16 ; bios keyboard services\n017\n018 mov ax, 0x0003 ; 80x25 text mode\n019 int 0x10 ; bios video services\n020\n021 mov ax, 0x4c00 ; terminate program\n022 int 0x21\n12.2. DOS VIDEO SERVICES\nServices of DOS are more cooked and at a higher level than BIOS. They\nprovide less control but make routine tasks much easier. Some important\nDOS services are listed below.\nINT 21 - READ CHARACTER FROM STANDARD INPUT, WITH ECHO\nAH = 01h\nReturn: AL = character read\nINT 21 - WRITE STRING TO STANDARD OUTPUT\nAH = 09h\nDS:DX -> $ terminated string\nINT 21 - BUFFERED INPUT\nAH = 0Ah\nDS:DX -> dos input buffer\nThe DOS input buffer has a special format where the first byte stores the\nmaximum characters buffer can hold, the second byte holds the number of\ncharacters actually read on return, and the following space is used for the\nactual characters read. We start will an example of reading a string with\nservice 1 and displaying it with service 9.\nVirtual University of Pakistan 144\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 12.4\n001 ; character input using dos services\n002 [org 0x0100]\n003 jmp start\n004\n005 maxlength: dw 80 ; maximum length of input\n006 message: db 10, 13, 'hello $' ; greetings message\n007 buffer: times 81 db 0 ; space for input string\n008\n009 start: mov cx, [maxlength] ; load maximum length in cx\n010 mov si, buffer ; point si to start of buffer\n011\n012 nextchar: mov ah, 1 ; service 1 \u2013 read character\n013 int 0x21 ; dos services\n014\n015 cmp al, 13 ; is enter pressed\n016 je exit ; yes, leave input\n017 mov [si], al ; no, save this character\n018 inc si ; increment buffer pointer\n019 loop nextchar ; repeat for next input char\n020\n021 exit: mov byte [si], '$' ; append $ to user input\n022\n023 mov dx, message ; greetings message\n024 mov ah, 9 ; service 9 \u2013 write string\n025 int 0x21 ; dos services\n026\n027 mov dx, buffer ; user input buffer\n028 mov ah, 9 ; service 9 \u2013 write string\n029 int 0x21 ; dos services\n030\n031 mov ax, 0x4c00 ; terminate program\n032 int 0x21\nOur next example uses the more cooked buffered input service of DOS and\nusing the same service 9 to print the string.\nExample 12.5\n001 ; buffer input using dos services\n002 [org 0x0100]\n003 jmp start\n004\n005 message: db 10,13,'hello ', 10, 13, '$'\n006 buffer: db 80 ; length of buffer\n007 db 0 ; number of character on return\n008 times 80 db 0 ; actual buffer space\n009\n010 start: mov dx, buffer ; input buffer\n011 mov ah, 0x0A ; service A \u2013 buffered input\n012 int 0x21 ; dos services\n013\n014 mov bh, 0\n015 mov bl, [buffer+1] ; read actual size in bx\n016 mov byte [buffer+2+bx], '$' ; append $ to user input\n017\n018 mov dx, message ; greetings message\n019 mov ah, 9 ; service 9 \u2013 write string\n020 int 0x21 ; dos services\n021\n022 mov dx, buffer+2 ; user input buffer\n023 mov ah, 9 ; service 9 \u2013 write string\n024 int 0x21 ; dos services\n025\n026 mov ax, 0x4c00 ; terminate program\n027 int 0x21\nMore detail of DOS and BIOS interrupts is available in the Ralf Brown\nInterrupt List.\nVirtual University of Pakistan 145\n\n13\nSecondary Storage\n13.1. PHYSICAL FORMATION\nA floppy disk is a circular plate with a fine coating of magnetic material\nover it. The plate is enclosed in a plastic jacket which has a cover that can\nslide to expose the magnetic surface. The drive motor attaches itself to the\ncentral piece and rotates the plate. Two heads on both sides can read the\nmagnetically encoded data on the disk.\nIf the head is fixed and the motor rotates the disk the readable area on the\ndisk surface forms a circle called a track. Head moved to the next step forms\nanother track and so on. In hard disks the same structure is extended to a\nlarger number of tracks and plates. The tracks are further cut vertically into\nsectors. This is a logical division of the area on the tracks. Each sector holds\n512 bytes of data. A standard floppy disk has 80 tracks and 18 sectors per\ntrack with two heads, one on each side totallying to 2880 sectors or 1440 KB\nof data. Hard disks have varying number of heads and tracks pertaining to\ntheir different capacities.\nBIOS sees the disks as a combination of sectors, tracks, and heads, as a\nraw storage device without concern to whether it is reading a file or directory.\nBIOS provides the simplest and most powerful interface to the storage\nmedium. However this raw storage is meaningless to the user who needs to\nstore his files and organize them into directories. DOS builds a logical\nstructure on this raw storage space to provide these abstractions. This\nlogical formation is read and interpreted by DOS. If another file system is\nbuild on the same storage medium the interpretations change. Main units of\nthe DOS structure are the boot sector in head 0, track 0, and sector 1, the\nfirst FAT starting from head 0, track 0, sector 2, the second copy of FAT\nstarting from head 0, track 0, sector 11, and the root directory starting from\nhead 1, track 0, sector 2. The area from head 0, track 1, sector 16 to head 1,\ntrack 79, sector 18 is used for storing the data of the files. Among this we will\nbe exploring the directory structure further. The 32 sectors reserved for the\nroot directory contain 512 directory entries. The format of a 32 byte directory\nentry is shown below.\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n+00 Filename (8 bytes)\n+08 Extension (3 bytes)\n+0B Flag Byte (1 byte)\n+0C Reserved (1 byte)\n+0D Creation Date/Time (5 bytes)\n+12 Last Accessed Data (2 bytes)\n+14 Starting Cluster High Word (2 bytes) for FAT32\n+16 Time (2 bytes)\n+18 Date (2 bytes)\n+1A Starting Cluster Low Word (2 bytes)\n+1C File Size (4 bytes)\n13.2. STORAGE ACCESS USING BIOS\nWe will be using BIOS disk services to directly see the data stored in the\ndirectory entries by DOS. For this purpose we will be using the BIOS disk\nservices.\nINT 13 - DISK - RESET DISK SYSTEM\nAH = 00h\nDL = drive\nReturn:\nCF = error flag\nAH = error code\nINT 13 - DISK - READ SECTOR(S) INTO MEMORY\nAH = 02h\nAL = number of sectors to read (must be nonzero)\nCH = low eight bits of cylinder number\nCL = sector number 1-63 (bits 0-5)\nhigh two bits of cylinder (bits 6-7, hard disk only)\nDH = head number\nDL = drive number (bit 7 set for hard disk)\nES:BX -> data buffer\nReturn:\nCF = error flag\nAH = error code\nAL = number of sectors transferred\nINT 13 - DISK - WRITE DISK SECTOR(S)\nAH = 03h\nAL = number of sectors to write (must be nonzero)\nCH = low eight bits of cylinder number\nCL = sector number 1-63 (bits 0-5)\nhigh two bits of cylinder (bits 6-7, hard disk only)\nDH = head number\nDL = drive number (bit 7 set for hard disk)\nES:BX -> data buffer\nReturn:\nCF = error flag\nAH = error code\nAL = number of sectors transferred\nINT 13 - DISK - GET DRIVE PARAMETERS\nAH = 08h\nDL = drive (bit 7 set for hard disk)\nReturn:\nCF = error flag\nAH = error code\nCH = low eight bits of maximum cylinder number\nCL = maximum sector number (bits 5-0)\nVirtual University of Pakistan 148\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nhigh two bits of maximum cylinder number (bits 7-6)\nDH = maximum head number\nDL = number of drives\nES:DI -> drive parameter table (floppies only)\nExample 13.1\n001 ; floppy directory using bios services\n002 [org 0x0100]\n003 jmp start\n004\n005 sector: times 512 db 0 ; space for directory sector\n006 entryname: times 11 db 0 ; space for a file name\n007 db 10, 13, '$' ; new line and terminating $\n008\n009 start: mov ah, 0 ; service 0 \u2013 reset disk system\n010 mov dl, 0 ; drive A:\n011 int 0x13 ; bios disk services\n012 jc error ; if error, terminate program\n013\n014 mov ah, 2 ; service 2 \u2013 read sectors\n015 mov al, 1 ; count of sectors\n016 mov ch, 0 ; cyliner\n017 mov cl, 2 ; sector\n018 mov dh, 1 ; head\n019 mov dl, 0 ; drive A:\n020 mov bx, sector ; buffer to read sector\n021 int 0x13 ; bios disk services\n022 jc error ; if error, terminate program\n023\n024 mov bx, 0 ; start from first entry\n025 nextentry: mov di, entryname ; point di to space for filename\n026 mov si, sector ; point si to sector\n027 add si, bx ; move ahead to desired entry\n028 mov cx, 11 ; one filename is 11 bytes long\n029 cld ; auto increment mode\n030 rep movsb ; copy filename\n031\n032 mov ah, 9 ; service 9 \u2013 output string\n033 mov dx, entryname ; filename to be printed\n034 int 0x21 ; dos services\n035\n036 add bx, 32 ; point to next dir entry\n037 cmp bx, 512 ; is last entry in this sector\n038 jne nextentry ; no, print next entry\n039\n040 error: mov ax, 0x4c00 ; terminate program\n041 int 0x21\nWith the given services and the bits allocated for heads, tracks, and\nsectors only 8GB disks can be accessed. This limitation can be overcome by\nusing INT 13 extensions that take a linear 64bit sector number and handle\nall the head, track, sector conversion themselves. The important services in\nthis category are listed below.\nINT 13 - INT 13 Extensions - EXTENDED READ\nAH = 42h\nDL = drive number\nDS:SI -> disk address packet\nReturn:\nCF = error flag\nAH = error code\ndisk address packet's block count field set to number of blocks\nsuccessfully transferred\nINT 13 - INT 13 Extensions - EXTENDED WRITE\nAH = 43h\nAL = write flags\nVirtual University of Pakistan 149\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nDL = drive number\nDS:SI -> disk address packet\nReturn:\nCF = error flag\nAH = error code\ndisk address packet's block count field set to number of blocks\nsuccessfully transferred\nThe format of the disk address packet used above is as follows.\nOffset Size Description\n00h BYTE size of packet = 10h\n01h BYTE reserved (0)\n02h WORD number of blocks to transfer\n04h DWORD -> transfer buffer\n08h QWORD starting absolute block number\nHard disks have a different formation from floppy disks in that there is a\npartition table at the start that allows several logical disks to be maintained\nwithin a single physical disk. The physical sector 0 holds the master boot\nrecord and a partition table towards the end. The first 446 bytes contain\nMBR, then there are 4 16 byte partition entries and then there is a 2 byte\nsignature. A partition table entry has the following format.\nByte 0 \u2013 0x80 for active 0x00 for inactive\nByte 1-3 \u2013 Starting CHS\nByte 4 \u2013 Partition Type\nByte 5-7 \u2013 Ending CHS\nByte 8-B \u2013 Starting LBA\nByte C-F \u2013 Size of Partition\nSome important partition types are listed below.\n00 Unused Entry\n01 FAT12\n05 Extended Partition\n06 FAT16\n0b FAT32\n0c FAT32 LBA\n0e FAT16 LBA\n0f Extended LBA\n07 NTFS\nExtended partition type signals that the specified area is treated as a\ncomplete hard disk with its own partition table and partitions. Therefore\nextended partitions allow a recursion in partitioning and consequently an\ninfinite number of partitions are possible. The following program reads the\npartition tables (primary and extended) using recursion and displays in an\nindented form all partitions present on the first hard disk in the system.\nExample 13.2\n001 ; a program to display the partition table\n002 [org 0x0100]\n003 jmp start\n004\n005 dap: db 0x10, 0 ; disk address packet\n006 dw 1\n007 dd 0, 0, 0\nVirtual University of Pakistan 150\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n008\n009-026 msg: times 17 db ' '\n027 db 10, 13, '$'\n028 fat12: db 'FAT12...$'\n029 fat16: db 'FAT16...$'\n030 fat32: db 'FAT32...$'\n031 ntfs: db 'NTFS....$'\n032 extended: db 'EXTEND..$'\n033 unknown: db 'UNKNOWN.$'\n034\n035 partypes: dw 0x1, fat12 ; table of known partition types\n036 dw 0x5, extended\n037 dw 0x6, fat16\n038 dw 0xe, fat16\n039 dw 0xb, fat32\n040 dw 0xc, fat32\n041 dw 0x7, ntfs\n042 dw 0xf, extended\n043 dw 0x0, unknown\n044\n045 ; subroutine to print a number in a string as hex\n046 ; takes address of string and a 16bit number as parameter\n047 printnum: push bp\n048 mov bp, sp\n049 push ax\n050 push bx\n051 push cx\n052 push dx\n053 push di\n054\n055 mov di, [bp+6] ; string to store the number\n056 add di, 3\n057\n058 mov ax, [bp+4] ; load number in ax\n059 mov bx, 16 ; use base 16 for division\n060 mov cx, 4\n061\n062 nextdigit: mov dx, 0\n063 div bx ; divide by 16\n064 add dl, 0x30 ; convert into ascii value\n065 cmp dl, 0x39\n066 jbe skipalpha\n067\n068 add dl, 7\n069\n070 skipalpha: mov [di], dl ; update char in string\n071 dec di\n072 loop nextdigit\n073\n074 pop di\n075 pop dx\n076 pop cx\n077 pop bx\n078 pop ax\n079 pop bp\n080 ret 4\n081\n082 ; subroutine to print the start and end of a partition\n083 ; takes the segment and offset of the partition table entry\n084 printpart: push bp\n085 mov bp, sp\n086 push es\n087 push ax\n088 push di\n089\n090 les di, [bp+4] ; point es:di to dap\n091\n092 mov ax, msg\n093 push ax\n094 push word [es:di+0xA]\n095 call printnum ; print first half of start\n096\n097 add ax, 4\n098 push ax\n099 push word [es:di+0x8]\n100 call printnum ; print second half of start\nVirtual University of Pakistan 151\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n101\n102 add ax, 5\n103 push ax\n104 push word [es:di+0xE]\n105 call printnum ; print first half of end\n106\n107 add ax, 4\n108 push ax\n109 push word [es:di+0xC]\n110 call printnum ; print second half of end\n111\n112 mov dx, msg\n113 mov ah, 9\n114 int 0x21 ; print the whole on the screen\n115\n116 pop di\n117 pop ax\n118 pop es\n119 pop bp\n120 ret 4\n121\n123 ; recursive subroutine to read the partition table\n124 ; take indentation level and 32bit absolute block number as parameters\n125 readpart: push bp\n126 mov bp, sp\n127 sub sp, 512 ; local space to read sector\n128 push ax\n129 push bx\n130 push cx\n131 push dx\n132 push si\n133\n134 mov ax, bp\n135 sub ax, 512\n136 mov word [dap+4], ax ; init dest offset in dap\n137 mov [dap+6], ds ; init dest segment in dap\n138 mov ax, [bp+4]\n139 mov [dap+0x8], ax ; init sector no in dap\n140 mov ax, [bp+6]\n141 mov [dap+0xA], ax ; init second half of sector no\n142\n143 mov ah, 0x42 ; read sector in LBA mode\n144 mov dl, 0x80 ; first hard disk\n145 mov si, dap ; address of dap\n146 int 0x13 ; int 13\n147\n148 jc failed ; if failed, leave\n149\n150 mov si, -66 ; start of partition info\n151 nextpart: mov ax, [bp+4] ; read relative sector number\n152 add [bp+si+0x8], ax ; make it absolute\n153 mov ax, [bp+6] ; read second half\n154 adc [bp+si+0xA], ax ; make seconf half absolute\n155\n156 cmp byte [bp+si+4], 0 ; is partition unused\n157 je exit\n158\n159 mov bx, partypes ; point to partition types\n160 mov di, 0\n161 nextmatch: mov ax, [bx+di]\n162 cmp [bp+si+4], al ; is this partition known\n163 je found ; yes, so print its name\n164 add di, 4 ; no, try next entry in table\n165 cmp di, 32 ; are all entries compared\n166 jne nextmatch ; no, try another\n167\n168 found: mov cx, [bp+8] ; load indentation level\n169 jcxz noindent ; skip if no indentation needed\n170 indent: mov dl, ' '\n171 mov ah, 2 ; display char service\n172 int 0x21 ; dos services\n173 loop indent ; print required no of spaces\n174\n175 noindent: add di, 2\n176 mov dx, [bx+di] ; point to partition type name\n177 mov ah, 9 ; print string service\nVirtual University of Pakistan 152\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n178 int 0x21 ; dos services\n179\n180 push ss\n181 mov ax, bp\n182 add ax, si\n183 push ax ; pass partition entry address\n184 call printpart ; print start and end from it\n185\n186 cmp byte [bp+si+4], 5 ; is it an extended partition\n187 je recurse ; yes, make a recursive call\n188\n189 cmp byte [bp+si+4], 0xf ; is it an extended partition\n190 jne exit ; yes, make a recursive call\n191\n192 recurse: mov ax, [bp+8]\n193 add ax, 2 ; increase indentation level\n194 push ax\n195 push word [bp+si+0xA] ; push partition type address\n196 push word [bp+si+0x8]\n197 call readpart ; recursive call\n198\n199 exit: add si, 16 ; point to next partition entry\n200 cmp si, -2 ; gone past last entry\n201 jne nextpart ; no, read this entry\n202\n203 failed: pop si\n204 pop dx\n205 pop bx\n206 pop cx\n207 pop ax\n208 mov sp, bp\n209 pop bp\n210 ret 6\n211\n212 start: xor ax, ax\n213 push ax ; start from zero indentation\n214 push ax ; main partition table at 0\n215 push ax\n216 call readpart ; read and print it\n217\n218 mov ax, 0x4c00 ; terminate program\n219 int 0x21\n13.3. STORAGE ACCESS USING DOS\nBIOS provides raw access to the storage medium while DOS gives a more\nlogical view and more cooked services. Everything is a file. A directory is a\nspecially organized file that is interpreted by the operating system itself. A\nlist of important DOS services for file manipulation is given below.\nINT 21 - CREATE OR TRUNCATE FILE\nAH = 3Ch\nCX = file attributes\nDS:DX -> ASCIZ filename\nReturn:\nCF = error flag\nAX = file handle or error code\nINT 21 - OPEN EXISTING FILE\nAH = 3Dh\nAL = access and sharing modes\nDS:DX -> ASCIZ filename\nCL = attribute mask of files to look for (server call only)\nReturn:\nCF = error flag\nAX = file handle or error code\nINT 21 - CLOSE FILE\nAH = 3Eh\nVirtual University of Pakistan 153\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nBX = file handle\nReturn:\nCF = error flag\nAX = error code\nINT 21 - READ FROM FILE\nAH = 3Fh\nBX = file handle\nCX = number of bytes to read\nDS:DX -> buffer for data\nReturn:\nCF = error flag\nAX = number of bytes actually read or error code\nINT 21 - WRITE TO FILE\nAH = 40h\nBX = file handle\nCX = number of bytes to write\nDS:DX -> data to write\nReturn:\nCF = error flag\nAX = number of bytes actually written or error code\nINT 21 - DELETE FILE\nAH = 41h\nDS:DX -> ASCIZ filename (no wildcards, but see notes)\nReturn:\nCF = error flag\nAX = error code\nINT 21 - SET CURRENT FILE POSITION\nAH = 42h\nAL = origin of move\nBX = file handle\nCX:DX = offset from origin of new file position\nReturn:\nCF = error flag\nDX:AX = new file position in bytes from start of file\nAX = error code in case of error\nINT 21 - GET FILE ATTRIBUTES\nAX = 4300h\nDS:DX -> ASCIZ filename\nReturn:\nCF = error flag\nCX = file attributes\nAX = error code\nINT 21 - SET FILE ATTRIBUTES\nAX = 4301h\nCX = new file attributes\nDS:DX -> ASCIZ filename\nReturn:\nCF = error flag\nAX = error code\nWe will use some of these services to find that two files are same in\ncontents or different. We will read the file names from the command prompt.\nThe command string is passed to the program in the program segment prefix\nlocated at offset 0 in the current segment. The area from 0-7F contains\ninformation for DOS, while the command tail length is stored at 80. From 81\nto FF, the actual command tail is stored terminated by a CR (Carriage\nRetrun).\nVirtual University of Pakistan 154\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 13.3\n001 ; file comparison using dos services\n002 [org 0x0100]\n003 jmp start\n004\n005 filename1: times 128 db 0 ; space for first filename\n006 filename2: times 128 db 0 ; space for second filename\n007 handle1: dw 0 ; handle for first file\n008 handle2: dw 0 ; handle for second file\n009 buffer1: times 4096 db 0 ; buffer for first file\n010 buffer2: times 4096 db 0 ; buffer for second file\n011\n012 format: db 'Usage error: diff <filename1> <filename2>$'\n013 openfailed: db 'First file could not be opened$'\n014 openfailed2: db 'Second file could not be opened$'\n015 readfailed: db 'First file could not be read$'\n016 readfailed2: db 'Second file could not be read$'\n017 different: db 'Files are different$'\n018 same: db 'Files are same$'\n019\n020 start: mov ch, 0\n021 mov cl, [0x80] ; command tail length in cx\n022 dec cx ; leave the first space\n023 mov di, 0x82 ; start of command tail in di\n024 mov al, 0x20 ; space for parameter separation\n025 cld ; auto increment mode\n026 repne scasb ; search space\n027 je param2 ; if found, proceed\n028 mov dx, format ; else, select error message\n029 jmp error ; proceed to error printing\n030\n031 param2: push cx ; save original cx\n032 mov si, 0x82 ; set si to start of param\n033 mov cx, di ; set di to end of param\n034 sub cx, 0x82 ; find param size in cx\n035 dec cx ; excluding the space\n036 mov di, filename1 ; set di to space for filename 1\n037 rep movsb ; copy filename there\n038 mov byte [di], 0 ; terminate filename with 0\n039 pop cx ; restore original cx\n040 inc si ; go to start of next filename\n041 mov di, filename2 ; set di to space for filename 2\n042 rep movsb ; copy filename there\n043 mov byte [di], 0 ; terminate filename with 0\n044\n045 mov ah, 0x3d ; service 3d \u2013 open file\n046 mov al, 0 ; readonly mode\n047 mov dx, filename1 ; address of filename\n048 int 0x21 ; dos services\n049 jnc open2 ; if no error, proceed\n050 mov dx, openfailed ; else, select error message\n051 jmp error ; proceed to error printing\n052\n053 open2: mov [handle1], ax ; save handle for first file\n054 mov ah, 0x3d ; service 3d \u2013 open file\n055 mov al, 0 ; readonly mode\n056 mov dx, filename2 ; address of filename\n057 int 0x21 ; dos services\n058 jnc store2 ; if no error, proceed\n059 mov dx, openfailed2 ; else, select error message\n060 jmp error ; proceed to error printing\n061\n062 store2: mov [handle2], ax ; save handle for second file\n063\n064 readloop: mov ah, 0x3f ; service 3f \u2013 read file\n065 mov bx, [handle1] ; handle for file to read\n066 mov cx, 4096 ; number of bytes to read\n067 mov dx, buffer1 ; buffer to read in\n068 int 0x21 ; dos services\n069 jnc read2 ; if no error, proceed\n070 mov dx, readfailed ; else, select error message\n071 jmp error ; proceed to error printing\n072\n073 read2: push ax ; save number of bytes read\n074 mov ah, 0x3f ; service 3f \u2013 read file\nVirtual University of Pakistan 155\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n075 mov bx, [handle2] ; handle for file to read\n076 mov cx, 4096 ; number of bytes to read\n077 mov dx, buffer2 ; buffer to read in\n078 int 0x21 ; dos services\n079 jnc check ; if no error, proceed\n080 mov dx, readfailed2 ; else, select error message\n081 jmp error ; proceed to error printing\n082\n083 check: pop cx ; number of bytes read of file 1\n084 cmp ax, cx ; are number of byte same\n085 je check2 ; yes, proceed to compare them\n086 mov dx, different ; no, files are different\n087 jmp error ; proceed to message printing\n088\n089 check2: test ax, ax ; are zero bytes read\n090 jnz compare ; no, compare them\n091 mov dx, same ; yes, files are same\n092 jmp error ; proceed to message printing\n093\n094 compare: mov si, buffer1 ; point si to file 1 buffer\n095 mov di, buffer2 ; point di to file 2 buffer\n096 repe cmpsb ; compare the two buffers\n097 je check3 ; if equal, proceed\n098 mov dx, different ; else, files are different\n099 jmp error ; proceed to message printing\n100\n101 check3: cmp ax, 4096 ; were 4096 bytes read\n102 je readloop ; yes, try to read more\n103 mov dx, same ; no, files are same\n104\n105 error: mov ah, 9 ; service 9 \u2013 output message\n106 int 0x21 ; dos services\n107\n108 mov ah, 0x3e ; service 3e \u2013 close file\n109 mov bx, [handle1] ; handle of file to close\n110 int 0x21 ; dos services\n111\n112 mov ah, 0x3e ; service 3e \u2013 close file\n113 mov bx, [handle2] ; handle of file to close\n114 int 0x21 ; dos services\n115\n116 mov ax, 0x4c00 ; terminate program\n117 int 0x21\nAnother interesting service that DOS provides regarding files is executing\nthem. An important point to understand here is that whenever a program is\nexecuted in DOS all available memory is allocated to it. No memory is\navailable to execute any new programs. Therefore memory must be freed\nusing explicit calls to DOS for this purpose before a program is executed.\nImportant services in this regard are listed below.\nINT 21 - ALLOCATE MEMORY\nAH = 48h\nBX = number of paragraphs to allocate\nReturn:\nCF = error flag\nAX = segment of allocated block or error code in case of error\nBX = size of largest available block in case of error\nINT 21 - FREE MEMORY\nAH = 49h\nES = segment of block to free\nReturn:\nCF = error flag\nAX = error code\nINT 21 - RESIZE MEMORY BLOCK\nAH = 4Ah\nBX = new size in paragraphs\nES = segment of block to resize\nVirtual University of Pakistan 156\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nReturn:\nCF = error flag\nAX = error code\nBX = maximum paragraphs available for specified memory block\nINT 21 - LOAD AND/OR EXECUTE PROGRAM\nAH = 4Bh\nAL = type of load (0 = load and execute)\nDS:DX -> ASCIZ program name (must include extension)\nES:BX -> parameter block\nReturn:\nCF = error flag\nAX = error code\nThe format of parameter block is as follows.\nOffset Size Description\n00h WORD segment of environment to copy for child process\n(copy caller's environment if 0000h)\n02h DWORD pointer to command tail to be copied into child's PSP\n06h DWORD pointer to first FCB to be copied into child's PSP\n0Ah DWORD pointer to second FCB to be copied into child's PSP\n0Eh DWORD (AL=01h) will hold subprogram's initial SS:SP on return\n12h DWORD (AL=01h) will hold entry point (CS:IP) on return\nAs an example we will use the multitasking kernel client from the\nmultitasking chapter and modify it such that after running all three threads\nit executes a new instance of the command prompt instead of indefinitely\nhanging around.\nExample 13.4\n001 ; another multitasking TSR caller\n002 [org 0x0100]\n003 jmp start\n004\n005 ; parameter block layout:\n006 ; cs,ip,ds,es,param\n007 ; 0, 2, 4, 6, 8\n008\n009 paramblock: times 5 dw 0 ; space for parameters\n010 lineno: dw 0 ; line number for next thread\n011 chars: db '\\|/-' ; chracters for rotating bar\n012 message: db 'moving hello' ; moving string\n013 message2: db ' ' ; to erase previous string\n014 messagelen: dw 12 ; length of above strings\n015 tail: db ' ',13\n016 command: db 'COMMAND.COM', 0\n017 execblock: times 11 dw 0\n018\n019-062 ;;;;; COPY LINES 028-071 FROM EXAMPLE 10.1 (printnum) ;;;;;\n063-104 ;;;;; COPY LINES 073-114 FROM EXAMPLE 10.1 (printstr) ;;;;;\n104-127 ;;;;; COPY LINES 103-126 FROM EXAMPLE 11.5 (mytask) ;;;;;\n128-146 ;;;;; COPY LINES 128-146 FROM EXAMPLE 11.5 (mytask2) ;;;;;\n147-192 ;;;;; COPY LINES 148-193 FROM EXAMPLE 11.5 (mytask3) ;;;;;\n193\n194 start: mov [paramblock+0], cs ; code segment parameter\n195 mov word [paramblock+2], mytask ; offset parameter\n196 mov [paramblock+4], ds ; data segment parameter\n197 mov [paramblock+6], es ; extra segment parameter\n198 mov word [paramblock+8], 0 ; parameter for thread\n199 mov si, paramblock ; address of param block in si\n200 int 0x80 ; multitasking kernel interrupt\n201\n202 mov [paramblock+0], cs ; code segment parameter\n203 mov word [paramblock+2], mytask2 ; offset parameter\n204 mov [paramblock+4], ds ; data segment parameter\nVirtual University of Pakistan 157\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n205 mov [paramblock+6], es ; extra segment parameter\n206 mov word [paramblock+8], 0 ; parameter for thread\n207 mov si, paramblock ; address of param block in si\n208 int 0x80 ; multitasking kernel interrupt\n209\n210 mov [paramblock+0], cs ; code segment parameter\n211 mov word [paramblock+2], mytask3 ; offset parameter\n212 mov [paramblock+4], ds ; data segment parameter\n213 mov [paramblock+6], es ; extra segment parameter\n214 mov word [paramblock+8], 0 ; parameter for thread\n215 mov si, paramblock ; address of param block in si\n216 int 0x80 ; multitasking kernel interrupt\n217\n218 mov ah, 0x4a ; service 4a \u2013 resize memory\n219 mov bx, end ; end of memory retained\n220 add bx, 15 ; rounding up\n221 mov cl, 4\n222 shr bx, cl ; converting into paras\n223 int 0x21 ; dos services\n224\n225 mov ah, 0x4b ; service 4b - exec\n226 mov al, 0 ; load and execute\n227 mov dx, command ; command to be executed\n228 mov bx, execblock ; address of execblock\n229 mov word [bx+2], tail ; offset of command tail\n230 mov [bx+4], ds ; segment of command tail\n231 int 0x21 ; dos services\n232\n233 jmp $ ; loop infinitely if returned\n234 end:\n13.4. DEVICE DRIVERS\nDevice drivers are operating system extensions that become part of the\noperating system and extend its services to new devices. Device drivers in\nDOS are very simple. They just have their services exposed through the file\nsystem interface.\nDevice driver file starts with a header containing a link to the next driver in\nthe first four bytes followed by a device attribute word. The most important\nbit in the device attribute word is bit 15 which dictates if it is a character\ndevice or a block device. If the bit is zero the device is a character device and\notherwise a block device. Next word in the header is the offset of a strategy\nroutine, and then is the offset of the interrupt routine and then in one byte,\nthe number of units supported is stored. This information is padded with\nseven zeroes.\nStrategy routine is called whenever the device is needed and it is passed a\nrequest header. Request header stores the unit requested, the command\ncode, space for return value and buffer pointers etc. Important command\ncodes include 0 to initialize, 1 to check media, 2 to build a BIOS parameter\nblock, 4 and 8 for read and write respectively. For every command the first\n13 bytes of request header are same.\nRH+0 BYTE Length of request header\nRH+1 BYTE Unit requested\nRH+2 BYTE Command code\nRH+3 BYTE Driver\u2019s return code\nRH+5 9 BYTES Reserved\nThe request header details for different commands is listed below.\n0 \u2013 Driver Initialization\nPassed to driver\nRH+18 DWORD Pointer to character after equal sign on CONFIG.SYS line\nthat loaded driver (read-only)\nVirtual University of Pakistan 158\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nRH+22 BYTE Drive number for first unit of this block driver\n(0=A...)\nReturn from driver\nRH+13 BYTE Number of units (block devices only)\nRH+14 DWORD Address of first free memory above driver (break\naddress)\nRH+18 DWORD BPB pointer array (block devices only)\n1 \u2013 Media Check\nRH+13 BYTE Media descriptor byte\nReturn\nRH+14 BYTE Media change code\n-1 if disk changed\n0 if dont know whether disk changed\n1 if disk not changed\nRH+15 DWORD pointer to previous volume label if device attrib bit\n11=1 (open/close/removable media supported)\n2 \u2013 Build BPB\nRH+13 BYTE Media descriptor byte\nRH+14 DWORD buffer address (one sector)\nReturn\nRH+18 DWORD pointer to new BPB\nif bit 13 (ibm format) is set buffer is first sector of fat, otherwise\nscrach space\n4 \u2013 Read / 8 \u2013 Write / 9 \u2013 Write with verify\nRH+13 BYTE Media descriptor byte\nRH+14 DWORD transfer address\nRH+18 WORD byte or sector count\nRH+20 WORD starting sector number (for block devices)\nReturn\nRH+18 WORD actual byte or sectors transferred\nRH+22 DWORD pointer to volume label if error 0Fh is returned\nThe BIOS parameter block discussed above is a structure that provides\nparameters about the storage medium. It is stored in the first sector or the\nboot sector of the device. Its contents are listed below.\n00-01 bytes per sector\n02 sectors per allocation unit\n03-04 Number of reserved sectors ( 0 based)\n05 number of file allocation tables\n06-07 max number of root directory entries\n08-09 total number of sectors in medium\n0A media descriptor byte\n0B-0C number of sectors occupied by a single FAT\n0D-0E sectors per track (3.0 or later)\n0F-10 number of heads (3.0 or later)\n11-12 number of hidden sectors (3.0 or later)\n13-14 high-order word of number of hidden sectors (4.0)\n15-18 IF bytes 8-9 are zero, total number of sectors in medium\n19-1E Reserved should be zero\nWe will be building an example device driver that takes some RAM and\nexpresses it as a secondary storage device to the operating system. Therefore\na new drive is added and that can be browsed to, filed copied to and from\njust like ordinary drives expect that this drive is very fast as it is located in\nthe RAM. This program cannot be directly executed since it is not a user\nprogram. This must be loaded by adding the line \u201cdevice=filename.sys\u201d in the\n\u201cconfig.sys\u201d file in the root directory.\nVirtual University of Pakistan 159\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nExample 13.5\n001 ; ram disk dos block device driver\n002 header: dd -1 ; no next driver\n003 dw 0x2000 ; driver attributes: block device\n004 dw strategy ; offset of strategy routine\n005 dw interrupt ; offset of interrupt routine\n006 db 1 ; no of units supported\n007 times 7 db 0 ; reserved\n008\n009 request: dd 0 ; space for request header\n010\n011 ramdisk: times 11 db 0 ; initial part of boot sector\n012 bpb: dw 512 ; bytes per sector\n013 db 1 ; sectors per cluster\n014 dw 1 ; reserved sectors\n015 db 1 ; fat copies\n016 dw 48 ; root dir entries\n017 dw 105 ; total sectors\n018 db 0xf8 ; media desc byte: fixed disk\n019 dw 1 ; sectors per fat\n020 times 482 db 0 ; remaining part of boot sector\n021 db 0xfe, 0xff, 0xff ; special bytes at start of FAT\n022 times 509 db 0 ; remaining FAT entries unused\n023 times 103*512 db 0 ; 103 sectors for data\n024 bpbptr: dw bpb ; array of bpb pointers\n025\n026 dispatch: dw init ; command 0: init\n027 dw mediacheck ; command 1: media check\n028 dw getbpb ; command 2: get bpb\n029 dw unknown ; command 3: not handled\n030 dw input ; command 4: input\n031 dw unknown ; command 5: not handled\n032 dw unknown ; command 6: not handled\n033 dw unknown ; command 7: not handled\n034 dw output ; command 8: output\n035 dw output ; command 9: output with verify\n036\n037 ; device driver strategy routine\n038 strategy: mov [cs:request], bx ; save request header offset\n039 mov [cs:request+2], es ; save request header segment\n040 retf\n041\n042 ; device driver interrupt routine\n043 interrupt: push ax\n044 push bx\n045 push cx\n046 push dx\n047 push si\n048 push di\n049 push ds\n050 push es\n051\n052 push cs\n053 pop ds\n054\n055 les di, [request]\n056 mov word [es:di+3], 0x0100\n057 mov bl, [es:di+2]\n058 mov bh, 0\n059 cmp bx, 9\n060 ja skip\n061 shl bx, 1\n062\n063 call [dispatch+bx]\n064\n065 skip: pop es\n066 pop ds\n067 pop di\n068 pop si\n069 pop dx\n070 pop cx\n071 pop bx\n072 pop ax\n073 retf\n074\nVirtual University of Pakistan 160\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n075 mediacheck: mov byte [es:di+14], 1\n076 ret\n077\n078 getbpb: mov word [es:di+18], bpb\n079 mov [es:di+20], ds\n080 ret\n081\n082 input: mov ax, 512\n083 mul word [es:di+18]\n084 mov cx, ax\n085\n086 mov ax, 512\n087 mul word [es:di+20]\n088 mov si, ax\n089 add si, ramdisk\n090\n091 les di, [es:di+14]\n092 cld\n093 rep movsb\n094 ret\n095\n096 output: mov ax, 512\n097 mul word [es:di+18]\n098 mov cx, ax\n099\n100 lds si, [es:di+14]\n101 mov ax, 512\n102 mul word [es:di+20]\n103 mov di, ax\n104 add di, ramdisk\n105\n106 push cs\n107 pop es\n108 cld\n109 rep movsb\n110 unknown: ret\n111\n112 init: mov ah, 9\n113 mov dx, message\n114 int 0x21\n115\n116 mov byte [es:di+13], 1\n117 mov word [es:di+14], init\n118 mov [es:di+16], ds\n119 mov word [es:di+18], bpbptr\n120 mov [es:di+20], ds\n121 ret\n122\n123 message: db 13, 10, 'RAM Disk Driver loaded',13,10,'$'\nVirtual University of Pakistan 161\n\n14\nSerial Port Programming\n14.1. INTRODUCTION\nSerial port is a way of communication among two devices just like the\nparallel port. The basic difference is that whole bytes are sent from one place\nto another in case of parallel port while the bits are sent one by one on the\nserial port in a specially formatted fashion. The serial port connection is a\n9pin DB-9 connector with pins assigned as shown below.\n1 \u2013 Carrier Detect\n6 \u2013 Data Set (CD)\nReady 2 \u2013 Received Data\n(DSR) (RD)\n7 \u2013 Request to 3 \u2013 Transmitted\nSend (RTS) Data (TD)\n8 \u2013 Clear to Send 4 \u2013 Data Terminal\n(CTS) Ready\n9 \u2013 Ring Indicator (DTR)\n(RI) 5 \u2013 Signal Ground\nWe have made a wire that connects signal ground of the two connectors,\nthe TD of one to the RD of the other and the RD of one to the TD of the other.\nThis three wire connection is sufficient for full duplex serial communication.\nThe data on the serial port is sent in a standard format called RS232\ncommunication. The data starts with a 1 bit called the start bit, then five to\neight data bits, an optional parity bit, and one to two 0 bits called stop bits.\nThe number of data bits, parity bits, and the number of stop bits have to be\nconfigured at both ends. Also the duration of a bit must be precisely known\nat both ends called the baud rate of the communication.\nThe BIOS INT 14 provides serial port services. We will use a mix of BIOS\nservices and direct port access for our example. A major limitation in using\nBIOS is that it does not allows interrupt driven data transfer, i.e. we are\ninterrupted whenever a byte is ready to be read or a byte can be transferred\nsince the previous transmission has completed. To achieve this we have to\nresort to direct port access. Important BIOS services regarding the serial port\nare discussed below.\nINT 14 - SERIAL - INITIALIZE PORT\nAH = 00h\nAL = port parameters\nDX = port number (00h-03h)\nReturn:\nAH = line status\nAL = modem status\nEvery bit of line status conveys different information. From most\nsignificant to least significant, the meanings are timeout, transmitter shift\nregister empty, transmitter holding register empty, break detect, receiver\nready, overrun, parity error, and framing error. Modem status is not used in\ndirect serial communication. The port parameters in AL consist of the baud\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nrate, parity scheme, number of stop bits, and number of data bits. The\ndescription of various bits is as under.\n7 6 5 4 3 2 1 0\ndata bits\nbaud rate\n00-5\n000-110\n01-6\n001-150\n10-7\n010-300\nparity 11-8\n011-600\n00-N\n100-1200\n10-N\n101-2400 stop bits\n110-4800 01-O 0-1\n111-9600 11-E 1-2\nINT 14 - SERIAL - WRITE CHARACTER TO PORT\nAH = 01h\nAL = character to write\nDX = port number (00h-03h)\nReturn:\nAH bit 7 = error flag\nAH bits 6-0 = port status\nINT 14 - SERIAL - READ CHARACTER FROM PORT\nAH = 02h\nDX = port number (00h-03h)\nReturn:\nAH = line status\nAL = received character if AH bit 7 clear\nINT 14 - SERIAL - GET PORT STATUS\nAH = 03h\nDX = port number (00h-03h)\nReturn:\nAH = line status\nAL = modem status\nSerial port is also accessible via I/O ports. COM1 is accessible via ports\n3F8-3FF while COM2 is accessible via 2F8-2FF. The first register at 3F8 (or\n2F8 for the other port) is the transmitter holding register if written to and the\nreceiver buffer register if read from. Other registers of our interest include\n3F9 whose bit 0 must be set to enable received data available interrupt and\nbit 1 must be set to enable transmitter holding register empty interrupt. Bit 0\nof 3FA is set if an interrupt is pending and its bits 1-3 identify the cause of\nthe interrupt. The three bit causes are as follows.\n110 (16550, 82510) timeout interrupt pending\n101 (82510) timer interrupt\n100 (82510) transmit machine\n011 receiver line status interrupt. priority=highest\n010 received data available register interrupt. priority=second\n001 transmitter holding register empty interrupt. priority=third\n000 modem status interrupt. priority=fourth\nThe register at 3FB is line control register while the one at 3FD is line\nstatus register. The line status register has the same bits as returned in line\nstatus by the get port status BIOS interrupt however the most significant bit\nVirtual University of Pakistan 164\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nis reserved in this case instead of signaling a timeout. The register at 3FC is\nthe modem control register. Bit 3 of this register must be set to enable\ninterrupt generation by the serial port.\n14.2. SERIAL COMMUNICATION\nWe give an example where two computers are connected using a serial\ncable made just as described above. The program is to be run on both\ncomputers. After that whatever is typed on one computer appears on the\nscreen of the other.\nExample 14.1\n001 ; a program using serial port to transfer data back and forth\n002 [org 0x0100]\n003 jmp start\n004\n005 screenpos: dw 0 ; where to display next character\n006\n007 ; subroutine to clear the screen\n008 clrscr: push es\n009 push ax\n010 push cx\n011 push di\n012\n013 mov ax, 0xb800\n014 mov es, ax ; point es to video base\n015 xor di, di ; point di to top left column\n016 mov ax, 0x0720 ; space char in normal attribute\n017 mov cx, 2000 ; number of screen locations\n018\n019 cld ; auto increment mode\n020 rep stosw ; clear the whole screen\n021\n022 pop di\n023 pop cx\n024 pop ax\n025 pop es\n026 ret\n027\n028 serial: push ax\n029 push bx\n030 push dx\n031 push es\n032\n033 mov dx, 0x3FA ; interrupt identification register\n034 in al, dx ; read register\n035 and al, 0x0F ; leave lowerniblle only\n036 cmp al, 4 ; is receiver data available\n037 jne skipall ; no, leave interrupt handler\n038\n039 mov dx, 0x3F8 ; data register\n040 in al, dx ; read character\n041\n042 mov dx, 0xB800\n043 mov es, dx ; point es to video memory\n044 mov bx, [cs:screenpos] ; get current screen position\n045 mov [es:bx], al ; write character on screen\n046 add word [cs:screenpos], 2 ; update screen position\n047 cmp word [cs:screenpos], 4000 ; is the screen full\n048 jne skipall ; no, leave interrupt handler\n049\n050 call clrscr ; clear the screen\n051 mov word [cs:screenpos], 0 ; reset screen position\n052\n053 skipall: mov al, 0x20\n054 out 0x20, al ; end of interrupt\n055\n056 pop es\n057 pop dx\n058 pop bx\n059 pop ax\n060 iret\nVirtual University of Pakistan 165\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n061\n062 start: call clrscr ; clear the screen\n063\n064 mov ah, 0 ; initialize port service\n065 mov al, 0xE3 ; line settings = 9600, 8, N, 1\n066 xor dx, dx ; port = COM1\n067 int 0x14 ; BIOS serial port services\n068\n069 xor ax, ax\n070 mov es, ax ; point es to IVT base\n071 mov word [es:0x0C*4], serial\n072 mov [es:0x0C*4+2], cs ; hook serial port interrupt\n073\n074 mov dx, 0x3FC ; modem control register\n075 in al, dx ; read register\n076 or al, 8 ; enable bit 3 (OUT2)\n077 out dx, al ; write back to register\n078\n079 mov dx, 0x3F9 ; interrupt enable register\n080 in al, dx ; read register\n081 or al, 1 ; receiver data interrupt enable\n082 out dx, al ; write back to register\n083\n084 in al, 0x21 ; read interrupt mask register\n085 and al, 0xEF ; enable IRQ 4\n086 out 0x21, al ; write back to register\n087\n088 main: mov ah, 0 ; read key service\n089 int 0x16 ; BIOS keybaord services\n090 push ax ; save key for later use\n091\n092 retest: mov ah, 3 ; get line status\n093 xor dx, dx ; port = COM1\n094 int 0x14 ; BIOS keyboard services\n095 and ah, 32 ; trasmitter holding register empty\n096 jz retest ; no, test again\n097\n098 pop ax ; load saved key\n099 mov dx, 0x3F8 ; data port\n100 out dx, al ; send on serial port\n101\n102 jmp main\nVirtual University of Pakistan 166\n15\nProtected Mode\nProgramming\n15.1. INTRODUCTION\nTill now we have been discussing the 8088 architecture which was a 16bit\nprocessor. Newer processors of the Intel series provide 32bit architecture. Till\nnow we were in real mode of a newer processor which is basically a\ncompatibility mode making the newer processor just a faster version of the\noriginal 8088. Switching processor in the newer 32bit mode is a very easy\ntask. Just turn on the least significant bit of a new register called CR0\n(Control Register 0) and the processor switches into 32bit mode called\nprotected mode. However manipulations in the protected mode are very\ndifferent from those in the read mode.\nAll registers in 386 have been extended to 32bits. The new names are EAX,\nEBX, ECX, EDX, ESI, EDI, ESP, EBP, EIP, and EFLAGS. The original names\nrefer to the lower 16bits of these registers. A 32bit address register can\naccess upto 4GB of memory so memory access has increased a lot.\nAs regards segment registers the scheme is not so simple. First of all we\ncall them segment selectors instead of segment registers and they are still\n16bits wide. We are also given two other segment selectors FS and GS for no\nspecific purpose just like ES.\nThe working of segment registers as being multiplied by 10 and added into\nthe offset for obtaining the physical address is totally changed. Now the\nselector is just an index into an array of segment descriptors where each\ndescriptor describes the base, limit, and attributes of a segment. Role of\nselector is to select on descriptor from the table of descriptors and the role of\ndescriptor is to define the actual base address. This decouples the selection\nand actual definition which is needed in certain protection mechanisms\nintroduced into this processor. For example an operating system can define\nthe possible descriptors for a program and the program is bound to select\none of them and nothing else. This sentence also hints that the processor\nhas some sense of programs that can or cannot do certain things like change\nthis table of descriptors. This is called the privilege level of the program and\nvaries for 0 (highest privilege) to 3 (lowest privilege). The format of a selector\nis shown below.\nThe table index (TI) is set to 0 to access the global table of descriptors\ncalled the GDT (Global Descriptor Table). It is set to 1 to access another\ntable, the local descriptor table (LDT) that we will not be using. RPL is the\nrequested privilege level that ranges from 0-3 and informs what privilege level\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nthe program wants when using this descriptor. The 13bit index is the actual\nindex into the GDT to select the appropriate descriptor. 13 bits mean that a\nmaximum of 8192 descriptors are possible in the GDT.\nThe GDT itself is an array of descriptors where each descriptor is an 8byte\nentry. The base and limit of GDT is stored in a 48bit register called the\nGDTR. This register is loaded with a special instruction LGDT and is given a\nmemory address from where the 48bits are fetched. The first entry of the\nGDT must always be zero. It is called the null descriptor. After that any\nnumber of entries upto a maximum of 8191 can follow. The format of a code\nand data descriptor is shown below.\nThe 32bit base in both descriptors is scattered into different places\nbecause of compatibility reasons. The limit is stored in 20 bits but the G bit\ndefines that the limit is in terms of bytes of 4K pages therefore a maximum of\n4GB size is possible. The P bit must be set to signal that this segment is\npresent in memory. DPL is the descriptor privilege level again related to the\nprotection levels in 386. D bit defines that this segment is to execute code is\n16bit mode or 32bit mode. C is conforming bit that we will not be using. R\nsignals that the segment is readable. A bit is automatically set whenever the\nsegment is accessed. The combination of S (system) and X (executable) tell\nthat the descriptors is a code or a data descriptor. B (big) bit tells that if this\ndata segment is used as stack SP is used or ESP is used.\nOur first example is a very rudimentary one that just goes into protected\nmode and prints an A on the screen by directly accessing 000B8000.\nExample 15.1\n001 [org 0x0100]\n002 jmp start\n003\n004 gdt: dd 0x00000000, 0x00000000 ; null descriptor\n005 dd 0x0000FFFF, 0x00CF9A00 ; 32bit code\n006 ; \\--/\\--/ \\/||||\\/\n007 ; | | | ||||+--- Base (16..23)=0 fill later\n008 ; | | | |||+--- X=1 C=0 R=1 A=0\n009 ; | | | ||+--- P=1 DPL=00 S=1\n010 ; | | | |+--- Limit (16..19) = F\n011 ; | | | +--- G=1 D=1 r=0 AVL=0\nVirtual University of Pakistan 168\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n012 ; | | +--- Base (24..31) = 0\n013 ; | +--- Limit (0..15) = FFFF\n014 ; +--- Base (0..15)=0 fill later\n015 dd 0x0000FFFF, 0x00CF9200 ; data\n016 ; \\--/\\--/ \\/||||\\/\n017 ; | | | ||||+--- Base (16..23) = 0\n018 ; | | | |||+--- X=0 E=0 W=1 A=0\n019 ; | | | ||+--- P=1 DPL=00 S=1\n020 ; | | | |+--- Limit (16..19) = F\n021 ; | | | +--- G=1 B=1 r=0 AVL=0\n022 ; | | +--- Base (24..31) = 0\n023 ; | +--- Limit (0..15) = FFFF\n024 ; +--- Base (0..15) = 0\n025\n026 gdtreg: dw 0x17 ; 16bit limit\n027 dd 0 ; 32bit base (filled later)\n028\n029 stack: times 256 dd 0 ; for use in p-mode\n030 stacktop:\n031\n032 start: mov ax, 0x2401\n033 int 0x15 ; enable A20\n034\n035 xor eax, eax\n036 mov ax, cs\n037 shl eax, 4\n038 mov [gdt+0x08+2], ax\n039 shr eax, 16\n040 mov [gdt+0x08+4], al ; fill base of code desc\n041\n042 xor edx, edx\n043 mov dx, cs\n044 shl edx, 4\n045 add edx, stacktop ; edx = stack top for p-\n046 mode\n047\n048 xor eax, eax\n049 mov ax, cs\n050 shl eax, 4\n051 add eax, gdt\n052 mov [gdtreg+2], eax ; fill phy base of gdt\n053 lgdt [gdtreg] ; load gdtr\n054\n055 mov eax, cr0\n056 or eax, 1\n057\n058 cli ; MUST disable interrupts\n059 mov cr0, eax ; P-MODE ON\n060 jmp 0x08:pstart ; load cs\n061\n062 ;;;;; 32bit protected mode ;;;;;\n063\n064 [bits 32] ; ask assembler to generate 32bit code\n065 pstart: mov eax, 0x10\n066 mov ds, ax\n067 mov es, ax ; load other seg regs\n068 mov fs, ax ; flat memory model\n069 mov gs, ax\n070 mov ss, ax\n071 mov esp, edx\n072\n073 mov byte [0x000b8000], 'A' ; direct poke at video\n074 jmp $ ; hang around\n075\nGate A20 is a workaround for a bug that is not detailed here. The BIOS call\nwill simply enable it to open the whole memory for us. Another important\nthing is that the far jump we used loaded 8 into CS but CS is now a selector\nso it means Index=1, TI=0, and RPL=0 and therefore the actual descriptor\nloaded is the one at index 1 in the GDT.\nVirtual University of Pakistan 169\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n15.2. 32BIT PROGRAMMING\nOur next example is to give a falvour of 32bit programming. We have\nwritten the printstr function for read and for protected mode. The availability\nof larger registers and flexible addressing rules allows writing a much\ncomprehensive version of the code. Also offsets to parameters and default\nwidths change.\nExample 15.2\n001 [org 0x0100]\n002 jmp start\n003\n004 gdt: dd 0x00000000, 0x00000000 ; null descriptor\n005 dd 0x0000FFFF, 0x00CF9A00 ; 32bit code\n006 dd 0x0000FFFF, 0x00CF9200 ; data\n007\n008 gdtreg: dw 0x17 ; 16bit limit\n009 dd 0 ; 32bit base\n010\n011 rstring: db 'In Real Mode...', 0\n012 pstring: db 'In Protected Mode...', 0\n013\n014 stack: times 256 dd 0 ; 1K stack\n015 stacktop:\n016\n017 printstr: push bp ; real mode print string\n018 mov bp, sp\n019 push ax\n020 push cx\n021 push si\n022 push di\n023 push es\n024\n025 mov di,[bp+4] ;load string address\n026 mov cx,0xffff ;load maximum possible size in cx\n027 xor al,al ;clear al reg\n028 repne scasb ;repeat scan\n029 mov ax,0xffff ;\n030 sub ax,cx ;calculate length\n031 dec ax ;off by one, as it includes zero\n032 mov cx,ax ;move length to counter\n033\n034 mov ax, 0xb800\n035 mov es, ax ; point es to video base\n036 mov ax,80 ;its a word move, clears ah\n037 mul byte [bp+8] ;its a byte mul to calc y offset\n038 add ax,[bp+10] ;add x offset\n039 shl ax,1 ;mul by 2 to get word offset\n040 mov di,ax ;load pointer\n041\n042 mov si, [bp+4] ; string to be printed\n043 mov ah, [bp+6] ; load attribute\n044\n045 cld ; set auto increment mode\n046 nextchar: lodsb ;load next char and inc si by 1\n047 stosw ;store ax and inc di by 2\n048 loop nextchar\n049\n050 pop es\n051 pop di\n052 pop si\n053 pop cx\n054 pop ax\n055 pop bp\n056 ret 8\n057\n058 start: push byte 0 ; 386 can directly push\n059 immediates\n060 push byte 10\n061 push byte 7\n062 push word rstring\n063 call printstr\n064\nVirtual University of Pakistan 170\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n065 mov ax, 0x2401\n066 int 0x15 ; enable a20\n067\n068 xor eax, eax\n069 mov ax, cs\n070 shl eax, 4\n071 mov [gdt+0x08+2], ax\n072 shr eax, 16\n073 mov [gdt+0x08+4], al ; set base of code desc\n074\n075 xor edx, edx\n076 mov dx, cs\n077 shl edx, 4\n078 add edx, stacktop ; stacktop to be used in p-mode\n079\n080 xor ebx, ebx\n081 mov bx, cs\n082 shl ebx, 4\n083 add ebx, pstring ; pstring to be used in p-mode\n084\n085 xor eax, eax\n086 mov ax, cs\n087 shl eax, 4\n088 add eax, gdt\n089 mov [gdtreg+2], eax ; set base of gdt\n090 lgdt [gdtreg] ; load gdtr\n091\n092 mov eax, cr0\n093 or eax, 1\n094\n095 cli ; disable interrupts\n096 mov cr0, eax ; enable protected mode\n097 jmp 0x08:pstart ; load cs\n098\n099 ;;;;; 32bit protected mode ;;;;;\n100\n101 [bits 32]\n102 pprintstr: push ebp ; p-mode print string routine\n103 mov ebp, esp\n104 push eax\n105 push ecx\n106 push esi\n107 push edi\n108\n109 mov edi, [ebp+8] ;load string address\n110 mov ecx, 0xffffffff ;load maximum possible size in cx\n111 xor al, al ;clear al reg\n112 repne scasb ;repeat scan\n113 mov eax, 0xffffffff ;\n114 sub eax, ecx ;calculate length\n115 dec eax ;off by one, as it includes zero\n116 mov ecx, eax ;move length to counter\n117\n118 mov eax, 80 ;its a word move, clears ah\n119 mul byte [ebp+16] ;its a byte mul to calc y\n120 offset\n121 add eax, [ebp+20] ;add x offset\n123 shl eax, 1 ;mul by 2 to get word offset\n124 add eax, 0xb8000\n125 mov edi, eax ;load pointer\n126\n127 mov esi, [ebp+8] ; string to be printed\n128 mov ah, [ebp+12] ; load attribute\n129\n130 cld ; set auto increment mode\n131 pnextchar: lodsb ;load next char and inc si by 1\n132 stosw ;store ax and inc di by 2\n133 loop pnextchar\n134\n135 pop edi\n136 pop esi\n137 pop ecx\n138 pop eax\n139 pop ebp\n140 ret 16 ; 4 args now mean 16 bytes\n141\nVirtual University of Pakistan 171\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n142 pstart: mov ax, 0x10 ; load all seg regs to 0x10\n143 mov ds, ax ; flat memory model\n144 mov es, ax\n145 mov fs, ax\n146 mov gs, ax\n147 mov ss, ax\n148 mov esp, edx ; load saved esp on stack\n149\n150 push byte 0\n133 push byte 11\n134 push byte 7\n135 push ebx\n136 call pprintstr ; call p-mode print string\n137 routine\n138\n139 mov eax, 0x000b8000\n140 mov ebx, '/-\\|'\n141\n142 nextsymbol: mov [eax], bl\n143 mov ecx, 0x00FFFFFF\n144 loop $\n145 ror ebx, 8\n146 jmp nextsymbol\n15.3. VESA LINEAR FRAME BUFFER\nAs an example of accessing a really large area of memory for which\nprotected mode is a necessity, we will be accessing the video memory in high\nresolution and high color graphics mode where the necessary video memory\nis alone above a megabyte. We will be using the VESA VBE 2.0 for a standard\nfor these high resolution modes.\nVESA is the Video Electronics Standards Association and VBE is the set of\nVideo BIOS Extensions proposed by them. The VESA VBE 2.0 standard\nincludes a linear frame buffer mode that we will be using. This mode allows\ndirect access to the whole video memory. Some important VESA services are\nlisted below.\nINT 10 \u2013 VESA \u2013 Get SuperVGA Infromation\nAX = 4F00h\nES:DI -> buffer for SuperVGA information\nReturn:\nAL = 4Fh if function supported\nAH = status\nINT 10 \u2013 VESA \u2013 Get SuperVGA Mode Information\nAX = 4F01h\nCX = SuperVGA video mode\nES:DI -> 256-byte buffer for mode information\nReturn:\nAL = 4Fh if function supported\nAH = status\nES:DI filled if no error\nINT 10 \u2013 VESA \u2013 Set VESA Video Mode\nAX = 4F02h\nBX = new video mode\nReturn:\nAL = 4Fh if function supported\nAH = status\nOne of the VESA defined modes is 4117 which is a 1024x768 mode with\n16bit color and a linear frame buffer. The 16 color bits for every pixel are\norganized in 5:6:5 format with 5 bits for red, 6 for green, and 5 for blue. This\nmakes 32 shades of red and blue and 64 shades of green and 64K total\nVirtual University of Pakistan 172\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\npossible colors. The 32bit linear frame buffer base address is available at\noffset 28 in the mode information buffer. Our example will produces shades\nof green on the screen and clear them and again print them in an infinite\nloop with delays in between.\nExample 15.3\n001 [org 0x0100]\n002 jmp start\n003\n004 modeblock: times 256 db 0\n005\n006 gdt: dd 0x00000000, 0x00000000 ; null descriptor\n007 dd 0x0000FFFF, 0x00CF9A00 ; 32bit code\n008 dd 0x0000FFFF, 0x00CF9200 ; data\n009\n010 gdtreg: dw 0x17 ; 16bit limit\n011 dd 0 ; 32bit base\n012\n013 stack: times 256 dd 0 ; 1K stack\n014 stacktop:\n015\n016 start: mov ax, 0x4f01 ; get vesa mode information\n017 mov cx, 0x4117 ; 1024*768*64K linear frame\n018 buffer\n019 mov di, modeblock\n020 int 0x10\n021 mov esi, [modeblock+0x28] ; save frame buffer base\n022\n023 mov ax, 0x4f02 ; set vesa mode\n024 mov bx, 0x4117\n025 int 0x10\n026\n027 mov ax, 0x2401\n028 int 0x15 ; enable a20\n029\n030 xor eax, eax\n031 mov ax, cs\n032 shl eax, 4\n033 mov [gdt+0x08+2], ax\n034 shr eax, 16\n035 mov [gdt+0x08+4], al ; set base of code desc\n036\n037 xor edx, edx\n038 mov dx, cs\n039 shl edx, 4\n040 add edx, stacktop ; stacktop to be used in p-mode\n041\n042 xor eax, eax\n043 mov ax, cs\n044 shl eax, 4\n045 add eax, gdt\n046 mov [gdtreg+2], eax ; set base of gdt\n047 lgdt [gdtreg] ; load gdtr\n048\n049 mov eax, cr0\n050 or eax, 1\n051\n052 cli ; disable interrupts\n053 mov cr0, eax ; enable protected mode\n054 jmp 0x08:pstart ; load cs\n055\n056 ;;;;; 32bit protected mode ;;;;;\n057\n058 [bits 32]\n059 pstart: mov ax, 0x10 ; load all seg regs to 0x10\n060 mov ds, ax ; flat memory model\n061 mov es, ax\n062 mov fs, ax\n063 mov gs, ax\n064 mov ss, ax\n065 mov esp, edx ; load saved esp on stack\n066\n067 l1: xor eax, eax\nVirtual University of Pakistan 173\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n068 mov edi, esi\n069 mov ecx, 1024*768*2/4 ; divide by 4 as dwords\n070 cld\n071 rep stosd\n072\n073 mov eax, 0x07FF07FF\n074 mov ecx, 32 ; no of bands\n075 mov edi, esi\n076\n077 l2: push ecx\n078 mov ecx, 768*16 ; band width = 32\n079 lines\n080 cld\n081 rep stosd\n082\n083 mov ecx, 0x000FFFFF ; small wait\n084 loop $\n085 pop ecx\n086\n087 sub eax, 0x00410041\n088 loop l2\n089\n090 mov ecx, 0x0FFFFFFF ; long wait\n091 loop $\n092 jmp l1\n093\n15.4. INTERRUPT HANDLING\nHandling interrupts in protected mode is also different. Instead of the IVT\nat physical address 0 there is the IDT (interrupt descriptor table) located at\nphysical address stored in IDTR, a special purpose register. The IDTR is also\na 48bit register similar in structure to the GDTR and loaded with another\nspecial instruction LGDT. The format of the interrupt descriptor is as shown\nbelow.\nThe P and DPL have the same meaning as in data and code descriptors.\nThe S bit tells that this is a system descriptor while the 1110 following it tells\nthat it is a 386 interrupt gate. Our example hooks the keyboard and timer\ninterrupts and displays certain things on the screen to show that they are\nworking.\nExample 15.4\n001 [org 0x0100]\n002 jmp start\n003\n004 gdt: dd 0x00000000, 0x00000000 ; null descriptor\n005 dd 0x0000FFFF, 0x00CF9A00 ; 32bit code\n006 dd 0x0000FFFF, 0x00CF9200 ; data\n007\n008 gdtreg: dw 0x17 ; 16bit limit\n009 dd 0 ; 32bit base\nVirtual University of Pakistan 174\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n010\n011 idt: times 8 dw unhandled, 0x0008, 0x8e00, 0x0000\n012 dw timer, 0x0008, 0x8e00, 0x0000\n013 \\---/ \\----/ ||\\/ \\----/\n014 | | || | +----- offset bits 16..32\n015 | | || +----- reserved\n016 | | |+------ Type=E 386 Interrupt Gate\n017 | | +--- P=1 DPL=00 S=0\n018 | +------- selector\n019 +-------- offset bits 0..15\n020 dw keyboard, 0x0008, 0x8e00, 0x0000\n021 times 246 dw unhandled, 0x0008, 0x8e00, 0x0000\n022\n023 idtreg: dw 0x07FF\n024 dd 0\n025\n026 stack: times 256 dd 0 ; 1K stack\n027 stacktop:\n028\n029 start: mov ax, 0x2401\n030 int 0x15 ; enable a20\n031\n032 xor eax, eax\n033 mov ax, cs\n034 shl eax, 4\n035 mov [gdt+0x08+2], ax\n036 shr eax, 16\n037 mov [gdt+0x08+4], al ; set base of code desc\n038\n039 xor edx, edx\n040 mov dx, cs\n041 shl edx, 4\n042 add edx, stacktop ; stacktop to be used in p-mode\n043\n044 xor eax, eax\n045 mov ax, cs\n046 shl eax, 4\n047 add eax, gdt\n048 mov [gdtreg+2], eax ; set base of gdt\n049 lgdt [gdtreg] ; load gdtr\n050\n051 xor eax, eax\n052 mov ax, cs\n053 shl eax, 4\n054 add eax, idt\n055 mov [idtreg+2], eax ; set base of idt\n056\n057 cli ; disable interrupts\n058 lidt [idtreg] ; load idtr\n059\n060 mov eax, cr0\n061 or eax, 1\n062 mov cr0, eax ; enable protected mode\n063\n064 jmp 0x08:pstart ; load cs\n065\n066 ;;;;; 32bit protected mode ;;;;;\n067\n068 [bits 32]\n069 unhandled: iret\n070\n071 timer: push eax\n072\n073 inc byte [0x000b8000]\n074\n075 mov al, 0x20\n076 out 0x20, al\n077 pop eax\n078 iret\n079\n080 keyboard: push eax\n081\n082 in al, 0x60\n083 mov ah, al\n084 and al, 0x0F\n085 shr ah, 4\nVirtual University of Pakistan 175\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n086 add ax, 0x3030\n087 cmp al, 0x39\n088 jbe skip1\n089 add al, 7\n090 skip1: cmp ah, 0x39\n091 jbe skip2\n092 add ah, 7\n093 skip2: mov [0x000b809C], ah\n094 mov [0x000b809E], al\n095\n096 skipkb: mov al, 0x20\n097 out 0x20, al\n098 pop eax\n099 iret\n100\n101 pstart: mov ax, 0x10 ; load all seg regs to 0x10\n102 mov ds, ax ; flat memory model\n103 mov es, ax\n104 mov fs, ax\n105 mov gs, ax\n106 mov ss, ax\n107 mov esp, edx ; load saved esp on stack\n108\n109 mov al, 0xFC\n110 out 0x21, al ; no unexpected int comes\n111\n112 sti ; interrupts are okay now\n113\n114 jmp $\nEXERCISES\n1. Write very brief and to-the-point answers.\na. Why loading idtr with a value appropriate for real mode is\nnecessary while gdtr is not?\nb. What should we do in protected mode so that when we turn\nprotection off, we are in unreal mode?\nc. If the line jmp code:next is replaced with call code:somefun,\nthe prefetch queue is still emptied. What problem will occur\nwhen somefun will return?\nd. How much is ESP decremented when an interrupt arrives.\nThis depends on weather we are in 16-bit mode or 32-bit.\nDoes it depend on any other thing as well? If yes, what?\ne. Give two instructions that change the TR register.\n2. Name the following descriptors like code descriptor, data descriptor,\ninterrupt gate etc.\ngdt: dd 0x00000000, 0x00000000\ndd 0x00000000, 0x00000000\ndd 0x80000fA0, 0x0000820b\ndd 0x0000ffff, 0x00409a00\ndd 0x80000000, 0x0001d20b\n3. Using the above GDT, which of the following values, when moved into\nDS will cause an exception and why.\n0x00\n0x08\n0x10\n0x18\n0x28\n0x23\n4. Using the above GDT, if DS contains 0x20, which of the following\noffsets will cause an exception on read access?\n0x0ffff\n0x10000\n0x10001\nVirtual University of Pakistan 176\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n5. The following function is written in 32-bit code for a 16-bit stack.\nAgainst every instruction, write the prefixes generated before that\ninstruction. Prefixes can be address size, operand size, repeat, or\nsegment override. Then rewrite the code such that no prefixes are\ngenerated considering that this is assembled and executed in 32-bit\nmode. Don\u2019t care for retaining register values. The function copies\nspecified number of DWORDs between two segments.\n[bits 32]\nmemcpy: mov bp, sp\nlds esi, [bp+4] ; source address\nles edi, [bp+10] ; destination address\nmov cx, [bp+16] ; count of DWORDs to move\nshl cx, 1 ; make into count of WORDs\nL1: mov dx, [si]\nmov [es:di], dx\ndec cx\njnz L1\nret\n6. Rewrite the following scheduler so that it schedules processes stored\nin readyQ, where enque and deque functions are redefined and\nreadyQ contains TSS selectors of processes to be multitasked.\nRemember you can\u2019t use a register as a segment in a jump (eg jmp\nax:0) but you can jump to an indirect address (eg jmp far [eax]) where\neax points to a six-byte address. Declare any variables you need.\nmov al, 0x20\nscheduler: jmp USERONESEL:0\nout 0x20, al\nmov byte [USERONEDESC+5], 0x89\njmp USERTWOSEL:0\nout 0x20, al\nmov byte [USERTWODESC+5], 0x89\njmp scheduler\n7. Protected mode has specialized mechanism for multitasking using task state\nsegments but the method used in real mode i.e. saving all registers in a PCB,\nselecting the next PCB and loading all registers from there is still applicable.\nMultitask two tasks in protected mode multitasking without TSS. Assume that\nall processes are at level zero so no protection issues arise. Be careful to\nsave the complete state of the process.\n8. Write the following descriptors.\na. 32 bit, conforming, execute-only code segment at level 2, with base\nat 6MB and a size of 4MB.\nb. 16 bit, non-conforming, readable code segment at level 0, with base\nat 1MB and a size of 10 bytes.\nc. Read only data segment at level 3, with base at 0 and size of 1MB.\nd. Interrupt Gate with selector 180h and offset 11223344h.\n9. Write physical addresses for the following accesses where CS points to the\nfirst descriptor above, DS to the second, ES to the third, EBX contains\n00010000h, and ESI contains 00020000h\na. [bx+si]\nb. [ebx+esi-2ffffh]\nc. [es:ebx-10h]\n10. Which of the following will cause exceptions and why. The registers have the\nsame values as the last question.\na. mov eax, [cs:10000h]\nb. mov [es:esi:100h], ebx\nc. mov ax, [es:ebx]\n11. Give short answers.\na. How can a GPF (General protection fault) occur while running\nthe following code\npush es\npop es\nVirtual University of Pakistan 177\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nb. How can a GPF occur during the following instruction? Give\nany two reasons.\njmp 10h:100h\nc. What will happen if we call interrupt 80h after loading out IDT\nand before switching to protected mode?\nd. What will happen if we call interrupt 80h after switching into\nprotected mode but before making a far jump?\n12. Write the following descriptors. Assume values for attributes not\nspecifically mentioned.\na. Write able 32-bit data segment with 1 GB base and 1 GB limit\nand a privilege level of 2.\nb. Readable 16-bit code descriptor with 1 MB base and 1 MB\nlimit and a privilege level of 1.\nc. Interrupt gate given that the handler is at 48h:12345678h and\na privilege level of 0.\n13. Describe the following descriptors. Give their type and the value of all\ntheir fields.\ndd 01234567h, 789abcdeh\ndd 30405060h, 70809010h\ndd 00aabb00h, 00ffee00h\n14. Make an EXE file, switch into protected mode, rotate an asterisk on\nthe border of the screen, and return to real mode when the border is\ntraversed.\nVirtual University of Pakistan 178\n16\nInterfacing with High\nLevel Languages\n16.1. CALLING CONVENTIONS\nTo interface an assembly routine with a high level language program\nmeans to be able to call functions back and forth. And to be able to do so\nrequires knowledge of certain behavior of the HLL when calling functions.\nThis behavior of calling functions is called the calling conventions of the\nlanguage. Two prevalent calling conventions are the C calling convention and\nthe Pascal calling convention.\nWhat is the naming convention\nC prepends an underscore to every function or variable name while Pascal\ntranslates the name to all uppercase. C++ has a weird name mangling\nscheme that is compiler dependent. To avoid it C++ can be forced to use C\nstyle naming with extern \u201cC\u201d directive.\nHow are parameters passed to the routine\nIn C parameters are pushed in reverse order with the rightmost being\npushed first. While in Pascal they are pushed in proper order with the\nleftmost being pushed first.\nWhich registers must be preserved\nBoth standards preserve EBX, ESI, EDI, EBP, ESP, DS, ES, and SS.\nWhich registers are used as scratch\nBoth standards do not preserve or guarantee the value of EAX, ECX, EDX,\nFS, GS, EFLAGS, and any other registers.\nWhich register holds the return value\nBoth C and Pascal return upto 32bit large values in EAX and upto 64bit\nlarge values in EDX:EAX.\nWho is responsible for removing the parameters\nIn C the caller removes the parameter while in Pascal the callee removes\nthem. The C scheme has reasons pertaining to its provision for variable\nnumber of arguments.\n16.2. CALLING C FROM ASSEMBLY\nFor example we take a function divide declared in C as follows.\nint divide( int dividend, int divisor );\nTo call this function from assembly we have to write.\npush dword [mydivisor]\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\npush dword [mydividend]\ncall _divide\nadd esp, 8\n; EAX holds the answer\nObserve the order of parameters according to the C calling conventions\nand observe that the caller cleared the stack. Now take another example of a\nfunction written in C as follows.\nvoid swap( int* p1, int* p2 )\n{\nint temp = *p1;\n*p1 = *p2;\n*p2 = temp;\n}\nTo call it from assembly we have to write this.\n[section .text]\nextern _swap\nx: dd 4\ny: dd 7\npush dword y\npush dword x\ncall _swap ; will only retain the specified registers\nadd esp, 8\nObserve how pointers were initialized appropriately. The above function\nswap was converted into assembly by the gcc compiler as follows.\n; swap generated by gcc with no optimizations (converted to Intel\nsyntax)\n; 15 instructions AND 13 memory accesses\n_swap:\npush ebp\nmov ebp, esp\nsub esp, 4 ; space created for temp\nmov eax, [ebp+8]\nmov eax, [eax]\nmov [ebp-4], eax ; temp = *p1\nmov edx, [ebp+8]\nmov eax, [ebp+12]\nmov eax, [eax]\nmov [edx], eax ; *p1 = *p2\nmov edx, [ebp+12]\nmov eax, [ebp-4]\nmov [edx], eax ; *p2 = temp\nleave ;;;;; EQUIVALENT TO mov esp, ebp AND pop ebp ;;;;;\nret\nIf we turn on optimizations the same function is compiled into the following\ncode.\nVirtual University of Pakistan 180\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\n; generated with full optimization by gcc compiler\n; 12 instructions AND 11 memory accesses\n_swap:\npush ebp\nmov ebp, esp\npush ebx\nmov edx, [ebp+8]\nmov ecx, [ebp+12]\nmov ebx, [edx]\nmov eax, [ecx]\nmov [edx], eax\nmov [ecx], ebx\npop ebx\npop ebp\nret\n16.3. CALLING ASSEMBLY FROM C\nWe now write a hand optimized version in assembly. Our version is only 6\ninstructions and 6 memory accesses.\nExample 16.1\n001 [section .text]\n002 global _swap\n003 _swap: mov ecx,[esp+4] ; copy parameter p1 to ecx\n004 mov edx,[esp+8] ; copy parameter p2 to edx\n005 mov eax,[ecx] ; copy *p1 into eax\n006 xchg eax,[edx] ; exchange eax with *p2\n007 mov [ecx],eax ; copy eax into *p1\n008 ret ; return from this function\nWe assemble the above program with the following command.\n\u2022\nnasm \u2013f win32 swap.asm\nThis produces a swap.obj file. The format directive told the assembler that\nit is to be linked with a 32bit Windows executable. The linking process\ninvolves resolving imported symbols of one object files with export symbols of\nanother. In NASM an imported symbol is declared with the extern directive\nwhile and exported symbol is declared with the global directive.\nWe write the following program in C to call this assembly routine. We\nshould have provided the swap.obj file to the C linker otherwise an\nunresolved external symbol error will come.\nExample 16.1\n001 #include <stdio.h>\n002\n003 void swap( int* p1, int* p2 );\n004\n005 int main()\n006 {\n007 int a = 10, b = 20;\n008 printf( \"a=%d b=%d\\n\", a, b );\n009 swap(&a, &b );\n010 printf( \"a=%d b=%d\\n\", a, b );\n011 system( \"PAUSE\" );\n012 return 0;\n013 }\nVirtual University of Pakistan 181\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nEXERCISES\n1. Write a traverse function in assembly, which takes an array, the\nnumber of elements in the array and the address of another function\nto be called for each member of the array. Call the function from a C\nprogram.\n2. Make the linked list functions make in Exercise 5.XX available to C\nprograms using the following declarations.\nstruct node {\nint data;\nstruct node* next;\n};\nvoid init( void );\nstruct node* createlist( void );\nvoid insertafter( struct node*, int );\nvoid deleteafter( struct node* );\nvoid deletelist( struct node* );\n3. Add two functions to the above program implemented in C. The\nfunction \u201cprintnode\u201d should print the data in the passed node using\nprintf, while \u201ccountfree\u201d should count the number of free nodes by\ntraversing the free list starting from the node address stored in\nfirstfree.\nvoid printnode( struct node* );\nvoid countfree( void );\n4. Add the function \u201cprintlist\u201d to the above program and implement in\nassembly. This function should traverse the list whose head is\npassed as parameter and for each node containing data (head is\ndummy and doesn\u2019t contain data) calls the C function printnode to\nactually print the contained data.\nvoid printlist( struct node* );\n5. Modify the createlist and deletelist functions in the above program to\nincrement and decrement an integer variable \u201clistcount\u201d declared in\nC to maintain a count of linked lists present.\nVirtual University of Pakistan 182\n17\nComparison with Other\nProcessors\nWe emphasized that assembly language has to be learned once and every\nprocessor can be programmed by that person. To give a flavour of two\ndifferent widely popular processors we introduce the Motorolla 68K series\nand the Sun SPARC processors. The Motorolla 68K processors are very\npopular in high performance embedded applications while the Sun SPARC\nprocessors are popular in very high end enterprise servers. We will compare\nthem with the Intel x86 series which is known for its success in the desktop\nmarket.\n17.1. MOTOROLLA 68K PROCESSORS\nMotorolla 68K processors are very similar to Intel x86 series in their\narchitecture and instruction set. The both are of the same era and added\nvarious features at the same time. The instructions are very similar however\nthe difference in architecture evident from a programmer\u2019s point of view must\nbe understood.\n68K processors have 16 23bit general purpose registers named from A0-A7\nand D0-D7. A0-A7 can hold addresses in indirect memory accesses. These\ncan also be used as software stack pointers. Stack in 68K is not as rigit a\nstructure as it is in x86. There is a 32bit program counter (PC) that holds the\naddress of currently executing instruction. The 8bit condition code register\n(CCR) holds the X (Extend) N (Negative) Z (Zero) V (Overflow) C (Carry) flags.\nX is set to C for extended operations (addition, subtraction, or shifting).\nMotrolla processors allow bit addressing, that is a specific bit in a byte or a\nbit field, i.e. a number of bits can be directly accessed. This is a very useful\nfeature especially in control applications. Other data types include byte,\nword, long word, and quad word. A special MOVE16 instruction also accepts\na 16byte block.\n68K allows indirect memory access using any A register. A special memory\naccess allows post increment or predecrement as part of memory access.\nThese forms are written as (An), (An)+, and \u2013(An). Other forms allow\naddressing with another regiser as index and with constant displacement.\nUsing one of the A registers as the stack pointer and using the post\nincrement and pre decrement forms of addressing, stack is implemented.\nImmediates can also be given as arguments and are preceded with a hash\nsign (#). Addressing is indicated with parenthesis instead of brackets.\n68K has no segmentation; it however has a paged memory model. It used\nthe big endian format in contrast to the little endian used by the Intel\nprocessors. It has varying instruction lengths from 1-11 words. It has a\ndecrementing stack just like the Intel one. The format of instructions is\n\u201coperation source, destination\u201d which is different from the Intel order of\noperands. Some instructions from various instruction groups are given\nbelow.\nData Movement\nEXG D0, D2\nMOVE.B (A1), (A2)\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nMOVEA (2222).L, A4\nMOVEQ #12, D7\nArithmetic\nADD D7, (A4)\nCLR (A3) (set to zero)\nCMP (A2), D1\nASL, ASR, LSL, LSR, ROR, ROL, ROXL, ROXR (shift operations)\nProgram Control\nBRA label\nJMP (A3)\nBSR label (CALL)\nJSR (A2) (indirect call)\nRTD #4 (RET N)\nConditional Branch\nBCC (branch if carry clear)\nBLS (branch if Lower or Same)\nBLT (branch if Less Than)\nBEQ (branch if Equal)\nBVC (branch if Overflow clear)\n17.2. SUN SPARC PROCESSOR\nThe Sun SPARC is a very popular processing belonging to the RISC\n(reduced instruction set computer) family of processors. RISC processors\noriginally named because of the very few rudimentary instructions they\nprovided, are now providing almost as many instruction as CISC (complex\ninstruction set computer). However some properties like a fixed instruction\nsize and single clock execution for most instructions are there.\nSPARC stands for Scalable Processor ARChitecture. SPARC is a 64bit\nprocessor. It byte order is user settable and even on a per program basis. So\none program may be using little endian byte order and another may be using\nbig endian at the same time. Data types include byte, Halfword, Word (32bit),\nand Double Word (64bits) and Quadword. It has a fixed 32bit instruction\nsize. It has a concept of ASI (Address Space Identifier); an 8bit number that\nworks similar to a segment.\nThere are 8 global registers and 8 alternate global registers. One of them is\nactive at a time and accessible as g0-g7. Apart from that it has 8 in registers\n(i0-i7), 8 local registers (l0-l7), and 8 out registers (o0-o7). All registers are\n64bit in size. The global registers can also be called r0-r7, in registers as r8-\nr15, local registers as r16-r23, and out registers as r24-r31.\nSPARC introduces a concept of register window. One window is 24\nregisters and the active window is pointed to by a special register called\nCurrent Window Pointer (CWP). The actual number of registers in the\nprocessor is in hundreds not restricted by the architecture definition. Two\ninstruction SAVE and RESTORE move this register window forward and\nbackward by 16 registers. Therefore one SAVE instruction makes the out\nregister the in registers and brings in new local and out registers. A\nRESTORE instruction makes the in registers out registers and restores the\nold local and in registers. This way parameters passing and returning can be\ntotally done in registers and there is no need to save and restore registers\ninside subroutines.\nThe register o6 is conventionally used as the stack pointer. Return address\nis stored in o7 by the CALL instruction. The register g0 (r0) is always 0 so\nloading 0 in a register is made easy. SPARC is a totally register based\narchitecture, or it is called a load-store architecture where memory access is\nonly allowed in data movement instruction. Rest of the operations must be\ndone on registers.\nVirtual University of Pakistan 184\nComputer Architecture & Assembly Language Programming Course Code: CS401\nCS401@vu.edu.pk\nSPARC instructions have two sources and a distinct destination. This\nallows more flexibility in writing programs. Some examples of instructions of\nthis processor follow.\nData Movement\nLDSB [rn], rn (load signed byte)\nLDUW [rn], rn (load unsigned word)\nSTH [rn], rn (store half word)\nArithmetic\nsource1 = rn\nsource2 = rn or simm13\ndest = rn\nADD r2, r3, r4\nSUB r2, 4000, r5\nSLL, SRA, SRL (shifting)\nAND, OR, XOR (logical)\nProgram Control\nCALL (direct call)\nJMPL (register indirect)\nRET\nSAVE\nRESTORE\nBA label (Branch Always)\nBE label (branch if equal)\nBCC label (branch if carry clear)\nBLE label (branch if less or equal)\nBVS label (branch if overflow set)\nVirtual University of Pakistan 185\n",
  "context": "grained and this is one of the basic objectives of teaching assembly language\nprogramming.\nThen there is the question that why should we learn assembly language",
  "source_file": "resources\\Year 2\\Wombat Machine\\Assembly Language Programming Lecture Notes - Belal Hashmi.pdf",
  "line_numbers": [
    50,
    10630
  ]
}
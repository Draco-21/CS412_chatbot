{
  "title": "C++ Documentation",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "C++ Language Tutorial Written by: Juan Souli\u00e9 Last revision: June, 2007",
  "code": "Available online at: http://www.cplusplus.com/doc/tutorial/\nThe online version is constantly revised and may contain corrections and changes\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThis document and its content is copyright of cplusplus.com \u00a9 cplusplus.com, 2008. All rights reserved.\nAny redistribution or reproduction of part or all of the content in any form is prohibited other than to print a\npersonal copy of the entire document or download it to a local hard disk, without modifying its content in any way\n(including, but not limited to, this copyright notice).\nYou may not, except with express written permission from cplusplus.com, distribute the content of this document.\nNor may you transmit it or store it in any other website or other form of electronic retrieval system.\n2\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nTable of contents\nTable of contents ...............................................................................................................................3\nIntroduction ......................................................................................................................................5\nInstructions for use ................................................................................................................................... 5\nBasics of C++ ......................................................................................................................................7\nStructure of a program ............................................................................................................................. 7\nVariables. Data Types. ............................................................................................................................. 11\nConstants ................................................................................................................................................ 17\nOperators ................................................................................................................................................ 21\nBasic Input/Output .................................................................................................................................. 29\nControl Structures ............................................................................................................................ 34\nControl Structures ................................................................................................................................... 34\nFunctions (I) ............................................................................................................................................ 41\nFunctions (II) ........................................................................................................................................... 47\nCompound data types ...................................................................................................................... 54\nArrays ...................................................................................................................................................... 54\nCharacter Sequences .............................................................................................................................. 60\nPointers ................................................................................................................................................... 63\nDynamic Memory .................................................................................................................................... 74\nData structures........................................................................................................................................ 77\nOther Data Types .................................................................................................................................... 82\nObject Oriented Programming .......................................................................................................... 86\nClasses (I)................................................................................................................................................. 86\nClasses (II) ............................................................................................................................................... 95\nFriendship and inheritance ................................................................................................................... 100\nPolymorphism ....................................................................................................................................... 107\nAdvanced concepts ........................................................................................................................ 113\nTemplates.............................................................................................................................................. 113\nNamespaces .......................................................................................................................................... 120\nExceptions ............................................................................................................................................. 123\nType Casting .......................................................................................................................................... 127\n3\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nPreprocessor directives ......................................................................................................................... 133\nC++ Standard Library ...................................................................................................................... 138\nInput/Output with files ......................................................................................................................... 138\n4\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nIntroduction\nInstructions for use\nTo whom is this tutorial directed?\nThis tutorial is for those people who want to learn programming in C++ and do not necessarily have any previous\nknowledge of other programming languages. Of course any knowledge of other programming languages or any\ngeneral computer skill can be useful to better understand this tutorial, although it is not essential.\nIt is also suitable for those who need a little update on the new features the language has acquired from the latest\nstandards.\nIf you are familiar with the C language, you can take the first 3 parts of this tutorial as a review of concepts, since\nthey mainly explain the C part of C++. There are slight differences in the C++ syntax for some C features, so I\nrecommend you its reading anyway.\nThe 4th part describes object-oriented programming.\nThe 5th part mostly describes the new features introduced by ANSI-C++ standard.\nStructure of this tutorial\nThe tutorial is divided in 6 parts and each part is divided on its turn into different sections covering a topic each\none. You can access any section directly from the section index available on the left side bar, or begin the tutorial\nfrom any point and follow the links at the bottom of each section.\nMany sections include examples that describe the use of the newly acquired knowledge in the chapter. It is\nrecommended to read these examples and to be able to understand each of the code lines that constitute it before\npassing to the next chapter.\nA good way to gain experience with a programming language is by modifying and adding new functionalities on\nyour own to the example programs that you fully understand. Don't be scared to modify the examples provided\nwith this tutorial, that's the way to learn!\nCompatibility Notes\nThe ANSI-C++ standard acceptation as an international standard is relatively recent. It was first published in\nNovember 1997, and revised in 2003. Nevertheless, the C++ language exists from a long time before (1980s).\nTherefore there are many compilers which do not support all the new capabilities included in ANSI-C++, especially\nthose released prior to the publication of the standard.\nThis tutorial is thought to be followed with modern compilers that support -at least on some degree- ANSI-C++\nspecifications. I encourage you to get one if yours is not adapted. There are many options, both commercial and\nfree.\nCompilers\nThe examples included in this tutorial are all console programs. That means they use text to communicate with\nthe user and to show their results.\n5\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nAll C++ compilers support the compilation of console programs. Check the user's manual of your compiler for more\ninfo on how to compile them.\n6\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nBasics of C++\nStructure of a program\nProbably the best way to start learning a programming language is by writing a program. Therefore, here is our\nfirst program:\n// my first program in C++ Hello World!\n#include <iostream>\nusing namespace std;\nint main ()\n{\ncout << \"Hello World!\";\nreturn 0;\n}\nThe first panel shows the source code for our first program. The second one shows the result of the program once\ncompiled and executed. The way to edit and compile a program depends on the compiler you are using. Depending\non whether it has a Development Interface or not and on its version. Consult the compilers section and the manual\nor help included with your compiler if you have doubts on how to compile a C++ console program.\nThe previous program is the typical program that programmer apprentices write for the first time, and its result is\nthe printing on screen of the \"Hello World!\" sentence. It is one of the simplest programs that can be written in\nC++, but it already contains the fundamental components that every C++ program has. We are going to look line\nby line at the code we have just written:\n// my first program in C++\nThis is a comment line. All lines beginning with two slash signs (//) are considered comments and do not\nhave any effect on the behavior of the program. The programmer can use them to include short\nexplanations or observations within the source code itself. In this case, the line is a brief description of\nwhat our program is.\n#include <iostream>\nLines beginning with a hash sign (#) are directives for the preprocessor. They are not regular code lines\nwith expressions but indications for the compiler's preprocessor. In this case the directive #include\n<iostream> tells the preprocessor to include the iostream standard file. This specific file (iostream)\nincludes the declarations of the basic standard input-output library in C++, and it is included because its\nfunctionality is going to be used later in the program.\nusing namespace std;\nAll the elements of the standard C++ library are declared within what is called a namespace, the\nnamespace with the name std. So in order to access its functionality we declare with this expression that\nwe will be using these entities. This line is very frequent in C++ programs that use the standard library,\nand in fact it will be included in most of the source codes included in these tutorials.\nint main ()\nThis line corresponds to the beginning of the definition of the main function. The main function is the point\nby where all C++ programs start their execution, independently of its location within the source code. It\ndoes not matter whether there are other functions with other names defined before or after it - the\ninstructions contained within this function's definition will always be the first ones to be executed in any\nC++ program. For that same reason, it is essential that all C++ programs have a main function.\nThe word main is followed in the code by a pair of parentheses (()). That is because it is a function\ndeclaration: In C++, what differentiates a function declaration from other types of expressions are these\nparentheses that follow its name. Optionally, these parentheses may enclose a list of parameters within\nthem.\nRight after these parentheses we can find the body of the main function enclosed in braces ({}). What is\ncontained within these braces is what the function does when it is executed.\n7\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\ncout << \"Hello World!\";\nThis line is a C++ statement. A statement is a simple or compound expression that can actually produce\nsome effect. In fact, this statement performs the only action that generates a visible effect in our first\nprogram.\ncout represents the standard output stream in C++, and the meaning of the entire statement is to insert\na sequence of characters (in this case the Hello World sequence of characters) into the standard output\nstream (which usually is the screen).\ncout is declared in the iostream standard file within the std namespace, so that's why we needed to\ninclude that specific file and to declare that we were going to use this specific namespace earlier in our\ncode.\nNotice that the statement ends with a semicolon character (;). This character is used to mark the end of\nthe statement and in fact it must be included at the end of all expression statements in all C++ programs\n(one of the most common syntax errors is indeed to forget to include some semicolon after a statement).\nreturn 0;\nThe return statement causes the main function to finish. return may be followed by a return code (in our\nexample is followed by the return code 0). A return code of 0 for the main function is generally interpreted\nas the program worked as expected without any errors during its execution. This is the most usual way to\nend a C++ console program.\nYou may have noticed that not all the lines of this program perform actions when the code is executed. There were\nlines containing only comments (those beginning by //). There were lines with directives for the compiler's\npreprocessor (those beginning by #). Then there were lines that began the declaration of a function (in this case,\nthe main function) and, finally lines with statements (like the insertion into cout), which were all included within\nthe block delimited by the braces ({}) of the main function.\nThe program has been structured in different lines in order to be more readable, but in C++, we do not have strict\nrules on how to separate instructions in different lines. For example, instead of\nint main ()\n{\ncout << \" Hello World!\";\nreturn 0;\n}\nWe could have written:\nint main () { cout << \"Hello World!\"; return 0; }\nAll in just one line and this would have had exactly the same meaning as the previous code.\nIn C++, the separation between statements is specified with an ending semicolon (;) at the end of each one, so\nthe separation in different code lines does not matter at all for this purpose. We can write many statements per\nline or write a single statement that takes many code lines. The division of code in different lines serves only to\nmake it more legible and schematic for the humans that may read it.\nLet us add an additional instruction to our first program:\n8\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// my second program in C++ Hello World! I'm a C++ program\n#include <iostream>\nusing namespace std;\nint main ()\n{\ncout << \"Hello World! \";\ncout << \"I'm a C++ program\";\nreturn 0;\n}\nIn this case, we performed two insertions into cout in two different statements. Once again, the separation in\ndifferent lines of code has been done just to give greater readability to the program, since main could have been\nperfectly valid defined this way:\nint main () { cout << \" Hello World! \"; cout << \" I'm a C++ program \"; return 0; }\nWe were also free to divide the code into more lines if we considered it more convenient:\nint main ()\n{\ncout <<\n\"Hello World!\";\ncout\n<< \"I'm a C++ program\";\nreturn 0;\n}\nAnd the result would again have been exactly the same as in the previous examples.\nPreprocessor directives (those that begin by #) are out of this general rule since they are not statements. They are\nlines read and processed by the preprocessor and do not produce any code by themselves. Preprocessor directives\nmust be specified in their own line and do not have to end with a semicolon (;).\nComments\nComments are parts of the source code disregarded by the compiler. They simply do nothing. Their purpose is only\nto allow the programmer to insert notes or descriptions embedded within the source code.\nC++ supports two ways to insert comments:\n// line comment\n/* block comment */\nThe first of them, known as line comment, discards everything from where the pair of slash signs (//) is found up\nto the end of that same line. The second one, known as block comment, discards everything between the /*\ncharacters and the first appearance of the */ characters, with the possibility of including more than one line.\nWe are going to add comments to our second program:\n9\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n/* my second program in C++ Hello World! I'm a C++ program\nwith more comments */\n#include <iostream>\nusing namespace std;\nint main ()\n{\ncout << \"Hello World! \"; // prints Hello\nWorld!\ncout << \"I'm a C++ program\"; // prints I'm a\nC++ program\nreturn 0;\n}\nIf you include comments within the source code of your programs without using the comment characters\ncombinations //, /* or */, the compiler will take them as if they were C++ expressions, most likely causing one or\nseveral error messages when you compile it.\n10\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nVariables. Data Types.\nThe usefulness of the \"Hello World\" programs shown in the previous section is quite questionable. We had to write\nseveral lines of code, compile them, and then execute the resulting program just to obtain a simple sentence\nwritten on the screen as result. It certainly would have been much faster to type the output sentence by ourselves.\nHowever, programming is not limited only to printing simple texts on the screen. In order to go a little further on\nand to become able to write programs that perform useful tasks that really save us work we need to introduce the\nconcept of variable.\nLet us think that I ask you to retain the number 5 in your mental memory, and then I ask you to memorize also\nthe number 2 at the same time. You have just stored two different values in your memory. Now, if I ask you to add\n1 to the first number I said, you should be retaining the numbers 6 (that is 5+1) and 2 in your memory. Values\nthat we could now for example subtract and obtain 4 as result.\nThe whole process that you have just done with your mental memory is a simile of what a computer can do with\ntwo variables. The same process can be expressed in C++ with the following instruction set:\na = 5;\nb = 2;\na = a + 1;\nresult = a - b;\nObviously, this is a very simple example since we have only used two small integer values, but consider that your\ncomputer can store millions of numbers like these at the same time and conduct sophisticated mathematical\noperations with them.\nTherefore, we can define a variable as a portion of memory to store a determined value.\nEach variable needs an identifier that distinguishes it from the others, for example, in the previous code the\nvariable identifiers were a, b and result, but we could have called the variables any names we wanted to invent,\nas long as they were valid identifiers.\nIdentifiers\nA valid identifier is a sequence of one or more letters, digits or underscore characters (_). Neither spaces nor\npunctuation marks or symbols can be part of an identifier. Only letters, digits and single underscore characters are\nvalid. In addition, variable identifiers always have to begin with a letter. They can also begin with an underline\ncharacter (_ ), but in some cases these may be reserved for compiler specific keywords or external identifiers, as\nwell as identifiers containing two successive underscore characters anywhere. In no case they can begin with a\ndigit.\nAnother rule that you have to consider when inventing your own identifiers is that they cannot match any keyword\nof the C++ language nor your compiler's specific ones, which are reserved keywords. The standard reserved\nkeywords are:\nasm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete,\ndo, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto,\nif, inline, int, long, mutable, namespace, new, operator, private, protected, public, register,\nreinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template,\nthis, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void,\nvolatile, wchar_t, while\nAdditionally, alternative representations for some operators cannot be used as identifiers since they are reserved\nwords under some circumstances:\nand, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq\n11\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nYour compiler may also include some additional specific reserved keywords.\nVery important: The C++ language is a \"case sensitive\" language. That means that an identifier written in capital\nletters is not equivalent to another one with the same name but written in small letters. Thus, for example, the\nRESULT variable is not the same as the result variable or the Result variable. These are three different variable\nidentifiers.\nFundamental data types\nWhen programming, we store the variables in our computer's memory, but the computer has to know what kind of\ndata we want to store in them, since it is not going to occupy the same amount of memory to store a simple\nnumber than to store a single letter or a large number, and they are not going to be interpreted the same way.\nThe memory in our computers is organized in bytes. A byte is the minimum amount of memory that we can\nmanage in C++. A byte can store a relatively small amount of data: one single character or a small integer\n(generally an integer between 0 and 255). In addition, the computer can manipulate more complex data types that\ncome from grouping several bytes, such as long numbers or non-integer numbers.\nNext you have a summary of the basic fundamental data types in C++, as well as the range of values that can be\nrepresented with each one:\nName Description Size* Range*\nsigned: -128 to 127\nchar Character or small integer. 1byte\nunsigned: 0 to 255\nshort int signed: -32768 to 32767\nShort Integer. 2bytes\n(short) unsigned: 0 to 65535\nsigned: -2147483648 to\nint Integer. 4bytes 2147483647\nunsigned: 0 to 4294967295\nsigned: -2147483648 to\nlong int (long) Long integer. 4bytes 2147483647\nunsigned: 0 to 4294967295\nBoolean value. It can take one of two values: true\nbool 1byte true or false\nor false.\nfloat Floating point number. 4bytes +/- 3.4e +/- 38 (~7 digits)\ndouble Double precision floating point number. 8bytes +/- 1.7e +/- 308 (~15 digits)\nlong double Long double precision floating point number. 8bytes +/- 1.7e +/- 308 (~15 digits)\n2 or 4\nwchar_t Wide character. 1 wide character\nbytes\n* The values of the columns Size and Range depend on the system the program is compiled for. The values\nshown above are those found on most 32-bit systems. But for other systems, the general specification is that int\nhas the natural size suggested by the system architecture (one \"word\") and the four integer types char, short,\nint and long must each one be at least as large as the one preceding it, with char being always 1 byte in size.\nThe same applies to the floating point types float, double and long double, where each one must provide at\nleast as much precision as the preceding one.\nDeclaration of variables\nIn order to use a variable in C++, we must first declare it specifying which data type we want it to be. The syntax\nto declare a new variable is to write the specifier of the desired data type (like int, bool, float...) followed by a valid\nvariable identifier. For example:\n12\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nint a;\nfloat mynumber;\nThese are two valid declarations of variables. The first one declares a variable of type int with the identifier a. The\nsecond one declares a variable of type float with the identifier mynumber. Once declared, the variables a and\nmynumber can be used within the rest of their scope in the program.\nIf you are going to declare more than one variable of the same type, you can declare all of them in a single\nstatement by separating their identifiers with commas. For example:\nint a, b, c;\nThis declares three variables (a, b and c), all of them of type int, and has exactly the same meaning as:\nint a;\nint b;\nint c;\nThe integer data types char, short, long and int can be either signed or unsigned depending on the range of\nnumbers needed to be represented. Signed types can represent both positive and negative values, whereas\nunsigned types can only represent positive values (and zero). This can be specified by using either the specifier\nsigned or the specifier unsigned before the type name. For example:\nunsigned short int NumberOfSisters;\nsigned int MyAccountBalance;\nBy default, if we do not specify either signed or unsigned most compiler settings will assume the type to be\nsigned, therefore instead of the second declaration above we could have written:\nint MyAccountBalance;\nwith exactly the same meaning (with or without the keyword signed)\nAn exception to this general rule is the char type, which exists by itself and is considered a different fundamental\ndata type from signed char and unsigned char, thought to store characters. You should use either signed or\nunsigned if you intend to store numerical values in a char-sized variable.\nshort and long can be used alone as type specifiers. In this case, they refer to their respective integer\nfundamental types: short is equivalent to short int and long is equivalent to long int. The following two\nvariable declarations are equivalent:\nshort Year;\nshort int Year;\nFinally, signed and unsigned may also be used as standalone type specifiers, meaning the same as signed int\nand unsigned int respectively. The following two declarations are equivalent:\nunsigned NextYear;\nunsigned int NextYear;\nTo see what variable declarations look like in action within a program, we are going to see the C++ code of the\nexample about your mental memory proposed at the beginning of this section:\n13\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// operating with variables 4\n#include <iostream>\nusing namespace std;\nint main ()\n{\n// declaring variables:\nint a, b;\nint result;\n// process:\na = 5;\nb = 2;\na = a + 1;\nresult = a - b;\n// print out the result:\ncout << result;\n// terminate the program:\nreturn 0;\n}\nDo not worry if something else than the variable declarations themselves looks a bit strange to you. You will see\nthe rest in detail in coming sections.\nScope of variables\nAll the variables that we intend to use in a program must have been declared with its type specifier in an earlier\npoint in the code, like we did in the previous code at the beginning of the body of the function main when we\ndeclared that a, b, and result were of type int.\nA variable can be either of global or local scope. A global variable is a variable declared in the main body of the\nsource code, outside all functions, while a local variable is one declared within the body of a function or a block.\nGlobal variables can be referred from anywhere in the code, even inside functions, whenever it is after its\ndeclaration.\n14\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThe scope of local variables is limited to the block enclosed in braces ({}) where they are declared. For example, if\nthey are declared at the beginning of the body of a function (like in function main) their scope is between its\ndeclaration point and the end of that function. In the example above, this means that if another function existed in\naddition to main, the local variables declared in main could not be accessed from the other function and vice versa.\nInitialization of variables\nWhen declaring a regular local variable, its value is by default undetermined. But you may want a variable to store\na concrete value at the same moment that it is declared. In order to do that, you can initialize the variable. There\nare two ways to do this in C++:\nThe first one, known as c-like, is done by appending an equal sign followed by the value to which the variable will\nbe initialized:\ntype identifier = initial_value ;\nFor example, if we want to declare an int variable called a initialized with a value of 0 at the moment in which it is\ndeclared, we could write:\nint a = 0;\nThe other way to initialize variables, known as constructor initialization, is done by enclosing the initial value\nbetween parentheses (()):\ntype identifier (initial_value) ;\nFor example:\nint a (0);\nBoth ways of initializing variables are valid and equivalent in C++.\n// initialization of variables 6\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint a=5; // initial value = 5\nint b(2); // initial value = 2\nint result; // initial value\nundetermined\na = a + 3;\nresult = a - b;\ncout << result;\nreturn 0;\n}\nIntroduction to strings\nVariables that can store non-numerical values that are longer than one single character are known as strings.\nThe C++ language library provides support for strings through the standard string class. This is not a\nfundamental type, but it behaves in a similar way as fundamental types do in its most basic usage.\n15\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nA first difference with fundamental data types is that in order to declare and use objects (variables) of this type we\nneed to include an additional header file in our source code: <string> and have access to the std namespace\n(which we already had in all our previous programs thanks to the using namespace statement).\n// my first string This is a string\n#include <iostream>\n#include <string>\nusing namespace std;\nint main ()\n{\nstring mystring = \"This is a string\";\ncout << mystring;\nreturn 0;\n}\nAs you may see in the previous example, strings can be initialized with any valid string literal just like numerical\ntype variables can be initialized to any valid numerical literal. Both initialization formats are valid with strings:\nstring mystring = \"This is a string\";\nstring mystring (\"This is a string\");\nStrings can also perform all the other basic operations that fundamental data types can, like being declared without\nan initial value and being assigned values during execution:\n// my first string This is the initial string content\n#include <iostream> This is a different string content\n#include <string>\nusing namespace std;\nint main ()\n{\nstring mystring;\nmystring = \"This is the initial string content\";\ncout << mystring << endl;\nmystring = \"This is a different string content\";\ncout << mystring << endl;\nreturn 0;\n}\nFor more details on C++ strings, you can have a look at the string class reference.\n16\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nConstants\nConstants are expressions with a fixed value.\nLiterals\nLiterals are used to express particular values within the source code of a program. We have already used these\npreviously to give concrete values to variables or to express messages we wanted our programs to print out, for\nexample, when we wrote:\na = 5;\nthe 5 in this piece of code was a literal constant.\nLiteral constants can be divided in Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean\nValues.\nInteger Numerals\n1776\n707\n-273\nThey are numerical constants that identify integer decimal values. Notice that to express a numerical constant we\ndo not have to write quotes (\") nor any special character. There is no doubt that it is a constant: whenever we\nwrite 1776 in a program, we will be referring to the value 1776.\nIn addition to decimal numbers (those that all of us are used to use every day) C++ allows the use as literal\nconstants of octal numbers (base 8) and hexadecimal numbers (base 16). If we want to express an octal number\nwe have to precede it with a 0 (zero character). And in order to express a hexadecimal number we have to precede\nit with the characters 0x (zero, x). For example, the following literal constants are all equivalent to each other:\n75 // decimal\n0113 // octal\n0x4b // hexadecimal\nAll of these represent the same number: 75 (seventy-five) expressed as a base-10 numeral, octal numeral and\nhexadecimal numeral, respectively.\nLiteral constants, like variables, are considered to have a specific data type. By default, integer literals are of type\nint. However, we can force them to either be unsigned by appending the u character to it, or long by appending l:\n75 // int\n75u // unsigned int\n75l // long\n75ul // unsigned long\nIn both cases, the suffix can be specified using either upper or lowercase letters.\nFloating Point Numbers\nThey express numbers with decimals and/or exponents. They can include either a decimal point, an e character\n(that expresses \"by ten at the Xth height\", where X is an integer value that follows the e character), or both a\ndecimal point and an e character:\n17\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n3.14159 // 3.14159\n6.02e23 // 6.02 x 10^23\n1.6e-19 // 1.6 x 10^-19\n3.0 // 3.0\nThese are four valid numbers with decimals expressed in C++. The first number is PI, the second one is the\nnumber of Avogadro, the third is the electric charge of an electron (an extremely small number) -all of them\napproximated- and the last one is the number three expressed as a floating-point numeric literal.\nThe default type for floating point literals is double. If you explicitly want to express a float or long double\nnumerical literal, you can use the f or l suffixes respectively:\n3.14159L // long double\n6.02e23f // float\nAny of the letters that can be part of a floating-point numerical constant (e, f, l) can be written using either lower\nor uppercase letters without any difference in their meanings.\nCharacter and string literals\nThere also exist non-numerical constants, like:\n'z'\n'p'\n\"Hello world\"\n\"How do you do?\"\nThe first two expressions represent single character constants, and the following two represent string literals\ncomposed of several characters. Notice that to represent a single character we enclose it between single quotes (')\nand to express a string (which generally consists of more than one character) we enclose it between double quotes\n(\").\nWhen writing both single character and string literals, it is necessary to put the quotation marks surrounding them\nto distinguish them from possible variable identifiers or reserved keywords. Notice the difference between these\ntwo expressions:\nx\n'x'\nx alone would refer to a variable whose identifier is x, whereas 'x' (enclosed within single quotation marks) would\nrefer to the character constant 'x'.\nCharacter and string literals have certain peculiarities, like the escape codes. These are special characters that are\ndifficult or impossible to express otherwise in the source code of a program, like newline (\\n) or tab (\\t). All of\nthem are preceded by a backslash (\\). Here you have a list of some of such escape codes:\n18\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n\\n newline\n\\r carriage return\n\\t tab\n\\v vertical tab\n\\b backspace\n\\f form feed (page feed)\n\\a alert (beep)\n\\' single quote (')\n\\\" double quote (\")\n\\? question mark (?)\n\\\\ backslash (\\)\nFor example:\n'\\n'\n'\\t'\n\"Left \\t Right\"\n\"one\\ntwo\\nthree\"\nAdditionally, you can express any character by its numerical ASCII code by writing a backslash character (\\)\nfollowed by the ASCII code expressed as an octal (base-8) or hexadecimal (base-16) number. In the first case\n(octal) the digits must immediately follow the backslash (for example \\23 or \\40), in the second case\n(hexadecimal), an x character must be written before the digits themselves (for example \\x20 or \\x4A).\nString literals can extend to more than a single line of code by putting a backslash sign (\\) at the end of each\nunfinished line.\n\"string expressed in \\\ntwo lines\"\nYou can also concatenate several string constants separating them by one or several blank spaces, tabulators,\nnewline or any other valid blank character:\n\"this forms\" \"a single\" \"string\" \"of characters\"\nFinally, if we want the string literal to be explicitly made of wide characters (wchar_t), instead of narrow characters\n(char), we can precede the constant with the L prefix:\nL\"This is a wide character string\"\nWide characters are used mainly to represent non-English or exotic character sets.\nBoolean literals\nThere are only two valid Boolean values: true and false. These can be expressed in C++ as values of type bool by\nusing the Boolean literals true and false.\nDefined constants (#define)\nYou can define your own names for constants that you use very often without having to resort to memory-\nconsuming variables, simply by using the #define preprocessor directive. Its format is:\n19\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n#define identifier value\nFor example:\n#define PI 3.14159\n#define NEWLINE '\\n'\nThis defines two new constants: PI and NEWLINE. Once they are defined, you can use them in the rest of the code\nas if they were any other regular constant, for example:\n// defined constants: calculate circumference 31.4159\n#include <iostream>\nusing namespace std;\n#define PI 3.14159\n#define NEWLINE '\\n'\nint main ()\n{\ndouble r=5.0; // radius\ndouble circle;\ncircle = 2 * PI * r;\ncout << circle;\ncout << NEWLINE;\nreturn 0;\n}\nIn fact the only thing that the compiler preprocessor does when it encounters #define directives is to literally\nreplace any occurrence of their identifier (in the previous example, these were PI and NEWLINE) by the code to\nwhich they have been defined (3.14159 and '\\n' respectively).\nThe #define directive is not a C++ statement but a directive for the preprocessor; therefore it assumes the entire\nline as the directive and does not require a semicolon (;) at its end. If you append a semicolon character (;) at the\nend, it will also be appended in all occurrences within the body of the program that the preprocessor replaces.\nDeclared constants (const)\nWith the const prefix you can declare constants with a specific type in the same way as you would do with a\nvariable:\nconst int pathwidth = 100;\nconst char tabulator = '\\t';\nHere, pathwidth and tabulator are two typed constants. They are treated just like regular variables except that\ntheir values cannot be modified after their definition.\n20\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nOperators\nOnce we know of the existence of variables and constants, we can begin to operate with them. For that purpose,\nC++ integrates operators. Unlike other languages whose operators are mainly keywords, operators in C++ are\nmostly made of signs that are not part of the alphabet but are available in all keyboards. This makes C++ code\nshorter and more international, since it relies less on English words, but requires a little of learning effort in the\nbeginning.\nYou do not have to memorize all the content of this page. Most details are only provided to serve as a later\nreference in case you need it.\nAssignment (=)\nThe assignment operator assigns a value to a variable.\na = 5;\nThis statement assigns the integer value 5 to the variable a. The part at the left of the assignment operator (=) is\nknown as the lvalue (left value) and the right one as the rvalue (right value). The lvalue has to be a variable\nwhereas the rvalue can be either a constant, a variable, the result of an operation or any combination of these.\nThe most important rule when assigning is the right-to-left rule: The assignment operation always takes place from\nright to left, and never the other way:\na = b;\nThis statement assigns to variable a (the lvalue) the value contained in variable b (the rvalue). The value that was\nstored until this moment in a is not considered at all in this operation, and in fact that value is lost.\nConsider also that we are only assigning the value of b to a at the moment of the assignment operation. Therefore\na later change of b will not affect the new value of a.\nFor example, let us have a look at the following code - I have included the evolution of the content stored in the\nvariables as comments:\n// assignment operator a:4 b:7\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint a, b; // a:?, b:?\na = 10; // a:10, b:?\nb = 4; // a:10, b:4\na = b; // a:4, b:4\nb = 7; // a:4, b:7\ncout << \"a:\";\ncout << a;\ncout << \" b:\";\ncout << b;\nreturn 0;\n}\nThis code will give us as result that the value contained in a is 4 and the one contained in b is 7. Notice how a was\nnot affected by the final modification of b, even though we declared a = b earlier (that is because of the right-to-\nleft rule).\n21\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nA property that C++ has over other programming languages is that the assignment operation can be used as the\nrvalue (or part of an rvalue) for another assignment operation. For example:\na = 2 + (b = 5);\nis equivalent to:\nb = 5;\na = 2 + b;\nthat means: first assign 5 to variable b and then assign to a the value 2 plus the result of the previous assignment\nof b (i.e. 5), leaving a with a final value of 7.\nThe following expression is also valid in C++:\na = b = c = 5;\nIt assigns 5 to the all the three variables: a, b and c.\nArithmetic operators ( +, -, *, /, % )\nThe five arithmetical operations supported by the C++ language are:\n+ addition\n- subtraction\n* multiplication\n/ division\n% modulo\nOperations of addition, subtraction, multiplication and division literally correspond with their respective\nmathematical operators. The only one that you might not be so used to see is modulo; whose operator is the\npercentage sign (%). Modulo is the operation that gives the remainder of a division of two values. For example, if\nwe write:\na = 11 % 3;\nthe variable a will contain the value 2, since 2 is the remainder from dividing 11 between 3.\nCompound assignment (+=, -=, *=, /=, %=, >>=, <<=, &=,\n^=, |=)\nWhen we want to modify the value of a variable by performing an operation on the value currently stored in that\nvariable we can use compound assignment operators:\nexpression is equivalent to\nvalue += increase; value = value + increase;\na -= 5; a = a - 5;\na /= b; a = a / b;\nprice *= units + 1; price = price * (units + 1);\nand the same for all other operators. For example:\n22\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// compound assignment operators 5\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint a, b=3;\na = b;\na+=2; // equivalent to a=a+2\ncout << a;\nreturn 0;\n}\nIncrease and decrease (++, --)\nShortening even more some expressions, the increase operator (++) and the decrease operator (--) increase or\nreduce by one the value stored in a variable. They are equivalent to +=1 and to -=1, respectively. Thus:\nc++;\nc+=1;\nc=c+1;\nare all equivalent in its functionality: the three of them increase by one the value of c.\nIn the early C compilers, the three previous expressions probably produced different executable code depending on\nwhich one was used. Nowadays, this type of code optimization is generally done automatically by the compiler,\nthus the three expressions should produce exactly the same executable code.\nA characteristic of this operator is that it can be used both as a prefix and as a suffix. That means that it can be\nwritten either before the variable identifier (++a) or after it (a++). Although in simple expressions like a++ or ++a\nboth have exactly the same meaning, in other expressions in which the result of the increase or decrease operation\nis evaluated as a value in an outer expression they may have an important difference in their meaning: In the case\nthat the increase operator is used as a prefix (++a) the value is increased before the result of the expression is\nevaluated and therefore the increased value is considered in the outer expression; in case that it is used as a suffix\n(a++) the value stored in a is increased after being evaluated and therefore the value stored before the increase\noperation is evaluated in the outer expression. Notice the difference:\nExample 1 Example 2\nB=3; B=3;\nA=++B; A=B++;\n// A contains 4, B contains 4 // A contains 3, B contains 4\nIn Example 1, B is increased before its value is copied to A. While in Example 2, the value of B is copied to A and\nthen B is increased.\nRelational and equality operators ( ==, !=, >, <, >=, <= )\nIn order to evaluate a comparison between two expressions we can use the relational and equality operators. The\nresult of a relational operation is a Boolean value that can only be true or false, according to its Boolean result.\nWe may want to compare two expressions, for example, to know if they are equal or if one is greater than the\nother is. Here is a list of the relational and equality operators that can be used in C++:\n23\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n== Equal to\n!= Not equal to\n> Greater than\n< Less than\n>= Greater than or equal to\n<= Less than or equal to\nHere there are some examples:\n(7 == 5) // evaluates to false.\n(5 > 4) // evaluates to true.\n(3 != 2) // evaluates to true.\n(6 >= 6) // evaluates to true.\n(5 < 5) // evaluates to false.\nOf course, instead of using only numeric constants, we can use any valid expression, including variables. Suppose\nthat a=2, b=3 and c=6,\n(a == 5) // evaluates to false since a is not equal to 5.\n(a*b >= c) // evaluates to true since (2*3 >= 6) is true.\n(b+4 > a*c) // evaluates to false since (3+4 > 2*6) is false.\n((b=2) == a) // evaluates to true.\nBe careful! The operator = (one equal sign) is not the same as the operator == (two equal signs), the first one is an\nassignment operator (assigns the value at its right to the variable at its left) and the other one (==) is the equality\noperator that compares whether both expressions in the two sides of it are equal to each other. Thus, in the last\nexpression ((b=2) == a), we first assigned the value 2 to b and then we compared it to a, that also stores the\nvalue 2, so the result of the operation is true.\nLogical operators ( !, &&, || )\nThe Operator ! is the C++ operator to perform the Boolean operation NOT, it has only one operand, located at its\nright, and the only thing that it does is to inverse the value of it, producing false if its operand is true and true if its\noperand is false. Basically, it returns the opposite Boolean value of evaluating its operand. For example:\n!(5 == 5) // evaluates to false because the expression at its right (5 == 5) is true.\n!(6 <= 4) // evaluates to true because (6 <= 4) would be false.\n!true // evaluates to false\n!false // evaluates to true.\nThe logical operators && and || are used when evaluating two expressions to obtain a single relational result. The\noperator && corresponds with Boolean logical operation AND. This operation results true if both its two operands\nare true, and false otherwise. The following panel shows the result of operator && evaluating the expression a &&\nb:\n&& OPERATOR\na b a && b\ntrue true true\ntrue false false\nfalse true false\nfalse false false\nThe operator || corresponds with Boolean logical operation OR. This operation results true if either one of its two\noperands is true, thus being false only when both operands are false themselves. Here are the possible results of a\n|| b:\n24\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n|| OPERATOR\na b a || b\ntrue true true\ntrue false true\nfalse true true\nfalse false false\nFor example:\n( (5 == 5) && (3 > 6) ) // evaluates to false ( true && false ).\n( (5 == 5) || (3 > 6) ) // evaluates to true ( true || false ).\nConditional operator ( ? )\nThe conditional operator evaluates an expression returning a value if that expression is true and a different one if\nthe expression is evaluated as false. Its format is:\ncondition ? result1 : result2\nIf condition is true the expression will return result1, if it is not it will return result2.\n7==5 ? 4 : 3 // returns 3, since 7 is not equal to 5.\n7==5+2 ? 4 : 3 // returns 4, since 7 is equal to 5+2.\n5>3 ? a : b // returns the value of a, since 5 is greater than 3.\na>b ? a : b // returns whichever is greater, a or b.\n// conditional operator 7\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint a,b,c;\na=2;\nb=7;\nc = (a>b) ? a : b;\ncout << c;\nreturn 0;\n}\nIn this example a was 2 and b was 7, so the expression being evaluated (a>b) was not true, thus the first value\nspecified after the question mark was discarded in favor of the second value (the one after the colon) which was b,\nwith a value of 7.\nComma operator ( , )\nThe comma operator (,) is used to separate two or more expressions that are included where only one expression\nis expected. When the set of expressions has to be evaluated for a value, only the rightmost expression is\nconsidered.\nFor example, the following code:\na = (b=3, b+2);\n25\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nWould first assign the value 3 to b, and then assign b+2 to variable a. So, at the end, variable a would contain the\nvalue 5 while variable b would contain value 3.\nBitwise Operators ( &, |, ^, ~, <<, >> )\nBitwise operators modify variables considering the bit patterns that represent the values they store.\noperator asm equivalent description\n& AND Bitwise AND\n| OR Bitwise Inclusive OR\n^ XOR Bitwise Exclusive OR\n~ NOT Unary complement (bit inversion)\n<< SHL Shift Left\n>> SHR Shift Right\nExplicit type casting operator\nType casting operators allow you to convert a datum of a given type to another. There are several ways to do this\nin C++. The simplest one, which has been inherited from the C language, is to precede the expression to be\nconverted by the new type enclosed between parentheses (()):\nint i;\nfloat f = 3.14;\ni = (int) f;\nThe previous code converts the float number 3.14 to an integer value (3), the remainder is lost. Here, the\ntypecasting operator was (int). Another way to do the same thing in C++ is using the functional notation:\npreceding the expression to be converted by the type and enclosing the expression between parentheses:\ni = int ( f );\nBoth ways of type casting are valid in C++.\nsizeof()\nThis operator accepts one parameter, which can be either a type or a variable itself and returns the size in bytes of\nthat type or object:\na = sizeof (char);\nThis will assign the value 1 to a because char is a one-byte long type.\nThe value returned by sizeof is a constant, so it is always determined before program execution.\nOther operators\nLater in these tutorials, we will see a few more operators, like the ones referring to pointers or the specifics for\nobject-oriented programming. Each one is treated in its respective section.\nPrecedence of operators\nWhen writing complex expressions with several operands, we may have some doubts about which operand is\nevaluated first and which later. For example, in this expression:\na = 5 + 7 % 2\n26\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nwe may doubt if it really means:\na = 5 + (7 % 2) // with a result of 6, or\na = (5 + 7) % 2 // with a result of 0\nThe correct answer is the first of the two expressions, with a result of 6. There is an established order with the\npriority of each operator, and not only the arithmetic ones (those whose preference come from mathematics) but\nfor all the operators which can appear in C++. From greatest to lowest priority, the priority order is as follows:\nLevel Operator Description Grouping\nLeft-to-\n1 :: scope\nright\n() [] . -> ++ -- dynamic_cast static_cast Left-to-\n2 postfix\nreinterpret_cast const_cast typeid right\n++ -- ~ ! sizeof new delete unary (prefix)\nindirection and reference Right-to-\n3 * &\n(pointers) left\n+ - unary sign operator\nRight-to-\n4 (type) type casting\nleft\nLeft-to-\n5 .* ->* pointer-to-member\nright\nLeft-to-\n6 * / % multiplicative\nright\nLeft-to-\n7 + - additive\nright\nLeft-to-\n8 << >> shift\nright\nLeft-to-\n9 < > <= >= relational\nright\nLeft-to-\n10 == != equality\nright\nLeft-to-\n11 & bitwise AND\nright\nLeft-to-\n12 ^ bitwise XOR\nright\nLeft-to-\n13 | bitwise OR\nright\nLeft-to-\n14 && logical AND\nright\nLeft-to-\n15 || logical OR\nright\nRight-to-\n16 ?: conditional\nleft\nRight-to-\n17 = *= /= %= += -= >>= <<= &= ^= |= assignment\nleft\nLeft-to-\n18 , comma\nright\nGrouping defines the precedence order in which operators are evaluated in the case that there are several\noperators of the same level in an expression.\nAll these precedence levels for operators can be manipulated or become more legible by removing possible\nambiguities using parentheses signs ( and ), as in this example:\na = 5 + 7 % 2;\n27\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nmight be written either as:\na = 5 + (7 % 2);\nor\na = (5 + 7) % 2;\ndepending on the operation that we want to perform.\nSo if you want to write complicated expressions and you are not completely sure of the precedence levels, always\ninclude parentheses. It will also become a code easier to read.\n28\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nBasic Input/Output\nUntil now, the example programs of previous sections provided very little interaction with the user, if any at all.\nUsing the standard input and output library, we will be able to interact with the user by printing messages on the\nscreen and getting the user's input from the keyboard.\nC++ uses a convenient abstraction called streams to perform input and output operations in sequential media such\nas the screen or the keyboard. A stream is an object where a program can either insert or extract characters\nto/from it. We do not really need to care about many specifications about the physical media associated with the\nstream - we only need to know it will accept or provide characters sequentially.\nThe standard C++ library includes the header file iostream, where the standard input and output stream objects\nare declared.\nStandard Output (cout)\nBy default, the standard output of a program is the screen, and the C++ stream object defined to access it is cout.\ncout is used in conjunction with the insertion operator, which is written as << (two \"less than\" signs).\ncout << \"Output sentence\"; // prints Output sentence on screen\ncout << 120; // prints number 120 on screen\ncout << x; // prints the content of x on screen\nThe << operator inserts the data that follows it into the stream preceding it. In the examples above it inserted the\nconstant string Output sentence, the numerical constant 120 and variable x into the standard output stream cout.\nNotice that the sentence in the first instruction is enclosed between double quotes (\") because it is a constant\nstring of characters. Whenever we want to use constant strings of characters we must enclose them between\ndouble quotes (\") so that they can be clearly distinguished from variable names. For example, these two sentences\nhave very different results:\ncout << \"Hello\"; // prints Hello\ncout << Hello; // prints the content of Hello variable\nThe insertion operator (<<) may be used more than once in a single statement:\ncout << \"Hello, \" << \"I am \" << \"a C++ statement\";\nThis last statement would print the message Hello, I am a C++ statement on the screen. The utility of repeating\nthe insertion operator (<<) is demonstrated when we want to print out a combination of variables and constants or\nmore than one variable:\ncout << \"Hello, I am \" << age << \" years old and my zipcode is \" << zipcode;\nIf we assume the age variable to contain the value 24 and the zipcode variable to contain 90064 the output of the\nprevious statement would be:\nHello, I am 24 years old and my zipcode is 90064\nIt is important to notice that cout does not add a line break after its output unless we explicitly indicate it,\ntherefore, the following statements:\n29\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\ncout << \"This is a sentence.\";\ncout << \"This is another sentence.\";\nwill be shown on the screen one following the other without any line break between them:\nThis is a sentence.This is another sentence.\neven though we had written them in two different insertions into cout. In order to perform a line break on the\noutput we must explicitly insert a new-line character into cout. In C++ a new-line character can be specified as \\n\n(backslash, n):\ncout << \"First sentence.\\n \";\ncout << \"Second sentence.\\nThird sentence.\";\nThis produces the following output:\nFirst sentence.\nSecond sentence.\nThird sentence.\nAdditionally, to add a new-line, you may also use the endl manipulator. For example:\ncout << \"First sentence.\" << endl;\ncout << \"Second sentence.\" << endl;\nwould print out:\nFirst sentence.\nSecond sentence.\nThe endl manipulator produces a newline character, exactly as the insertion of '\\n' does, but it also has an\nadditional behavior when it is used with buffered streams: the buffer is flushed. Anyway, cout will be an\nunbuffered stream in most cases, so you can generally use both the \\n escape character and the endl manipulator\nin order to specify a new line without any difference in its behavior.\nStandard Input (cin).\nThe standard input device is usually the keyboard. Handling the standard input in C++ is done by applying the\noverloaded operator of extraction (>>) on the cin stream. The operator must be followed by the variable that will\nstore the data that is going to be extracted from the stream. For example:\nint age;\ncin >> age;\nThe first statement declares a variable of type int called age, and the second one waits for an input from cin (the\nkeyboard) in order to store it in this integer variable.\ncin can only process the input from the keyboard once the RETURN key has been pressed. Therefore, even if you\nrequest a single character, the extraction from cin will not process the input until the user presses RETURN after\nthe character has been introduced.\nYou must always consider the type of the variable that you are using as a container with cin extractions. If you\nrequest an integer you will get an integer, if you request a character you will get a character and if you request a\nstring of characters you will get a string of characters.\n30\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// i/o example Please enter an integer value: 702\nThe value you entered is 702 and its double is\n#include <iostream> 1404.\nusing namespace std;\nint main ()\n{\nint i;\ncout << \"Please enter an integer value: \";\ncin >> i;\ncout << \"The value you entered is \" << i;\ncout << \" and its double is \" << i*2 << \".\\n\";\nreturn 0;\n}\nThe user of a program may be one of the factors that generate errors even in the simplest programs that use cin\n(like the one we have just seen). Since if you request an integer value and the user introduces a name (which\ngenerally is a string of characters), the result may cause your program to misoperate since it is not what we were\nexpecting from the user. So when you use the data input provided by cin extractions you will have to trust that\nthe user of your program will be cooperative and that he/she will not introduce his/her name or something similar\nwhen an integer value is requested. A little ahead, when we see the stringstream class we will see a possible\nsolution for the errors that can be caused by this type of user input.\nYou can also use cin to request more than one datum input from the user:\ncin >> a >> b;\nis equivalent to:\ncin >> a;\ncin >> b;\nIn both cases the user must give two data, one for variable a and another one for variable b that may be separated\nby any valid blank separator: a space, a tab character or a newline.\ncin and strings\nWe can use cin to get strings with the extraction operator (>>) as we do with fundamental data type variables:\ncin >> mystring;\nHowever, as it has been said, cin extraction stops reading as soon as if finds any blank space character, so in this\ncase we will be able to get just one word for each extraction. This behavior may or may not be what we want; for\nexample if we want to get a sentence from the user, this extraction operation would not be useful.\nIn order to get entire lines, we can use the function getline, which is the more recommendable way to get user\ninput with cin:\n31\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// cin with strings What's your name? Juan Souli\u00c3\u203e\u00c2\u00bf\u00c2\u00bd\n#include <iostream> Hello Juan Souli\u00c3\u203e\u00c2\u00bf\u00c2\u00bd.\n#include <string> What is your favorite team? The Isotopes\nusing namespace std; I like The Isotopes too!\nint main ()\n{\nstring mystr;\ncout << \"What's your name? \";\ngetline (cin, mystr);\ncout << \"Hello \" << mystr << \".\\n\";\ncout << \"What is your favorite team? \";\ngetline (cin, mystr);\ncout << \"I like \" << mystr << \" too!\\n\";\nreturn 0;\n}\nNotice how in both calls to getline we used the same string identifier (mystr). What the program does in the\nsecond call is simply to replace the previous content by the new one that is introduced.\nstringstream\nThe standard header file <sstream> defines a class called stringstream that allows a string-based object to be\ntreated as a stream. This way we can perform extraction or insertion operations from/to strings, which is especially\nuseful to convert strings to numerical values and vice versa. For example, if we want to extract an integer from a\nstring we can write:\nstring mystr (\"1204\");\nint myint;\nstringstream(mystr) >> myint;\nThis declares a string object with a value of \"1204\", and an int object. Then we use stringstream's constructor\nto construct an object of this type from the string object. Because we can use stringstream objects as if they\nwere streams, we can extract an integer from it as we would have done on cin by applying the extractor operator\n(>>) on it followed by a variable of type int.\nAfter this piece of code, the variable myint will contain the numerical value 1204.\n// stringstreams Enter price: 22.25\n#include <iostream> Enter quantity: 7\n#include <string> Total price: 155.75\n#include <sstream>\nusing namespace std;\nint main ()\n{\nstring mystr;\nfloat price=0;\nint quantity=0;\ncout << \"Enter price: \";\ngetline (cin,mystr);\nstringstream(mystr) >> price;\ncout << \"Enter quantity: \";\ngetline (cin,mystr);\nstringstream(mystr) >> quantity;\ncout << \"Total price: \" << price*quantity <<\nendl;\nreturn 0;\n}\nIn this example, we acquire numeric values from the standard input indirectly. Instead of extracting numeric values\ndirectly from the standard input, we get lines from the standard input (cin) into a string object (mystr), and then\nwe extract the integer values from this string into a variable of type int (quantity).\n32\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nUsing this method, instead of direct extractions of integer values, we have more control over what happens with\nthe input of numeric values from the user, since we are separating the process of obtaining input from the user (we\nnow simply ask for lines) with the interpretation of that input. Therefore, this method is usually preferred to get\nnumerical values from the user in all programs that are intensive in user input.\n33\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nControl Structures\nControl Structures\nA program is usually not limited to a linear sequence of instructions. During its process it may bifurcate, repeat\ncode or take decisions. For that purpose, C++ provides control structures that serve to specify what has to be done\nby our program, when and under which circumstances.\nWith the introduction of control structures we are going to have to introduce a new concept: the compound-\nstatement or block. A block is a group of statements which are separated by semicolons (;) like all C++\nstatements, but grouped together in a block enclosed in braces: { }:\n{ statement1; statement2; statement3; }\nMost of the control structures that we will see in this section require a generic statement as part of its syntax. A\nstatement can be either a simple statement (a simple instruction ending with a semicolon) or a compound\nstatement (several instructions grouped in a block), like the one just described. In the case that we want the\nstatement to be a simple statement, we do not need to enclose it in braces ({}). But in the case that we want the\nstatement to be a compound statement it must be enclosed between braces ({}), forming a block.\nConditional structure: if and else\nThe if keyword is used to execute a statement or block only if a condition is fulfilled. Its form is:\nif (condition) statement\nWhere condition is the expression that is being evaluated. If this condition is true, statement is executed. If it is\nfalse, statement is ignored (not executed) and the program continues right after this conditional structure.\nFor example, the following code fragment prints x is 100 only if the value stored in the x variable is indeed 100:\nif (x == 100)\ncout << \"x is 100\";\nIf we want more than a single statement to be executed in case that the condition is true we can specify a block\nusing braces { }:\nif (x == 100)\n{\ncout << \"x is \";\ncout << x;\n}\nWe can additionally specify what we want to happen if the condition is not fulfilled by using the keyword else. Its\nform used in conjunction with if is:\nif (condition) statement1 else statement2\nFor example:\n34\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nif (x == 100)\ncout << \"x is 100\";\nelse\ncout << \"x is not 100\";\nprints on the screen x is 100 if indeed x has a value of 100, but if it has not -and only if not- it prints out x is\nnot 100.\nThe if + else structures can be concatenated with the intention of verifying a range of values. The following\nexample shows its use telling if the value currently stored in x is positive, negative or none of them (i.e. zero):\nif (x > 0)\ncout << \"x is positive\";\nelse if (x < 0)\ncout << \"x is negative\";\nelse\ncout << \"x is 0\";\nRemember that in case that we want more than a single statement to be executed, we must group them in a block\nby enclosing them in braces { }.\nIteration structures (loops)\nLoops have as purpose to repeat a statement a certain number of times or while a condition is fulfilled.\nThe while loop\nIts format is:\nwhile (expression) statement\nand its functionality is simply to repeat statement while the condition set in expression is true.\nFor example, we are going to make a program to countdown using a while-loop:\n// custom countdown using while Enter the starting number > 8\n8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint n;\ncout << \"Enter the starting number > \";\ncin >> n;\nwhile (n>0) {\ncout << n << \", \";\n--n;\n}\ncout << \"FIRE!\\n\";\nreturn 0;\n}\nWhen the program starts the user is prompted to insert a starting number for the countdown. Then the while loop\nbegins, if the value entered by the user fulfills the condition n>0 (that n is greater than zero) the block that follows\nthe condition will be executed and repeated while the condition (n>0) remains being true.\nThe whole process of the previous program can be interpreted according to the following script (beginning in\nmain):\n35\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n1. User assigns a value to n\n2. The while condition is checked (n>0). At this point there are two posibilities:\n* condition is true: statement is executed (to step 3)\n* condition is false: ignore statement and continue after it (to step 5)\n3. Execute statement:\ncout << n << \", \";\n--n;\n(prints the value of n on the screen and decreases n by 1)\n4. End of block. Return automatically to step 2\n5. Continue the program right after the block: print FIRE! and end program.\nWhen creating a while-loop, we must always consider that it has to end at some point, therefore we must provide\nwithin the block some method to force the condition to become false at some point, otherwise the loop will\ncontinue looping forever. In this case we have included --n; that decreases the value of the variable that is being\nevaluated in the condition (n) by one - this will eventually make the condition (n>0) to become false after a certain\nnumber of loop iterations: to be more specific, when n becomes 0, that is where our while-loop and our countdown\nend.\nOf course this is such a simple action for our computer that the whole countdown is performed instantly without\nany practical delay between numbers.\nThe do-while loop\nIts format is:\ndo statement while (condition);\nIts functionality is exactly the same as the while loop, except that condition in the do-while loop is evaluated after\nthe execution of statement instead of before, granting at least one execution of statement even if condition is\nnever fulfilled. For example, the following example program echoes any number you enter until you enter 0.\n// number echoer Enter number (0 to end): 12345\nYou entered: 12345\n#include <iostream> Enter number (0 to end): 160277\nusing namespace std; You entered: 160277\nEnter number (0 to end): 0\nint main () You entered: 0\n{\nunsigned long n;\ndo {\ncout << \"Enter number (0 to end): \";\ncin >> n;\ncout << \"You entered: \" << n << \"\\n\";\n} while (n != 0);\nreturn 0;\n}\nThe do-while loop is usually used when the condition that has to determine the end of the loop is determined within\nthe loop statement itself, like in the previous case, where the user input within the block is what is used to\ndetermine if the loop has to end. In fact if you never enter the value 0 in the previous example you can be\nprompted for more numbers forever.\nThe for loop\nIts format is:\nfor (initialization; condition; increase) statement;\n36\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nand its main function is to repeat statement while condition remains true, like the while loop. But in addition, the\nfor loop provides specific locations to contain an initialization statement and an increase statement. So this\nloop is specially designed to perform a repetitive action with a counter which is initialized and increased on each\niteration.\nIt works in the following way:\n1. initialization is executed. Generally it is an initial value setting for a counter variable. This is executed\nonly once.\n2. condition is checked. If it is true the loop continues, otherwise the loop ends and statement is skipped\n(not executed).\n3. statement is executed. As usual, it can be either a single statement or a block enclosed in braces { }.\n4. finally, whatever is specified in the increase field is executed and the loop gets back to step 2.\nHere is an example of countdown using a for loop:\n// countdown using a for loop 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n#include <iostream>\nusing namespace std;\nint main ()\n{\nfor (int n=10; n>0; n--) {\ncout << n << \", \";\n}\ncout << \"FIRE!\\n\";\nreturn 0;\n}\nThe initialization and increase fields are optional. They can remain empty, but in all cases the semicolon signs\nbetween them must be written. For example we could write: for (;n<10;) if we wanted to specify no initialization\nand no increase; or for (;n<10;n++) if we wanted to include an increase field but no initialization (maybe because\nthe variable was already initialized before).\nOptionally, using the comma operator (,) we can specify more than one expression in any of the fields included in\na for loop, like in initialization, for example. The comma operator (,) is an expression separator, it serves to\nseparate more than one expression where only one is generally expected. For example, suppose that we wanted to\ninitialize more than one variable in our loop:\nfor ( n=0, i=100 ; n!=i ; n++, i-- )\n{\n// whatever here...\n}\nThis loop will execute for 50 times if neither n or i are modified within the loop:\nn starts with a value of 0, and i with 100, the condition is n!=i (that n is not equal to i). Because n is increased by\none and i decreased by one, the loop's condition will become false after the 50th loop, when both n and i will be\nequal to 50.\n37\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nJump statements.\nThe break statement\nUsing break we can leave a loop even if the condition for its end is not fulfilled. It can be used to end an infinite\nloop, or to force it to end before its natural end. For example, we are going to stop the count down before its\nnatural end (maybe because of an engine check failure?):\n// break loop example 10, 9, 8, 7, 6, 5, 4, 3, countdown aborted!\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint n;\nfor (n=10; n>0; n--)\n{\ncout << n << \", \";\nif (n==3)\n{\ncout << \"countdown aborted!\";\nbreak;\n}\n}\nreturn 0;\n}\nThe continue statement\nThe continue statement causes the program to skip the rest of the loop in the current iteration as if the end of the\nstatement block had been reached, causing it to jump to the start of the following iteration. For example, we are\ngoing to skip the number 5 in our countdown:\n// continue loop example 10, 9, 8, 7, 6, 4, 3, 2, 1, FIRE!\n#include <iostream>\nusing namespace std;\nint main ()\n{\nfor (int n=10; n>0; n--) {\nif (n==5) continue;\ncout << n << \", \";\n}\ncout << \"FIRE!\\n\";\nreturn 0;\n}\nThe goto statement\ngoto allows to make an absolute jump to another point in the program. You should use this feature with caution\nsince its execution causes an unconditional jump ignoring any type of nesting limitations.\nThe destination point is identified by a label, which is then used as an argument for the goto statement. A label is\nmade of a valid identifier followed by a colon (:).\nGenerally speaking, this instruction has no concrete use in structured or object oriented programming aside from\nthose that low-level programming fans may find for it. For example, here is our countdown loop using goto:\n38\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// goto loop example 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint n=10;\nloop:\ncout << n << \", \";\nn--;\nif (n>0) goto loop;\ncout << \"FIRE!\\n\";\nreturn 0;\n}\nThe exit function\nexit is a function defined in the cstdlib library.\nThe purpose of exit is to terminate the current program with a specific exit code. Its prototype is:\nvoid exit (int exitcode);\nThe exitcode is used by some operating systems and may be used by calling programs. By convention, an exit\ncode of 0 means that the program finished normally and any other value means that some error or unexpected\nresults happened.\nThe selective structure: switch.\nThe syntax of the switch statement is a bit peculiar. Its objective is to check several possible constant values for an\nexpression. Something similar to what we did at the beginning of this section with the concatenation of several if\nand else if instructions. Its form is the following:\nswitch (expression)\n{\ncase constant1:\ngroup of statements 1;\nbreak;\ncase constant2:\ngroup of statements 2;\nbreak;\n.\n.\n.\ndefault:\ndefault group of statements\n}\nIt works in the following way: switch evaluates expression and checks if it is equivalent to constant1, if it is, it\nexecutes group of statements 1 until it finds the break statement. When it finds this break statement the\nprogram jumps to the end of the switch selective structure.\nIf expression was not equal to constant1 it will be checked against constant2. If it is equal to this, it will execute\ngroup of statements 2 until a break keyword is found, and then will jump to the end of the switch selective\nstructure.\nFinally, if the value of expression did not match any of the previously specified constants (you can include as\nmany case labels as values you want to check), the program will execute the statements included after the\ndefault: label, if it exists (since it is optional).\n39\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nBoth of the following code fragments have the same behavior:\nswitch example if-else equivalent\nswitch (x) {\nif (x == 1) {\ncase 1:\ncout << \"x is 1\";\ncout << \"x is 1\";\n}\nbreak;\nelse if (x == 2) {\ncase 2:\ncout << \"x is 2\";\ncout << \"x is 2\";\n}\nbreak;\nelse {\ndefault:\ncout << \"value of x unknown\";\ncout << \"value of x unknown\";\n}\n}\nThe switch statement is a bit peculiar within the C++ language because it uses labels instead of blocks. This\nforces us to put break statements after the group of statements that we want to be executed for a specific\ncondition. Otherwise the remainder statements -including those corresponding to other labels- will also be\nexecuted until the end of the switch selective block or a break statement is reached.\nFor example, if we did not include a break statement after the first group for case one, the program will not\nautomatically jump to the end of the switch selective block and it would continue executing the rest of statements\nuntil it reaches either a break instruction or the end of the switch selective block. This makes unnecessary to\ninclude braces { } surrounding the statements for each of the cases, and it can also be useful to execute the same\nblock of instructions for different possible values for the expression being evaluated. For example:\nswitch (x) {\ncase 1:\ncase 2:\ncase 3:\ncout << \"x is 1, 2 or 3\";\nbreak;\ndefault:\ncout << \"x is not 1, 2 nor 3\";\n}\nNotice that switch can only be used to compare an expression against constants. Therefore we cannot put variables\nas labels (for example case n: where n is a variable) or ranges (case (1..3):) because they are not valid C++\nconstants.\nIf you need to check ranges or values that are not constants, use a concatenation of if and else if statements.\n40\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nFunctions (I)\nUsing functions we can structure our programs in a more modular way, accessing all the potential that structured\nprogramming can offer to us in C++.\nA function is a group of statements that is executed when it is called from some point of the program. The\nfollowing is its format:\ntype name ( parameter1, parameter2, ...) { statements }\nwhere:\n\u2022\ntype is the data type specifier of the data returned by the function.\n\u2022\nname is the identifier by which it will be possible to call the function.\n\u2022\nparameters (as many as needed): Each parameter consists of a data type specifier followed by an\nidentifier, like any regular variable declaration (for example: int x) and which acts within the function as\na regular local variable. They allow to pass arguments to the function when it is called. The different\nparameters are separated by commas.\n\u2022\nstatements is the function's body. It is a block of statements surrounded by braces { }.\nHere you have the first function example:\n// function example The result is 8\n#include <iostream>\nusing namespace std;\nint addition (int a, int b)\n{\nint r;\nr=a+b;\nreturn (r);\n}\nint main ()\n{\nint z;\nz = addition (5,3);\ncout << \"The result is \" << z;\nreturn 0;\n}\nIn order to examine this code, first of all remember something said at the beginning of this tutorial: a C++\nprogram always begins its execution by the main function. So we will begin there.\nWe can see how the main function begins by declaring the variable z of type int. Right after that, we see a call to\na function called addition. Paying attention we will be able to see the similarity between the structure of the call\nto the function and the declaration of the function itself some code lines above:\nThe parameters and arguments have a clear correspondence. Within the main function we called to addition\npassing two values: 5 and 3, that correspond to the int a and int b parameters declared for function addition.\n41\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nAt the point at which the function is called from within main, the control is lost by main and passed to function\naddition. The value of both arguments passed in the call (5 and 3) are copied to the local variables int a and int\nb within the function.\nFunction addition declares another local variable (int r), and by means of the expression r=a+b, it assigns to r\nthe result of a plus b. Because the actual parameters passed for a and b are 5 and 3 respectively, the result is 8.\nThe following line of code:\nreturn (r);\nfinalizes function addition, and returns the control back to the function that called it in the first place (in this case,\nmain). At this moment the program follows it regular course from the same point at which it was interrupted by the\ncall to addition. But additionally, because the return statement in function addition specified a value: the\ncontent of variable r (return (r);), which at that moment had a value of 8. This value becomes the value of\nevaluating the function call.\nSo being the value returned by a function the value given to the function call itself when it is evaluated, the\nvariable z will be set to the value returned by addition (5, 3), that is 8. To explain it another way, you can\nimagine that the call to a function (addition (5,3)) is literally replaced by the value it returns (8).\nThe following line of code in main is:\ncout << \"The result is \" << z;\nThat, as you may already expect, produces the printing of the result on the screen.\n42\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nScope of variables\nThe scope of variables declared within a function or any other inner block is only their own function or their own\nblock and cannot be used outside of them. For example, in the previous example it would have been impossible to\nuse the variables a, b or r directly in function main since they were variables local to function addition. Also, it\nwould have been impossible to use the variable z directly within function addition, since this was a variable local\nto the function main.\nTherefore, the scope of local variables is limited to the same block level in which they are declared. Nevertheless,\nwe also have the possibility to declare global variables; These are visible from any point of the code, inside and\noutside all functions. In order to declare global variables you simply have to declare the variable outside any\nfunction or block; that means, directly in the body of the program.\nAnd here is another example about functions:\n43\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// function example The first result is 5\n#include <iostream> The second result is 5\nusing namespace std; The third result is 2\nThe fourth result is 6\nint subtraction (int a, int b)\n{\nint r;\nr=a-b;\nreturn (r);\n}\nint main ()\n{\nint x=5, y=3, z;\nz = subtraction (7,2);\ncout << \"The first result is \" << z << '\\n';\ncout << \"The second result is \" << subtraction (7,2) << '\\n';\ncout << \"The third result is \" << subtraction (x,y) << '\\n';\nz= 4 + subtraction (x,y);\ncout << \"The fourth result is \" << z << '\\n';\nreturn 0;\n}\nIn this case we have created a function called subtraction. The only thing that this function does is to subtract\nboth passed parameters and to return the result.\nNevertheless, if we examine function main we will see that we have made several calls to function subtraction.\nWe have used some different calling methods so that you see other ways or moments when a function can be\ncalled.\nIn order to fully understand these examples you must consider once again that a call to a function could be\nreplaced by the value that the function call itself is going to return. For example, the first case (that you should\nalready know because it is the same pattern that we have used in previous examples):\nz = subtraction (7,2);\ncout << \"The first result is \" << z;\nIf we replace the function call by the value it returns (i.e., 5), we would have:\nz = 5;\ncout << \"The first result is \" << z;\nAs well as\ncout << \"The second result is \" << subtraction (7,2);\nhas the same result as the previous call, but in this case we made the call to subtraction directly as an insertion\nparameter for cout. Simply consider that the result is the same as if we had written:\ncout << \"The second result is \" << 5;\nsince 5 is the value returned by subtraction (7,2).\nIn the case of:\ncout << \"The third result is \" << subtraction (x,y);\n44\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThe only new thing that we introduced is that the parameters of subtraction are variables instead of constants.\nThat is perfectly valid. In this case the values passed to function subtraction are the values of x and y, that are 5\nand 3 respectively, giving 2 as result.\nThe fourth case is more of the same. Simply note that instead of:\nz = 4 + subtraction (x,y);\nwe could have written:\nz = subtraction (x,y) + 4;\nwith exactly the same result. I have switched places so you can see that the semicolon sign (;) goes at the end of\nthe whole statement. It does not necessarily have to go right after the function call. The explanation might be once\nagain that you imagine that a function can be replaced by its returned value:\nz = 4 + 2;\nz = 2 + 4;\nFunctions with no type. The use of void.\nIf you remember the syntax of a function declaration:\ntype name ( argument1, argument2 ...) statement\nyou will see that the declaration begins with a type, that is the type of the function itself (i.e., the type of the\ndatum that will be returned by the function with the return statement). But what if we want to return no value?\nImagine that we want to make a function just to show a message on the screen. We do not need it to return any\nvalue. In this case we should use the void type specifier for the function. This is a special specifier that indicates\nabsence of type.\n// void function example I'm a function!\n#include <iostream>\nusing namespace std;\nvoid printmessage ()\n{\ncout << \"I'm a function!\";\n}\nint main ()\n{\nprintmessage ();\nreturn 0;\n}\nvoid can also be used in the function's parameter list to explicitly specify that we want the function to take no\nactual parameters when it is called. For example, function printmessage could have been declared as:\nvoid printmessage (void)\n{\ncout << \"I'm a function!\";\n}\nAlthough it is optional to specify void in the parameter list. In C++, a parameter list can simply be left blank if we\nwant a function with no parameters.\n45\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nWhat you must always remember is that the format for calling a function includes specifying its name and\nenclosing its parameters between parentheses. The non-existence of parameters does not exempt us from the\nobligation to write the parentheses. For that reason the call to printmessage is:\nprintmessage ();\nThe parentheses clearly indicate that this is a call to a function and not the name of a variable or some other C++\nstatement. The following call would have been incorrect:\nprintmessage;\n46\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nFunctions (II)\nArguments passed by value and by reference.\nUntil now, in all the functions we have seen, the arguments passed to the functions have been passed by value.\nThis means that when calling a function with parameters, what we have passed to the function were copies of their\nvalues but never the variables themselves. For example, suppose that we called our first function addition using\nthe following code:\nint x=5, y=3, z;\nz = addition ( x , y );\nWhat we did in this case was to call to function addition passing the values of x and y, i.e. 5 and 3 respectively, but\nnot the variables x and y themselves.\nThis way, when the function addition is called, the value of its local variables a and b become 5 and 3 respectively,\nbut any modification to either a or b within the function addition will not have any effect in the values of x and y\noutside it, because variables x and y were not themselves passed to the function, but only copies of their values at\nthe moment the function was called.\nBut there might be some cases where you need to manipulate from inside a function the value of an external\nvariable. For that purpose we can use arguments passed by reference, as in the function duplicate of the following\nexample:\n// passing parameters by reference x=2, y=6, z=14\n#include <iostream>\nusing namespace std;\nvoid duplicate (int& a, int& b, int& c)\n{\na*=2;\nb*=2;\nc*=2;\n}\nint main ()\n{\nint x=1, y=3, z=7;\nduplicate (x, y, z);\ncout << \"x=\" << x << \", y=\" << y << \", z=\" << z;\nreturn 0;\n}\nThe first thing that should call your attention is that in the declaration of duplicate the type of each parameter\nwas followed by an ampersand sign (&). This ampersand is what specifies that their corresponding arguments are\nto be passed by reference instead of by value.\nWhen a variable is passed by reference we are not passing a copy of its value, but we are somehow passing the\nvariable itself to the function and any modification that we do to the local variables will have an effect in their\ncounterpart variables passed as arguments in the call to the function.\n47\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nTo explain it in another way, we associate a, b and c with the arguments passed on the function call (x, y and z)\nand any change that we do on a within the function will affect the value of x outside it. Any change that we do on b\nwill affect y, and the same with c and z.\nThat is why our program's output, that shows the values stored in x, y and z after the call to duplicate, shows the\nvalues of all the three variables of main doubled.\nIf when declaring the following function:\nvoid duplicate (int& a, int& b, int& c)\nwe had declared it this way:\nvoid duplicate (int a, int b, int c)\ni.e., without the ampersand signs (&), we would have not passed the variables by reference, but a copy of their\nvalues instead, and therefore, the output on screen of our program would have been the values of x, y and z\nwithout having been modified.\nPassing by reference is also an effective way to allow a function to return more than one value. For example, here\nis a function that returns the previous and next numbers of the first parameter passed.\n// more than one returning value Previous=99, Next=101\n#include <iostream>\nusing namespace std;\nvoid prevnext (int x, int& prev, int& next)\n{\nprev = x-1;\nnext = x+1;\n}\nint main ()\n{\nint x=100, y, z;\nprevnext (x, y, z);\ncout << \"Previous=\" << y << \", Next=\" << z;\nreturn 0;\n}\nDefault values in parameters.\nWhen declaring a function we can specify a default value for each of the last parameters. This value will be used if\nthe corresponding argument is left blank when calling to the function. To do that, we simply have to use the\nassignment operator and a value for the arguments in the function declaration. If a value for that parameter is not\npassed when the function is called, the default value is used, but if a value is specified this default value is ignored\nand the passed value is used instead. For example:\n48\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// default values in functions 6\n#include <iostream> 5\nusing namespace std;\nint divide (int a, int b=2)\n{\nint r;\nr=a/b;\nreturn (r);\n}\nint main ()\n{\ncout << divide (12);\ncout << endl;\ncout << divide (20,4);\nreturn 0;\n}\nAs we can see in the body of the program there are two calls to function divide. In the first one:\ndivide (12)\nwe have only specified one argument, but the function divide allows up to two. So the function divide has\nassumed that the second parameter is 2 since that is what we have specified to happen if this parameter was not\npassed (notice the function declaration, which finishes with int b=2, not just int b). Therefore the result of this\nfunction call is 6 (12/2).\nIn the second call:\ndivide (20,4)\nthere are two parameters, so the default value for b (int b=2) is ignored and b takes the value passed as\nargument, that is 4, making the result returned equal to 5 (20/4).\n49\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nOverloaded functions.\nIn C++ two different functions can have the same name if their parameter types or number are different. That\nmeans that you can give the same name to more than one function if they have either a different number of\nparameters or different types in their parameters. For example:\n// overloaded function 10\n#include <iostream> 2.5\nusing namespace std;\nint operate (int a, int b)\n{\nreturn (a*b);\n}\nfloat operate (float a, float b)\n{\nreturn (a/b);\n}\nint main ()\n{\nint x=5,y=2;\nfloat n=5.0,m=2.0;\ncout << operate (x,y);\ncout << \"\\n\";\ncout << operate (n,m);\ncout << \"\\n\";\nreturn 0;\n}\nIn this case we have defined two functions with the same name, operate, but one of them accepts two parameters\nof type int and the other one accepts them of type float. The compiler knows which one to call in each case by\nexamining the types passed as arguments when the function is called. If it is called with two ints as its arguments\nit calls to the function that has two int parameters in its prototype and if it is called with two floats it will call to\nthe one which has two float parameters in its prototype.\nIn the first call to operate the two arguments passed are of type int, therefore, the function with the first\nprototype is called; This function returns the result of multiplying both parameters. While the second call passes\ntwo arguments of type float, so the function with the second prototype is called. This one has a different\nbehavior: it divides one parameter by the other. So the behavior of a call to operate depends on the type of the\narguments passed because the function has been overloaded.\nNotice that a function cannot be overloaded only by its return type. At least one of its parameters must have a\ndifferent type.\ninline functions.\nThe inline specifier indicates the compiler that inline substitution is preferred to the usual function call mechanism\nfor a specific function. This does not change the behavior of a function itself, but is used to suggest to the compiler\nthat the code generated by the function body is inserted at each point the function is called, instead of being\ninserted only once and perform a regular call to it, which generally involves some additional overhead in running\ntime.\nThe format for its declaration is:\ninline type name ( arguments ... ) { instructions ... }\nand the call is just like the call to any other function. You do not have to include the inline keyword when calling\nthe function, only in its declaration.\n50\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nMost compilers already optimize code to generate inline functions when it is more convenient. This specifier only\nindicates the compiler that inline is preferred for this function.\nRecursivity.\nRecursivity is the property that functions have to be called by themselves. It is useful for many tasks, like sorting\nor calculate the factorial of numbers. For example, to obtain the factorial of a number (n!) the mathematical\nformula would be:\nn! = n * (n-1) * (n-2) * (n-3) ... * 1\nmore concretely, 5! (factorial of 5) would be:\n5! = 5 * 4 * 3 * 2 * 1 = 120\nand a recursive function to calculate this in C++ could be:\n// factorial calculator Please type a number: 9\n#include <iostream> 9! = 362880\nusing namespace std;\nlong factorial (long a)\n{\nif (a > 1)\nreturn (a * factorial (a-1));\nelse\nreturn (1);\n}\nint main ()\n{\nlong number;\ncout << \"Please type a number: \";\ncin >> number;\ncout << number << \"! = \" << factorial (number);\nreturn 0;\n}\nNotice how in function factorial we included a call to itself, but only if the argument passed was greater than 1,\nsince otherwise the function would perform an infinite recursive loop in which once it arrived to 0 it would continue\nmultiplying by all the negative numbers (probably provoking a stack overflow error on runtime).\nThis function has a limitation because of the data type we used in its design (long) for more simplicity. The results\ngiven will not be valid for values much greater than 10! or 15!, depending on the system you compile it.\nDeclaring functions.\nUntil now, we have defined all of the functions before the first appearance of calls to them in the source code.\nThese calls were generally in function main which we have always left at the end of the source code. If you try to\nrepeat some of the examples of functions described so far, but placing the function main before any of the other\nfunctions that were called from within it, you will most likely obtain compiling errors. The reason is that to be able\nto call a function it must have been declared in some earlier point of the code, like we have done in all our\nexamples.\nBut there is an alternative way to avoid writing the whole code of a function before it can be used in main or in\nsome other function. This can be achieved by declaring just a prototype of the function before it is used, instead of\nthe entire definition. This declaration is shorter than the entire definition, but significant enough for the compiler to\ndetermine its return type and the types of its parameters.\nIts form is:\n51\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\ntype name ( argument_type1, argument_type2, ...);\nIt is identical to a function definition, except that it does not include the body of the function itself (i.e., the\nfunction statements that in normal definitions are enclosed in braces { }) and instead of that we end the prototype\ndeclaration with a mandatory semicolon (;).\nThe parameter enumeration does not need to include the identifiers, but only the type specifiers. The inclusion of a\nname for each parameter as in the function definition is optional in the prototype declaration. For example, we can\ndeclare a function called protofunction with two int parameters with any of the following declarations:\nint protofunction (int first, int second);\nint protofunction (int, int);\nAnyway, including a name for each variable makes the prototype more legible.\n// declaring functions prototypes Type a number (0 to exit): 9\n#include <iostream> Number is odd.\nusing namespace std; Type a number (0 to exit): 6\nNumber is even.\nvoid odd (int a); Type a number (0 to exit): 1030\nvoid even (int a); Number is even.\nType a number (0 to exit): 0\nint main () Number is even.\n{\nint i;\ndo {\ncout << \"Type a number (0 to exit): \";\ncin >> i;\nodd (i);\n} while (i!=0);\nreturn 0;\n}\nvoid odd (int a)\n{\nif ((a%2)!=0) cout << \"Number is odd.\\n\";\nelse even (a);\n}\nvoid even (int a)\n{\nif ((a%2)==0) cout << \"Number is even.\\n\";\nelse odd (a);\n}\nThis example is indeed not an example of efficiency. I am sure that at this point you can already make a program\nwith the same result, but using only half of the code lines that have been used in this example. Anyway this\nexample illustrates how prototyping works. Moreover, in this concrete example the prototyping of at least one of\nthe two functions is necessary in order to compile the code without errors.\nThe first things that we see are the declaration of functions odd and even:\nvoid odd (int a);\nvoid even (int a);\nThis allows these functions to be used before they are defined, for example, in main, which now is located where\nsome people find it to be a more logical place for the start of a program: the beginning of the source code.\nAnyway, the reason why this program needs at least one of the functions to be declared before it is defined is\nbecause in odd there is a call to even and in even there is a call to odd. If none of the two functions had been\n52\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\npreviously declared, a compilation error would happen, since either odd would not not be visible from even\n(because it has still not been declared), or even would not be visible from odd (for the same reason).\nHaving the prototype of all functions together in the same place within the source code is found practical by some\nprogrammers, and this can be easily achieved by declaring all functions prototypes at the beginning of a program.\n53\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nCompound data types\nArrays\nAn array is a series of elements of the same type placed in contiguous memory locations that can be individually\nreferenced by adding an index to a unique identifier.\nThat means that, for example, we can store 5 values of type int in an array without having to declare 5 different\nvariables, each one with a different identifier. Instead of that, using an array we can store 5 different values of the\nsame type, int for example, with a unique identifier.\nFor example, an array to contain 5 integer values of type int called billy could be represented like this:\nwhere each blank panel represents an element of the array, that in this case are integer values of type int. These\nelements are numbered from 0 to 4 since in arrays the first index is always 0, independently of its length.\nLike a regular variable, an array must be declared before it is used. A typical declaration for an array in C++ is:\ntype name [elements];\nwhere type is a valid type (like int, float...), name is a valid identifier and the elements field (which is always\nenclosed in square brackets []), specifies how many of these elements the array has to contain.\nTherefore, in order to declare an array called billy as the one shown in the above diagram it is as simple as:\nint billy [5];\nNOTE: The elements field within brackets [] which represents the number of elements the array is going to hold,\nmust be a constant value, since arrays are blocks of non-dynamic memory whose size must be determined before\nexecution. In order to create arrays with a variable length dynamic memory is needed, which is explained later in\nthese tutorials.\nInitializing arrays.\nWhen declaring a regular array of local scope (within a function, for example), if we do not specify otherwise, its\nelements will not be initialized to any value by default, so their content will be undetermined until we store some\nvalue in them. The elements of global and static arrays, on the other hand, are automatically initialized with their\ndefault values, which for all fundamental types this means they are filled with zeros.\nIn both cases, local and global, when we declare an array, we have the possibility to assign initial values to each\none of its elements by enclosing the values in braces { }. For example:\nint billy [5] = { 16, 2, 77, 40, 12071 };\nThis declaration would have created an array like this:\n54\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThe amount of values between braces { } must not be larger than the number of elements that we declare for the\narray between square brackets [ ]. For example, in the example of array billy we have declared that it has 5\nelements and in the list of initial values within braces { } we have specified 5 values, one for each element.\nWhen an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets\nempty [ ]. In this case, the compiler will assume a size for the array that matches the number of values included\nbetween braces { }:\nint billy [] = { 16, 2, 77, 40, 12071 };\nAfter this declaration, array billy would be 5 ints long, since we have provided 5 initialization values.\nAccessing the values of an array.\nIn any point of a program in which an array is visible, we can access the value of any of its elements individually as\nif it was a normal variable, thus being able to both read and modify its value. The format is as simple as:\nname[index]\nFollowing the previous examples in which billy had 5 elements and each of those elements was of type int, the\nname which we can use to refer to each element is the following:\nFor example, to store the value 75 in the third element of billy, we could write the following statement:\nbilly[2] = 75;\nand, for example, to pass the value of the third element of billy to a variable called a, we could write:\na = billy[2];\nTherefore, the expression billy[2] is for all purposes like a variable of type int.\nNotice that the third element of billy is specified billy[2], since the first one is billy[0], the second one is\nbilly[1], and therefore, the third one is billy[2]. By this same reason, its last element is billy[4]. Therefore, if\nwe write billy[5], we would be accessing the sixth element of billy and therefore exceeding the size of the array.\nIn C++ it is syntactically correct to exceed the valid range of indices for an array. This can create problems, since\naccessing out-of-range elements do not cause compilation errors but can cause runtime errors. The reason why\nthis is allowed will be seen further ahead when we begin to use pointers.\nAt this point it is important to be able to clearly distinguish between the two uses that brackets [ ] have related to\narrays. They perform two different tasks: one is to specify the size of arrays when they are declared; and the\nsecond one is to specify indices for concrete array elements. Do not confuse these two possible uses of brackets [\n] with arrays.\n55\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nint billy[5]; // declaration of a new array\nbilly[2] = 75; // access to an element of the array.\nIf you read carefully, you will see that a type specifier always precedes a variable or array declaration, while it\nnever precedes an access.\nSome other valid operations with arrays:\nbilly[0] = a;\nbilly[a] = 75;\nb = billy [a+2];\nbilly[billy[a]] = billy[2] + 5;\n// arrays example 12206\n#include <iostream>\nusing namespace std;\nint billy [] = {16, 2, 77, 40, 12071};\nint n, result=0;\nint main ()\n{\nfor ( n=0 ; n<5 ; n++ )\n{\nresult += billy[n];\n}\ncout << result;\nreturn 0;\n}\nMultidimensional arrays\nMultidimensional arrays can be described as \"arrays of arrays\". For example, a bidimensional array can be\nimagined as a bidimensional table made of elements, all of them of a same uniform data type.\njimmy represents a bidimensional array of 3 per 5 elements of type int. The way to declare this array in C++\nwould be:\nint jimmy [3][5];\nand, for example, the way to reference the second element vertically and fourth horizontally in an expression\nwould be:\njimmy[1][3]\n56\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n(remember that array indices always begin by zero).\nMultidimensional arrays are not limited to two indices (i.e., two dimensions). They can contain as many indices as\nneeded. But be careful! The amount of memory needed for an array rapidly increases with each dimension. For\nexample:\nchar century [100][365][24][60][60];\ndeclares an array with a char element for each second in a century, that is more than 3 billion chars. So this\ndeclaration would consume more than 3 gigabytes of memory!\nMultidimensional arrays are just an abstraction for programmers, since we can obtain the same results with a\nsimple array just by putting a factor between its indices:\nint jimmy [3][5]; // is equivalent to\nint jimmy [15]; // (3 * 5 = 15)\nWith the only difference that with multidimensional arrays the compiler remembers the depth of each imaginary\ndimension for us. Take as example these two pieces of code, with both exactly the same result. One uses a\nbidimensional array and the other one uses a simple array:\nmultidimensional array pseudo-multidimensional array\n#define WIDTH 5 #define WIDTH 5\n#define HEIGHT 3 #define HEIGHT 3\nint jimmy [HEIGHT][WIDTH]; int jimmy [HEIGHT * WIDTH];\nint n,m; int n,m;\nint main () int main ()\n{ {\nfor (n=0;n<HEIGHT;n++) for (n=0;n<HEIGHT;n++)\nfor (m=0;m<WIDTH;m++) for (m=0;m<WIDTH;m++)\n{ {\njimmy[n][m]=(n+1)*(m+1); jimmy[n*WIDTH+m]=(n+1)*(m+1);\n} }\nreturn 0; return 0;\n} }\nNone of the two source codes above produce any output on the screen, but both assign values to the memory\nblock called jimmy in the following way:\n57\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nWe have used \"defined constants\" (#define) to simplify possible future modifications of the program. For example,\nin case that we decided to enlarge the array to a height of 4 instead of 3 it could be done simply by changing the\nline:\n#define HEIGHT 3\nto:\n#define HEIGHT 4\nwith no need to make any other modifications to the program.\nArrays as parameters\nAt some moment we may need to pass an array to a function as a parameter. In C++ it is not possible to pass a\ncomplete block of memory by value as a parameter to a function, but we are allowed to pass its address. In\npractice this has almost the same effect and it is a much faster and more efficient operation.\nIn order to accept arrays as parameters the only thing that we have to do when declaring the function is to specify\nin its parameters the element type of the array, an identifier and a pair of void brackets []. For example, the\nfollowing function:\nvoid procedure (int arg[])\naccepts a parameter of type \"array of int\" called arg. In order to pass to this function an array declared as:\nint myarray [40];\nit would be enough to write a call like this:\nprocedure (myarray);\nHere you have a complete example:\n// arrays as parameters 5 10 15\n#include <iostream> 2 4 6 8 10\nusing namespace std;\nvoid printarray (int arg[], int length) {\nfor (int n=0; n<length; n++)\ncout << arg[n] << \" \";\ncout << \"\\n\";\n}\nint main ()\n{\nint firstarray[] = {5, 10, 15};\nint secondarray[] = {2, 4, 6, 8, 10};\nprintarray (firstarray,3);\nprintarray (secondarray,5);\nreturn 0;\n}\nAs you can see, the first parameter (int arg[]) accepts any array whose elements are of type int, whatever its\nlength. For that reason we have included a second parameter that tells the function the length of each array that\n58\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nwe pass to it as its first parameter. This allows the for loop that prints out the array to know the range to iterate in\nthe passed array without going out of range.\nIn a function declaration it is also possible to include multidimensional arrays. The format for a tridimensional array\nparameter is:\nbase_type[][depth][depth]\nfor example, a function with a multidimensional array as argument could be:\nvoid procedure (int myarray[][3][4])\nNotice that the first brackets [] are left blank while the following ones are not. This is so because the compiler\nmust be able to determine within the function which is the depth of each additional dimension.\nArrays, both simple or multidimensional, passed as function parameters are a quite common source of errors for\nnovice programmers. I recommend the reading of the chapter about Pointers for a better understanding on how\narrays operate.\n59\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nCharacter Sequences\nAs you may already know, the C++ Standard Library implements a powerful string class, which is very useful to\nhandle and manipulate strings of characters. However, because strings are in fact sequences of characters, we can\nrepresent them also as plain arrays of char elements.\nFor example, the following array:\nchar jenny [20];\nis an array that can store up to 20 elements of type char. It can be represented as:\nTherefore, in this array, in theory, we can store sequences of characters up to 20 characters long. But we can also\nstore shorter sequences. For example, jenny could store at some point in a program either the sequence \"Hello\"\nor the sequence \"Merry christmas\", since both are shorter than 20 characters.\nTherefore, since the array of characters can store shorter sequences than its total length, a special character is\nused to signal the end of the valid sequence: the null character, whose literal constant can be written as '\\0'\n(backslash, zero).\nOur array of 20 elements of type char, called jenny, can be represented storing the characters sequences \"Hello\"\nand \"Merry Christmas\" as:\nNotice how after the valid content a null character ('\\0') has been included in order to indicate the end of the\nsequence. The panels in gray color represent char elements with undetermined values.\nInitialization of null-terminated character sequences\nBecause arrays of characters are ordinary arrays they follow all their same rules. For example, if we want to\ninitialize an array of characters with some predetermined sequence of characters we can do it just like any other\narray:\nchar myword[] = { 'H', 'e', 'l', 'l', 'o', '\\0' };\nIn this case we would have declared an array of 6 elements of type char initialized with the characters that form\nthe word \"Hello\" plus a null character '\\0' at the end.\nBut arrays of char elements have an additional method to initialize their values: using string literals.\nIn the expressions we have used in some examples in previous chapters, constants that represent entire strings of\ncharacters have already showed up several times. These are specified enclosing the text to become a string literal\nbetween double quotes (\"). For example:\n\"the result is: \"\n60\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nis a constant string literal that we have probably used already.\nDouble quoted strings (\") are literal constants whose type is in fact a null-terminated array of characters. So string\nliterals enclosed between double quotes always have a null character ('\\0') automatically appended at the end.\nTherefore we can initialize the array of char elements called myword with a null-terminated sequence of characters\nby either one of these two methods:\nchar myword [] = { 'H', 'e', 'l', 'l', 'o', '\\0' };\nchar myword [] = \"Hello\";\nIn both cases the array of characters myword is declared with a size of 6 elements of type char: the 5 characters\nthat compose the word \"Hello\" plus a final null character ('\\0') which specifies the end of the sequence and that,\nin the second case, when using double quotes (\") it is appended automatically.\nPlease notice that we are talking about initializing an array of characters in the moment it is being declared, and\nnot about assigning values to them once they have already been declared. In fact because this type of null-\nterminated arrays of characters are regular arrays we have the same restrictions that we have with any other\narray, so we are not able to copy blocks of data with an assignment operation.\nAssuming mystext is a char[] variable, expressions within a source code like:\nmystext = \"Hello\";\nmystext[] = \"Hello\";\nwould not be valid, like neither would be:\nmystext = { 'H', 'e', 'l', 'l', 'o', '\\0' };\nThe reason for this may become more comprehensible once you know a bit more about pointers, since then it will\nbe clarified that an array is in fact a constant pointer pointing to a block of memory.\nUsing null-terminated sequences of characters\nNull-terminated sequences of characters are the natural way of treating strings in C++, so they can be used as\nsuch in many procedures. In fact, regular string literals have this type (char[]) and can also be used in most\ncases.\nFor example, cin and cout support null-terminated sequences as valid containers for sequences of characters, so\nthey can be used directly to extract strings of characters from cin or to insert them into cout. For example:\n61\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// null-terminated sequences of characters Please, enter your first name: John\n#include <iostream> Hello, John!\nusing namespace std;\nint main ()\n{\nchar question[] = \"Please, enter your first\nname: \";\nchar greeting[] = \"Hello, \";\nchar yourname [80];\ncout << question;\ncin >> yourname;\ncout << greeting << yourname << \"!\";\nreturn 0;\n}\nAs you can see, we have declared three arrays of char elements. The first two were initialized with string literal\nconstants, while the third one was left uninitialized. In any case, we have to speficify the size of the array: in the\nfirst two (question and greeting) the size was implicitly defined by the length of the literal constant they were\ninitialized to. While for yourname we have explicitly specified that it has a size of 80 chars.\nFinally, sequences of characters stored in char arrays can easily be converted into string objects just by using the\nassignment operator:\nstring mystring;\nchar myntcs[]=\"some text\";\nmystring = myntcs;\n62\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nPointers\nWe have already seen how variables are seen as memory cells that can be accessed using their identifiers. This\nway we did not have to care about the physical location of our data within memory, we simply used its identifier\nwhenever we wanted to refer to our variable.\nThe memory of your computer can be imagined as a succession of memory cells, each one of the minimal size that\ncomputers manage (one byte). These single-byte memory cells are numbered in a consecutive way, so as, within\nany block of memory, every cell has the same number as the previous one plus one.\nThis way, each cell can be easily located in the memory because it has a unique address and all the memory cells\nfollow a successive pattern. For example, if we are looking for cell 1776 we know that it is going to be right\nbetween cells 1775 and 1777, exactly one thousand cells after 776 and exactly one thousand cells before cell 2776.\nReference operator (&)\nAs soon as we declare a variable, the amount of memory needed is assigned for it at a specific location in memory\n(its memory address). We generally do not actively decide the exact location of the variable within the panel of\ncells that we have imagined the memory to be - Fortunately, that is a task automatically performed by the\noperating system during runtime. However, in some cases we may be interested in knowing the address where our\nvariable is being stored during runtime in order to operate with relative positions to it.\nThe address that locates a variable within memory is what we call a reference to that variable. This reference to a\nvariable can be obtained by preceding the identifier of a variable with an ampersand sign (&), known as reference\noperator, and which can be literally translated as \"address of\". For example:\nted = &andy;\nThis would assign to ted the address of variable andy, since when preceding the name of the variable andy with\nthe reference operator (&) we are no longer talking about the content of the variable itself, but about its reference\n(i.e., its address in memory).\nFrom now on we are going to assume that andy is placed during runtime in the memory address 1776. This number\n(1776) is just an arbitrary assumption we are inventing right now in order to help clarify some concepts in this\ntutorial, but in reality, we cannot know before runtime the real value the address of a variable will have in memory.\nConsider the following code fragment:\nandy = 25;\nfred = andy;\nted = &andy;\nThe values contained in each variable after the execution of this, are shown in the following diagram:\nFirst, we have assigned the value 25 to andy (a variable whose address in memory we have assumed to be 1776).\n63\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThe second statement copied to fred the content of variable andy (which is 25). This is a standard assignment\noperation, as we have done so many times before.\nFinally, the third statement copies to ted not the value contained in andy but a reference to it (i.e., its address,\nwhich we have assumed to be 1776). The reason is that in this third assignment operation we have preceded the\nidentifier andy with the reference operator (&), so we were no longer referring to the value of andy but to its\nreference (its address in memory).\nThe variable that stores the reference to another variable (like ted in the previous example) is what we call a\npointer. Pointers are a very powerful feature of the C++ language that has many uses in advanced programming.\nFarther ahead, we will see how this type of variable is used and declared.\nDereference operator (*)\nWe have just seen that a variable which stores a reference to another variable is called a pointer. Pointers are said\nto \"point to\" the variable whose reference they store.\nUsing a pointer we can directly access the value stored in the variable which it points to. To do this, we simply\nhave to precede the pointer's identifier with an asterisk (*), which acts as dereference operator and that can be\nliterally translated to \"value pointed by\".\nTherefore, following with the values of the previous example, if we write:\nbeth = *ted;\n(that we could read as: \"beth equal to value pointed by ted\") beth would take the value 25, since ted is 1776, and\nthe value pointed by 1776 is 25.\nYou must clearly differentiate that the expression ted refers to the value 1776, while *ted (with an asterisk *\npreceding the identifier) refers to the value stored at address 1776, which in this case is 25. Notice the difference of\nincluding or not including the dereference operator (I have included an explanatory commentary of how each of\nthese two expressions could be read):\nbeth = ted; // beth equal to ted ( 1776 )\nbeth = *ted; // beth equal to value pointed by ted ( 25 )\nNotice the difference between the reference and dereference operators:\n\u2022\n& is the reference operator and can be read as \"address of\"\n\u2022\n* is the dereference operator and can be read as \"value pointed by\"\n64\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThus, they have complementary (or opposite) meanings. A variable referenced with & can be dereferenced with *.\nEarlier we performed the following two assignment operations:\nandy = 25;\nted = &andy;\nRight after these two statements, all of the following expressions would give true as result:\nandy == 25\n&andy == 1776\nted == 1776\n*ted == 25\nThe first expression is quite clear considering that the assignment operation performed on andy was andy=25. The\nsecond one uses the reference operator (&), which returns the address of variable andy, which we assumed it to\nhave a value of 1776. The third one is somewhat obvious since the second expression was true and the assignment\noperation performed on ted was ted=&andy. The fourth expression uses the dereference operator (*) that, as we\nhave just seen, can be read as \"value pointed by\", and the value pointed by ted is indeed 25.\nSo, after all that, you may also infer that for as long as the address pointed by ted remains unchanged the\nfollowing expression will also be true:\n*ted == andy\nDeclaring variables of pointer types\nDue to the ability of a pointer to directly refer to the value that it points to, it becomes necessary to specify in its\ndeclaration which data type a pointer is going to point to. It is not the same thing to point to a char as to point to\nan int or a float.\nThe declaration of pointers follows this format:\ntype * name;\nwhere type is the data type of the value that the pointer is intended to point to. This type is not the type of the\npointer itself! but the type of the data the pointer points to. For example:\nint * number;\nchar * character;\nfloat * greatnumber;\nThese are three declarations of pointers. Each one is intended to point to a different data type, but in fact all of\nthem are pointers and all of them will occupy the same amount of space in memory (the size in memory of a\npointer depends on the platform where the code is going to run). Nevertheless, the data to which they point to do\nnot occupy the same amount of space nor are of the same type: the first one points to an int, the second one to a\nchar and the last one to a float. Therefore, although these three example variables are all of them pointers which\noccupy the same size in memory, they are said to have different types: int*, char* and float* respectively,\ndepending on the type they point to.\nI want to emphasize that the asterisk sign (*) that we use when declaring a pointer only means that it is a pointer\n(it is part of its type compound specifier), and should not be confused with the dereference operator that we have\nseen a bit earlier, but which is also written with an asterisk (*). They are simply two different things represented\nwith the same sign.\n65\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nNow have a look at this code:\n// my first pointer firstvalue is 10\n#include <iostream> secondvalue is 20\nusing namespace std;\nint main ()\n{\nint firstvalue, secondvalue;\nint * mypointer;\nmypointer = &firstvalue;\n*mypointer = 10;\nmypointer = &secondvalue;\n*mypointer = 20;\ncout << \"firstvalue is \" << firstvalue << endl;\ncout << \"secondvalue is \" << secondvalue << endl;\nreturn 0;\n}\nNotice that even though we have never directly set a value to either firstvalue or secondvalue, both end up with\na value set indirectly through the use of mypointer. This is the procedure:\nFirst, we have assigned as value of mypointer a reference to firstvalue using the reference operator (&). And\nthen we have assigned the value 10 to the memory location pointed by mypointer, that because at this moment is\npointing to the memory location of firstvalue, this in fact modifies the value of firstvalue.\nIn order to demonstrate that a pointer may take several different values during the same program I have repeated\nthe process with secondvalue and that same pointer, mypointer.\nHere is an example a little bit more elaborated:\n// more pointers firstvalue is 10\n#include <iostream> secondvalue is 20\nusing namespace std;\nint main ()\n{\nint firstvalue = 5, secondvalue = 15;\nint * p1, * p2;\np1 = &firstvalue; // p1 = address of firstvalue\np2 = &secondvalue; // p2 = address of secondvalue\n*p1 = 10; // value pointed by p1 = 10\n*p2 = *p1; // value pointed by p2 = value pointed by\np1\np1 = p2; // p1 = p2 (value of pointer is copied)\n*p1 = 20; // value pointed by p1 = 20\ncout << \"firstvalue is \" << firstvalue << endl;\ncout << \"secondvalue is \" << secondvalue << endl;\nreturn 0;\n}\nI have included as a comment on each line how the code can be read: ampersand (&) as \"address of\" and asterisk\n(*) as \"value pointed by\".\nNotice that there are expressions with pointers p1 and p2, both with and without dereference operator (*). The\nmeaning of an expression using the dereference operator (*) is very different from one that does not: When this\noperator precedes the pointer name, the expression refers to the value being pointed, while when a pointer name\nappears without this operator, it refers to the value of the pointer itself (i.e. the address of what the pointer is\npointing to).\n66\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nAnother thing that may call your attention is the line:\nint * p1, * p2;\nThis declares the two pointers used in the previous example. But notice that there is an asterisk (*) for each\npointer, in order for both to have type int* (pointer to int).\nOtherwise, the type for the second variable declared in that line would have been int (and not int*) because of\nprecedence relationships. If we had written:\nint * p1, p2;\np1 would indeed have int* type, but p2 would have type int (spaces do not matter at all for this purpose). This is\ndue to operator precedence rules. But anyway, simply remembering that you have to put one asterisk per pointer\nis enough for most pointer users.\nPointers and arrays\nThe concept of array is very much bound to the one of pointer. In fact, the identifier of an array is equivalent to the\naddress of its first element, as a pointer is equivalent to the address of the first element that it points to, so in fact\nthey are the same concept. For example, supposing these two declarations:\nint numbers [20];\nint * p;\nThe following assignment operation would be valid:\np = numbers;\nAfter that, p and numbers would be equivalent and would have the same properties. The only difference is that we\ncould change the value of pointer p by another one, whereas numbers will always point to the first of the 20\nelements of type int with which it was defined. Therefore, unlike p, which is an ordinary pointer, numbers is an\narray, and an array can be considered a constant pointer. Therefore, the following allocation would not be valid:\nnumbers = p;\nBecause numbers is an array, so it operates as a constant pointer, and we cannot assign values to constants.\nDue to the characteristics of variables, all expressions that include pointers in the following example are perfectly\nvalid:\n67\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// more pointers 10, 20, 30, 40, 50,\n#include <iostream>\nusing namespace std;\nint main ()\n{\nint numbers[5];\nint * p;\np = numbers; *p = 10;\np++; *p = 20;\np = &numbers[2]; *p = 30;\np = numbers + 3; *p = 40;\np = numbers; *(p+4) = 50;\nfor (int n=0; n<5; n++)\ncout << numbers[n] << \", \";\nreturn 0;\n}\nIn the chapter about arrays we used brackets ([]) several times in order to specify the index of an element of the\narray to which we wanted to refer. Well, these bracket sign operators [] are also a dereference operator known as\noffset operator. They dereference the variable they follow just as * does, but they also add the number between\nbrackets to the address being dereferenced. For example:\na[5] = 0; // a [offset of 5] = 0\n*(a+5) = 0; // pointed by (a+5) = 0\nThese two expressions are equivalent and valid both if a is a pointer or if a is an array.\nPointer initialization\nWhen declaring pointers we may want to explicitly specify which variable we want them to point to:\nint number;\nint *tommy = &number;\nThe behavior of this code is equivalent to:\nint number;\nint *tommy;\ntommy = &number;\nWhen a pointer initialization takes place we are always assigning the reference value to where the pointer points\n(tommy), never the value being pointed (*tommy). You must consider that at the moment of declaring a pointer, the\nasterisk (*) indicates only that it is a pointer, it is not the dereference operator (although both use the same sign:\n*). Remember, they are two different functions of one sign. Thus, we must take care not to confuse the previous\ncode with:\nint number;\nint *tommy;\n*tommy = &number;\nthat is incorrect, and anyway would not have much sense in this case if you think about it.\nAs in the case of arrays, the compiler allows the special case that we want to initialize the content at which the\npointer points with constants at the same moment the pointer is declared:\nchar * terry = \"hello\";\n68\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nIn this case, memory space is reserved to contain \"hello\" and then a pointer to the first character of this memory\nblock is assigned to terry. If we imagine that \"hello\" is stored at the memory locations that start at addresses\n1702, we can represent the previous declaration as:\nIt is important to indicate that terry contains the value 1702, and not 'h' nor \"hello\", although 1702 indeed is\nthe address of both of these.\nThe pointer terry points to a sequence of characters and can be read as if it was an array (remember that an\narray is just like a constant pointer). For example, we can access the fifth element of the array with any of these\ntwo expression:\n*(terry+4)\nterry[4]\nBoth expressions have a value of 'o' (the fifth element of the array).\nPointer arithmetics\nTo conduct arithmetical operations on pointers is a little different than to conduct them on regular integer data\ntypes. To begin with, only addition and subtraction operations are allowed to be conducted with them, the others\nmake no sense in the world of pointers. But both addition and subtraction have a different behavior with pointers\naccording to the size of the data type to which they point.\nWhen we saw the different fundamental data types, we saw that some occupy more or less space than others in\nthe memory. For example, let's assume that in a given compiler for a specific machine, char takes 1 byte, short\ntakes 2 bytes and long takes 4.\nSuppose that we define three pointers in this compiler:\nchar *mychar;\nshort *myshort;\nlong *mylong;\nand that we know that they point to memory locations 1000, 2000 and 3000 respectively.\nSo if we write:\nmychar++;\nmyshort++;\nmylong++;\nmychar, as you may expect, would contain the value 1001. But not so obviously, myshort would contain the value\n2002, and mylong would contain 3004, even though they have each been increased only once. The reason is that\nwhen adding one to a pointer we are making it to point to the following element of the same type with which it has\nbeen defined, and therefore the size in bytes of the type pointed is added to the pointer.\n69\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThis is applicable both when adding and subtracting any number to a pointer. It would happen exactly the same if\nwe write:\nmychar = mychar + 1;\nmyshort = myshort + 1;\nmylong = mylong + 1;\nBoth the increase (++) and decrease (--) operators have greater operator precedence than the dereference\noperator (*), but both have a special behavior when used as suffix (the expression is evaluated with the value it\nhad before being increased). Therefore, the following expression may lead to confusion:\n*p++\nBecause ++ has greater precedence than *, this expression is equivalent to *(p++). Therefore, what it does is to\nincrease the value of p (so it now points to the next element), but because ++ is used as postfix the whole\nexpression is evaluated as the value pointed by the original reference (the address the pointer pointed to before\nbeing increased).\nNotice the difference with:\n(*p)++\nHere, the expression would have been evaluated as the value pointed by p increased by one. The value of p (the\npointer itself) would not be modified (what is being modified is what it is being pointed to by this pointer).\nIf we write:\n*p++ = *q++;\nBecause ++ has a higher precedence than *, both p and q are increased, but because both increase operators (++)\nare used as postfix and not prefix, the value assigned to *p is *q before both p and q are increased. And then both\nare increased. It would be roughly equivalent to:\n*p = *q;\n++p;\n++q;\nLike always, I recommend you to use parentheses () in order to avoid unexpected results and to give more\nlegibility to the code.\n70\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nPointers to pointers\nC++ allows the use of pointers that point to pointers, that these, in its turn, point to data (or even to other\npointers). In order to do that, we only need to add an asterisk (*) for each level of reference in their declarations:\nchar a;\nchar * b;\nchar ** c;\na = 'z';\nb = &a;\nc = &b;\nThis, supposing the randomly chosen memory locations for each variable of 7230, 8092 and 10502, could be\nrepresented as:\nThe value of each variable is written inside each cell; under the cells are their respective addresses in memory.\nThe new thing in this example is variable c, which can be used in three different levels of indirection, each one of\nthem would correspond to a different value:\n\u2022\nc has type char** and a value of 8092\n\u2022\n*c has type char* and a value of 7230\n\u2022\n**c has type char and a value of 'z'\nvoid pointers\nThe void type of pointer is a special type of pointer. In C++, void represents the absence of type, so void pointers\nare pointers that point to a value that has no type (and thus also an undetermined length and undetermined\ndereference properties).\nThis allows void pointers to point to any data type, from an integer value or a float to a string of characters. But in\nexchange they have a great limitation: the data pointed by them cannot be directly dereferenced (which is logical,\nsince we have no type to dereference to), and for that reason we will always have to cast the address in the void\npointer to some other pointer type that points to a concrete data type before dereferencing it.\nOne of its uses may be to pass generic parameters to a function:\n71\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// increaser y, 1603\n#include <iostream>\nusing namespace std;\nvoid increase (void* data, int psize)\n{\nif ( psize == sizeof(char) )\n{ char* pchar; pchar=(char*)data; ++(*pchar); }\nelse if (psize == sizeof(int) )\n{ int* pint; pint=(int*)data; ++(*pint); }\n}\nint main ()\n{\nchar a = 'x';\nint b = 1602;\nincrease (&a,sizeof(a));\nincrease (&b,sizeof(b));\ncout << a << \", \" << b << endl;\nreturn 0;\n}\nsizeof is an operator integrated in the C++ language that returns the size in bytes of its parameter. For non-\ndynamic data types this value is a constant. Therefore, for example, sizeof(char) is 1, because char type is one\nbyte long.\nNull pointer\nA null pointer is a regular pointer of any pointer type which has a special value that indicates that it is not pointing\nto any valid reference or memory address. This value is the result of type-casting the integer value zero to any\npointer type.\nint * p;\np = 0; // p has a null pointer value\nDo not confuse null pointers with void pointers. A null pointer is a value that any pointer may take to represent\nthat it is pointing to \"nowhere\", while a void pointer is a special type of pointer that can point to somewhere\nwithout a specific type. One refers to the value stored in the pointer itself and the other to the type of data it points\nto.\nPointers to functions\nC++ allows operations with pointers to functions. The typical use of this is for passing a function as an argument to\nanother function, since these cannot be passed dereferenced. In order to declare a pointer to a function we have to\ndeclare it like the prototype of the function except that the name of the function is enclosed between parentheses\n() and an asterisk (*) is inserted before the name:\n72\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// pointer to functions 8\n#include <iostream>\nusing namespace std;\nint addition (int a, int b)\n{ return (a+b); }\nint subtraction (int a, int b)\n{ return (a-b); }\nint operation (int x, int y, int\n(*functocall)(int,int))\n{\nint g;\ng = (*functocall)(x,y);\nreturn (g);\n}\nint main ()\n{\nint m,n;\nint (*minus)(int,int) = subtraction;\nm = operation (7, 5, addition);\nn = operation (20, m, minus);\ncout <<n;\nreturn 0;\n}\nIn the example, minus is a pointer to a function that has two parameters of type int. It is immediately assigned to\npoint to the function subtraction, all in a single line:\nint (* minus)(int,int) = subtraction;\n73\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nDynamic Memory\nUntil now, in all our programs, we have only had as much memory available as we declared for our variables,\nhaving the size of all of them to be determined in the source code, before the execution of the program. But, what\nif we need a variable amount of memory that can only be determined during runtime? For example, in the case\nthat we need some user input to determine the necessary amount of memory space.\nThe answer is dynamic memory, for which C++ integrates the operators new and delete.\nOperators new and new[]\nIn order to request dynamic memory we use the operator new. new is followed by a data type specifier and -if a\nsequence of more than one element is required- the number of these within brackets []. It returns a pointer to the\nbeginning of the new block of memory allocated. Its form is:\npointer = new type\npointer = new type [number_of_elements]\nThe first expression is used to allocate memory to contain one single element of type type. The second one is used\nto assign a block (an array) of elements of type type, where number_of_elements is an integer value representing\nthe amount of these. For example:\nint * bobby;\nbobby = new int [5];\nIn this case, the system dynamically assigns space for five elements of type int and returns a pointer to the first\nelement of the sequence, which is assigned to bobby. Therefore, now, bobby points to a valid block of memory with\nspace for five elements of type int.\nThe first element pointed by bobby can be accessed either with the expression bobby[0] or the expression *bobby.\nBoth are equivalent as has been explained in the section about pointers. The second element can be accessed\neither with bobby[1] or *(bobby+1) and so on...\nYou could be wondering the difference between declaring a normal array and assigning dynamic memory to a\npointer, as we have just done. The most important difference is that the size of an array has to be a constant\nvalue, which limits its size to what we decide at the moment of designing the program, before its execution,\nwhereas the dynamic memory allocation allows us to assign memory during the execution of the program\n(runtime) using any variable or constant value as its size.\nThe dynamic memory requested by our program is allocated by the system from the memory heap. However,\ncomputer memory is a limited resource, and it can be exhausted. Therefore, it is important to have some\nmechanism to check if our request to allocate memory was successful or not.\nC++ provides two standard methods to check if the allocation was successful:\nOne is by handling exceptions. Using this method an exception of type bad_alloc is thrown when the allocation\nfails. Exceptions are a powerful C++ feature explained later in these tutorials. But for now you should know that if\nthis exception is thrown and it is not handled by a specific handler, the program execution is terminated.\n74\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThis exception method is the default method used by new, and is the one used in a declaration like:\nbobby = new int [5]; // if it fails an exception is thrown\nThe other method is known as nothrow, and what happens when it is used is that when a memory allocation fails,\ninstead of throwing a bad_alloc exception or terminating the program, the pointer returned by new is a null\npointer, and the program continues its execution.\nThis method can be specified by using a special object called nothrow, declared in header <new>, as argument for\nnew:\nbobby = new (nothrow) int [5];\nIn this case, if the allocation of this block of memory failed, the failure could be detected by checking if bobby took\na null pointer value:\nint * bobby;\nbobby = new (nothrow) int [5];\nif (bobby == 0) {\n// error assigning memory. Take measures.\n};\nThis nothrow method requires more work than the exception method, since the value returned has to be checked\nafter each and every memory allocation, but I will use it in our examples due to its simplicity. Anyway this method\ncan become tedious for larger projects, where the exception method is generally preferred. The exception method\nwill be explained in detail later in this tutorial.\nOperators delete and delete[]\nSince the necessity of dynamic memory is usually limited to specific moments within a program, once it is no\nlonger needed it should be freed so that the memory becomes available again for other requests of dynamic\nmemory. This is the purpose of the operator delete, whose format is:\ndelete pointer;\ndelete [] pointer;\nThe first expression should be used to delete memory allocated for a single element, and the second one for\nmemory allocated for arrays of elements.\nThe value passed as argument to delete must be either a pointer to a memory block previously allocated with new,\nor a null pointer (in the case of a null pointer, delete produces no effect).\n75\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// rememb-o-matic How many numbers would you like to type? 5\n#include <iostream> Enter number : 75\n#include <new> Enter number : 436\nusing namespace std; Enter number : 1067\nEnter number : 8\nint main () Enter number : 32\n{ You have entered: 75, 436, 1067, 8, 32,\nint i,n;\nint * p;\ncout << \"How many numbers would you like to type? \";\ncin >> i;\np= new (nothrow) int[i];\nif (p == 0)\ncout << \"Error: memory could not be allocated\";\nelse\n{\nfor (n=0; n<i; n++)\n{\ncout << \"Enter number: \";\ncin >> p[n];\n}\ncout << \"You have entered: \";\nfor (n=0; n<i; n++)\ncout << p[n] << \", \";\ndelete[] p;\n}\nreturn 0;\n}\nNotice how the value within brackets in the new statement is a variable value entered by the user (i), not a\nconstant value:\np= new (nothrow) int[i];\nBut the user could have entered a value for i so big that our system could not handle it. For example, when I tried\nto give a value of 1 billion to the \"How many numbers\" question, my system could not allocate that much memory\nfor the program and I got the text message we prepared for this case (Error: memory could not be allocated).\nRemember that in the case that we tried to allocate the memory without specifying the nothrow parameter in the\nnew expression, an exception would be thrown, which if it's not handled terminates the program.\nIt is a good practice to always check if a dynamic memory block was successfully allocated. Therefore, if you use\nthe nothrow method, you should always check the value of the pointer returned. Otherwise, use the exception\nmethod, even if you do not handle the exception. This way, the program will terminate at that point without\ncausing the unexpected results of continuing executing a code that assumes a block of memory to have been\nallocated when in fact it has not.\nDynamic memory in ANSI-C\nOperators new and delete are exclusive of C++. They are not available in the C language. But using pure C\nlanguage and its library, dynamic memory can also be used through the functions malloc, calloc, realloc and free,\nwhich are also available in C++ including the <cstdlib> header file (see cstdlib for more info).\nThe memory blocks allocated by these functions are not necessarily compatible with those returned by new, so\neach one should be manipulated with its own set of functions or operators.\n76\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nData structures\nWe have already learned how groups of sequential data can be used in C++. But this is somewhat restrictive, since\nin many occasions what we want to store are not mere sequences of elements all of the same data type, but sets\nof different elements with different data types.\nData structures\nA data structure is a group of data elements grouped together under one name. These data elements, known as\nmembers, can have different types and different lengths. Data structures are declared in C++ using the following\nsyntax:\nstruct structure_name {\nmember_type1 member_name1;\nmember_type2 member_name2;\nmember_type3 member_name3;\n.\n.\n} object_names;\nwhere structure_name is a name for the structure type, object_name can be a set of valid identifiers for objects\nthat have the type of this structure. Within braces { } there is a list with the data members, each one is specified\nwith a type and a valid identifier as its name.\nThe first thing we have to know is that a data structure creates a new type: Once a data structure is declared, a\nnew type with the identifier specified as structure_name is created and can be used in the rest of the program as\nif it was any other type. For example:\nstruct product {\nint weight;\nfloat price;\n} ;\nproduct apple;\nproduct banana, melon;\nWe have first declared a structure type called product with two members: weight and price, each of a different\nfundamental type. We have then used this name of the structure type (product) to declare three objects of that\ntype: apple, banana and melon as we would have done with any fundamental data type.\nOnce declared, product has become a new valid type name like the fundamental ones int, char or short and\nfrom that point on we are able to declare objects (variables) of this compound new type, like we have done with\napple, banana and melon.\nRight at the end of the struct declaration, and before the ending semicolon, we can use the optional field\nobject_name to directly declare objects of the structure type. For example, we can also declare the structure\nobjects apple, banana and melon at the moment we define the data structure type this way:\nstruct product {\nint weight;\nfloat price;\n} apple, banana, melon;\nIt is important to clearly differentiate between what is the structure type name, and what is an object (variable)\nthat has this structure type. We can instantiate many objects (i.e. variables, like apple, banana and melon) from a\nsingle structure type (product).\n77\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nOnce we have declared our three objects of a determined structure type (apple, banana and melon) we can\noperate directly with their members. To do that we use a dot (.) inserted between the object name and the\nmember name. For example, we could operate with any of these elements as if they were standard variables of\ntheir respective types:\napple.weight\napple.price\nbanana.weight\nbanana.price\nmelon.weight\nmelon.price\nEach one of these has the data type corresponding to the member they refer to: apple.weight, banana.weight\nand melon.weight are of type int, while apple.price, banana.price and melon.price are of type float.\nLet's see a real example where you can see how a structure type can be used in the same way as fundamental\ntypes:\n// example about structures Enter title: Alien\n#include <iostream> Enter year: 1979\n#include <string>\n#include <sstream> My favorite movie is:\nusing namespace std; 2001 A Space Odyssey (1968)\nAnd yours is:\nstruct movies_t { Alien (1979)\nstring title;\nint year;\n} mine, yours;\nvoid printmovie (movies_t movie);\nint main ()\n{\nstring mystr;\nmine.title = \"2001 A Space Odyssey\";\nmine.year = 1968;\ncout << \"Enter title: \";\ngetline (cin,yours.title);\ncout << \"Enter year: \";\ngetline (cin,mystr);\nstringstream(mystr) >> yours.year;\ncout << \"My favorite movie is:\\n \";\nprintmovie (mine);\ncout << \"And yours is:\\n \";\nprintmovie (yours);\nreturn 0;\n}\nvoid printmovie (movies_t movie)\n{\ncout << movie.title;\ncout << \" (\" << movie.year << \")\\n\";\n}\nThe example shows how we can use the members of an object as regular variables. For example, the member\nyours.year is a valid variable of type int, and mine.title is a valid variable of type string.\nThe objects mine and yours can also be treated as valid variables of type movies_t, for example we have passed\nthem to the function printmovie as we would have done with regular variables. Therefore, one of the most\nimportant advantages of data structures is that we can either refer to their members individually or to the entire\nstructure as a block with only one identifier.\n78\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nData structures are a feature that can be used to represent databases, especially if we consider the possibility of\nbuilding arrays of them:\n// array of structures Enter title: Blade Runner\n#include <iostream> Enter year: 1982\n#include <string> Enter title: Matrix\n#include <sstream> Enter year: 1999\nusing namespace std; Enter title: Taxi Driver\nEnter year: 1976\n#define N_MOVIES 3\nYou have entered these movies:\nstruct movies_t { Blade Runner (1982)\nstring title; Matrix (1999)\nint year; Taxi Driver (1976)\n} films [N_MOVIES];\nvoid printmovie (movies_t movie);\nint main ()\n{\nstring mystr;\nint n;\nfor (n=0; n<N_MOVIES; n++)\n{\ncout << \"Enter title: \";\ngetline (cin,films[n].title);\ncout << \"Enter year: \";\ngetline (cin,mystr);\nstringstream(mystr) >> films[n].year;\n}\ncout << \"\\nYou have entered these movies:\\n\";\nfor (n=0; n<N_MOVIES; n++)\nprintmovie (films[n]);\nreturn 0;\n}\nvoid printmovie (movies_t movie)\n{\ncout << movie.title;\ncout << \" (\" << movie.year << \")\\n\";\n}\nPointers to structures\nLike any other type, structures can be pointed by its own type of pointers:\nstruct movies_t {\nstring title;\nint year;\n};\nmovies_t amovie;\nmovies_t * pmovie;\nHere amovie is an object of structure type movies_t, and pmovie is a pointer to point to objects of structure type\nmovies_t. So, the following code would also be valid:\npmovie = &amovie;\nThe value of the pointer pmovie would be assigned to a reference to the object amovie (its memory address).\n79\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nWe will now go with another example that includes pointers, which will serve to introduce a new operator: the\narrow operator (->):\n// pointers to structures Enter title: Invasion of the body snatchers\n#include <iostream> Enter year: 1978\n#include <string>\n#include <sstream> You have entered:\nusing namespace std; Invasion of the body snatchers (1978)\nstruct movies_t {\nstring title;\nint year;\n};\nint main ()\n{\nstring mystr;\nmovies_t amovie;\nmovies_t * pmovie;\npmovie = &amovie;\ncout << \"Enter title: \";\ngetline (cin, pmovie->title);\ncout << \"Enter year: \";\ngetline (cin, mystr);\n(stringstream) mystr >> pmovie->year;\ncout << \"\\nYou have entered:\\n\";\ncout << pmovie->title;\ncout << \" (\" << pmovie->year << \")\\n\";\nreturn 0;\n}\nThe previous code includes an important introduction: the arrow operator (->). This is a dereference operator that\nis used exclusively with pointers to objects with members. This operator serves to access a member of an object to\nwhich we have a reference. In the example we used:\npmovie->title\nWhich is for all purposes equivalent to:\n(*pmovie).title\nBoth expressions pmovie->title and (*pmovie).title are valid and both mean that we are evaluating the\nmember title of the data structure pointed by a pointer called pmovie. It must be clearly differentiated from:\n*pmovie.title\nwhich is equivalent to:\n*(pmovie.title)\nAnd that would access the value pointed by a hypothetical pointer member called title of the structure object\npmovie (which in this case would not be a pointer). The following panel summarizes possible combinations of\npointers and structure members:\n80\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nExpression What is evaluated Equivalent\na.b Member b of object a\na->b Member b of object pointed by a (*a).b\n*a.b Value pointed by member b of object a *(a.b)\nNesting structures\nStructures can also be nested so that a valid element of a structure can also be in its turn another structure.\nstruct movies_t {\nstring title;\nint year;\n};\nstruct friends_t {\nstring name;\nstring email;\nmovies_t favorite_movie;\n} charlie, maria;\nfriends_t * pfriends = &charlie;\nAfter the previous declaration we could use any of the following expressions:\ncharlie.name\nmaria.favorite_movie.title\ncharlie.favorite_movie.year\npfriends->favorite_movie.year\n(where, by the way, the last two expressions refer to the same member).\n81\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nOther Data Types\nDefined data types (typedef)\nC++ allows the definition of our own types based on other existing data types. We can do this using the keyword\ntypedef, whose format is:\ntypedef existing_type new_type_name ;\nwhere existing_type is a C++ fundamental or compound type and new_type_name is the name for the new type\nwe are defining. For example:\ntypedef char C;\ntypedef unsigned int WORD;\ntypedef char * pChar;\ntypedef char field [50];\nIn this case we have defined four data types: C, WORD, pChar and field as char, unsigned int, char* and\nchar[50] respectively, that we could perfectly use in declarations later as any other valid type:\nC mychar, anotherchar, *ptc1;\nWORD myword;\npChar ptc2;\nfield name;\ntypedef does not create different types. It only creates synonyms of existing types. That means that the type of\nmyword can be considered to be either WORD or unsigned int, since both are in fact the same type.\ntypedef can be useful to define an alias for a type that is frequently used within a program. It is also useful to\ndefine types when it is possible that we will need to change the type in later versions of our program, or if a type\nyou want to use has a name that is too long or confusing.\nUnions\nUnions allow one same portion of memory to be accessed as different data types, since all of them are in fact the\nsame location in memory. Its declaration and use is similar to the one of structures but its functionality is totally\ndifferent:\nunion union_name {\nmember_type1 member_name1;\nmember_type2 member_name2;\nmember_type3 member_name3;\n.\n.\n} object_names;\nAll the elements of the union declaration occupy the same physical space in memory. Its size is the one of the\ngreatest element of the declaration. For example:\n82\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nunion mytypes_t {\nchar c;\nint i;\nfloat f;\n} mytypes;\ndefines three elements:\nmytypes.c\nmytypes.i\nmytypes.f\neach one with a different data type. Since all of them are referring to the same location in memory, the\nmodification of one of the elements will affect the value of all of them. We cannot store different values in them\nindependent of each other.\nOne of the uses a union may have is to unite an elementary type with an array or structures of smaller elements.\nFor example:\nunion mix_t {\nlong l;\nstruct {\nshort hi;\nshort lo;\n} s;\nchar c[4];\n} mix;\ndefines three names that allow us to access the same group of 4 bytes: mix.l, mix.s and mix.c and which we can\nuse according to how we want to access these bytes, as if they were a single long-type data, as if they were two\nshort elements or as an array of char elements, respectively. I have mixed types, arrays and structures in the\nunion so that you can see the different ways that we can access the data. For a little-endian system (most PC\nplatforms), this union could be represented as:\nThe exact alignment and order of the members of a union in memory is platform dependant. Therefore be aware of\npossible portability issues with this type of use.\nAnonymous unions\nIn C++ we have the option to declare anonymous unions. If we declare a union without any name, the union will\nbe anonymous and we will be able to access its members directly by their member names. For example, look at the\ndifference between these two structure declarations:\n83\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nstructure with regular union structure with anonymous union\nstruct { struct {\nchar title[50]; char title[50];\nchar author[50]; char author[50];\nunion { union {\nfloat dollars; float dollars;\nint yens; int yens;\n} price; };\n} book; } book;\nThe only difference between the two pieces of code is that in the first one we have given a name to the union\n(price) and in the second one we have not. The difference is seen when we access the members dollars and\nyens of an object of this type. For an object of the first type, it would be:\nbook.price.dollars\nbook.price.yens\nwhereas for an object of the second type, it would be:\nbook.dollars\nbook.yens\nOnce again I remind you that because it is a union and not a struct, the members dollars and yens occupy the\nsame physical space in the memory so they cannot be used to store two different values simultaneously. You can\nset a value for price in dollars or in yens, but not in both.\nEnumerations (enum)\nEnumerations create new data types to contain something different that is not limited to the values fundamental\ndata types may take. Its form is the following:\nenum enumeration_name {\nvalue1,\nvalue2,\nvalue3,\n.\n.\n} object_names;\nFor example, we could create a new type of variable called color to store colors with the following declaration:\nenum colors_t {black, blue, green, cyan, red, purple, yellow, white};\nNotice that we do not include any fundamental data type in the declaration. To say it somehow, we have created a\nwhole new data type from scratch without basing it on any other existing type. The possible values that variables\nof this new type color_t may take are the new constant values included within braces. For example, once the\ncolors_t enumeration is declared the following expressions will be valid:\ncolors_t mycolor;\nmycolor = blue;\nif (mycolor == green) mycolor = red;\nEnumerations are type compatible with numeric variables, so their constants are always assigned an integer\nnumerical value internally. If it is not specified, the integer value equivalent to the first possible value is equivalent\nto 0 and the following ones follow a +1 progression. Thus, in our data type colors_t that we have defined above,\nblack would be equivalent to 0, blue would be equivalent to 1, green to 2, and so on.\n84\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nWe can explicitly specify an integer value for any of the constant values that our enumerated type can take. If the\nconstant value that follows it is not given an integer value, it is automatically assumed the same value as the\nprevious one plus one. For example:\nenum months_t { january=1, february, march, april,\nmay, june, july, august,\nseptember, october, november, december} y2k;\nIn this case, variable y2k of enumerated type months_t can contain any of the 12 possible values that go from\njanuary to december and that are equivalent to values between 1 and 12 (not between 0 and 11, since we have\nmade january equal to 1).\n85\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nObject Oriented Programming\nClasses (I)\nA class is an expanded concept of a data structure: instead of holding only data, it can hold both data and\nfunctions.\nAn object is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the\nvariable.\nClasses are generally declared using the keyword class, with the following format:\nclass class_name {\naccess_specifier_1:\nmember1;\naccess_specifier_2:\nmember2;\n...\n} object_names;\nWhere class_name is a valid identifier for the class, object_names is an optional list of names for objects of this\nclass. The body of the declaration can contain members, that can be either data or function declarations, and\noptionally access specifiers.\nAll is very similar to the declaration on data structures, except that we can now include also functions and\nmembers, but also this new thing called access specifier. An access specifier is one of the following three\nkeywords: private, public or protected. These specifiers modify the access rights that the members following\nthem acquire:\n\u2022\nprivate members of a class are accessible only from within other members of the same class or from\ntheir friends.\n\u2022\nprotected members are accessible from members of their same class and from their friends, but also\nfrom members of their derived classes.\n\u2022\nFinally, public members are accessible from anywhere where the object is visible.\nBy default, all members of a class declared with the class keyword have private access for all its members.\nTherefore, any member that is declared before one other class specifier automatically has private access. For\nexample:\nclass CRectangle {\nint x, y;\npublic:\nvoid set_values (int,int);\nint area (void);\n} rect;\nDeclares a class (i.e., a type) called CRectangle and an object (i.e., a variable) of this class called rect. This class\ncontains four members: two data members of type int (member x and member y) with private access (because\nprivate is the default access level) and two member functions with public access: set_values() and area(), of\nwhich for now we have only included their declaration, not their definition.\nNotice the difference between the class name and the object name: In the previous example, CRectangle was the\nclass name (i.e., the type), whereas rect was an object of type CRectangle. It is the same relationship int and a\nhave in the following declaration:\n86\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nint a;\nwhere int is the type name (the class) and a is the variable name (the object).\nAfter the previous declarations of CRectangle and rect, we can refer within the body of the program to any of the\npublic members of the object rect as if they were normal functions or normal variables, just by putting the object's\nname followed by a dot (.) and then the name of the member. All very similar to what we did with plain data\nstructures before. For example:\nrect.set_values (3,4);\nmyarea = rect.area();\nThe only members of rect that we cannot access from the body of our program outside the class are x and y, since\nthey have private access and they can only be referred from within other members of that same class.\nHere is the complete example of class CRectangle:\n// classes example area: 12\n#include <iostream>\nusing namespace std;\nclass CRectangle {\nint x, y;\npublic:\nvoid set_values (int,int);\nint area () {return (x*y);}\n};\nvoid CRectangle::set_values (int a, int b) {\nx = a;\ny = b;\n}\nint main () {\nCRectangle rect;\nrect.set_values (3,4);\ncout << \"area: \" << rect.area();\nreturn 0;\n}\nThe most important new thing in this code is the operator of scope (::, two colons) included in the definition of\nset_values(). It is used to define a member of a class from outside the class definition itself.\nYou may notice that the definition of the member function area() has been included directly within the definition of\nthe CRectangle class given its extreme simplicity, whereas set_values() has only its prototype declared within\nthe class, but its definition is outside it. In this outside declaration, we must use the operator of scope (::) to\nspecify that we are defining a function that is a member of the class CRectangle and not a regular global function.\nThe scope operator (::) specifies the class to which the member being declared belongs, granting exactly the same\nscope properties as if this function definition was directly included within the class definition. For example, in the\nfunction set_values() of the previous code, we have been able to use the variables x and y, which are private\nmembers of class CRectangle, which means they are only accessible from other members of their class.\nThe only difference between defining a class member function completely within its class or to include only the\nprototype and later its definition, is that in the first case the function will automatically be considered an inline\nmember function by the compiler, while in the second it will be a normal (not-inline) class member function, which\nin fact supposes no difference in behavior.\nMembers x and y have private access (remember that if nothing else is said, all members of a class defined with\nkeyword class have private access). By declaring them private we deny access to them from anywhere outside the\n87\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nclass. This makes sense, since we have already defined a member function to set values for those members within\nthe object: the member function set_values(). Therefore, the rest of the program does not need to have direct\naccess to them. Perhaps in a so simple example as this, it is difficult to see an utility in protecting those two\nvariables, but in greater projects it may be very important that values cannot be modified in an unexpected way\n(unexpected from the point of view of the object).\nOne of the greater advantages of a class is that, as any other type, we can declare several objects of it. For\nexample, following with the previous example of class CRectangle, we could have declared the object rectb in\naddition to the object rect:\n// example: one class, two objects rect area: 12\n#include <iostream> rectb area: 30\nusing namespace std;\nclass CRectangle {\nint x, y;\npublic:\nvoid set_values (int,int);\nint area () {return (x*y);}\n};\nvoid CRectangle::set_values (int a, int b) {\nx = a;\ny = b;\n}\nint main () {\nCRectangle rect, rectb;\nrect.set_values (3,4);\nrectb.set_values (5,6);\ncout << \"rect area: \" << rect.area() << endl;\ncout << \"rectb area: \" << rectb.area() << endl;\nreturn 0;\n}\nIn this concrete case, the class (type of the objects) to which we are talking about is CRectangle, of which there\nare two instances or objects: rect and rectb. Each one of them has its own member variables and member\nfunctions.\nNotice that the call to rect.area() does not give the same result as the call to rectb.area(). This is because\neach object of class CRectangle has its own variables x and y, as they, in some way, have also their own function\nmembers set_value() and area() that each uses its object's own variables to operate.\nThat is the basic concept of object-oriented programming: Data and functions are both members of the object. We\nno longer use sets of global variables that we pass from one function to another as parameters, but instead we\nhandle objects that have their own data and functions embedded as members. Notice that we have not had to give\nany parameters in any of the calls to rect.area or rectb.area. Those member functions directly used the data\nmembers of their respective objects rect and rectb.\nConstructors and destructors\nObjects generally need to initialize variables or assign dynamic memory during their process of creation to become\noperative and to avoid returning unexpected values during their execution. For example, what would happen if in\nthe previous example we called the member function area() before having called function set_values()? Probably\nwe would have gotten an undetermined result since the members x and y would have never been assigned a value.\nIn order to avoid that, a class can include a special function called constructor, which is automatically called\nwhenever a new object of this class is created. This constructor function must have the same name as the class,\nand cannot have any return type; not even void.\nWe are going to implement CRectangle including a constructor:\n88\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// example: class constructor rect area: 12\n#include <iostream> rectb area: 30\nusing namespace std;\nclass CRectangle {\nint width, height;\npublic:\nCRectangle (int,int);\nint area () {return (width*height);}\n};\nCRectangle::CRectangle (int a, int b) {\nwidth = a;\nheight = b;\n}\nint main () {\nCRectangle rect (3,4);\nCRectangle rectb (5,6);\ncout << \"rect area: \" << rect.area() << endl;\ncout << \"rectb area: \" << rectb.area() << endl;\nreturn 0;\n}\nAs you can see, the result of this example is identical to the previous one. But now we have removed the member\nfunction set_values(), and have included instead a constructor that performs a similar action: it initializes the\nvalues of x and y with the parameters that are passed to it.\nNotice how these arguments are passed to the constructor at the moment at which the objects of this class are\ncreated:\nCRectangle rect (3,4);\nCRectangle rectb (5,6);\nConstructors cannot be called explicitly as if they were regular member functions. They are only executed when a\nnew object of that class is created.\nYou can also see how neither the constructor prototype declaration (within the class) nor the latter constructor\ndefinition include a return value; not even void.\nThe destructor fulfills the opposite functionality. It is automatically called when an object is destroyed, either\nbecause its scope of existence has finished (for example, if it was defined as a local object within a function and the\nfunction ends) or because it is an object dynamically assigned and it is released using the operator delete.\nThe destructor must have the same name as the class, but preceded with a tilde sign (~) and it must also return no\nvalue.\nThe use of destructors is especially suitable when an object assigns dynamic memory during its lifetime and at the\nmoment of being destroyed we want to release the memory that the object was allocated.\n89\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// example on constructors and destructors rect area: 12\n#include <iostream> rectb area: 30\nusing namespace std;\nclass CRectangle {\nint *width, *height;\npublic:\nCRectangle (int,int);\n~CRectangle ();\nint area () {return (*width * *height);}\n};\nCRectangle::CRectangle (int a, int b) {\nwidth = new int;\nheight = new int;\n*width = a;\n*height = b;\n}\nCRectangle::~CRectangle () {\ndelete width;\ndelete height;\n}\nint main () {\nCRectangle rect (3,4), rectb (5,6);\ncout << \"rect area: \" << rect.area() << endl;\ncout << \"rectb area: \" << rectb.area() << endl;\nreturn 0;\n}\nOverloading Constructors\nLike any other function, a constructor can also be overloaded with more than one function that have the same\nname but different types or number of parameters. Remember that for overloaded functions the compiler will call\nthe one whose parameters match the arguments used in the function call. In the case of constructors, which are\nautomatically called when an object is created, the one executed is the one that matches the arguments passed on\nthe object declaration:\n90\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// overloading class constructors rect area: 12\n#include <iostream> rectb area: 25\nusing namespace std;\nclass CRectangle {\nint width, height;\npublic:\nCRectangle ();\nCRectangle (int,int);\nint area (void) {return (width*height);}\n};\nCRectangle::CRectangle () {\nwidth = 5;\nheight = 5;\n}\nCRectangle::CRectangle (int a, int b) {\nwidth = a;\nheight = b;\n}\nint main () {\nCRectangle rect (3,4);\nCRectangle rectb;\ncout << \"rect area: \" << rect.area() << endl;\ncout << \"rectb area: \" << rectb.area() << endl;\nreturn 0;\n}\nIn this case, rectb was declared without any arguments, so it has been initialized with the constructor that has no\nparameters, which initializes both width and height with a value of 5.\nImportant: Notice how if we declare a new object and we want to use its default constructor (the one without\nparameters), we do not include parentheses ():\nCRectangle rectb; // right\nCRectangle rectb(); // wrong!\nDefault constructor\nIf you do not declare any constructors in a class definition, the compiler assumes the class to have a default\nconstructor with no arguments. Therefore, after declaring a class like this one:\nclass CExample {\npublic:\nint a,b,c;\nvoid multiply (int n, int m) { a=n; b=m; c=a*b; };\n};\nThe compiler assumes that CExample has a default constructor, so you can declare objects of this class by simply\ndeclaring them without any arguments:\nCExample ex;\nBut as soon as you declare your own constructor for a class, the compiler no longer provides an implicit default\nconstructor. So you have to declare all objects of that class according to the constructor prototypes you defined for\nthe class:\n91\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nclass CExample {\npublic:\nint a,b,c;\nCExample (int n, int m) { a=n; b=m; };\nvoid multiply () { c=a*b; };\n};\nHere we have declared a constructor that takes two parameters of type int. Therefore the following object\ndeclaration would be correct:\nCExample ex (2,3);\nBut,\nCExample ex;\nWould not be correct, since we have declared the class to have an explicit constructor, thus replacing the default\nconstructor.\nBut the compiler not only creates a default constructor for you if you do not specify your own. It provides three\nspecial member functions in total that are implicitly declared if you do not declare your own. These are the copy\nconstructor, the copy assignment operator, and the default destructor.\nThe copy constructor and the copy assignment operator copy all the data contained in another object to the data\nmembers of the current object. For CExample, the copy constructor implicitly declared by the compiler would be\nsomething similar to:\nCExample::CExample (const CExample& rv) {\na=rv.a; b=rv.b; c=rv.c;\n}\nTherefore, the two following object declarations would be correct:\nCExample ex (2,3);\nCExample ex2 (ex); // copy constructor (data copied from ex)\nPointers to classes\nIt is perfectly valid to create pointers that point to classes. We simply have to consider that once declared, a class\nbecomes a valid type, so we can use the class name as the type for the pointer. For example:\nCRectangle * prect;\nis a pointer to an object of class CRectangle.\nAs it happened with data structures, in order to refer directly to a member of an object pointed by a pointer we can\nuse the arrow operator (->) of indirection. Here is an example with some possible combinations:\n92\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// pointer to classes example a area: 2\n#include <iostream> *b area: 12\nusing namespace std; *c area: 2\nd[0] area: 30\nclass CRectangle { d[1] area: 56\nint width, height;\npublic:\nvoid set_values (int, int);\nint area (void) {return (width * height);}\n};\nvoid CRectangle::set_values (int a, int b) {\nwidth = a;\nheight = b;\n}\nint main () {\nCRectangle a, *b, *c;\nCRectangle * d = new CRectangle[2];\nb= new CRectangle;\nc= &a;\na.set_values (1,2);\nb->set_values (3,4);\nd->set_values (5,6);\nd[1].set_values (7,8);\ncout << \"a area: \" << a.area() << endl;\ncout << \"*b area: \" << b->area() << endl;\ncout << \"*c area: \" << c->area() << endl;\ncout << \"d[0] area: \" << d[0].area() << endl;\ncout << \"d[1] area: \" << d[1].area() << endl;\ndelete[] d;\ndelete b;\nreturn 0;\n}\nNext you have a summary on how can you read some pointer and class operators (*, &, ., ->, [ ]) that appear in\nthe previous example:\nexpression can be read as\n*x pointed by x\n&x address of x\nx.y member y of object x\nx->y member y of object pointed by x\n(*x).y member y of object pointed by x (equivalent to the previous one)\nx[0] first object pointed by x\nx[1] second object pointed by x\nx[n] (n+1)th object pointed by x\nBe sure that you understand the logic under all of these expressions before proceeding with the next sections. If\nyou have doubts, read again this section and/or consult the previous sections about pointers and data structures.\nClasses defined with struct and union\nClasses can be defined not only with keyword class, but also with keywords struct and union.\nThe concepts of class and data structure are so similar that both keywords (struct and class) can be used in C++\nto declare classes (i.e. structs can also have function members in C++, not only data members). The only\ndifference between both is that members of classes declared with the keyword struct have public access by\ndefault, while members of classes declared with the keyword class have private access. For all other purposes\nboth keywords are equivalent.\n93\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nThe concept of unions is different from that of classes declared with struct and class, since unions only store one\ndata member at a time, but nevertheless they are also classes and can thus also hold function members. The\ndefault access in union classes is public.\n94\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nClasses (II)\nOverloading operators\nC++ incorporates the option to use standard operators to perform operations with classes in addition to with\nfundamental types. For example:\nint a, b, c;\na = b + c;\nThis is obviously valid code in C++, since the different variables of the addition are all fundamental types.\nNevertheless, it is not so obvious that we could perform an operation similar to the following one:\nstruct {\nstring product;\nfloat price;\n} a, b, c;\na = b + c;\nIn fact, this will cause a compilation error, since we have not defined the behavior our class should have with\naddition operations. However, thanks to the C++ feature to overload operators, we can design classes able to\nperform operations using standard operators. Here is a list of all the operators that can be overloaded:\nOverloadable operators\n+ - * / = < > += -= *= /= << >>\n<<= >>= == != <= >= ++ -- % & ^ ! |\n~ &= ^= |= && || %= [] () , ->* -> new\ndelete new[] delete[]\nTo overload an operator in order to use it with classes we declare operator functions, which are regular functions\nwhose names are the operator keyword followed by the operator sign that we want to overload. The format is:\ntype operator sign (parameters) { /*...*/ }\nHere you have an example that overloads the addition operator (+). We are going to create a class to store\nbidimensional vectors and then we are going to add two of them: a(3,1) and b(1,2). The addition of two\nbidimensional vectors is an operation as simple as adding the two x coordinates to obtain the resulting x coordinate\nand adding the two y coordinates to obtain the resulting y. In this case the result will be (3+1,1+2) = (4,3).\n95\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// vectors: overloading operators example 4,3\n#include <iostream>\nusing namespace std;\nclass CVector {\npublic:\nint x,y;\nCVector () {};\nCVector (int,int);\nCVector operator + (CVector);\n};\nCVector::CVector (int a, int b) {\nx = a;\ny = b;\n}\nCVector CVector::operator+ (CVector param) {\nCVector temp;\ntemp.x = x + param.x;\ntemp.y = y + param.y;\nreturn (temp);\n}\nint main () {\nCVector a (3,1);\nCVector b (1,2);\nCVector c;\nc = a + b;\ncout << c.x << \",\" << c.y;\nreturn 0;\n}\nIt may be a little confusing to see so many times the CVector identifier. But, consider that some of them refer to\nthe class name (type) CVector and some others are functions with that name (constructors must have the same\nname as the class). Do not confuse them:\nCVector (int, int); // function name CVector (constructor)\nCVector operator+ (CVector); // function returns a CVector\nThe function operator+ of class CVector is the one that is in charge of overloading the addition operator (+). This\nfunction can be called either implicitly using the operator, or explicitly using the function name:\nc = a + b;\nc = a.operator+ (b);\nBoth expressions are equivalent.\nNotice also that we have included the empty constructor (without parameters) and we have defined it with an\nempty block:\nCVector () { };\nThis is necessary, since we have explicitly declared another constructor:\nCVector (int, int);\nAnd when we explicitly declare any constructor, with any number of parameters, the default constructor with no\nparameters that the compiler can declare automatically is not declared, so we need to declare it ourselves in order\nto be able to construct objects of this type without parameters. Otherwise, the declaration:\n96\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nCVector c;\nincluded in main() would not have been valid.\nAnyway, I have to warn you that an empty block is a bad implementation for a constructor, since it does not fulfill\nthe minimum functionality that is generally expected from a constructor, which is the initialization of all the\nmember variables in its class. In our case this constructor leaves the variables x and y undefined. Therefore, a\nmore advisable definition would have been something similar to this:\nCVector () { x=0; y=0; };\nwhich in order to simplify and show only the point of the code I have not included in the example.\nAs well as a class includes a default constructor and a copy constructor even if they are not declared, it also\nincludes a default definition for the assignment operator (=) with the class itself as parameter. The behavior which\nis defined by default is to copy the whole content of the data members of the object passed as argument (the one\nat the right side of the sign) to the one at the left side:\nCVector d (2,3);\nCVector e;\ne = d; // copy assignment operator\nThe copy assignment operator function is the only operator member function implemented by default. Of course,\nyou can redefine it to any other functionality that you want, like for example, copy only certain class members or\nperform additional initialization procedures.\nThe overload of operators does not force its operation to bear a relation to the mathematical or usual meaning of\nthe operator, although it is recommended. For example, the code may not be very intuitive if you use operator +\nto subtract two classes or operator== to fill with zeros a class, although it is perfectly possible to do so.\nAlthough the prototype of a function operator+ can seem obvious since it takes what is at the right side of the\noperator as the parameter for the operator member function of the object at its left side, other operators may not\nbe so obvious. Here you have a table with a summary on how the different operator functions have to be declared\n(replace @ by the operator in each case):\nExpression Operator Member function Global function\n@a + - * & ! ~ ++ -- A::operator@() operator@(A)\na@ ++ -- A::operator@(int) operator@(A,int)\na@b + - * / % ^ & | < > == != <= >= << >> && || , A::operator@ (B) operator@(A,B)\na@b = += -= *= /= %= ^= &= |= <<= >>= [] A::operator@ (B) -\na(b, c...) () A::operator() (B, C...) -\na->x -> A::operator->() -\nWhere a is an object of class A, b is an object of class B and c is an object of class C.\nYou can see in this panel that there are two ways to overload some class operators: as a member function and as a\nglobal function. Its use is indistinct, nevertheless I remind you that functions that are not members of a class\ncannot access the private or protected members of that class unless the global function is its friend (friendship is\nexplained later).\nThe keyword this\nThe keyword this represents a pointer to the object whose member function is being executed. It is a pointer to\nthe object itself.\n97\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nOne of its uses can be to check if a parameter passed to a member function is the object itself. For example,\n// this yes, &a is b\n#include <iostream>\nusing namespace std;\nclass CDummy {\npublic:\nint isitme (CDummy& param);\n};\nint CDummy::isitme (CDummy& param)\n{\nif (&param == this) return true;\nelse return false;\n}\nint main () {\nCDummy a;\nCDummy* b = &a;\nif ( b->isitme(a) )\ncout << \"yes, &a is b\";\nreturn 0;\n}\nIt is also frequently used in operator= member functions that return objects by reference (avoiding the use of\ntemporary objects). Following with the vector's examples seen before we could have written an operator= function\nsimilar to this one:\nCVector& CVector::operator= (const CVector& param)\n{\nx=param.x;\ny=param.y;\nreturn *this;\n}\nIn fact this function is very similar to the code that the compiler generates implicitly for this class if we do not\ninclude an operator= member function to copy objects of this class.\nStatic members\nA class can contain static members, either data or functions.\nStatic data members of a class are also known as \"class variables\", because there is only one unique value for all\nthe objects of that same class. Their content is not different from one object of this class to another.\nFor example, it may be used for a variable within a class that can contain a counter with the number of objects of\nthat class that are currently allocated, as in the following example:\n98\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// static members in classes 7\n#include <iostream> 6\nusing namespace std;\nclass CDummy {\npublic:\nstatic int n;\nCDummy () { n++; };\n~CDummy () { n--; };\n};\nint CDummy::n=0;\nint main () {\nCDummy a;\nCDummy b[5];\nCDummy * c = new CDummy;\ncout << a.n << endl;\ndelete c;\ncout << CDummy::n << endl;\nreturn 0;\n}\nIn fact, static members have the same properties as global variables but they enjoy class scope. For that reason,\nand to avoid them to be declared several times, we can only include the prototype (its declaration) in the class\ndeclaration but not its definition (its initialization). In order to initialize a static data-member we must include a\nformal definition outside the class, in the global scope, as in the previous example:\nint CDummy::n=0;\nBecause it is a unique variable value for all the objects of the same class, it can be referred to as a member of any\nobject of that class or even directly by the class name (of course this is only valid for static members):\ncout << a.n;\ncout << CDummy::n;\nThese two calls included in the previous example are referring to the same variable: the static variable n within\nclass CDummy shared by all objects of this class.\nOnce again, I remind you that in fact it is a global variable. The only difference is its name and possible access\nrestrictions outside its class.\nJust as we may include static data within a class, we can also include static functions. They represent the same:\nthey are global functions that are called as if they were object members of a given class. They can only refer to\nstatic data, in no case to non-static members of the class, as well as they do not allow the use of the keyword\nthis, since it makes reference to an object pointer and these functions in fact are not members of any object but\ndirect members of the class.\n99\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nFriendship and inheritance\nFriend functions\nIn principle, private and protected members of a class cannot be accessed from outside the same class in which\nthey are declared. However, this rule does not affect friends.\nFriends are functions or classes declared as such.\nIf we want to declare an external function as friend of a class, thus allowing this function to have access to the\nprivate and protected members of this class, we do it by declaring a prototype of this external function within the\nclass, and preceding it with the keyword friend:\n// friend functions 24\n#include <iostream>\nusing namespace std;\nclass CRectangle {\nint width, height;\npublic:\nvoid set_values (int, int);\nint area () {return (width * height);}\nfriend CRectangle duplicate (CRectangle);\n};\nvoid CRectangle::set_values (int a, int b) {\nwidth = a;\nheight = b;\n}\nCRectangle duplicate (CRectangle rectparam)\n{\nCRectangle rectres;\nrectres.width = rectparam.width*2;\nrectres.height = rectparam.height*2;\nreturn (rectres);\n}\nint main () {\nCRectangle rect, rectb;\nrect.set_values (2,3);\nrectb = duplicate (rect);\ncout << rectb.area();\nreturn 0;\n}\nThe duplicate function is a friend of CRectangle. From within that function we have been able to access the\nmembers width and height of different objects of type CRectangle, which are private members. Notice that\nneither in the declaration of duplicate() nor in its later use in main() have we considered duplicate a member\nof class CRectangle. It isn't! It simply has access to its private and protected members without being a member.\nThe friend functions can serve, for example, to conduct operations between two different classes. Generally, the\nuse of friend functions is out of an object-oriented programming methodology, so whenever possible it is better to\nuse members of the same class to perform operations with them. Such as in the previous example, it would have\nbeen shorter to integrate duplicate() within the class CRectangle.\n100\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nFriend classes\nJust as we have the possibility to define a friend function, we can also define a class as friend of another one,\ngranting that first class access to the protected and private members of the second one.\n// friend class 16\n#include <iostream>\nusing namespace std;\nclass CSquare;\nclass CRectangle {\nint width, height;\npublic:\nint area ()\n{return (width * height);}\nvoid convert (CSquare a);\n};\nclass CSquare {\nprivate:\nint side;\npublic:\nvoid set_side (int a)\n{side=a;}\nfriend class CRectangle;\n};\nvoid CRectangle::convert (CSquare a) {\nwidth = a.side;\nheight = a.side;\n}\nint main () {\nCSquare sqr;\nCRectangle rect;\nsqr.set_side(4);\nrect.convert(sqr);\ncout << rect.area();\nreturn 0;\n}\nIn this example, we have declared CRectangle as a friend of CSquare so that CRectangle member functions could\nhave access to the protected and private members of CSquare, more concretely to CSquare::side, which describes\nthe side width of the square.\nYou may also see something new at the beginning of the program: an empty declaration of class CSquare. This is\nnecessary because within the declaration of CRectangle we refer to CSquare (as a parameter in convert()). The\ndefinition of CSquare is included later, so if we did not include a previous empty declaration for CSquare this class\nwould not be visible from within the definition of CRectangle.\nConsider that friendships are not corresponded if we do not explicitly specify so. In our example, CRectangle is\nconsidered as a friend class by CSquare, but CRectangle does not consider CSquare to be a friend, so CRectangle\ncan access the protected and private members of CSquare but not the reverse way. Of course, we could have\ndeclared also CSquare as friend of CRectangle if we wanted to.\nAnother property of friendships is that they are not transitive: The friend of a friend is not considered to be a friend\nunless explicitly specified.\nInheritance between classes\nA key feature of C++ classes is inheritance. Inheritance allows to create classes which are derived from other\nclasses, so that they automatically include some of its \"parent's\" members, plus its own. For example, we are going\n101\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nto suppose that we want to declare a series of classes that describe polygons like our CRectangle, or like\nCTriangle. They have certain common properties, such as both can be described by means of only two sides:\nheight and base.\nThis could be represented in the world of classes with a class CPolygon from which we would derive the two other\nones: CRectangle and CTriangle.\nThe class CPolygon would contain members that are common for both types of polygon. In our case: width and\nheight. And CRectangle and CTriangle would be its derived classes, with specific features that are different from\none type of polygon to the other.\nClasses that are derived from others inherit all the accessible members of the base class. That means that if a base\nclass includes a member A and we derive it to another class with another member called B, the derived class will\ncontain both members A and B.\nIn order to derive a class from another, we use a colon (:) in the declaration of the derived class using the\nfollowing format:\nclass derived_class_name: public base_class_name\n{ /*...*/ };\nWhere derived_class_name is the name of the derived class and base_class_name is the name of the class on\nwhich it is based. The public access specifier may be replaced by any one of the other access specifiers protected\nand private. This access specifier describes the minimum access level for the members that are inherited from the\nbase class.\n102\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// derived classes 20\n#include <iostream> 10\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b;}\n};\nclass CRectangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nrect.set_values (4,5);\ntrgl.set_values (4,5);\ncout << rect.area() << endl;\ncout << trgl.area() << endl;\nreturn 0;\n}\nThe objects of the classes CRectangle and CTriangle each contain members inherited from CPolygon. These are:\nwidth, height and set_values().\nThe protected access specifier is similar to private. Its only difference occurs in fact with inheritance. When a\nclass inherits from another one, the members of the derived class can access the protected members inherited\nfrom the base class, but not its private members.\nSince we wanted width and height to be accessible from members of the derived classes CRectangle and\nCTriangle and not only by members of CPolygon, we have used protected access instead of private.\nWe can summarize the different access types according to who can access them in the following way:\nAccess public protected private\nmembers of the same class yes yes yes\nmembers of derived classes yes yes no\nnot members yes no no\nWhere \"not members\" represent any access from outside the class, such as from main(), from another class or\nfrom a function.\nIn our example, the members inherited by CRectangle and CTriangle have the same access permissions as they\nhad in their base class CPolygon:\n103\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nCPolygon::width // protected access\nCRectangle::width // protected access\nCPolygon::set_values() // public access\nCRectangle::set_values() // public access\nThis is because we have used the public keyword to define the inheritance relationship on each of the derived\nclasses:\nclass CRectangle: public CPolygon { ... }\nThis public keyword after the colon (:) denotes the maximum access level for all the members inherited from the\nclass that follows it (in this case CPolygon). Since public is the most accessible level, by specifying this keyword\nthe derived class will inherit all the members with the same levels they had in the base class.\nIf we specify a more restrictive access level like protected, all public members of the base class are inherited as\nprotected in the derived class. Whereas if we specify the most restricting of all access levels: private, all the base\nclass members are inherited as private.\nFor example, if daughter was a class derived from mother that we defined as:\nclass daughter: protected mother;\nThis would set protected as the maximum access level for the members of daughter that it inherited from\nmother. That is, all members that were public in mother would become protected in daughter. Of course, this\nwould not restrict daughter to declare its own public members. That maximum access level is only set for the\nmembers inherited from mother.\nIf we do not explicitly specify any access level for the inheritance, the compiler assumes private for classes\ndeclared with class keyword and public for those declared with struct.\nWhat is inherited from the base class?\nIn principle, a derived class inherits every member of a base class except:\n\u2022\nits constructor and its destructor\n\u2022\nits operator=() members\n\u2022\nits friends\nAlthough the constructors and destructors of the base class are not inherited themselves, its default constructor\n(i.e., its constructor with no parameters) and its destructor are always called when a new object of a derived class\nis created or destroyed.\nIf the base class has no default constructor or you want that an overloaded constructor is called when a new\nderived object is created, you can specify it in each constructor definition of the derived class:\nderived_constructor_name (parameters) : base_constructor_name (parameters) {...}\nFor example:\n104\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// constructors and derived classes mother: no parameters\n#include <iostream> daughter: int parameter\nusing namespace std;\nmother: int parameter\nclass mother { son: int parameter\npublic:\nmother ()\n{ cout << \"mother: no parameters\\n\"; }\nmother (int a)\n{ cout << \"mother: int parameter\\n\"; }\n};\nclass daughter : public mother {\npublic:\ndaughter (int a)\n{ cout << \"daughter: int parameter\\n\\n\"; }\n};\nclass son : public mother {\npublic:\nson (int a) : mother (a)\n{ cout << \"son: int parameter\\n\\n\"; }\n};\nint main () {\ndaughter cynthia (0);\nson daniel(0);\nreturn 0;\n}\nNotice the difference between which mother's constructor is called when a new daughter object is created and\nwhich when it is a son object. The difference is because the constructor declaration of daughter and son:\ndaughter (int a) // nothing specified: call default\nson (int a) : mother (a) // constructor specified: call this\nMultiple inheritance\nIn C++ it is perfectly possible that a class inherits members from more than one class. This is done by simply\nseparating the different base classes with commas in the derived class declaration. For example, if we had a\nspecific class to print on screen (COutput) and we wanted our classes CRectangle and CTriangle to also inherit its\nmembers in addition to those of CPolygon we could write:\nclass CRectangle: public CPolygon, public COutput;\nclass CTriangle: public CPolygon, public COutput;\nhere is the complete example:\n105\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// multiple inheritance 20\n#include <iostream> 10\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b;}\n};\nclass COutput {\npublic:\nvoid output (int i);\n};\nvoid COutput::output (int i) {\ncout << i << endl;\n}\nclass CRectangle: public CPolygon, public COutput {\npublic:\nint area ()\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon, public COutput {\npublic:\nint area ()\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nrect.set_values (4,5);\ntrgl.set_values (4,5);\nrect.output (rect.area());\ntrgl.output (trgl.area());\nreturn 0;\n}\n106\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nPolymorphism\nBefore getting into this section, it is recommended that you have a proper understanding of pointers and class\ninheritance. If any of the following statements seem strange to you, you should review the indicated sections:\nStatement: Explained in:\nint a::b(c) {}; Classes\na->b Data Structures\nclass a: public b; Friendship and inheritance\nPointers to base class\nOne of the key features of derived classes is that a pointer to a derived class is type-compatible with a pointer to\nits base class. Polymorphism is the art of taking advantage of this simple but powerful and versatile feature, that\nbrings Object Oriented Methodologies to its full potential.\nWe are going to start by rewriting our program about the rectangle and the triangle of the previous section taking\ninto consideration this pointer compatibility property:\n// pointers to base class 20\n#include <iostream> 10\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\n};\nclass CRectangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nCPolygon * ppoly1 = &rect;\nCPolygon * ppoly2 = &trgl;\nppoly1->set_values (4,5);\nppoly2->set_values (4,5);\ncout << rect.area() << endl;\ncout << trgl.area() << endl;\nreturn 0;\n}\nIn function main, we create two pointers that point to objects of class CPolygon (ppoly1 and ppoly2). Then we\nassign references to rect and trgl to these pointers, and because both are objects of classes derived from\nCPolygon, both are valid assignment operations.\nThe only limitation in using *ppoly1 and *ppoly2 instead of rect and trgl is that both *ppoly1 and *ppoly2 are\nof type CPolygon* and therefore we can only use these pointers to refer to the members that CRectangle and\n107\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nCTriangle inherit from CPolygon. For that reason when we call the area() members at the end of the program we\nhave had to use directly the objects rect and trgl instead of the pointers *ppoly1 and *ppoly2.\nIn order to use area() with the pointers to class CPolygon, this member should also have been declared in the\nclass CPolygon, and not only in its derived classes, but the problem is that CRectangle and CTriangle implement\ndifferent versions of area, therefore we cannot implement it in the base class. This is when virtual members\nbecome handy:\nVirtual members\nA member of a class that can be redefined in its derived classes is known as a virtual member. In order to declare\na member of a class as virtual, we must precede its declaration with the keyword virtual:\n// virtual members 20\n#include <iostream> 10\nusing namespace std; 0\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\nvirtual int area ()\n{ return (0); }\n};\nclass CRectangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area ()\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nCPolygon poly;\nCPolygon * ppoly1 = &rect;\nCPolygon * ppoly2 = &trgl;\nCPolygon * ppoly3 = &poly;\nppoly1->set_values (4,5);\nppoly2->set_values (4,5);\nppoly3->set_values (4,5);\ncout << ppoly1->area() << endl;\ncout << ppoly2->area() << endl;\ncout << ppoly3->area() << endl;\nreturn 0;\n}\nNow the three classes (CPolygon, CRectangle and CTriangle) have all the same members: width, height,\nset_values() and area().\nThe member function area() has been declared as virtual in the base class because it is later redefined in each\nderived class. You can verify if you want that if you remove this virtual keyword from the declaration of area()\nwithin CPolygon, and then you run the program the result will be 0 for the three polygons instead of 20, 10 and 0.\nThat is because instead of calling the corresponding area() function for each object (CRectangle::area(),\nCTriangle::area() and CPolygon::area(), respectively), CPolygon::area() will be called in all cases since the\ncalls are via a pointer whose type is CPolygon*.\n108\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nTherefore, what the virtual keyword does is to allow a member of a derived class with the same name as one in\nthe base class to be appropriately called from a pointer, and more precisely when the type of the pointer is a\npointer to the base class but is pointing to an object of the derived class, as in the above example.\nA class that declares or inherits a virtual function is called a polymorphic class.\nNote that despite of its virtuality, we have also been able to declare an object of type CPolygon and to call its own\narea() function, which always returns 0.\nAbstract base classes\nAbstract base classes are something very similar to our CPolygon class of our previous example. The only\ndifference is that in our previous example we have defined a valid area() function with a minimal functionality for\nobjects that were of class CPolygon (like the object poly), whereas in an abstract base classes we could leave that\narea() member function without implementation at all. This is done by appending =0 (equal to zero) to the\nfunction declaration.\nAn abstract base CPolygon class could look like this:\n// abstract class CPolygon\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\nvirtual int area () =0;\n};\nNotice how we appended =0 to virtual int area () instead of specifying an implementation for the function.\nThis type of function is called a pure virtual function, and all classes that contain at least one pure virtual function\nare abstract base classes.\nThe main difference between an abstract base class and a regular polymorphic class is that because in abstract\nbase classes at least one of its members lacks implementation we cannot create instances (objects) of it.\nBut a class that cannot instantiate objects is not totally useless. We can create pointers to it and take advantage of\nall its polymorphic abilities. Therefore a declaration like:\nCPolygon poly;\nwould not be valid for the abstract base class we have just declared, because tries to instantiate an object.\nNevertheless, the following pointers:\nCPolygon * ppoly1;\nCPolygon * ppoly2;\nwould be perfectly valid.\nThis is so for as long as CPolygon includes a pure virtual function and therefore it's an abstract base class.\nHowever, pointers to this abstract base class can be used to point to objects of derived classes.\nHere you have the complete example:\n109\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// abstract base class 20\n#include <iostream> 10\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\nvirtual int area (void) =0;\n};\nclass CRectangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nCPolygon * ppoly1 = &rect;\nCPolygon * ppoly2 = &trgl;\nppoly1->set_values (4,5);\nppoly2->set_values (4,5);\ncout << ppoly1->area() << endl;\ncout << ppoly2->area() << endl;\nreturn 0;\n}\nIf you review the program you will notice that we refer to objects of different but related classes using a unique\ntype of pointer (CPolygon*). This can be tremendously useful. For example, now we can create a function member\nof the abstract base class CPolygon that is able to print on screen the result of the area() function even though\nCPolygon itself has no implementation for this function:\n110\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// pure virtual members can be called 20\n// from the abstract base class 10\n#include <iostream>\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\nvirtual int area (void) =0;\nvoid printarea (void)\n{ cout << this->area() << endl; }\n};\nclass CRectangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height / 2); }\n};\nint main () {\nCRectangle rect;\nCTriangle trgl;\nCPolygon * ppoly1 = &rect;\nCPolygon * ppoly2 = &trgl;\nppoly1->set_values (4,5);\nppoly2->set_values (4,5);\nppoly1->printarea();\nppoly2->printarea();\nreturn 0;\n}\nVirtual members and abstract classes grant C++ the polymorphic characteristics that make object-oriented\nprogramming such a useful instrument in big projects. Of course, we have seen very simple uses of these features,\nbut these features can be applied to arrays of objects or dynamically allocated objects.\nLet's end with the same example again, but this time with objects that are dynamically allocated:\n111\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// dynamic allocation and polymorphism 20\n#include <iostream> 10\nusing namespace std;\nclass CPolygon {\nprotected:\nint width, height;\npublic:\nvoid set_values (int a, int b)\n{ width=a; height=b; }\nvirtual int area (void) =0;\nvoid printarea (void)\n{ cout << this->area() << endl; }\n};\nclass CRectangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height); }\n};\nclass CTriangle: public CPolygon {\npublic:\nint area (void)\n{ return (width * height / 2); }\n};\nint main () {\nCPolygon * ppoly1 = new CRectangle;\nCPolygon * ppoly2 = new CTriangle;\nppoly1->set_values (4,5);\nppoly2->set_values (4,5);\nppoly1->printarea();\nppoly2->printarea();\ndelete ppoly1;\ndelete ppoly2;\nreturn 0;\n}\nNotice that the ppoly pointers:\nCPolygon * ppoly1 = new CRectangle;\nCPolygon * ppoly2 = new CTriangle;\nare declared being of type pointer to CPolygon but the objects dynamically allocated have been declared having\nthe derived class type directly.\n112\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nAdvanced concepts\nTemplates\nFunction templates\nFunction templates are special functions that can operate with generic types. This allows us to create a function\ntemplate whose functionality can be adapted to more than one type or class without repeating the entire code for\neach type.\nIn C++ this can be achieved using template parameters. A template parameter is a special kind of parameter that\ncan be used to pass a type as argument: just like regular function parameters can be used to pass values to a\nfunction, template parameters allow to pass also types to a function. These function templates can use these\nparameters as if they were any other regular type.\nThe format for declaring function templates with type parameters is:\ntemplate <class identifier> function_declaration;\ntemplate <typename identifier> function_declaration;\nThe only difference between both prototypes is the use of either the keyword class or the keyword typename. Its\nuse is indistinct, since both expressions have exactly the same meaning and behave exactly the same way.\nFor example, to create a template function that returns the greater one of two objects we could use:\ntemplate <class myType>\nmyType GetMax (myType a, myType b) {\nreturn (a>b?a:b);\n}\nHere we have created a template function with myType as its template parameter. This template parameter\nrepresents a type that has not yet been specified, but that can be used in the template function as if it were a\nregular type. As you can see, the function template GetMax returns the greater of two parameters of this still-\nundefined type.\nTo use this function template we use the following format for the function call:\nfunction_name <type> (parameters);\nFor example, to call GetMax to compare two integer values of type int we can write:\nint x,y;\nGetMax <int> (x,y);\nWhen the compiler encounters this call to a template function, it uses the template to automatically generate a\nfunction replacing each appearance of myType by the type passed as the actual template parameter (int in this\ncase) and then calls it. This process is automatically performed by the compiler and is invisible to the programmer.\nHere is the entire example:\n113\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// function template 6\n#include <iostream> 10\nusing namespace std;\ntemplate <class T>\nT GetMax (T a, T b) {\nT result;\nresult = (a>b)? a : b;\nreturn (result);\n}\nint main () {\nint i=5, j=6, k;\nlong l=10, m=5, n;\nk=GetMax<int>(i,j);\nn=GetMax<long>(l,m);\ncout << k << endl;\ncout << n << endl;\nreturn 0;\n}\nIn this case, we have used T as the template parameter name instead of myType because it is shorter and in fact is\na very common template parameter name. But you can use any identifier you like.\nIn the example above we used the function template GetMax() twice. The first time with arguments of type int\nand the second one with arguments of type long. The compiler has instantiated and then called each time the\nappropriate version of the function.\nAs you can see, the type T is used within the GetMax() template function even to declare new objects of that type:\nT result;\nTherefore, result will be an object of the same type as the parameters a and b when the function template is\ninstantiated with a specific type.\nIn this specific case where the generic type T is used as a parameter for GetMax the compiler can find out\nautomatically which data type has to instantiate without having to explicitly specify it within angle brackets (like we\nhave done before specifying <int> and <long>). So we could have written instead:\nint i,j;\nGetMax (i,j);\nSince both i and j are of type int, and the compiler can automatically find out that the template parameter can\nonly be int. This implicit method produces exactly the same result:\n114\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// function template II 6\n#include <iostream> 10\nusing namespace std;\ntemplate <class T>\nT GetMax (T a, T b) {\nreturn (a>b?a:b);\n}\nint main () {\nint i=5, j=6, k;\nlong l=10, m=5, n;\nk=GetMax(i,j);\nn=GetMax(l,m);\ncout << k << endl;\ncout << n << endl;\nreturn 0;\n}\nNotice how in this case, we called our function template GetMax() without explicitly specifying the type between\nangle-brackets <>. The compiler automatically determines what type is needed on each call.\nBecause our template function includes only one template parameter (class T) and the function template itself\naccepts two parameters, both of this T type, we cannot call our function template with two objects of different\ntypes as arguments:\nint i;\nlong l;\nk = GetMax (i,l);\nThis would not be correct, since our GetMax function template expects two arguments of the same type, and in this\ncall to it we use objects of two different types.\nWe can also define function templates that accept more than one type parameter, simply by specifying more\ntemplate parameters between the angle brackets. For example:\ntemplate <class T, class U>\nT GetMin (T a, U b) {\nreturn (a<b?a:b);\n}\nIn this case, our function template GetMin() accepts two parameters of different types and returns an object of the\nsame type as the first parameter (T) that is passed. For example, after that declaration we could call GetMin()\nwith:\nint i,j;\nlong l;\ni = GetMin<int,long> (j,l);\nor simply:\ni = GetMin (j,l);\neven though j and l have different types, since the compiler can determine the appropriate instantiation anyway.\n115\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nClass templates\nWe also have the possibility to write class templates, so that a class can have members that use template\nparameters as types. For example:\ntemplate <class T>\nclass mypair {\nT values [2];\npublic:\nmypair (T first, T second)\n{\nvalues[0]=first; values[1]=second;\n}\n};\nThe class that we have just defined serves to store two elements of any valid type. For example, if we wanted to\ndeclare an object of this class to store two integer values of type int with the values 115 and 36 we would write:\nmypair<int> myobject (115, 36);\nthis same class would also be used to create an object to store any other type:\nmypair<double> myfloats (3.0, 2.18);\nThe only member function in the previous class template has been defined inline within the class declaration itself.\nIn case that we define a function member outside the declaration of the class template, we must always precede\nthat definition with the template <...> prefix:\n// class templates 100\n#include <iostream>\nusing namespace std;\ntemplate <class T>\nclass mypair {\nT a, b;\npublic:\nmypair (T first, T second)\n{a=first; b=second;}\nT getmax ();\n};\ntemplate <class T>\nT mypair<T>::getmax ()\n{\nT retval;\nretval = a>b? a : b;\nreturn retval;\n}\nint main () {\nmypair <int> myobject (100, 75);\ncout << myobject.getmax();\nreturn 0;\n}\nNotice the syntax of the definition of member function getmax:\n116\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\ntemplate <class T>\nT mypair<T>::getmax ()\nConfused by so many T's? There are three T's in this declaration: The first one is the template parameter. The\nsecond T refers to the type returned by the function. And the third T (the one between angle brackets) is also a\nrequirement: It specifies that this function's template parameter is also the class template parameter.\nTemplate specialization\nIf we want to define a different implementation for a template when a specific type is passed as template\nparameter, we can declare a specialization of that template.\nFor example, let's suppose that we have a very simple class called mycontainer that can store one element of any\ntype and that it has just one member function called increase, which increases its value. But we find that when it\nstores an element of type char it would be more convenient to have a completely different implementation with a\nfunction member uppercase, so we decide to declare a class template specialization for that type:\n// template specialization 8\n#include <iostream> J\nusing namespace std;\n// class template:\ntemplate <class T>\nclass mycontainer {\nT element;\npublic:\nmycontainer (T arg) {element=arg;}\nT increase () {return ++element;}\n};\n// class template specialization:\ntemplate <>\nclass mycontainer <char> {\nchar element;\npublic:\nmycontainer (char arg) {element=arg;}\nchar uppercase ()\n{\nif ((element>='a')&&(element<='z'))\nelement+='A'-'a';\nreturn element;\n}\n};\nint main () {\nmycontainer<int> myint (7);\nmycontainer<char> mychar ('j');\ncout << myint.increase() << endl;\ncout << mychar.uppercase() << endl;\nreturn 0;\n}\nThis is the syntax used in the class template specialization:\ntemplate <> class mycontainer <char> { ... };\nFirst of all, notice that we precede the class template name with an emptytemplate<> parameter list. This is to\nexplicitly declare it as a template specialization.\n117\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nBut more important than this prefix, is the <char> specialization parameter after the class template name. This\nspecialization parameter itself identifies the type for which we are going to declare a template class specialization\n(char). Notice the differences between the generic class template and the specialization:\ntemplate <class T> class mycontainer { ... };\ntemplate <> class mycontainer <char> { ... };\nThe first line is the generic template, and the second one is the specialization.\nWhen we declare specializations for a template class, we must also define all its members, even those exactly\nequal to the generic template class, because there is no \"inheritance\" of members from the generic template to the\nspecialization.\nNon-type parameters for templates\nBesides the template arguments that are preceded by the class or typename keywords , which represent types,\ntemplates can also have regular typed parameters, similar to those found in functions. As an example, have a look\nat this class template that is used to contain sequences of elements:\n// sequence template 100\n#include <iostream> 3.1416\nusing namespace std;\ntemplate <class T, int N>\nclass mysequence {\nT memblock [N];\npublic:\nvoid setmember (int x, T value);\nT getmember (int x);\n};\ntemplate <class T, int N>\nvoid mysequence<T,N>::setmember (int x, T value)\n{\nmemblock[x]=value;\n}\ntemplate <class T, int N>\nT mysequence<T,N>::getmember (int x) {\nreturn memblock[x];\n}\nint main () {\nmysequence <int,5> myints;\nmysequence <double,5> myfloats;\nmyints.setmember (0,100);\nmyfloats.setmember (3,3.1416);\ncout << myints.getmember(0) << '\\n';\ncout << myfloats.getmember(3) << '\\n';\nreturn 0;\n}\nIt is also possible to set default values or types for class template parameters. For example, if the previous class\ntemplate definition had been:\ntemplate <class T=char, int N=10> class mysequence {..};\nWe could create objects using the default template parameters by declaring:\nmysequence<> myseq;\nWhich would be equivalent to:\n118\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nmysequence<char,10> myseq;\nTemplates and multiple-file projects\nFrom the point of view of the compiler, templates are not normal functions or classes. They are compiled on\ndemand, meaning that the code of a template function is not compiled until an instantiation with specific template\narguments is required. At that moment, when an instantiation is required, the compiler generates a function\nspecifically for those arguments from the template.\nWhen projects grow it is usual to split the code of a program in different source code files. In these cases, the\ninterface and implementation are generally separated. Taking a library of functions as example, the interface\ngenerally consists of declarations of the prototypes of all the functions that can be called. These are generally\ndeclared in a \"header file\" with a .h extension, and the implementation (the definition of these functions) is in an\nindependent file with c++ code.\nBecause templates are compiled when required, this forces a restriction for multi-file projects: the implementation\n(definition) of a template class or function must be in the same file as its declaration. That means that we cannot\nseparate the interface in a separate header file, and that we must include both interface and implementation in any\nfile that uses the templates.\nSince no code is generated until a template is instantiated when required, compilers are prepared to allow the\ninclusion more than once of the same template file with both declarations and definitions in a project without\ngenerating linkage errors.\n119\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nNamespaces\nNamespaces allow to group entities like classes, objects and functions under a name. This way the global scope can\nbe divided in \"sub-scopes\", each one with its own name.\nThe format of namespaces is:\nnamespace identifier\n{\nentities\n}\nWhere identifier is any valid identifier and entities is the set of classes, objects and functions that are included\nwithin the namespace. For example:\nnamespace myNamespace\n{\nint a, b;\n}\nIn this case, the variables a and b are normal variables declared within a namespace called myNamespace. In order\nto access these variables from outside the myNamespace namespace we have to use the scope operator ::. For\nexample, to access the previous variables from outside myNamespace we can write:\nmyNamespace::a\nmyNamespace::b\nThe functionality of namespaces is especially useful in the case that there is a possibility that a global object or\nfunction uses the same identifier as another one, causing redefinition errors. For example:\n// namespaces 5\n#include <iostream> 3.1416\nusing namespace std;\nnamespace first\n{\nint var = 5;\n}\nnamespace second\n{\ndouble var = 3.1416;\n}\nint main () {\ncout << first::var << endl;\ncout << second::var << endl;\nreturn 0;\n}\nIn this case, there are two global variables with the same name: var. One is defined within the namespace first\nand the other one in second. No redefinition errors happen thanks to namespaces.\n120\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nusing\nThe keyword using is used to introduce a name from a namespace into the current declarative region. For\nexample:\n// using 5\n#include <iostream> 2.7183\nusing namespace std; 10\n3.1416\nnamespace first\n{\nint x = 5;\nint y = 10;\n}\nnamespace second\n{\ndouble x = 3.1416;\ndouble y = 2.7183;\n}\nint main () {\nusing first::x;\nusing second::y;\ncout << x << endl;\ncout << y << endl;\ncout << first::y << endl;\ncout << second::x << endl;\nreturn 0;\n}\nNotice how in this code, x (without any name qualifier) refers to first::x whereas y refers to second::y, exactly\nas our using declarations have specified. We still have access to first::y and second::x using their fully qualified\nnames.\nThe keyword using can also be used as a directive to introduce an entire namespace:\n// using 5\n#include <iostream> 10\nusing namespace std; 3.1416\n2.7183\nnamespace first\n{\nint x = 5;\nint y = 10;\n}\nnamespace second\n{\ndouble x = 3.1416;\ndouble y = 2.7183;\n}\nint main () {\nusing namespace first;\ncout << x << endl;\ncout << y << endl;\ncout << second::x << endl;\ncout << second::y << endl;\nreturn 0;\n}\nIn this case, since we have declared that we were using namespace first, all direct uses of x and y without name\nqualifiers were referring to their declarations in namespace first.\n121\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nusing and using namespace have validity only in the same block in which they are stated or in the entire code if\nthey are used directly in the global scope. For example, if we had the intention to first use the objects of one\nnamespace and then those of another one, we could do something like:\n// using namespace example 5\n#include <iostream> 3.1416\nusing namespace std;\nnamespace first\n{\nint x = 5;\n}\nnamespace second\n{\ndouble x = 3.1416;\n}\nint main () {\n{\nusing namespace first;\ncout << x << endl;\n}\n{\nusing namespace second;\ncout << x << endl;\n}\nreturn 0;\n}\nNamespace alias\nWe can declare alternate names for existing namespaces according to the following format:\nnamespace new_name = current_name;\nNamespace std\nAll the files in the C++ standard library declare all of its entities within the std namespace. That is why we have\ngenerally included the using namespace std; statement in all programs that used any entity defined in iostream.\n122\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nExceptions\nExceptions provide a way to react to exceptional circumstances (like runtime errors) in our program by transferring\ncontrol to special functions called handlers.\nTo catch exceptions we must place a portion of code under exception inspection. This is done by enclosing that\nportion of code in a try block. When an exceptional circumstance arises within that block, an exception is thrown\nthat transfers the control to the exception handler. If no exception is thrown, the code continues normally and all\nhandlers are ignored.\nA exception is thrown by using the throw keyword from inside the try block. Exception handlers are declared with\nthe keyword catch, which must be placed immediately after the try block:\n// exceptions An exception occurred. Exception Nr. 20\n#include <iostream>\nusing namespace std;\nint main () {\ntry\n{\nthrow 20;\n}\ncatch (int e)\n{\ncout << \"An exception occurred. \"\ncout << \"Exception Nr. \" << e << endl;\n}\nreturn 0;\n}\nThe code under exception handling is enclosed in a try block. In this example this code simply throws an\nexception:\nthrow 20;\nA throw expression accepts one parameter (in this case the integer value 20), which is passed as an argument to\nthe exception handler.\nThe exception handler is declared with the catch keyword. As you can see, it follows immediately the closing brace\nof the try block. The catch format is similar to a regular function that always has at least one parameter. The type\nof this parameter is very important, since the type of the argument passed by the throw expression is checked\nagainst it, and only in the case they match, the exception is caught.\nWe can chain multiple handlers (catch expressions), each one with a different parameter type. Only the handler\nthat matches its type with the argument specified in the throw statement is executed.\nIf we use an ellipsis (...) as the parameter of catch, that handler will catch any exception no matter what the\ntype of the throw exception is. This can be used as a default handler that catches all exceptions not caught by\nother handlers if it is specified at last:\n123\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\ntry {\n// code here\n}\ncatch (int param) { cout << \"int exception\"; }\ncatch (char param) { cout << \"char exception\"; }\ncatch (...) { cout << \"default exception\"; }\nIn this case the last handler would catch any exception thrown with any parameter that is neither an int nor a\nchar.\nAfter an exception has been handled the program execution resumes after the try-catch block, not after the\nthrow statement!.\nIt is also possible to nest try-catch blocks within more external try blocks. In these cases, we have the possibility\nthat an internal catch block forwards the exception to its external level. This is done with the expression throw;\nwith no arguments. For example:\ntry {\ntry {\n// code here\n}\ncatch (int n) {\nthrow;\n}\n}\ncatch (...) {\ncout << \"Exception occurred\";\n}\nException specifications\nWhen declaring a function we can limit the exception type it might directly or indirectly throw by appending a\nthrow suffix to the function declaration:\nfloat myfunction (char param) throw (int);\nThis declares a function called myfunction which takes one agument of type char and returns an element of type\nfloat. The only exception that this function might throw is an exception of type int. If it throws an exception with\na different type, either directly or indirectly, it cannot be caught by a regular int-type handler.\nIf this throw specifier is left empty with no type, this means the function is not allowed to throw exceptions.\nFunctions with no throw specifier (regular functions) are allowed to throw exceptions with any type:\nint myfunction (int param) throw(); // no exceptions allowed\nint myfunction (int param); // all exceptions allowed\nStandard exceptions\nThe C++ Standard library provides a base class specifically designed to declare objects to be thrown as exceptions.\nIt is called exception and is defined in the <exception> header file under the namespace std. This class has the\nusual default and copy constructors, operators and destructors, plus an additional virtual member function called\nwhat that returns a null-terminated character sequence (char *) and that can be overwritten in derived classes to\ncontain some sort of description of the exception.\n124\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// standard exceptions My exception happened.\n#include <iostream>\n#include <exception>\nusing namespace std;\nclass myexception: public exception\n{\nvirtual const char* what() const throw()\n{\nreturn \"My exception happened\";\n}\n} myex;\nint main () {\ntry\n{\nthrow myex;\n}\ncatch (exception& e)\n{\ncout << e.what() << endl;\n}\nreturn 0;\n}\nWe have placed a handler that catches exception objects by reference (notice the ampersand & after the type),\ntherefore this catches also classes derived from exception, like our myex object of class myexception.\nAll exceptions thrown by components of the C++ Standard library throw exceptions derived from this\nstd::exception class. These are:\nexception description\nbad_alloc thrown by new on allocation failure\nbad_cast thrown by dynamic_cast when fails with a referenced type\nbad_exception thrown when an exception type doesn't match any catch\nbad_typeid thrown by typeid\nios_base::failure thrown by functions in the iostream library\nFor example, if we use the operator new and the memory cannot be allocated, an exception of type bad_alloc is\nthrown:\ntry\n{\nint * myarray= new int[1000];\n}\ncatch (bad_alloc&)\n{\ncout << \"Error allocating memory.\" << endl;\n}\nIt is recommended to include all dynamic memory allocations within a try block that catches this type of exception\nto perform a clean action instead of an abnormal program termination, which is what happens when this type of\nexception is thrown and not caught. If you want to force a bad_alloc exception to see it in action, you can try to\nallocate a huge array; On my system, trying to allocate 1 billion ints threw a bad_alloc exception.\nBecause bad_alloc is derived from the standard base class exception, we can handle that same exception by\ncatching references to the exception class:\n125\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// bad_alloc standard exception\n#include <iostream>\n#include <exception>\nusing namespace std;\nint main () {\ntry\n{\nint* myarray= new int[1000];\n}\ncatch (exception& e)\n{\ncout << \"Standard exception: \" << e.what()\n<< endl;\n}\nreturn 0;\n}\n126\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nType Casting\nConverting an expression of a given type into another type is known as type-casting. We have already seen some\nways to type cast:\nImplicit conversion\nImplicit conversions do not require any operator. They are automatically performed when a value is copied to a\ncompatible type. For example:\nshort a=2000;\nint b;\nb=a;\nHere, the value of a has been promoted from short to int and we have not had to specify any type-casting\noperator. This is known as a standard conversion. Standard conversions affect fundamental data types, and allow\nconversions such as the conversions between numerical types (short to int, int to float, double to int...), to or\nfrom bool, and some pointer conversions. Some of these conversions may imply a loss of precision, which the\ncompiler can signal with a warning. This can be avoided with an explicit conversion.\nImplicit conversions also include constructor or operator conversions, which affect classes that include specific\nconstructors or operator functions to perform conversions. For example:\nclass A {};\nclass B { public: B (A a) {} };\nA a;\nB b=a;\nHere, a implicit conversion happened between objects of class A and class B, because B has a constructor that\ntakes an object of class A as parameter. Therefore implicit conversions from A to B are allowed.\nExplicit conversion\nC++ is a strong-typed language. Many conversions, specially those that imply a different interpretation of the\nvalue, require an explicit conversion. We have already seen two notations for explicit type conversion: functional\nand c-like casting:\nshort a=2000;\nint b;\nb = (int) a; // c-like cast notation\nb = int (a); // functional notation\nThe functionality of these explicit conversion operators is enough for most needs with fundamental data types.\nHowever, these operators can be applied indiscriminately on classes and pointers to classes, which can lead to code\nthat while being syntactically correct can cause runtime errors. For example, the following code is syntactically\ncorrect:\n127\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// class type-casting\n#include <iostream>\nusing namespace std;\nclass CDummy {\nfloat i,j;\n};\nclass CAddition {\nint x,y;\npublic:\nCAddition (int a, int b) { x=a; y=b; }\nint result() { return x+y;}\n};\nint main () {\nCDummy d;\nCAddition * padd;\npadd = (CAddition*) &d;\ncout << padd->result();\nreturn 0;\n}\nThe program declares a pointer to CAddition, but then it assigns to it a reference to an object of another\nincompatible type using explicit type-casting:\npadd = (CAddition*) &d;\nTraditional explicit type-casting allows to convert any pointer into any other pointer type, independently of the\ntypes they point to. The subsequent call to member result will produce either a run-time error or a unexpected\nresult.\nIn order to control these types of conversions between classes, we have four specific casting operators:\ndynamic_cast, reinterpret_cast, static_cast and const_cast. Their format is to follow the new type enclosed\nbetween angle-brackets (<>) and immediately after, the expression to be converted between parentheses.\ndynamic_cast <new_type> (expression)\nreinterpret_cast <new_type> (expression)\nstatic_cast <new_type> (expression)\nconst_cast <new_type> (expression)\nThe traditional type-casting equivalents to these expressions would be:\n(new_type) expression\nnew_type (expression)\nbut each one with its own special characteristics:\ndynamic_cast\ndynamic_cast can be used only with pointers and references to objects. Its purpose is to ensure that the result of\nthe type conversion is a valid complete object of the requested class.\nTherefore, dynamic_cast is always successful when we cast a class to one of its base classes:\n128\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nclass CBase { };\nclass CDerived: public CBase { };\nCBase b; CBase* pb;\nCDerived d; CDerived* pd;\npb = dynamic_cast<CBase*>(&d); // ok: derived-to-base\npd = dynamic_cast<CDerived*>(&b); // wrong: base-to-derived\nThe second conversion in this piece of code would produce a compilation error since base-to-derived conversions\nare not allowed with dynamic_cast unless the base class is polymorphic.\nWhen a class is polymorphic, dynamic_cast performs a special checking during runtime to ensure that the\nexpression yields a valid complete object of the requested class:\n// dynamic_cast Null pointer on second type-\n#include <iostream> cast\n#include <exception>\nusing namespace std;\nclass CBase { virtual void dummy() {} };\nclass CDerived: public CBase { int a; };\nint main () {\ntry {\nCBase * pba = new CDerived;\nCBase * pbb = new CBase;\nCDerived * pd;\npd = dynamic_cast<CDerived*>(pba);\nif (pd==0) cout << \"Null pointer on first type-cast\" << endl;\npd = dynamic_cast<CDerived*>(pbb);\nif (pd==0) cout << \"Null pointer on second type-cast\" << endl;\n} catch (exception& e) {cout << \"Exception: \" << e.what();}\nreturn 0;\n}\nCompatibility note: dynamic_cast requires the Run-Time Type Information (RTTI) to keep track of dynamic\ntypes. Some compilers support this feature as an option which is disabled by default. This must be enabled for\nruntime type checking using dynamic_cast to work properly.\nThe code tries to perform two dynamic casts from pointer objects of type CBase* (pba and pbb) to a pointer object\nof type CDerived*, but only the first one is successful. Notice their respective initializations:\nCBase * pba = new CDerived;\nCBase * pbb = new CBase;\nEven though both are pointers of type CBase*, pba points to an object of type CDerived, while pbb points to an\nobject of type CBase. Thus, when their respective type-castings are performed using dynamic_cast, pba is pointing\nto a full object of class CDerived, whereas pbb is pointing to an object of class CBase, which is an incomplete\nobject of class CDerived.\nWhen dynamic_cast cannot cast a pointer because it is not a complete object of the required class -as in the\nsecond conversion in the previous example- it returns a null pointer to indicate the failure. If dynamic_cast is used\nto convert to a reference type and the conversion is not possible, an exception of type bad_cast is thrown instead.\ndynamic_cast can also cast null pointers even between pointers to unrelated classes, and can also cast pointers of\nany type to void pointers (void*).\n129\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nstatic_cast\nstatic_cast can perform conversions between pointers to related classes, not only from the derived class to its\nbase, but also from a base class to its derived. This ensures that at least the classes are compatible if the proper\nobject is converted, but no safety check is performed during runtime to check if the object being converted is in\nfact a full object of the destination type. Therefore, it is up to the programmer to ensure that the conversion is\nsafe. On the other side, the overhead of the type-safety checks of dynamic_cast is avoided.\nclass CBase {};\nclass CDerived: public CBase {};\nCBase * a = new CBase;\nCDerived * b = static_cast<CDerived*>(a);\nThis would be valid, although b would point to an incomplete object of the class and could lead to runtime errors if\ndereferenced.\nstatic_cast can also be used to perform any other non-pointer conversion that could also be performed implicitly,\nlike for example standard conversion between fundamental types:\ndouble d=3.14159265;\nint i = static_cast<int>(d);\nOr any conversion between classes with explicit constructors or operator functions as described in \"implicit\nconversions\" above.\nreinterpret_cast\nreinterpret_cast converts any pointer type to any other pointer type, even of unrelated classes. The operation\nresult is a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed:\nneither the content pointed nor the pointer type itself is checked.\nIt can also cast pointers to or from integer types. The format in which this integer value represents a pointer is\nplatform-specific. The only guarantee is that a pointer cast to an integer type large enough to fully contain it, is\ngranted to be able to be cast back to a valid pointer.\nThe conversions that can be performed by reinterpret_cast but not by static_cast have no specific uses in\nC++ are low-level operations, whose interpretation results in code which is generally system-specific, and thus\nnon-portable. For example:\nclass A {};\nclass B {};\nA * a = new A;\nB * b = reinterpret_cast<B*>(a);\nThis is valid C++ code, although it does not make much sense, since now we have a pointer that points to an\nobject of an incompatible class, and thus dereferencing it is unsafe.\nconst_cast\nThis type of casting manipulates the constness of an object, either to be set or to be removed. For example, in\norder to pass a const argument to a function that expects a non-constant parameter:\n130\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// const_cast sample text\n#include <iostream>\nusing namespace std;\nvoid print (char * str)\n{\ncout << str << endl;\n}\nint main () {\nconst char * c = \"sample text\";\nprint ( const_cast<char *> (c) );\nreturn 0;\n}\ntypeid\ntypeid allows to check the type of an expression:\ntypeid (expression)\nThis operator returns a reference to a constant object of type type_info that is defined in the standard header file\n<typeinfo>. This returned value can be compared with another one using operators == and != or can serve to\nobtain a null-terminated character sequence representing the data type or class name by using its name() member.\n// typeid a and b are of different types:\n#include <iostream> a is: int *\n#include <typeinfo> b is: int\nusing namespace std;\nint main () {\nint * a,b;\na=0; b=0;\nif (typeid(a) != typeid(b))\n{\ncout << \"a and b are of different types:\\n\";\ncout << \"a is: \" << typeid(a).name() << '\\n';\ncout << \"b is: \" << typeid(b).name() << '\\n';\n}\nreturn 0;\n}\nWhen typeid is applied to classes typeid uses the RTTI to keep track of the type of dynamic objects. When typeid\nis applied to an expression whose type is a polymorphic class, the result is the type of the most derived complete\nobject:\n131\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// typeid, polymorphic class a is: class CBase *\n#include <iostream> b is: class CBase *\n#include <typeinfo> *a is: class CBase\n#include <exception> *b is: class CDerived\nusing namespace std;\nclass CBase { virtual void f(){} };\nclass CDerived : public CBase {};\nint main () {\ntry {\nCBase* a = new CBase;\nCBase* b = new CDerived;\ncout << \"a is: \" << typeid(a).name() << '\\n';\ncout << \"b is: \" << typeid(b).name() << '\\n';\ncout << \"*a is: \" << typeid(*a).name() << '\\n';\ncout << \"*b is: \" << typeid(*b).name() << '\\n';\n} catch (exception& e) { cout << \"Exception: \" << e.what() << endl;\n}\nreturn 0;\n}\nNotice how the type that typeid considers for pointers is the pointer type itself (both a and b are of type class\nCBase *). However, when typeid is applied to objects (like *a and *b) typeid yields their dynamic type (i.e. the\ntype of their most derived complete object).\nIf the type typeid evaluates is a pointer preceded by the dereference operator (*), and this pointer has a null\nvalue, typeid throws a bad_typeid exception.\n132\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nPreprocessor directives\nPreprocessor directives are lines included in the code of our programs that are not program statements but\ndirectives for the preprocessor. These lines are always preceded by a hash sign (#). The preprocessor is executed\nbefore the actual compilation of code begins, therefore the preprocessor digests all these directives before any\ncode is generated by the statements.\nThese preprocessor directives extend only across a single line of code. As soon as a newline character is found, the\npreprocessor directive is considered to end. No semicolon (;) is expected at the end of a preprocessor directive.\nThe only way a preprocessor directive can extend through more than one line is by preceding the newline character\nat the end of the line by a backslash (\\).\nmacro definitions (#define, #undef)\nTo define preprocessor macros we can use #define. Its format is:\n#define identifier replacement\nWhen the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code\nby replacement. This replacement can be an expression, a statement, a block or simply anything. The\npreprocessor does not understand C++, it simply replaces any occurrence of identifier by replacement.\n#define TABLE_SIZE 100\nint table1[TABLE_SIZE];\nint table2[TABLE_SIZE];\nAfter the preprocessor has replaced TABLE_SIZE, the code becomes equivalent to:\nint table1[100];\nint table2[100];\nThis use of #define as constant definer is already known by us from previous tutorials, but #define can work also\nwith parameters to define function macros:\n#define getmax(a,b) a>b?a:b\nThis would replace any occurrence of getmax followed by two arguments by the replacement expression, but also\nreplacing each argument by its identifier, exactly as you would expect if it was a function:\n// function macro 5\n#include <iostream> 7\nusing namespace std;\n#define getmax(a,b) ((a)>(b)?(a):(b))\nint main()\n{\nint x=5, y;\ny= getmax(x,2);\ncout << y << endl;\ncout << getmax(7,x) << endl;\nreturn 0;\n}\nDefined macros are not affected by block structure. A macro lasts until it is undefined with the #undef preprocessor\ndirective:\n133\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n#define TABLE_SIZE 100\nint table1[TABLE_SIZE];\n#undef TABLE_SIZE\n#define TABLE_SIZE 200\nint table2[TABLE_SIZE];\nThis would generate the same code as:\nint table1[100];\nint table2[200];\nFunction macro definitions accept two special operators (# and ##) in the replacement sequence:\nIf the operator # is used before a parameter is used in the replacement sequence, that parameter is replaced by a\nstring literal (as if it were enclosed between double quotes)\n#define str(x) #x\ncout << str(test);\nThis would be translated into:\ncout << \"test\";\nThe operator ## concatenates two arguments leaving no blank spaces between them:\n#define glue(a,b) a ## b\nglue(c,out) << \"test\";\nThis would also be translated into:\ncout << \"test\";\nBecause preprocessor replacements happen before any C++ syntax check, macro definitions can be a tricky\nfeature, but be careful: code that relies heavily on complicated macros may result obscure to other programmers,\nsince the syntax they expect is on many occasions different from the regular expressions programmers expect in\nC++.\nConditional inclusions (#ifdef, #ifndef, #if, #endif, #else and\n#elif)\nThese directives allow to include or discard part of the code of a program if a certain condition is met.\n#ifdef allows a section of a program to be compiled only if the macro that is specified as the parameter has been\ndefined, no matter which its value is. For example:\n#ifdef TABLE_SIZE\nint table[TABLE_SIZE];\n#endif\nIn this case, the line of code int table[TABLE_SIZE]; is only compiled if TABLE_SIZE was previously defined with\n#define, independently of its value. If it was not defined, that line will not be included in the program compilation.\n#ifndef serves for the exact opposite: the code between #ifndef and #endif directives is only compiled if the\nspecified identifier has not been previously defined. For example:\n134\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n#ifndef TABLE_SIZE\n#define TABLE_SIZE 100\n#endif\nint table[TABLE_SIZE];\nIn this case, if when arriving at this piece of code, the TABLE_SIZE macro has not been defined yet, it would be\ndefined to a value of 100. If it already existed it would keep its previous value since the #define directive would\nnot be executed.\nThe #if, #else and #elif (i.e., \"else if\") directives serve to specify some condition to be met in order for the\nportion of code they surround to be compiled. The condition that follows #if or #elif can only evaluate constant\nexpressions, including macro expressions. For example:\n#if TABLE_SIZE>200\n#undef TABLE_SIZE\n#define TABLE_SIZE 200\n#elif TABLE_SIZE<50\n#undef TABLE_SIZE\n#define TABLE_SIZE 50\n#else\n#undef TABLE_SIZE\n#define TABLE_SIZE 100\n#endif\nint table[TABLE_SIZE];\nNotice how the whole structure of #if, #elif and #else chained directives ends with #endif.\nThe behavior of #ifdef and #ifndef can also be achieved by using the special operators defined and !defined\nrespectively in any #if or #elif directive:\n#if !defined TABLE_SIZE\n#define TABLE_SIZE 100\n#elif defined ARRAY_SIZE\n#define TABLE_SIZE ARRAY_SIZE\nint table[TABLE_SIZE];\nLine control (#line)\nWhen we compile a program and some error happen during the compiling process, the compiler shows an error\nmessage with references to the name of the file where the error happened and a line number, so it is easier to find\nthe code generating the error.\nThe #line directive allows us to control both things, the line numbers within the code files as well as the file name\nthat we want that appears when an error takes place. Its format is:\n#line number \"filename\"\nWhere number is the new line number that will be assigned to the next code line. The line numbers of successive\nlines will be increased one by one from this point on.\n\"filename\" is an optional parameter that allows to redefine the file name that will be shown. For example:\n135\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n#line 20 \"assigning variable\"\nint a?;\nThis code will generate an error that will be shown as error in file \"assigning variable\", line 20.\nError directive (#error)\nThis directive aborts the compilation process when it is found, generating a compilation the error that can be\nspecified as its parameter:\n#ifndef __cplusplus\n#error A C++ compiler is required!\n#endif\nThis example aborts the compilation process if the macro name __cplusplus is not defined (this macro name is\ndefined by default in all C++ compilers).\nSource file inclusion (#include)\nThis directive has also been used assiduously in other sections of this tutorial. When the preprocessor finds an\n#include directive it replaces it by the entire content of the specified file. There are two ways to specify a file to be\nincluded:\n#include \"file\"\n#include <file>\nThe only difference between both expressions is the places (directories) where the compiler is going to look for the\nfile. In the first case where the file name is specified between double-quotes, the file is searched first in the same\ndirectory that includes the file containing the directive. In case that it is not there, the compiler searches the file in\nthe default directories where it is configured to look for the standard header files.\nIf the file name is enclosed between angle-brackets <> the file is searched directly where the compiler is configured\nto look for the standard header files. Therefore, standard header files are usually included in angle-brackets, while\nother specific header files are included using quotes.\nPragma directive (#pragma)\nThis directive is used to specify diverse options to the compiler. These options are specific for the platform and the\ncompiler you use. Consult the manual or the reference of your compiler for more information on the possible\nparameters that you can define with #pragma.\nIf the compiler does not support a specific argument for #pragma, it is ignored - no error is generated.\nPredefined macro names\nThe following macro names are defined at any time:\nmacro value\n__LINE__ Integer value representing the current line in the source code file being compiled.\n__FILE__ A string literal containing the presumed name of the source file being compiled.\n__DATE__ A string literal in the form \"Mmm dd yyyy\" containing the date in which the compilation process began.\n__TIME__ A string literal in the form \"hh:mm:ss\" containing the time at which the compilation process began.\nAn integer value. All C++ compilers have this constant defined to some value. If the compiler is fully\n__cplusplus compliant with the C++ standard its value is equal or greater than 199711L depending on the version\nof the standard they comply.\nFor example:\n136\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// standard macro names This is the line number 7 of file\n#include <iostream> /home/jay/stdmacronames.cpp.\nusing namespace std; Its compilation began Nov 1 2005 at\n10:12:29.\nint main() The compiler gives a __cplusplus value\n{ of 1\ncout << \"This is the line number \" << __LINE__;\ncout << \" of file \" << __FILE__ << \".\\n\";\ncout << \"Its compilation began \" << __DATE__;\ncout << \" at \" << __TIME__ << \".\\n\";\ncout << \"The compiler gives a __cplusplus value of \";\ncout << __cplusplus;\nreturn 0;\n}\n137\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nC++ Standard Library\nInput/Output with files\nC++ provides the following classes to perform output and input of characters to/from files:\n\u2022\nofstream: Stream class to write on files\n\u2022\nifstream: Stream class to read from files\n\u2022\nfstream: Stream class to both read and write from/to files.\nThese classes are derived directly or indirectly from the classes istream, and ostream. We have already used\nobjects whose types were these classes: cin is an object of class istream and cout is an object of class ostream.\nTherfore, we have already been using classes that are related to our file streams. And in fact, we can use our file\nstreams the same way we are already used to use cin and cout, with the only difference that we have to associate\nthese streams with physical files. Let's see an example:\n// basic file operations [file example.txt]\n#include <iostream> Writing this to a file\n#include <fstream>\nusing namespace std;\nint main () {\nofstream myfile;\nmyfile.open (\"example.txt\");\nmyfile << \"Writing this to a file.\\n\";\nmyfile.close();\nreturn 0;\n}\nThis code creates a file called example.txt and inserts a sentence into it in the same way we are used to do with\ncout, but using the file stream myfile instead.\nBut let's go step by step:\nOpen a file\nThe first operation generally performed on an object of one of these classes is to associate it to a real file. This\nprocedure is known as to open a file. An open file is represented within a program by a stream object (an\ninstantiation of one of these classes, in the previous example this was myfile) and any input or output operation\nperformed on this stream object will be applied to the physical file associated to it.\nIn order to open a file with a stream object we use its member function open():\nopen (filename, mode);\nWhere filename is a null-terminated character sequence of type const char * (the same type that string literals\nhave) representing the name of the file to be opened, and mode is an optional parameter with a combination of the\nfollowing flags:\n138\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nios::in Open for input operations.\nios::out Open for output operations.\nios::binary Open in binary mode.\nSet the initial position at the end of the file.\nios::ate\nIf this flag is not set to any value, the initial position is the beginning of the file.\nAll output operations are performed at the end of the file, appending the content to the current content\nios::app\nof the file. This flag can only be used in streams open for output-only operations.\nIf the file opened for output operations already existed before, its previous content is deleted and\nios::trunc\nreplaced by the new one.\nAll these flags can be combined using the bitwise operator OR (|). For example, if we want to open the file\nexample.bin in binary mode to add data we could do it by the following call to member function open():\nofstream myfile;\nmyfile.open (\"example.bin\", ios::out | ios::app | ios::binary);\nEach one of the open() member functions of the classes ofstream, ifstream and fstream has a default mode that\nis used if the file is opened without a second argument:\nclass default mode parameter\nofstream ios::out\nifstream ios::in\nfstream ios::in | ios::out\nFor ifstream and ofstream classes, ios::in and ios::out are automatically and respectively assumed, even if a\nmode that does not include them is passed as second argument to the open() member function.\nThe default value is only applied if the function is called without specifying any value for the mode parameter. If\nthe function is called with any value in that parameter the default mode is overridden, not combined.\nFile streams opened in binary mode perform input and output operations independently of any format\nconsiderations. Non-binary files are known as text files, and some translations may occur due to formatting of\nsome special characters (like newline and carriage return characters).\nSince the first task that is performed on a file stream object is generally to open a file, these three classes include\na constructor that automatically calls the open() member function and has the exact same parameters as this\nmember. Therefore, we could also have declared the previous myfile object and conducted the same opening\noperation in our previous example by writing:\nofstream myfile (\"example.bin\", ios::out | ios::app | ios::binary);\nCombining object construction and stream opening in a single statement. Both forms to open a file are valid and\nequivalent.\nTo check if a file stream was successful opening a file, you can do it by calling to member is_open() with no\narguments. This member function returns a bool value of true in the case that indeed the stream object is\nassociated with an open file, or false otherwise:\nif (myfile.is_open()) { /* ok, proceed with output */ }\n139\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nClosing a file\nWhen we are finished with our input and output operations on a file we shall close it so that its resources become\navailable again. In order to do that we have to call the stream's member function close(). This member function\ntakes no parameters, and what it does is to flush the associated buffers and close the file:\nmyfile.close();\nOnce this member function is called, the stream object can be used to open another file, and the file is available\nagain to be opened by other processes.\nIn case that an object is destructed while still associated with an open file, the destructor automatically calls the\nmember function close().\nText files\nText file streams are those where we do not include the ios::binary flag in their opening mode. These files are\ndesigned to store text and thus all values that we input or output from/to them can suffer some formatting\ntransformations, which do not necessarily correspond to their literal binary value.\nData output operations on text files are performed in the same way we operated with cout:\n// writing on a text file [file example.txt]\n#include <iostream> This is a line.\n#include <fstream> This is another line.\nusing namespace std;\nint main () {\nofstream myfile (\"example.txt\");\nif (myfile.is_open())\n{\nmyfile << \"This is a line.\\n\";\nmyfile << \"This is another line.\\n\";\nmyfile.close();\n}\nelse cout << \"Unable to open file\";\nreturn 0;\n}\nData input from a file can also be performed in the same way that we did with cin:\n140\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// reading a text file This is a line.\n#include <iostream> This is another line.\n#include <fstream>\n#include <string>\nusing namespace std;\nint main () {\nstring line;\nifstream myfile (\"example.txt\");\nif (myfile.is_open())\n{\nwhile (! myfile.eof() )\n{\ngetline (myfile,line);\ncout << line << endl;\n}\nmyfile.close();\n}\nelse cout << \"Unable to open file\";\nreturn 0;\n}\nThis last example reads a text file and prints out its content on the screen. Notice how we have used a new\nmember function, called eof() that returns true in the case that the end of the file has been reached. We have\ncreated a while loop that finishes when indeed myfile.eof() becomes true (i.e., the end of the file has been\nreached).\nChecking state flags\nIn addition to eof(), which checks if the end of file has been reached, other member functions exist to check the\nstate of a stream (all of them return a bool value):\nbad()\nReturns true if a reading or writing operation fails. For example in the case that we try to write to a file\nthat is not open for writing or if the device where we try to write has no space left.\nfail()\nReturns true in the same cases as bad(), but also in the case that a format error happens, like when an\nalphabetical character is extracted when we are trying to read an integer number.\neof()\nReturns true if a file open for reading has reached the end.\ngood()\nIt is the most generic state flag: it returns false in the same cases in which calling any of the previous\nfunctions would return true.\nIn order to reset the state flags checked by any of these member functions we have just seen we can use the\nmember function clear(), which takes no parameters.\nget and put stream pointers\nAll i/o streams objects have, at least, one internal stream pointer:\nifstream, like istream, has a pointer known as the get pointer that points to the element to be read in the next\ninput operation.\n141\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nofstream, like ostream, has a pointer known as the put pointer that points to the location where the next element\nhas to be written.\nFinally, fstream, inherits both, the get and the put pointers, from iostream (which is itself derived from both\nistream and ostream).\nThese internal stream pointers that point to the reading or writing locations within a stream can be manipulated\nusing the following member functions:\ntellg() and tellp()\nThese two member functions have no parameters and return a value of the member type pos_type, which is an\ninteger data type representing the current position of the get stream pointer (in the case of tellg) or the put\nstream pointer (in the case of tellp).\nseekg() and seekp()\nThese functions allow us to change the position of the get and put stream pointers. Both functions are overloaded\nwith two different prototypes. The first prototype is:\nseekg ( position );\nseekp ( position );\nUsing this prototype the stream pointer is changed to the absolute position position (counting from the beginning\nof the file). The type for this parameter is the same as the one returned by functions tellg and tellp: the\nmember type pos_type, which is an integer value.\nThe other prototype for these functions is:\nseekg ( offset, direction );\nseekp ( offset, direction );\nUsing this prototype, the position of the get or put pointer is set to an offset value relative to some specific point\ndetermined by the parameter direction. offset is of the member type off_type, which is also an integer type.\nAnd direction is of type seekdir, which is an enumerated type (enum) that determines the point from where\noffset is counted from, and that can take any of the following values:\nios::beg offset counted from the beginning of the stream\nios::cur offset counted from the current position of the stream pointer\nios::end offset counted from the end of the stream\nThe following example uses the member functions we have just seen to obtain the size of a file:\n142\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\n// obtaining file size size is: 40 bytes.\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main () {\nlong begin,end;\nifstream myfile (\"example.txt\");\nbegin = myfile.tellg();\nmyfile.seekg (0, ios::end);\nend = myfile.tellg();\nmyfile.close();\ncout << \"size is: \" << (end-begin) << \" bytes.\\n\";\nreturn 0;\n}\nBinary files\nIn binary files, to input and output data with the extraction and insertion operators (<< and >>) and functions like\ngetline is not efficient, since we do not need to format any data, and data may not use the separation codes used\nby text files to separate elements (like space, newline, etc...).\nFile streams include two member functions specifically designed to input and output binary data sequentially:\nwrite and read. The first one (write) is a member function of ostream inherited by ofstream. And read is a\nmember function of istream that is inherited by ifstream. Objects of class fstream have both members. Their\nprototypes are:\nwrite ( memory_block, size );\nread ( memory_block, size );\nWhere memory_block is of type \"pointer to char\" (char*), and represents the address of an array of bytes where\nthe read data elements are stored or from where the data elements to be written are taken. The size parameter is\nan integer value that specifies the number of characters to be read or written from/to the memory block.\n// reading a complete binary file the complete file content is in memory\n#include <iostream>\n#include <fstream>\nusing namespace std;\nifstream::pos_type size;\nchar * memblock;\nint main () {\nifstream file (\"example.bin\",\nios::in|ios::binary|ios::ate);\nif (file.is_open())\n{\nsize = file.tellg();\nmemblock = new char [size];\nfile.seekg (0, ios::beg);\nfile.read (memblock, size);\nfile.close();\ncout << \"the complete file content is in memory\";\ndelete[] memblock;\n}\nelse cout << \"Unable to open file\";\nreturn 0;\n}\nIn this example the entire file is read and stored in a memory block. Let's examine how this is done:\n143\n\u00a9 cplusplus.com 2008. All rights reserved\nTThhee CC++++ LLaanngguuaaggee TTuuttoorriiaall\nFirst, the file is open with the ios::ate flag, which means that the get pointer will be positioned at the end of the\nfile. This way, when we call to member tellg(), we will directly obtain the size of the file. Notice the type we have\nused to declare variable size:\nifstream::pos_type size;\nifstream::pos_type is a specific type used for buffer and file positioning and is the type returned by\nfile.tellg(). This type is defined as an integer type, therefore we can conduct on it the same operations we\nconduct on any other integer value, and can safely be converted to another integer type large enough to contain\nthe size of the file. For a file with a size under 2GB we could use int:\nint size;\nsize = (int) file.tellg();\nOnce we have obtained the size of the file, we request the allocation of a memory block large enough to hold the\nentire file:\nmemblock = new char[size];\nRight after that, we proceed to set the get pointer at the beginning of the file (remember that we opened the file\nwith this pointer at the end), then read the entire file, and finally close it:\nfile.seekg (0, ios::beg);\nfile.read (memblock, size);\nfile.close();\nAt this point we could operate with the data obtained from the file. Our program simply announces that the content\nof the file is in memory and then terminates.\nBuffers and Synchronization\nWhen we operate with file streams, these are associated to an internal buffer of type streambuf. This buffer is a\nmemory block that acts as an intermediary between the stream and the physical file. For example, with an\nofstream, each time the member function put (which writes a single character) is called, the character is not\nwritten directly to the physical file with which the stream is associated. Instead of that, the character is inserted in\nthat stream's intermediate buffer.\nWhen the buffer is flushed, all the data contained in it is written to the physical medium (if it is an output stream)\nor simply freed (if it is an input stream). This process is called synchronization and takes place under any of the\nfollowing circumstances:\n\u2022\nWhen the file is closed: before closing a file all buffers that have not yet been flushed are synchronized\nand all pending data is written or read to the physical medium.\n\u2022\nWhen the buffer is full: Buffers have a certain size. When the buffer is full it is automatically\nsynchronized.\n\u2022\nExplicitly, with manipulators: When certain manipulators are used on streams, an explicit\nsynchronization takes place. These manipulators are: flush and endl.\n\u2022\nExplicitly, with member function sync(): Calling stream's member function sync(), which takes no\nparameters, causes an immediate synchronization. This function returns an int value equal to -1 if the\nstream has no associated buffer or in case of failure. Otherwise (if the stream buffer was successfully\nsynchronized) it returns 0.\n144\n\u00a9 cplusplus.com 2008. All rights reserved\n",
  "context": "C++ Language Tutorial\nWritten by: Juan Souli\u00e9\nLast revision: June, 2007",
  "source_file": "resources\\Year 1\\C++ Docs\\C++ Documentation.pdf",
  "line_numbers": [
    5,
    5488
  ]
}
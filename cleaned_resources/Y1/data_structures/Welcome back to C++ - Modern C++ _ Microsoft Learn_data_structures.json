{
  "title": "Welcome back to C++ - Modern C++ _ Microsoft Learn",
  "language": "cpp",
  "topics": [
    "web_dev",
    "fundamentals",
    "networking",
    "algorithms",
    "data_structures"
  ],
  "purpose": "languages: It can work at the highest levels of abstraction, and down at the level of the silicon.",
  "code": "program: Games, device drivers, HPC, cloud, desktop, embedded, and mobile apps, and much\nmore. Even libraries and compilers for other programming languages get written in C++.\nOne of the original requirements for C++ was backward compatibility with the C language. As a\nresult, C++ has always permitted C-style programming, with raw pointers, arrays, null-terminated\ncharacter strings, and other features. They may enable great performance, but can also spawn\nbugs and complexity. The evolution of C++ has emphasized features that greatly reduce the need\nto use C-style idioms. The old C-programming facilities are still there when you need them.\nHowever, in modern C++ code you should need them less and less. Modern C++ code is simpler,\nsafer, more elegant, and still as fast as ever.\nThe following sections provide an overview of the main features of modern C++. Unless noted\notherwise, the features listed here are available in C++11 and later. In the Microsoft C++\ncompiler, you can set the /std compiler option to specify which version of the standard to use for\nyour project.\nResources and smart pointers\nOne of the major classes of bugs in C-style programming is the memory leak. Leaks are often\ncaused by a failure to call delete for memory that was allocated with new. Modern C++\nemphasizes the principle of resource acquisition is initialization (RAII). The idea is simple.\nResources (heap memory, file handles, sockets, and so on) should be owned by an object. That\nobject creates, or receives, the newly allocated resource in its constructor, and deletes it in its\ndestructor. The principle of RAII guarantees that all resources get properly returned to the\noperating system when the owning object goes out of scope.\nTo support easy adoption of RAII principles, the C++ Standard Library provides three smart\npointer types: std::unique_ptr, std::shared_ptr, and std::weak_ptr. A smart pointer handles the\nallocation and deletion of the memory it owns. The following example shows a class with an array\nmember that is allocated on the heap in the call to make_unique(). The calls to new and delete\nare encapsulated by the unique_ptr class. When a widget object goes out of scope, the\nunique_ptr destructor will be invoked and it will release the memory that was allocated for the\narray.\nC++\n#include <memory>\nclass widget\n{\nprivate:\nstd::unique_ptr<int[]> data;\npublic:\nwidget(const int size) { data = std::make_unique<int[]>(size); }\nvoid do_something() {}\n};\nvoid functionUsingWidget() {\nwidget w(1000000); // lifetime automatically tied to enclosing scope\n// constructs w, including the w.data gadget member\n// ...\nw.do_something();\n// ...\n} // automatic destruction and deallocation for w and w.data\nWhenever possible, use a smart pointer to manage heap memory. If you must use the new and\ndelete operators explicitly, follow the principle of RAII. For more information, see Object lifetime\nand resource management (RAII).\nstd::string and std::string_view\nC-style strings are another major source of bugs. By using std::string and std::wstring, you can\neliminate virtually all the errors associated with C-style strings. You also gain the benefit of\nmember functions for searching, appending, prepending, and so on. Both are highly optimized for\nspeed. When passing a string to a function that requires only read-only access, in C++17 you can\nuse std::string_view for even greater performance benefit.\nstd::vector and other Standard Library containers\nThe standard library containers all follow the principle of RAII. They provide iterators for safe\ntraversal of elements. And, they're highly optimized for performance and have been thoroughly\ntested for correctness. By using these containers, you eliminate the potential for bugs or\ninefficiencies that might be introduced in custom data structures. Instead of raw arrays, use vector\nas a sequential container in C++.\nC++\nvector<string> apples;\napples.push_back(\"Granny Smith\");\nUse map (not unordered_map) as the default associative container. Use set, multimap, and multiset\nfor degenerate and multi cases.\nC++\nmap<string, string> apple_color;\n// ...\napple_color[\"Granny Smith\"] = \"Green\";\nWhen performance optimization is needed, consider using:\nUnordered associative containers such as unordered_map. These have lower per-element\noverhead and constant-time lookup, but they can be harder to use correctly and efficiently.\nSorted vector. For more information, see Algorithms.\nDon't use C-style arrays. For older APIs that need direct access to the data, use accessor methods\nsuch as f(vec.data(), vec.size()); instead. For more information about containers, see C++\nStandard Library Containers.\nStandard Library algorithms\nBefore you assume that you need to write a custom algorithm for your program, first review the\nC++ Standard Library algorithms. The Standard Library contains an ever-growing assortment of\nalgorithms for many common operations such as searching, sorting, filtering, and randomizing.\nThe math library is extensive. In C++17 and later, parallel versions of many algorithms are\nprovided.\nHere are some important examples:\nfor_each, the default traversal algorithm (along with range-based for loops).\ntransform, for not-in-place modification of container elements\nfind_if, the default search algorithm.\nsort, lower_bound, and the other default sorting and searching algorithms.\nTo write a comparator, use strict < and use named lambdas when you can.\nC++\nauto comp = [](const widget& w1, const widget& w2)\n{ return w1.weight() < w2.weight(); }\nsort( v.begin(), v.end(), comp );\nauto i = lower_bound( v.begin(), v.end(), widget{0}, comp );\nauto instead of explicit type names\nC++11 introduced the auto keyword for use in variable, function, and template declarations. auto\ntells the compiler to deduce the type of the object so that you don't have to type it explicitly.\nauto is especially useful when the deduced type is a nested template:\nC++\nmap<int,list<string>>::iterator i = m.begin(); // C-style\nauto i = m.begin(); // modern C++\nRange-based for loops\nC-style iteration over arrays and containers is prone to indexing errors and is also tedious to type.\nTo eliminate these errors, and make your code more readable, use range-based for loops with\nboth Standard Library containers and raw arrays. For more information, see Range-based for\nstatement.\nC++\n#include <iostream>\n#include <vector>\nint main()\n{\nstd::vector<int> v {1,2,3};\n// C-style\nfor(int i = 0; i < v.size(); ++i)\n{\nstd::cout << v[i];\n}\n// Modern C++:\nfor(auto& num : v)\n{\nstd::cout << num;\n}\n}\nconstexpr expressions instead of macros\nMacros in C and C++ are tokens that are processed by the preprocessor before compilation. Each\ninstance of a macro token is replaced with its defined value or expression before the file is\ncompiled. Macros are commonly used in C-style programming to define compile-time constant\nvalues. However, macros are error-prone and difficult to debug. In modern C++, you should\nprefer constexpr variables for compile-time constants:\nC++\n#define SIZE 10 // C-style\nconstexpr int size = 10; // modern C++\nUniform initialization\nIn modern C++, you can use brace initialization for any type. This form of initialization is\nespecially convenient when initializing arrays, vectors, or other containers. In the following\nexample, v2 is initialized with three instances of S. v3 is initialized with three instances of S that\nare themselves initialized using braces. The compiler infers the type of each element based on the\ndeclared type of v3.\nC++\n#include <vector>\nstruct S\n{\nstd::string name;\nfloat num;\nS(std::string s, float f) : name(s), num(f) {}\n};\nint main()\n{\n// C-style initialization\nstd::vector<S> v;\nS s1(\"Norah\", 2.7);\nS s2(\"Frank\", 3.5);\nS s3(\"Jeri\", 85.9);\nv.push_back(s1);\nv.push_back(s2);\nv.push_back(s3);\n// Modern C++:\nstd::vector<S> v2 {s1, s2, s3};\n// or...\nstd::vector<S> v3{ {\"Norah\", 2.7}, {\"Frank\", 3.5}, {\"Jeri\", 85.9} };\n}\nFor more information, see Brace initialization.\nMove semantics\nModern C++ provides move semantics, which make it possible to eliminate unnecessary memory\ncopies. In earlier versions of the language, copies were unavoidable in certain situations. A move\noperation transfers ownership of a resource from one object to the next without making a copy.\nSome classes own resources such as heap memory, file handles, and so on. When you implement\na resource-owning class, you can define a move constructor and move assignment operator for it.\nThe compiler chooses these special members during overload resolution in situations where a\ncopy isn't needed. The Standard Library container types invoke the move constructor on objects if\none is defined. For more information, see Move Constructors and Move Assignment Operators\n(C++).\nLambda expressions\nIn C-style programming, a function can be passed to another function by using a function pointer.\nFunction pointers are inconvenient to maintain and understand. The function they refer to may be\ndefined elsewhere in the source code, far away from the point at which it's invoked. Also, they're\nnot type-safe. Modern C++ provides function objects, classes that override the operator()\noperator, which enables them to be called like a function. The most convenient way to create\nfunction objects is with inline lambda expressions. The following example shows how to use a\nlambda expression to pass a function object, that the find_if function will invoke on each\nelement in the vector:\nC++\nstd::vector<int> v {1,2,3,4,5};\nint x = 2;\nint y = 4;\nauto result = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });\nThe lambda expression [=](int i) { return i > x && i < y; } can be read as \"function that\ntakes a single argument of type int and returns a boolean that indicates whether the argument is\ngreater than x and less than y.\" Notice that the variables x and y from the surrounding context\ncan be used in the lambda. The [=] specifies that those variables are captured by value; in other\nwords, the lambda expression has its own copies of those values.\nExceptions\nModern C++ emphasizes exceptions, not error codes, as the best way to report and handle error\nconditions. For more information, see Modern C++ best practices for exceptions and error\nhandling.\nstd::atomic\nUse the C++ Standard Library std::atomic struct and related types for inter-thread communication\nmechanisms.\nstd::variant (C++17)\nUnions are commonly used in C-style programming to conserve memory by enabling members of\ndifferent types to occupy the same memory location. However, unions aren't type-safe and are\nprone to programming errors. C++17 introduces the std::variant class as a more robust and safe\nalternative to unions. The std::visit function can be used to access the members of a variant type\nin a type-safe manner.\nSee also\nC++ Language Reference\nLambda Expressions\nC++ Standard Library\nMicrosoft C/C++ language conformance\n",
  "context": "languages: It can work at the highest levels of abstraction, and down at the level of the silicon.\nC++ supplies highly optimized standard libraries. It enables access to low-level hardware features,\nto maximize speed and minimize memory requirements. C++ can create almost any kind of",
  "source_file": "resources\\Year 1\\C++ Docs\\Welcome back to C++ - Modern C++ _ Microsoft Learn.pdf",
  "line_numbers": [
    8,
    216
  ]
}
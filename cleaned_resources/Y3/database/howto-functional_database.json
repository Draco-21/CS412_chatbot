{
  "title": "howto-functional",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "",
  "code": "Functional Programming HOWTO\nRelease 3.13.3\nGuido van Rossum and the Python development team\nApril27,2025\nPythonSoftwareFoundation\nEmail: docs@python.org\nContents\n1 Introduction 2\n1.1 Formalprovability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2 Modularity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.3 Easeofdebuggingandtesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.4 Composability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n2 Iterators 4\n2.1 DataTypesThatSupportIterators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n3 Generatorexpressionsandlistcomprehensions 6\n4 Generators 7\n4.1 Passingvaluesintoagenerator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n5 Built-infunctions 10\n6 Theitertoolsmodule 11\n6.1 Creatingnewiterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n6.2 Callingfunctionsonelements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n6.3 Selectingelements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n6.4 Combinatoricfunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n6.5 Groupingelements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n7 Thefunctoolsmodule 15\n7.1 Theoperatormodule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n8 Smallfunctionsandthelambdaexpression 17\n9 RevisionHistoryandAcknowledgements 18\n10 References 18\n10.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n10.2 Python-specific . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n10.3 Pythondocumentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nIndex 20\n1\nAuthor\nA.M.Kuchling\nRelease\n0.32\nIn this document, we\u2019ll take a tour of Python\u2019s features suitable for implementing programs in a functional style.\nAfteranintroductiontotheconceptsoffunctionalprogramming,we\u2019lllookatlanguagefeaturessuchasiteratorsand\ngeneratorsandrelevantlibrarymodulessuchasitertoolsandfunctools.\n1 Introduction\nThissectionexplainsthebasicconceptoffunctionalprogramming;ifyou\u2019rejustinterestedinlearningaboutPython\nlanguagefeatures,skiptothenextsectiononIterators.\nProgramminglanguagessupportdecomposingproblemsinseveraldifferentways:\n\u2022 Mostprogramminglanguagesareprocedural: programsarelistsofinstructionsthattellthecomputerwhat\ntodowiththeprogram\u2019sinput. C,Pascal,andevenUnixshellsareprocedurallanguages.\n\u2022 Indeclarativelanguages,youwriteaspecificationthatdescribestheproblemtobesolved,andthelanguage\nimplementationfiguresouthowtoperformthecomputationefficiently. SQListhedeclarativelanguageyou\u2019re\nmostlikelytobefamiliarwith;aSQLquerydescribesthedatasetyouwanttoretrieve,andtheSQLengine\ndecideswhethertoscantablesoruseindexes,whichsubclausesshouldbeperformedfirst,etc.\n\u2022 Object-orientedprogramsmanipulatecollectionsofobjects. Objectshaveinternalstateandsupportmethods\nthatqueryormodifythisinternalstateinsomeway. SmalltalkandJavaareobject-orientedlanguages. C++\nandPythonarelanguagesthatsupportobject-orientedprogramming,butdon\u2019tforcetheuseofobject-oriented\nfeatures.\n\u2022 Functional programming decomposes a problem into a set of functions. Ideally, functions only take inputs\nandproduceoutputs,anddon\u2019thaveanyinternalstatethataffectstheoutputproducedforagiveninput. Well-\nknownfunctionallanguagesincludetheMLfamily(StandardML,OCaml,andothervariants)andHaskell.\nThedesignersofsomecomputerlanguageschoosetoemphasizeoneparticularapproachtoprogramming. Thisoften\nmakesitdifficulttowriteprogramsthatuseadifferentapproach. Otherlanguagesaremulti-paradigmlanguagesthat\nsupportseveraldifferentapproaches. Lisp,C++,andPythonaremulti-paradigm;youcanwriteprogramsorlibraries\nthat are largely procedural, object-oriented, or functional in all of these languages. In a large program, different\nsectionsmightbewrittenusingdifferentapproaches;theGUImightbeobject-orientedwhiletheprocessinglogicis\nproceduralorfunctional,forexample.\nInafunctionalprogram,inputflowsthroughasetoffunctions. Eachfunctionoperatesonitsinputandproducessome\noutput. Functionalstylediscouragesfunctionswithsideeffectsthatmodifyinternalstateormakeotherchangesthat\naren\u2019t visible in the function\u2019s return value. Functions that have no side effects at all are called purely functional.\nAvoidingsideeffectsmeansnotusingdatastructuresthatgetupdatedasaprogramruns;everyfunction\u2019soutputmust\nonlydependonitsinput.\nSomelanguagesareverystrictaboutpurityanddon\u2019tevenhaveassignmentstatementssuchasa=3orc = a + b,\nbutit\u2019sdifficulttoavoidallsideeffects,suchasprintingtothescreenorwritingtoadiskfile. Anotherexampleisa\ncalltotheprint()ortime.sleep()function,neitherofwhichreturnsausefulvalue. Botharecalledonlyfor\ntheirsideeffectsofsendingsometexttothescreenorpausingexecutionforasecond.\nPythonprogramswritteninfunctionalstyleusuallywon\u2019tgototheextremeofavoidingallI/Oorallassignments;\ninstead,they\u2019llprovideafunctional-appearinginterfacebutwillusenon-functionalfeaturesinternally. Forexample,\nthe implementation of a function will still use assignments to local variables, but won\u2019t modify global variables or\nhaveothersideeffects.\nFunctionalprogrammingcanbeconsideredtheoppositeofobject-orientedprogramming. Objectsarelittlecapsules\ncontainingsomeinternalstatealongwithacollectionofmethodcallsthatletyoumodifythisstate, andprograms\nconsistofmakingtherightsetofstatechanges. Functionalprogrammingwantstoavoidstatechangesasmuchas\npossibleandworkswithdataflowingbetweenfunctions. InPythonyoumightcombinethetwoapproachesbywriting\nfunctionsthattakeandreturninstancesrepresentingobjectsinyourapplication(e-mailmessages,transactions,etc.).\n2\nFunctionaldesignmayseemlikeanoddconstrainttoworkunder. Whyshouldyouavoidobjectsandsideeffects?\nTherearetheoreticalandpracticaladvantagestothefunctionalstyle:\n\u2022 Formalprovability.\n\u2022 Modularity.\n\u2022 Composability.\n\u2022 Easeofdebuggingandtesting.\n1.1 Formal provability\nAtheoreticalbenefitisthatit\u2019seasiertoconstructamathematicalproofthatafunctionalprogramiscorrect.\nForalongtimeresearchershavebeeninterestedinfindingwaystomathematicallyproveprogramscorrect. Thisis\ndifferentfromtestingaprogramonnumerousinputsandconcludingthatitsoutputisusuallycorrect, orreadinga\nprogram\u2019ssourcecodeandconcludingthatthecodelooksright;thegoalisinsteadarigorousproofthataprogram\nproducestherightresultforallpossibleinputs.\nThetechniqueusedtoproveprogramscorrectistowritedowninvariants,propertiesoftheinputdataandofthe\nprogram\u2019svariablesthatarealwaystrue. Foreachlineofcode,youthenshowthatifinvariantsXandYaretruebefore\nthelineisexecuted,theslightlydifferentinvariantsX\u2019andY\u2019aretrueafterthelineisexecuted. Thiscontinuesuntil\nyoureachtheendoftheprogram,atwhichpointtheinvariantsshouldmatchthedesiredconditionsontheprogram\u2019s\noutput.\nFunctionalprogramming\u2019savoidanceofassignmentsarosebecauseassignmentsaredifficulttohandlewiththistech-\nnique;assignmentscanbreakinvariantsthatweretruebeforetheassignmentwithoutproducinganynewinvariants\nthatcanbepropagatedonward.\nUnfortunately, proving programs correct is largely impractical and not relevant to Python software. Even trivial\nprogramsrequireproofsthatareseveralpageslong;theproofofcorrectnessforamoderatelycomplicatedprogram\nwouldbeenormous,andfewornoneoftheprogramsyouusedaily(thePythoninterpreter,yourXMLparser,your\nwebbrowser)couldbeprovencorrect. Evenifyouwrotedownorgeneratedaproof,therewouldthenbethequestion\nofverifyingtheproof;maybethere\u2019sanerrorinit,andyouwronglybelieveyou\u2019veprovedtheprogramcorrect.\n1.2 Modularity\nAmorepracticalbenefitoffunctionalprogrammingisthatitforcesyoutobreakapartyourproblemintosmallpieces.\nProgramsaremoremodularasaresult. It\u2019seasiertospecifyandwriteasmallfunctionthatdoesonethingthana\nlargefunctionthatperformsacomplicatedtransformation. Smallfunctionsarealsoeasiertoreadandtocheckfor\nerrors.\n1.3 Ease of debugging and testing\nTestinganddebuggingafunctional-styleprogramiseasier.\nDebuggingissimplifiedbecausefunctionsaregenerallysmallandclearlyspecified. Whenaprogramdoesn\u2019twork,\neachfunctionisaninterfacepointwhereyoucancheckthatthedataarecorrect. Youcanlookattheintermediate\ninputsandoutputstoquicklyisolatethefunctionthat\u2019sresponsibleforabug.\nTestingiseasierbecauseeachfunctionisapotentialsubjectforaunittest. Functionsdon\u2019tdependonsystemstate\nthatneedstobereplicatedbeforerunningatest;insteadyouonlyhavetosynthesizetherightinputandthencheck\nthattheoutputmatchesexpectations.\n1.4 Composability\nAsyouworkonafunctional-styleprogram,you\u2019llwriteanumberoffunctionswithvaryinginputsandoutputs. Some\nofthesefunctionswillbeunavoidablyspecializedtoaparticularapplication,butotherswillbeusefulinawidevariety\nofprograms. Forexample,afunctionthattakesadirectorypathandreturnsalltheXMLfilesinthedirectory,ora\nfunctionthattakesafilenameandreturnsitscontents,canbeappliedtomanydifferentsituations.\nOver time you\u2019ll form a personal library of utilities. Often you\u2019ll assemble new programs by arranging existing\nfunctionsinanewconfigurationandwritingafewfunctionsspecializedforthecurrenttask.\n3\n2 Iterators\nI\u2019llstartbylookingataPythonlanguagefeaturethat\u2019sanimportantfoundationforwritingfunctional-styleprograms:\niterators.\nAniteratorisanobjectrepresentingastreamofdata;thisobjectreturnsthedataoneelementatatime. APython\niteratormustsupportamethodcalled__next__()thattakesnoargumentsandalwaysreturnsthenextelementof\nthestream. Iftherearenomoreelementsinthestream,__next__()mustraisetheStopIterationexception.\nIteratorsdon\u2019thavetobefinite,though;it\u2019sperfectlyreasonabletowriteaniteratorthatproducesaninfinitestream\nofdata.\nThe built-in iter() function takes an arbitrary object and tries to return an iterator that will return the object\u2019s\ncontents or elements, raising TypeError if the object doesn\u2019t support iteration. Several of Python\u2019s built-in data\ntypessupportiteration,themostcommonbeinglistsanddictionaries. Anobjectiscallediterableifyoucangetan\niteratorforit.\nYoucanexperimentwiththeiterationinterfacemanually:\n>>> L = [1, 2, 3]\n>>> it = iter(L)\n>>> it\n<...iterator object at ...>\n>>> it.__next__() # same as next(it)\n1\n>>> next(it)\n2\n>>> next(it)\n3\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nStopIteration\n>>>\nPython expects iterable objects in several different contexts, the most important being the for statement. In the\nstatementfor X in Y,Ymustbeaniteratororsomeobjectforwhichiter()cancreateaniterator. Thesetwo\nstatementsareequivalent:\nfor i in iter(obj):\nprint(i)\nfor i in obj:\nprint(i)\nIteratorscanbematerializedaslistsortuplesbyusingthelist()ortuple()constructorfunctions:\n>>> L = [1, 2, 3]\n>>> iterator = iter(L)\n>>> t = tuple(iterator)\n>>> t\n(1, 2, 3)\nSequenceunpackingalsosupportsiterators: ifyouknowaniteratorwillreturnNelements, youcanunpackthem\nintoanN-tuple:\n>>> L = [1, 2, 3]\n>>> iterator = iter(L)\n>>> a, b, c = iterator\n>>> a, b, c\n(1, 2, 3)\n4\nBuilt-infunctionssuchasmax()andmin()cantakeasingleiteratorargumentandwillreturnthelargestorsmallest\nelement. The\"in\" and\"not in\" operatorsalsosupportiterators: X in iterator istrue ifX isfoundinthe\nstreamreturnedbytheiterator. You\u2019llrunintoobviousproblemsiftheiteratorisinfinite;max(),min()willnever\nreturn,andiftheelementXneverappearsinthestream,the\"in\"and\"not in\"operatorswon\u2019treturneither.\nNote that you can only go forward in an iterator; there\u2019s no way to get the previous element, reset the iterator, or\nmakeacopyofit. Iteratorobjectscanoptionallyprovidetheseadditionalcapabilities,buttheiteratorprotocolonly\nspecifiesthe__next__()method. Functionsmaythereforeconsumealloftheiterator\u2019soutput,andifyouneedto\ndosomethingdifferentwiththesamestream,you\u2019llhavetocreateanewiterator.\n2.1 Data Types That Support Iterators\nWe\u2019ve already seen how lists and tuples support iterators. In fact, any Python sequence type, such as strings, will\nautomaticallysupportcreationofaniterator.\nCallingiter()onadictionaryreturnsaniteratorthatwillloopoverthedictionary\u2019skeys:\n>>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n... 'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n>>> for key in m:\n... print(key, m[key])\nJan 1\nFeb 2\nMar 3\nApr 4\nMay 5\nJun 6\nJul 7\nAug 8\nSep 9\nOct 10\nNov 11\nDec 12\nNotethatstartingwithPython3.7,dictionaryiterationorderisguaranteedtobethesameastheinsertionorder. In\nearlierversions,thebehaviourwasunspecifiedandcouldvarybetweenimplementations.\nApplyingiter()toadictionaryalwaysloopsoverthekeys,butdictionarieshavemethodsthatreturnotheriterators.\nIfyouwanttoiterateovervaluesorkey/valuepairs,youcanexplicitlycallthevalues()oritems()methodsto\ngetanappropriateiterator.\nThedict()constructorcanacceptaniteratorthatreturnsafinitestreamof(key, value)tuples:\n>>> L = [('Italy', 'Rome'), ('France', 'Paris'), ('US', 'Washington DC')]\n>>> dict(iter(L))\n{'Italy': 'Rome', 'France': 'Paris', 'US': 'Washington DC'}\nFilesalsosupportiterationbycallingthereadline()methoduntiltherearenomorelinesinthefile. Thismeans\nyoucanreadeachlineofafilelikethis:\nfor line in file:\n# do something for each line\n...\nSetscantaketheircontentsfromaniterableandletyouiterateovertheset\u2019selements:\n>>> S = {2, 3, 5, 7, 11, 13}\n>>> for i in S:\n... print(i)\n2\n(continuesonnextpage)\n5\n(continuedfrompreviouspage)\n3\n5\n7\n11\n13\n3 Generator expressions and list comprehensions\nTwocommonoperationsonaniterator\u2019soutputare1)performingsomeoperationforeveryelement,2)selectinga\nsubsetofelementsthatmeetsomecondition. Forexample,givenalistofstrings,youmightwanttostripofftrailing\nwhitespacefromeachlineorextractallthestringscontainingagivensubstring.\nList comprehensions and generator expressions (short form: \u201clistcomps\u201d and \u201cgenexps\u201d) are a concise notation for\nsuchoperations,borrowedfromthefunctionalprogramminglanguageHaskell(https://www.haskell.org/). Youcan\nstripallthewhitespacefromastreamofstringswiththefollowingcode:\n>>> line_list = [' line 1\\n', 'line 2 \\n', ' \\n', '']\n>>> # Generator expression -- returns iterator\n>>> stripped_iter = (line.strip() for line in line_list)\n>>> # List comprehension -- returns list\n>>> stripped_list = [line.strip() for line in line_list]\nYoucanselectonlycertainelementsbyaddingan\"if\"condition:\n>>> stripped_list = [line.strip() for line in line_list\n... if line != \"\"]\nWithalistcomprehension,yougetbackaPythonlist;stripped_listisalistcontainingtheresultinglines,notan\niterator. Generatorexpressionsreturnaniteratorthatcomputesthevaluesasnecessary,notneedingtomaterialize\nallthevaluesatonce. Thismeansthatlistcomprehensionsaren\u2019tusefulifyou\u2019reworkingwithiteratorsthatreturn\naninfinitestreamoraverylargeamountofdata. Generatorexpressionsarepreferableinthesesituations.\nGeneratorexpressionsaresurroundedbyparentheses(\u201c()\u201d)andlistcomprehensionsaresurroundedbysquarebrack-\nets(\u201c[]\u201d). Generatorexpressionshavetheform:\n( expression for expr in sequence1\nif condition1\nfor expr2 in sequence2\nif condition2\nfor expr3 in sequence3\n...\nif condition3\nfor exprN in sequenceN\nif conditionN )\nAgain,foralistcomprehensiononlytheoutsidebracketsaredifferent(squarebracketsinsteadofparentheses).\nTheelementsofthegeneratedoutputwillbethesuccessivevaluesofexpression. Theifclausesarealloptional;\nifpresent,expressionisonlyevaluatedandaddedtotheresultwhenconditionistrue.\nGeneratorexpressionsalwayshavetobewritteninsideparentheses,buttheparenthesessignallingafunctioncallalso\ncount. Ifyouwanttocreateaniteratorthatwillbeimmediatelypassedtoafunctionyoucanwrite:\nobj_total = sum(obj.count for obj in list_all_objects())\nThefor...inclausescontainthesequencestobeiteratedover. Thesequencesdonothavetobethesamelength,\nbecausetheyareiteratedoverfromlefttoright, notinparallel. Foreachelementinsequence1, sequence2is\n6\nloopedoverfromthebeginning. sequence3isthenloopedoverforeachresultingpairofelementsfromsequence1\nandsequence2.\nToputitanotherway,alistcomprehensionorgeneratorexpressionisequivalenttothefollowingPythoncode:\nfor expr1 in sequence1:\nif not (condition1):\ncontinue # Skip this element\nfor expr2 in sequence2:\nif not (condition2):\ncontinue # Skip this element\n...\nfor exprN in sequenceN:\nif not (conditionN):\ncontinue # Skip this element\n# Output the value of\n# the expression.\nThismeansthatwhentherearemultiplefor...inclausesbutnoifclauses,thelengthoftheresultingoutputwill\nbe equal to the product of the lengths of all the sequences. If you have two lists of length 3, the output list is 9\nelementslong:\n>>> seq1 = 'abc'\n>>> seq2 = (1, 2, 3)\n>>> [(x, y) for x in seq1 for y in seq2]\n[('a', 1), ('a', 2), ('a', 3),\n('b', 1), ('b', 2), ('b', 3),\n('c', 1), ('c', 2), ('c', 3)]\nToavoidintroducinganambiguityintoPython\u2019sgrammar,ifexpressioniscreatingatuple,itmustbesurrounded\nwithparentheses. Thefirstlistcomprehensionbelowisasyntaxerror,whilethesecondoneiscorrect:\n# Syntax error\n[x, y for x in seq1 for y in seq2]\n# Correct\n[(x, y) for x in seq1 for y in seq2]\n4 Generators\nGeneratorsareaspecialclassoffunctionsthatsimplifythetaskofwritingiterators. Regularfunctionscomputea\nvalueandreturnit,butgeneratorsreturnaniteratorthatreturnsastreamofvalues.\nYou\u2019redoubtlessfamiliarwithhowregularfunctioncallsworkinPythonorC.Whenyoucallafunction, itgetsa\nprivatenamespacewhereitslocalvariablesarecreated. Whenthefunctionreachesareturnstatement,thelocal\nvariablesaredestroyedandthevalueisreturnedtothecaller. Alatercalltothesamefunctioncreatesanewprivate\nnamespaceandafreshsetoflocalvariables. But,whatifthelocalvariablesweren\u2019tthrownawayonexitingafunction?\nWhatifyoucouldlaterresumethefunctionwhereitleftoff? Thisiswhatgeneratorsprovide;theycanbethought\nofasresumablefunctions.\nHere\u2019sthesimplestexampleofageneratorfunction:\n>>> def generate_ints(N):\n... for i in range(N):\n... yield i\nAny function containing a yield keyword is a generator function; this is detected by Python\u2019s bytecode compiler\nwhichcompilesthefunctionspeciallyasaresult.\n7\nWhenyoucallageneratorfunction,itdoesn\u2019treturnasinglevalue;insteaditreturnsageneratorobjectthatsupports\ntheiteratorprotocol. Onexecutingtheyieldexpression,thegeneratoroutputsthevalueofi,similartoareturn\nstatement. Thebigdifferencebetweenyieldandareturnstatementisthatonreachingayieldthegenerator\u2019s\nstateofexecutionissuspendedandlocalvariablesarepreserved. Onthenextcalltothegenerator\u2019s__next__()\nmethod,thefunctionwillresumeexecuting.\nHere\u2019sasampleusageofthegenerate_ints()generator:\n>>> gen = generate_ints(3)\n>>> gen\n<generator object generate_ints at ...>\n>>> next(gen)\n0\n>>> next(gen)\n1\n>>> next(gen)\n2\n>>> next(gen)\nTraceback (most recent call last):\nFile \"stdin\", line 1, in <module>\nFile \"stdin\", line 2, in generate_ints\nStopIteration\nYoucouldequallywritefor i in generate_ints(5),ora, b, c = generate_ints(3).\nInsideageneratorfunction,return valuecausesStopIteration(value)toberaisedfromthe__next__()\nmethod. Oncethishappens,orthebottomofthefunctionisreached,theprocessionofvaluesendsandthegenerator\ncannotyieldanyfurthervalues.\nYoucouldachievetheeffectofgeneratorsmanuallybywritingyourownclassandstoringallthelocalvariablesofthe\ngeneratorasinstancevariables. Forexample,returningalistofintegerscouldbedonebysettingself.countto0,\nandhavingthe__next__()methodincrementself.countandreturnit. However,foramoderatelycomplicated\ngenerator,writingacorrespondingclasscanbemuchmessier.\nThetestsuiteincludedwithPython\u2019slibrary,Lib/test/test_generators.py,containsanumberofmoreinterestingex-\namples. Here\u2019sonegeneratorthatimplementsanin-ordertraversalofatreeusinggeneratorsrecursively.\n# A recursive generator that generates Tree leaves in in-order.\ndef inorder(t):\nif t:\nfor x in inorder(t.left):\nyield x\nyield t.label\nfor x in inorder(t.right):\nyield x\nTwootherexamplesintest_generators.pyproducesolutionsfortheN-Queensproblem(placingNqueenson\nanNxNchessboardsothatnoqueenthreatensanother)andtheKnight\u2019sTour(findingaroutethattakesaknightto\neverysquareofanNxNchessboardwithoutvisitinganysquaretwice).\n4.1 Passing values into a generator\nInPython2.4andearlier,generatorsonlyproducedoutput. Onceagenerator\u2019scodewasinvokedtocreateaniterator,\nthere was no way to pass any new information into the function when its execution is resumed. You could hack\ntogether this ability by making the generator look at a global variable or by passing in some mutable object that\ncallersthenmodify,buttheseapproachesaremessy.\nInPython2.5there\u2019sasimplewaytopassvaluesintoagenerator. yieldbecameanexpression,returningavalue\nthatcanbeassignedtoavariableorotherwiseoperatedon:\n8\nval = (yield i)\nI recommend that you always put parentheses around a yield expression when you\u2019re doing something with the\nreturnedvalue,asintheaboveexample. Theparenthesesaren\u2019talwaysnecessary,butit\u2019seasiertoalwaysaddthem\ninsteadofhavingtorememberwhenthey\u2019reneeded.\n(PEP342explainstheexactrules,whicharethatayield-expressionmustalwaysbeparenthesizedexceptwhenit\noccursatthetop-levelexpressionontheright-handsideofanassignment. Thismeansyoucanwriteval = yield\nibuthavetouseparentheseswhenthere\u2019sanoperation,asinval = (yield i) + 12.)\nValuesaresentintoageneratorbycallingitssend(value)method. Thismethodresumesthegenerator\u2019scodeand\ntheyieldexpressionreturnsthespecifiedvalue. Iftheregular__next__()methodiscalled,theyieldreturns\nNone.\nHere\u2019sasimplecounterthatincrementsby1andallowschangingthevalueoftheinternalcounter.\ndef counter(maximum):\ni = 0\nwhile i < maximum:\nval = (yield i)\n# If value provided, change counter\nif val is not None:\ni = val\nelse:\ni += 1\nAndhere\u2019sanexampleofchangingthecounter:\n>>> it = counter(10)\n>>> next(it)\n0\n>>> next(it)\n1\n>>> it.send(8)\n8\n>>> next(it)\n9\n>>> next(it)\nTraceback (most recent call last):\nFile \"t.py\", line 15, in <module>\nit.next()\nStopIteration\nBecause yield will often be returning None, you should always check for this case. Don\u2019t just use its value in\nexpressions unless you\u2019re sure that the send() method will be the only method used to resume your generator\nfunction.\nInadditiontosend(),therearetwoothermethodsongenerators:\n\u2022 throw(value)isusedtoraiseanexceptioninsidethegenerator; theexceptionisraisedbytheyieldex-\npressionwherethegenerator\u2019sexecutionispaused.\n\u2022 close() raises a GeneratorExit exception inside the generator to terminate the iteration. On receiving\nthis exception, the generator\u2019s code must either raise GeneratorExit or StopIteration; catching the\nexceptionanddoinganythingelseisillegalandwilltriggeraRuntimeError. close()willalsobecalledby\nPython\u2019sgarbagecollectorwhenthegeneratorisgarbage-collected.\nIf you need to run cleanup code when a GeneratorExit occurs, I suggest using a try: ... finally:\nsuiteinsteadofcatchingGeneratorExit.\nThecumulativeeffectofthesechangesistoturngeneratorsfromone-wayproducersofinformationintobothpro-\nducersandconsumers.\n9\nGeneratorsalsobecomecoroutines,amoregeneralizedformofsubroutines. Subroutinesareenteredatonepoint\nandexitedatanotherpoint(thetopofthefunction,andareturnstatement),butcoroutinescanbeentered,exited,\nandresumedatmanydifferentpoints(theyieldstatements).\n5 Built-in functions\nLet\u2019slookinmoredetailatbuilt-infunctionsoftenusedwithiterators.\nTwoofPython\u2019sbuilt-infunctions,map()andfilter()duplicatethefeaturesofgeneratorexpressions:\nmap(f, iterA, iterB, ...)returnsaniteratoroverthesequence\nf(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ....\n>>> def upper(s):\n... return s.upper()\n>>> list(map(upper, ['sentence', 'fragment']))\n['SENTENCE', 'FRAGMENT']\n>>> [upper(s) for s in ['sentence', 'fragment']]\n['SENTENCE', 'FRAGMENT']\nYoucanofcourseachievethesameeffectwithalistcomprehension.\nfilter(predicate, iter)returnsaniteratoroverallthesequenceelementsthatmeetacertaincondition,andis\nsimilarlyduplicatedbylistcomprehensions. Apredicateisafunctionthatreturnsthetruthvalueofsomecondition;\nforusewithfilter(),thepredicatemusttakeasinglevalue.\n>>> def is_even(x):\n... return (x % 2) == 0\n>>> list(filter(is_even, range(10)))\n[0, 2, 4, 6, 8]\nThiscanalsobewrittenasalistcomprehension:\n>>> list(x for x in range(10) if is_even(x))\n[0, 2, 4, 6, 8]\nenumerate(iter, start=0)countsofftheelementsintheiterablereturning2-tuplescontainingthecount(from\nstart)andeachelement.\n>>> for item in enumerate(['subject', 'verb', 'object']):\n... print(item)\n(0, 'subject')\n(1, 'verb')\n(2, 'object')\nenumerate()isoftenusedwhenloopingthroughalistandrecordingtheindexesatwhichcertainconditionsare\nmet:\nf = open('data.txt', 'r')\nfor i, line in enumerate(f):\nif line.strip() == '':\nprint('Blank line at line #%i' % i)\nsorted(iterable, key=None, reverse=False)collectsalltheelementsoftheiterableintoalist,sortsthe\nlist,andreturnsthesortedresult. Thekeyandreverseargumentsarepassedthroughtotheconstructedlist\u2019ssort()\nmethod.\n10\n>>> import random\n>>> # Generate 8 random numbers between [0, 10000)\n>>> rand_list = random.sample(range(10000), 8)\n>>> rand_list\n[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n>>> sorted(rand_list)\n[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n>>> sorted(rand_list, reverse=True)\n[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]\n(Foramoredetaileddiscussionofsorting,seethesortinghowto.)\nTheany(iter)andall(iter)built-inslookatthetruthvaluesofaniterable\u2019scontents. any()returnsTrueif\nanyelementintheiterableisatruevalue,andall()returnsTrueifalloftheelementsaretruevalues:\n>>> any([0, 1, 0])\nTrue\n>>> any([0, 0, 0])\nFalse\n>>> any([1, 1, 1])\nTrue\n>>> all([0, 1, 0])\nFalse\n>>> all([0, 0, 0])\nFalse\n>>> all([1, 1, 1])\nTrue\nzip(iterA, iterB, ...)takesoneelementfromeachiterableandreturnstheminatuple:\nzip(['a', 'b', 'c'], (1, 2, 3)) =>\n('a', 1), ('b', 2), ('c', 3)\nItdoesn\u2019tconstructanin-memorylistandexhaustalltheinputiteratorsbeforereturning;insteadtuplesareconstructed\nandreturnedonlyifthey\u2019rerequested. (Thetechnicaltermforthisbehaviourislazyevaluation.)\nThis iterator is intended to be used with iterables that are all of the same length. If the iterables are of different\nlengths,theresultingstreamwillbethesamelengthastheshortestiterable.\nzip(['a', 'b'], (1, 2, 3)) =>\n('a', 1), ('b', 2)\nYoushouldavoiddoingthis,though,becauseanelementmaybetakenfromthelongeriteratorsanddiscarded. This\nmeansyoucan\u2019tgoontousetheiteratorsfurtherbecauseyouriskskippingadiscardedelement.\n6 The itertools module\nTheitertoolsmodulecontainsanumberofcommonlyusediteratorsaswellasfunctionsforcombiningseveral\niterators. Thissectionwillintroducethemodule\u2019scontentsbyshowingsmallexamples.\nThemodule\u2019sfunctionsfallintoafewbroadclasses:\n\u2022 Functionsthatcreateanewiteratorbasedonanexistingiterator.\n\u2022 Functionsfortreatinganiterator\u2019selementsasfunctionarguments.\n\u2022 Functionsforselectingportionsofaniterator\u2019soutput.\n\u2022 Afunctionforgroupinganiterator\u2019soutput.\n11\n6.1 Creating new iterators\nitertools.count(start, step)returnsaninfinitestreamofevenlyspacedvalues. Youcanoptionallysupply\nthestartingnumber,whichdefaultsto0,andtheintervalbetweennumbers,whichdefaultsto1:\nitertools.count() =>\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\nitertools.count(10) =>\n10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\nitertools.count(10, 5) =>\n10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ...\nitertools.cycle(iter)savesacopyofthecontentsofaprovidediterableandreturnsanewiteratorthatreturns\nitselementsfromfirsttolast. Thenewiteratorwillrepeattheseelementsinfinitely.\nitertools.cycle([1, 2, 3, 4, 5]) =>\n1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\nitertools.repeat(elem, [n])returnstheprovidedelementntimes, orreturnstheelementendlesslyifnis\nnotprovided.\nitertools.repeat('abc') =>\nabc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\nitertools.repeat('abc', 5) =>\nabc, abc, abc, abc, abc\nitertools.chain(iterA, iterB, ...) takes an arbitrary number of iterables as input, and returns all the\nelements of the first iterator, then all the elements of the second, and so on, until all of the iterables have been\nexhausted.\nitertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\na, b, c, 1, 2, 3\nitertools.islice(iter, [start], stop, [step])returnsastreamthat\u2019sasliceoftheiterator. Witha\nsinglestopargument,itwillreturnthefirststopelements. Ifyousupplyastartingindex,you\u2019llgetstop-startelements,\nandifyousupplyavalueforstep,elementswillbeskippedaccordingly. UnlikePython\u2019sstringandlistslicing,you\ncan\u2019tusenegativevaluesforstart,stop,orstep.\nitertools.islice(range(10), 8) =>\n0, 1, 2, 3, 4, 5, 6, 7\nitertools.islice(range(10), 2, 8) =>\n2, 3, 4, 5, 6, 7\nitertools.islice(range(10), 2, 8, 2) =>\n2, 4, 6\nitertools.tee(iter, [n])replicatesaniterator;itreturnsnindependentiteratorsthatwillallreturnthecon-\ntentsofthesourceiterator. Ifyoudon\u2019tsupplyavalueforn,thedefaultis2. Replicatingiteratorsrequiressaving\nsomeofthecontentsofthesourceiterator,sothiscanconsumesignificantmemoryiftheiteratorislargeandone\nofthenewiteratorsisconsumedmorethantheothers.\nitertools.tee( itertools.count() ) =>\niterA, iterB\nwhere iterA ->\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\nand iterB ->\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n12\n6.2 Calling functions on elements\nThe operator module contains a set of functions corresponding to Python\u2019s operators. Some examples\nare operator.add(a, b) (adds two values), operator.ne(a, b) (same as a != b), and operator.\nattrgetter('id')(returnsacallablethatfetchesthe.idattribute).\nitertools.starmap(func, iter)assumesthattheiterablewillreturnastreamoftuples,andcallsfuncusing\nthesetuplesasthearguments:\nitertools.starmap(os.path.join,\n[('/bin', 'python'), ('/usr', 'bin', 'java'),\n('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n=>\n/bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby\n6.3 Selecting elements\nAnothergroupoffunctionschoosesasubsetofaniterator\u2019selementsbasedonapredicate.\nitertools.filterfalse(predicate, iter)istheoppositeoffilter(),returningallelementsforwhich\nthepredicatereturnsfalse:\nitertools.filterfalse(is_even, itertools.count()) =>\n1, 3, 5, 7, 9, 11, 13, 15, ...\nitertools.takewhile(predicate, iter)returnselementsforaslongasthepredicatereturnstrue. Oncethe\npredicatereturnsfalse,theiteratorwillsignaltheendofitsresults.\ndef less_than_10(x):\nreturn x < 10\nitertools.takewhile(less_than_10, itertools.count()) =>\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nitertools.takewhile(is_even, itertools.count()) =>\n0\nitertools.dropwhile(predicate, iter)discardselementswhilethepredicatereturnstrue,andthenreturns\ntherestoftheiterable\u2019sresults.\nitertools.dropwhile(less_than_10, itertools.count()) =>\n10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\nitertools.dropwhile(is_even, itertools.count()) =>\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...\nitertools.compress(data, selectors)takestwoiteratorsandreturnsonlythoseelementsofdataforwhich\nthecorrespondingelementofselectorsistrue,stoppingwhenevereitheroneisexhausted:\nitertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n1, 2, 5\n6.4 Combinatoric functions\nThe itertools.combinations(iterable, r) returns an iterator giving all possible r-tuple combinations of\ntheelementscontainediniterable.\nitertools.combinations([1, 2, 3, 4, 5], 2) =>\n(1, 2), (1, 3), (1, 4), (1, 5),\n(continuesonnextpage)\n13\n(continuedfrompreviouspage)\n(2, 3), (2, 4), (2, 5),\n(3, 4), (3, 5),\n(4, 5)\nitertools.combinations([1, 2, 3, 4, 5], 3) =>\n(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n(2, 3, 4), (2, 3, 5), (2, 4, 5),\n(3, 4, 5)\nTheelementswithineachtupleremaininthesameorderasiterablereturnedthem. Forexample, thenumber1is\nalwaysbefore2, 3, 4, or5intheexamplesabove. Asimilarfunction, itertools.permutations(iterable,\nr=None),removesthisconstraintontheorder,returningallpossiblearrangementsoflengthr:\nitertools.permutations([1, 2, 3, 4, 5], 2) =>\n(1, 2), (1, 3), (1, 4), (1, 5),\n(2, 1), (2, 3), (2, 4), (2, 5),\n(3, 1), (3, 2), (3, 4), (3, 5),\n(4, 1), (4, 2), (4, 3), (4, 5),\n(5, 1), (5, 2), (5, 3), (5, 4)\nitertools.permutations([1, 2, 3, 4, 5]) =>\n(1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n...\n(5, 4, 3, 2, 1)\nIfyoudon\u2019tsupplyavalueforrthelengthoftheiterableisused,meaningthatalltheelementsarepermuted.\nNotethatthesefunctionsproduceallofthepossiblecombinationsbypositionanddon\u2019trequirethatthecontentsof\niterableareunique:\nitertools.permutations('aba', 3) =>\n('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')\nTheidenticaltuple('a', 'a', 'b')occurstwice,butthetwo\u2018a\u2019stringscamefromdifferentpositions.\nThe itertools.combinations_with_replacement(iterable, r) function relaxes a different constraint:\nelementscanberepeatedwithinasingletuple. Conceptuallyanelementisselectedforthefirstpositionofeachtuple\nandthenisreplacedbeforethesecondelementisselected.\nitertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n(1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n(2, 2), (2, 3), (2, 4), (2, 5),\n(3, 3), (3, 4), (3, 5),\n(4, 4), (4, 5),\n(5, 5)\n6.5 Grouping elements\nThe last function I\u2019ll discuss, itertools.groupby(iter, key_func=None), is the most complicated.\nkey_func(elem) is a function that can compute a key value for each element returned by the iterable. If you\ndon\u2019tsupplyakeyfunction,thekeyissimplyeachelementitself.\ngroupby() collects all the consecutive elements from the underlying iterable that have the same key value, and\nreturnsastreamof2-tuplescontainingakeyvalueandaniteratorfortheelementswiththatkey.\ncity_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n('Anchorage', 'AK'), ('Nome', 'AK'),\n(continuesonnextpage)\n14\n(continuedfrompreviouspage)\n('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n...\n]\ndef get_state(city_state):\nreturn city_state[1]\nitertools.groupby(city_list, get_state) =>\n('AL', iterator-1),\n('AK', iterator-2),\n('AZ', iterator-3), ...\nwhere\niterator-1 =>\n('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\niterator-2 =>\n('Anchorage', 'AK'), ('Nome', 'AK')\niterator-3 =>\n('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')\ngroupby()assumesthattheunderlyingiterable\u2019scontentswillalreadybesortedbasedonthekey. Notethatthe\nreturnediteratorsalsousetheunderlyingiterable,soyouhavetoconsumetheresultsofiterator-1beforerequesting\niterator-2anditscorrespondingkey.\n7 The functools module\nThefunctoolsmodulecontainssomehigher-orderfunctions. Ahigher-orderfunctiontakesoneormorefunc-\ntions as input and returns a new function. The most useful tool in this module is the functools.partial()\nfunction.\nForprogramswritteninafunctionalstyle,you\u2019llsometimeswanttoconstructvariantsofexistingfunctionsthathave\nsomeoftheparametersfilledin. ConsideraPythonfunctionf(a, b, c);youmaywishtocreateanewfunction\ng(b, c) that\u2019s equivalent to f(1, b, c); you\u2019re filling in a value for one of f()\u2019s parameters. This is called\n\u201cpartialfunctionapplication\u201d.\nThe constructor for partial() takes the arguments (function, arg1, arg2, ..., kwarg1=value1,\nkwarg2=value2). The resulting object is callable, so you can just call it to invoke function with the filled-in\narguments.\nHere\u2019sasmallbutrealisticexample:\nimport functools\ndef log(message, subsystem):\n\"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\nprint('%s: %s' % (subsystem, message))\n...\nserver_log = functools.partial(log, subsystem='server')\nserver_log('Unable to open socket')\nfunctools.reduce(func, iter, [initial_value]) cumulatively performs an operation on all the iter-\nable\u2019selementsand,therefore,can\u2019tbeappliedtoinfiniteiterables. funcmustbeafunctionthattakestwoelements\nand returns a single value. functools.reduce() takes the first two elements A and B returned by the iterator\nandcalculatesfunc(A, B).Itthenrequeststhethirdelement, C,calculatesfunc(func(A, B), C),combines\nthis result with the fourth element returned, and continues until the iterable is exhausted. If the iterable returns\nno values at all, a TypeError exception is raised. If the initial value is supplied, it\u2019s used as a starting point and\nfunc(initial_value, A)isthefirstcalculation.\n15\n>>> import operator, functools\n>>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n'ABBC'\n>>> functools.reduce(operator.concat, [])\nTraceback (most recent call last):\n...\nTypeError: reduce() of empty sequence with no initial value\n>>> functools.reduce(operator.mul, [1, 2, 3], 1)\n6\n>>> functools.reduce(operator.mul, [], 1)\n1\nIfyouuseoperator.add()withfunctools.reduce(),you\u2019lladdupalltheelementsoftheiterable. Thiscase\nissocommonthatthere\u2019saspecialbuilt-incalledsum()tocomputeit:\n>>> import functools, operator\n>>> functools.reduce(operator.add, [1, 2, 3, 4], 0)\n10\n>>> sum([1, 2, 3, 4])\n10\n>>> sum([])\n0\nFormanyusesoffunctools.reduce(),though,itcanbeclearertojustwritetheobviousforloop:\nimport functools\n# Instead of:\nproduct = functools.reduce(operator.mul, [1, 2, 3], 1)\n# You can write:\nproduct = 1\nfor i in [1, 2, 3]:\nproduct *= i\nArelatedfunctionisitertools.accumulate(iterable, func=operator.add). Itperformsthesamecal-\nculation,butinsteadofreturningonlythefinalresult,accumulate()returnsaniteratorthatalsoyieldseachpartial\nresult:\nitertools.accumulate([1, 2, 3, 4, 5]) =>\n1, 3, 6, 10, 15\nitertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n1, 2, 6, 24, 120\n7.1 The operator module\nThe operator module was mentioned earlier. It contains a set of functions corresponding to Python\u2019s operators.\nThese functions are often useful in functional-style code because they save you from writing trivial functions that\nperformasingleoperation.\nSomeofthefunctionsinthismoduleare:\n\u2022 Mathoperations: add(),sub(),mul(),floordiv(),abs(),\u2026\n\u2022 Logicaloperations: not_(),truth().\n\u2022 Bitwiseoperations: and_(),or_(),invert().\n\u2022 Comparisons: eq(),ne(),lt(),le(),gt(),andge().\n\u2022 Objectidentity: is_(),is_not().\n16\nConsulttheoperatormodule\u2019sdocumentationforacompletelist.\n8 Small functions and the lambda expression\nWhen writing functional-style programs, you\u2019ll often need little functions that act as predicates or that combine\nelementsinsomeway.\nIfthere\u2019saPythonbuilt-inoramodulefunctionthat\u2019ssuitable,youdon\u2019tneedtodefineanewfunctionatall:\nstripped_lines = [line.strip() for line in lines]\nexisting_files = filter(os.path.exists, file_list)\nIfthefunctionyouneeddoesn\u2019texist,youneedtowriteit. Onewaytowritesmallfunctionsistousethelambda\nexpression. lambda takes a number ofparameters andan expressioncombining theseparameters, and createsan\nanonymousfunctionthatreturnsthevalueoftheexpression:\nadder = lambda x, y: x+y\nprint_assign = lambda name, value: name + '=' + str(value)\nAnalternativeistojustusethedefstatementanddefineafunctionintheusualway:\ndef adder(x, y):\nreturn x + y\ndef print_assign(name, value):\nreturn name + '=' + str(value)\nWhichalternativeispreferable? That\u2019sastylequestion;myusualcourseistoavoidusinglambda.\nOne reason for my preference is that lambda is quite limited in the functions it can define. The result has to be\ncomputableasasingleexpression, whichmeansyoucan\u2019thavemultiwayif... elif... elsecomparisonsor\ntry... exceptstatements. Ifyoutrytodotoomuchinalambdastatement,you\u2019llendupwithanoverlycom-\nplicatedexpressionthat\u2019shardtoread. Quick,what\u2019sthefollowingcodedoing?\nimport functools\ntotal = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]\nYoucanfigureitout,butittakestimetodisentangletheexpressiontofigureoutwhat\u2019sgoingon. Usingashortnested\ndefstatementsmakesthingsalittlebitbetter:\nimport functools\ndef combine(a, b):\nreturn 0, a[1] + b[1]\ntotal = functools.reduce(combine, items)[1]\nButitwouldbebestofallifIhadsimplyusedaforloop:\ntotal = 0\nfor a, b in items:\ntotal += b\nOrthesum()built-inandageneratorexpression:\ntotal = sum(b for a, b in items)\nManyusesoffunctools.reduce()areclearerwhenwrittenasforloops.\nFredrikLundhoncesuggestedthefollowingsetofrulesforrefactoringusesoflambda:\n17\n1. Writealambdafunction.\n2. Writeacommentexplainingwhattheheckthatlambdadoes.\n3. Studythecommentforawhile,andthinkofanamethatcapturestheessenceofthecomment.\n4. Convertthelambdatoadefstatement,usingthatname.\n5. Removethecomment.\nIreallyliketheserules,butyou\u2019refreetodisagreeaboutwhetherthislambda-freestyleisbetter.\n9 Revision History and Acknowledgements\nTheauthorwouldliketothankthefollowingpeopleforofferingsuggestions,correctionsandassistancewithvarious\ndraftsofthisarticle: IanBicking,NickCoghlan,NickEfford,RaymondHettinger,JimJewett,MikeKrell,Leandro\nLameiro,JussiSalmela,CollinWinter,BlakeWinton.\nVersion0.1: postedJune302006.\nVersion0.11: postedJuly12006. Typofixes.\nVersion0.2: postedJuly102006. Mergedgenexpandlistcompsectionsintoone. Typofixes.\nVersion0.21: Addedmorereferencessuggestedonthetutormailinglist.\nVersion0.30:AddsasectiononthefunctionalmodulewrittenbyCollinWinter;addsshortsectionontheoperator\nmodule;afewotheredits.\n10 References\n10.1 General\nStructure and Interpretation of Computer Programs, by Harold Abelson and Gerald Jay Sussman with Julie\nSussman. The book can be found at https://mitpress.mit.edu/sicp. In this classic textbook of computer science,\nchapters2and3discusstheuseofsequencesandstreamstoorganizethedataflowinsideaprogram. Thebookuses\nSchemeforitsexamples,butmanyofthedesignapproachesdescribedinthesechaptersareapplicabletofunctional-\nstylePythoncode.\nhttps://www.defmacro.org/ramblings/fp.html: AgeneralintroductiontofunctionalprogrammingthatusesJavaex-\namplesandhasalengthyhistoricalintroduction.\nhttps://en.wikipedia.org/wiki/Functional_programming: General Wikipedia entry describing functional program-\nming.\nhttps://en.wikipedia.org/wiki/Coroutine: Entryforcoroutines.\nhttps://en.wikipedia.org/wiki/Partial_application: Entryfortheconceptofpartialfunctionapplication.\nhttps://en.wikipedia.org/wiki/Currying: Entryfortheconceptofcurrying.\n10.2 Python-specific\nhttps://gnosis.cx/TPiP/: ThefirstchapterofDavidMertz\u2019sbookTextProcessinginPythondiscussesfunctionalpro-\ngrammingfortextprocessing,inthesectiontitled\u201cUtilizingHigher-OrderFunctionsinTextProcessing\u201d.\nMertzalsowrotea3-partseriesofarticlesonfunctionalprogrammingforIBM\u2019sDeveloperWorkssite; seepart1,\npart2,andpart3,\n10.3 Python documentation\nDocumentationfortheitertoolsmodule.\nDocumentationforthefunctoolsmodule.\nDocumentationfortheoperatormodule.\n18\nPEP289: \u201cGeneratorExpressions\u201d\nPEP342: \u201cCoroutinesviaEnhancedGenerators\u201ddescribesthenewgeneratorfeaturesinPython2.5.\n19\nIndex\nP\nPython Enhancement Proposals\nPEP 289,19\nPEP 342,9,19\n20\n",
  "context": "",
  "source_file": "resources\\Year 3\\Python\\howto-functional.pdf",
  "line_numbers": [
    1,
    819
  ]
}
{
  "title": "howto-annotations",
  "language": "python",
  "topics": [
    "database",
    "data_structures",
    "web_dev"
  ],
  "purpose": "you\u2019relookingforinformationonhowtouse\u201ctypehints\u201dinyourcode,pleaseseethetypingmodule.",
  "code": "Python3.10addsanewfunctiontothestandardlibrary: inspect.get_annotations(). InPythonversions3.10\nand newer, calling this function is the best practice for accessing the annotations dict of any object that supports\nannotations. Thisfunctioncanalso\u201cun-stringize\u201dstringizedannotationsforyou.\n1\nIf for some reason inspect.get_annotations() isn\u2019t viable for your use case, you may access the\n__annotations__ data member manually. Best practice for this changed in Python 3.10 as well: as of Python\n3.10, o.__annotations__ is guaranteed to always work on Python functions, classes, and modules. If you\u2019re\ncertaintheobjectyou\u2019reexaminingisoneofthesethreespecificobjects,youmaysimplyuseo.__annotations__\ntogetattheobject\u2019sannotationsdict.\nHowever, other types of callables\u2013for example, callables created by functools.partial()\u2013may not have an\n__annotations__attributedefined. Whenaccessingthe__annotations__ofapossiblyunknownobject,best\npracticeinPythonversions3.10andneweristocallgetattr()withthreearguments,forexamplegetattr(o,\n'__annotations__', None).\nBeforePython3.10,accessing__annotations__onaclassthatdefinesnoannotationsbutthathasaparentclass\nwithannotationswouldreturntheparent\u2019s__annotations__. InPython3.10andnewer,thechildclass\u2019sannota-\ntionswillbeanemptydictinstead.\n2 Accessing The Annotations Dict Of An Object In Python 3.9 And\nOlder\nInPython3.9andolder,accessingtheannotationsdictofanobjectismuchmorecomplicatedthaninnewerversions.\nTheproblemisadesignflawintheseolderversionsofPython,specificallytodowithclassannotations.\nBestpracticeforaccessingtheannotationsdictofotherobjects\u2013functions,othercallables,andmodules\u2013isthesameas\nbestpracticefor3.10,assumingyouaren\u2019tcallinginspect.get_annotations(): youshouldusethree-argument\ngetattr()toaccesstheobject\u2019s__annotations__attribute.\nUnfortunately,thisisn\u2019tbestpracticeforclasses. Theproblemisthat,since__annotations__isoptionalonclasses,\nandbecauseclassescaninheritattributesfromtheirbaseclasses, accessingthe__annotations__ attributeofa\nclassmayinadvertentlyreturntheannotationsdictofabaseclass. Asanexample:\nclass Base:\na: int = 3\nb: str = 'abc'\nclass Derived(Base):\npass\nprint(Derived.__annotations__)\nThiswillprinttheannotationsdictfromBase,notDerived.\nYourcodewillhavetohaveaseparatecodepathiftheobjectyou\u2019reexaminingisaclass(isinstance(o, type)).\nIn that case, best practice relies on an implementation detail of Python 3.9 and before: if a class has annotations\ndefined,theyarestoredintheclass\u2019s__dict__dictionary. Sincetheclassmayormaynothaveannotationsdefined,\nbestpracticeistocalltheget()methodontheclassdict.\nToputitalltogether,hereissomesamplecodethatsafelyaccessesthe__annotations__attributeonanarbitrary\nobjectinPython3.9andbefore:\nif isinstance(o, type):\nann = o.__dict__.get('__annotations__', None)\nelse:\nann = getattr(o, '__annotations__', None)\nAfterrunningthiscode,annshouldbeeitheradictionaryorNone. You\u2019reencouragedtodouble-checkthetypeof\nannusingisinstance()beforefurtherexamination.\nNotethatsomeexoticormalformedtypeobjectsmaynothavea__dict__attribute,soforextrasafetyyoumay\nalsowishtousegetattr()toaccess__dict__.\n2\n3 Manually Un-Stringizing Stringized Annotations\nIn situations where some annotations may be \u201cstringized\u201d, and you wish to evaluate those strings to produce the\nPythonvaluestheyrepresent,itreallyisbesttocallinspect.get_annotations()todothisworkforyou.\nIfyou\u2019reusingPython3.9orolder,orifforsomereasonyoucan\u2019tuseinspect.get_annotations(),you\u2019llneed\ntoduplicateitslogic. You\u2019reencouragedtoexaminetheimplementationofinspect.get_annotations()inthe\ncurrentPythonversionandfollowasimilarapproach.\nInanutshell,ifyouwishtoevaluateastringizedannotationonanarbitraryobjecto:\n\u2022 Ifoisamodule,useo.__dict__astheglobalswhencallingeval().\n\u2022 Ifoisaclass,usesys.modules[o.__module__].__dict__astheglobals,anddict(vars(o))as\nthelocals,whencallingeval().\n\u2022 Ifoisawrappedcallableusingfunctools.update_wrapper(),functools.wraps(),orfunctools.\npartial(),iterativelyunwrapitbyaccessingeithero.__wrapped__oro.funcasappropriate,untilyou\nhavefoundtherootunwrappedfunction.\n\u2022 Ifoisacallable(butnotaclass),useo.__globals__astheglobalswhencallingeval().\nHowever,notallstringvaluesusedasannotationscanbesuccessfullyturnedintoPythonvaluesbyeval(). String\nvaluescouldtheoreticallycontainanyvalidstring,andinpracticetherearevalidusecasesfortypehintsthatrequire\nannotatingwithstringvaluesthatspecificallycan\u2019tbeevaluated. Forexample:\n\u2022 PEP604uniontypesusing|,beforesupportforthiswasaddedtoPython3.10.\n\u2022 Definitionsthataren\u2019tneededatruntime,onlyimportedwhentyping.TYPE_CHECKINGistrue.\nIfeval()attemptstoevaluatesuchvalues,itwillfailandraiseanexception. So,whendesigningalibraryAPIthat\nworkswithannotations,it\u2019srecommendedtoonlyattempttoevaluatestringvalueswhenexplicitlyrequestedtoby\nthecaller.\n4 Best Practices For __annotations__ In Any Python Version\n\u2022 Youshouldavoidassigningtothe__annotations__memberofobjectsdirectly. LetPythonmanagesetting\n__annotations__.\n\u2022 Ifyoudoassigndirectlytothe__annotations__memberofanobject,youshouldalwayssetittoadict\nobject.\n\u2022 Ifyoudirectlyaccessthe__annotations__memberofanobject, youshouldensurethatit\u2019sadictionary\nbeforeattemptingtoexamineitscontents.\n\u2022 Youshouldavoidmodifying__annotations__dicts.\n\u2022 Youshouldavoiddeletingthe__annotations__attributeofanobject.\n5 __annotations__ Quirks\nInallversionsofPython3,functionobjectslazy-createanannotationsdictifnoannotationsaredefinedonthatobject.\nYou can delete the __annotations__ attribute using del fn.__annotations__, but if you then access fn.\n__annotations__theobjectwillcreateanewemptydictthatitwillstoreandreturnasitsannotations. Deleting\ntheannotationsonafunctionbeforeithaslazilycreateditsannotationsdictwillthrowanAttributeError;using\ndel fn.__annotations__twiceinarowisguaranteedtoalwaysthrowanAttributeError.\nEverythingintheaboveparagraphalsoappliestoclassandmoduleobjectsinPython3.10andnewer.\nInallversionsofPython3,youcanset__annotations__onafunctionobjecttoNone. However,subsequently\naccessingtheannotationsonthatobjectusingfn.__annotations__willlazy-createanemptydictionaryasper\nthefirstparagraphofthissection. Thisisnottrueofmodulesandclasses,inanyPythonversion;thoseobjectspermit\nsetting__annotations__toanyPythonvalue,andwillretainwhatevervalueisset.\n3\nIfPythonstringizesyourannotationsforyou(usingfrom __future__ import annotations),andyouspecify\nastringasanannotation,thestringwillitselfbequoted. Ineffecttheannotationisquotedtwice. Forexample:\nfrom __future__ import annotations\ndef foo(a: \"str\"): pass\nprint(foo.__annotations__)\nThisprints{'a': \"'str'\"}. Thisshouldn\u2019treallybeconsidereda\u201cquirk\u201d;it\u2019smentionedheresimplybecauseit\nmightbesurprising.\n4\nIndex\nP\nPython Enhancement Proposals\nPEP 604,3\n5\n",
  "context": "you\u2019relookingforinformationonhowtouse\u201ctypehints\u201dinyourcode,pleaseseethetypingmodule.\n1 Accessing The Annotations Dict Of An Object In Python 3.10 And\nNewer",
  "source_file": "resources\\Year 3\\Python\\howto-annotations.pdf",
  "line_numbers": [
    27,
    131
  ]
}
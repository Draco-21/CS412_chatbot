{
  "title": "howto-perf_profiling",
  "language": "cpp",
  "topics": [
    "web_dev",
    "fundamentals",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "of your application.",
  "code": "nativesymbols,thatis,thenamesoffunctionsandprocedureswritteninC.Thismeansthatthenamesandfilenames\nofPythonfunctionsinyourcodewillnotappearintheoutputofperf.\nSincePython3.12,theinterpretercanruninaspecialmodethatallowsPythonfunctionstoappearintheoutputof\ntheperfprofiler. Whenthismodeisenabled,theinterpreterwillinterposeasmallpieceofcodecompiledonthe\nflybeforetheexecutionofeveryPythonfunctionanditwillteachperftherelationshipbetweenthispieceofcode\nandtheassociatedPythonfunctionusingperfmapfiles.\n(cid:174) Note\nSupportfortheperfprofileriscurrentlyonlyavailableforLinuxonselectarchitectures. Checktheoutputofthe\nconfigurebuildsteporchecktheoutputofpython -m sysconfig | grep HAVE_PERF_TRAMPOLINE\ntoseeifyoursystemissupported.\nForexample,considerthefollowingscript:\ndef foo(n):\nresult = 0\n(continuesonnextpage)\n1\n(continuedfrompreviouspage)\nfor _ in range(n):\nresult += 1\nreturn result\ndef bar(n):\nfoo(n)\ndef baz(n):\nbar(n)\nif __name__ == \"__main__\":\nbaz(1000000)\nWecanrunperftosampleCPUstacktracesat9999hertz:\n$ perf record -F 9999 -g -o perf.data python my_script.py\nThenwecanuseperf reporttoanalyzethedata:\n$ perf report --stdio -n -g\n# Children Self Samples Command Shared Object Symbol\n# ........ ........ ............ .......... .................. ...............\n,\u2192...........................\n#\n91.08% 0.00% 0 python.exe python.exe [.] _start\n|\n---_start\n|\n--90.71%--__libc_start_main\nPy_BytesMain\n|\n|--56.88%--pymain_run_python.constprop.0\n| |\n| |--56.13%--_PyRun_AnyFileObject\n| | _PyRun_SimpleFileObject\n| | |\n| | |--55.02%--run_mod\n| | | |\n| | | --54.65%--PyEval_EvalCode\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | |\n| | | |--51.67%--_\n(continuesonnextpage)\n2\n(continuedfrompreviouspage)\n,\u2192PyEval_EvalFrameDefault\n| | | | |\n| | | | |--\n,\u219211.52%--_PyLong_Add\n| | | | | \u2423\n,\u2192 |\n| | | | | \u2423\n,\u2192 |--2.97%--_PyObject_Malloc\n...\nAsyoucansee,thePythonfunctionsarenotshownintheoutput,only_PyEval_EvalFrameDefault(thefunction\nthatevaluatesthePythonbytecode)showsup. Unfortunatelythat\u2019snotveryusefulbecauseallPythonfunctionsuse\nthesameCfunctiontoevaluatebytecodesowecannotknowwhichPythonfunctioncorrespondstowhichbytecode-\nevaluatingfunction.\nInstead,ifwerunthesameexperimentwithperfsupportenabledweget:\n$ perf report --stdio -n -g\n# Children Self Samples Command Shared Object Symbol\n# ........ ........ ............ .......... .................. ...............\n,\u2192......................................................\n#\n90.58% 0.36% 1 python.exe python.exe [.] _start\n|\n---_start\n|\n--89.86%--__libc_start_main\nPy_BytesMain\n|\n|--55.43%--pymain_run_python.constprop.0\n| |\n| |--54.71%--_PyRun_AnyFileObject\n| | _PyRun_SimpleFileObject\n| | |\n| | |--53.62%--run_mod\n| | | |\n| | | --53.26%--PyEval_EvalCode\n| | | py::<module>:/\n,\u2192src/script.py\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | py::baz:/src/\n,\u2192script.py\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | py::bar:/src/\n,\u2192script.py\n| | | _PyEval_\n,\u2192EvalFrameDefault\n| | | PyObject_\n(continuesonnextpage)\n3\n(continuedfrompreviouspage)\n,\u2192Vectorcall\n| | | _PyEval_Vector\n| | | py::foo:/src/\n,\u2192script.py\n| | | |\n| | | |--51.81%--_\n,\u2192PyEval_EvalFrameDefault\n| | | | |\n| | | | |--\n,\u219213.77%--_PyLong_Add\n| | | | | \u2423\n,\u2192 |\n| | | | | \u2423\n,\u2192 |--3.26%--_PyObject_Malloc\n1 How to enable perf profiling support\nperfprofilingsupportcanbeenabledeitherfromthestartusingtheenvironmentvariablePYTHONPERFSUPPORT\nor the -X perf option, or dynamically using sys.activate_stack_trampoline() and sys.\ndeactivate_stack_trampoline().\nThesysfunctionstakeprecedenceoverthe-Xoption,the-Xoptiontakesprecedenceovertheenvironmentvariable.\nExample,usingtheenvironmentvariable:\n$ PYTHONPERFSUPPORT=1 perf record -F 9999 -g -o perf.data python my_script.py\n$ perf report -g -i perf.data\nExample,usingthe-Xoption:\n$ perf record -F 9999 -g -o perf.data python -X perf my_script.py\n$ perf report -g -i perf.data\nExample,usingthesysAPIsinfileexample.py:\nimport sys\nsys.activate_stack_trampoline(\"perf\")\ndo_profiled_stuff()\nsys.deactivate_stack_trampoline()\nnon_profiled_stuff()\n\u2026then:\n$ perf record -F 9999 -g -o perf.data python ./example.py\n$ perf report -g -i perf.data\n2 How to obtain the best results\nFor best results, Python should be compiled with CFLAGS=\"-fno-omit-frame-pointer\n-mno-omit-leaf-frame-pointer\" as this allows profilers to unwind using only the frame pointer and\nnot on DWARF debug information. This is because as the code that is interposed to allow perf support is\ndynamicallygenerateditdoesn\u2019thaveanyDWARFdebugginginformationavailable.\nYoucancheckifyoursystemhasbeencompiledwiththisflagbyrunning:\n4\n$ python -m sysconfig | grep 'no-omit-frame-pointer'\nIfyoudon\u2019tseeanyoutputitmeansthatyourinterpreterhasnotbeencompiledwithframepointersandthereforeit\nmaynotbeabletoshowPythonfunctionsintheoutputofperf.\n3 How to work without frame pointers\nIf you are working with a Python interpreter that has been compiled without frame pointers, you can still use the\nperf profiler, but the overhead will be a bit higher because Python needs to generate unwinding information for\neveryPythonfunctioncallonthefly. Additionally,perfwilltakemoretimetoprocessthedatabecauseitwillneed\ntousetheDWARFdebugginginformationtounwindthestackandthisisaslowprocess.\nTo enable this mode, you can use the environment variable PYTHON_PERF_JIT_SUPPORT or the -X perf_jit\noption,whichwillenabletheJITmodefortheperfprofiler.\n(cid:174) Note\nDuetoabugintheperftool,onlyperfversionshigherthanv6.8willworkwiththeJITmode. Thefixwas\nalsobackportedtothev6.7.2versionofthetool.\nNotethatwhencheckingtheversionoftheperftool(whichcanbedonebyrunningperf version)youmust\ntakeintoaccountthatsomedistrosaddsomecustomversionnumbersincludinga-character. Thismeansthat\nperf 6.7-3isnotnecessarilyperf 6.7.3.\nWhenusingtheperfJITmode,youneedanextrastepbeforeyoucanrunperf report. Youneedtocalltheperf\ninjectcommandtoinjecttheJITinformationintotheperf.datafile.:\n$ perf record -F 9999 -g -k 1 --call-graph dwarf -o perf.data python -Xperf_jit my_\n,\u2192script.py\n$ perf inject -i perf.data --jit --output perf.jit.data\n$ perf report -g -i perf.jit.data\norusingtheenvironmentvariable:\n$ PYTHON_PERF_JIT_SUPPORT=1 perf record -F 9999 -g --call-graph dwarf -o perf.data\u2423\n,\u2192python my_script.py\n$ perf inject -i perf.data --jit --output perf.jit.data\n$ perf report -g -i perf.jit.data\nperf inject --jitcommandwillreadperf.data,automaticallypickuptheperfdumpfilethatPythoncreates\n(in/tmp/perf-$PID.dump),andthencreateperf.jit.datawhichmergesalltheJITinformationtogether. It\nshouldalsocreatealotofjitted-XXXX-N.sofilesinthecurrentdirectorywhichareELFimagesforalltheJIT\ntrampolinesthatwerecreatedbyPython.\n(cid:193) Warning\nWhenusing--call-graph dwarf,theperftoolwilltakesnapshotsofthestackoftheprocessbeingprofiled\nandsavetheinformationintheperf.datafile. Bydefault,thesizeofthestackdumpis8192bytes,butyou\ncanchangethesizebypassingitafteracommalike--call-graph dwarf,16384.\nThesizeofthestackdumpisimportantbecauseifthesizeistoosmallperfwillnotbeabletounwindthestack\nandtheoutputwillbeincomplete. Ontheotherhand,ifthesizeistoobig,thenperfwon\u2019tbeabletosample\ntheprocessasfrequentlyasitwouldlikeastheoverheadwillbehigher.\nThestacksizeisparticularlyimportantwhenprofilingPythoncodecompiledwithlowoptimizationlevels(like\n-O0), as these builds tend to have larger stack frames. If you are compiling Python with -O0 and not seeing\nPythonfunctionsinyourprofilingoutput,tryincreasingthestackdumpsizeto65528bytes(themaximum):\n5\n$ perf record -F 9999 -g -k 1 --call-graph dwarf,65528 -o perf.data python -\n,\u2192Xperf_jit my_script.py\nDifferentcompilationflagscansignificantlyimpactstacksizes:\n\u2022 Buildswith-O0typicallyhavemuchlargerstackframesthanthosewith-O1orhigher\n\u2022 Addingoptimizations(-O1,-O2,etc.) typicallyreducesstacksize\n\u2022 Framepointers(-fno-omit-frame-pointer)generallyprovidemorereliablestackunwinding\n6\nIndex\nE\nenvironment variable\nPYTHON_PERF_JIT_SUPPORT,5\nPYTHONPERFSUPPORT,4\nP\nPYTHON_PERF_JIT_SUPPORT,5\nPYTHONPERFSUPPORT,4\n7\n",
  "context": "of your application. perf also has a very vibrant ecosystem of tools that aid with the analysis of the data that it\nproduces.\nThemainproblemwithusingtheperfprofilerwithPythonapplicationsisthatperfonlygetsinformationabout",
  "source_file": "resources\\Year 3\\Python\\howto-perf_profiling.pdf",
  "line_numbers": [
    19,
    242
  ]
}
{
  "title": "howto-sockets",
  "language": "cpp",
  "topics": [
    "web_dev",
    "fundamentals",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "dependingoncontext.",
  "code": "\u201cclient\u201dsocketsexclusively;thewebserverit\u2019stalkingtousesboth\u201cserver\u201dsocketsand\u201cclient\u201dsockets.\n1.1 History\nOf the various forms of IPC (Inter Process Communication), sockets are by far the most popular. On any given\nplatform,therearelikelytobeotherformsofIPCthatarefaster,butforcross-platformcommunication,socketsare\nabouttheonlygameintown.\nThey were invented in Berkeley as part of the BSD flavor of Unix. They spread like wildfire with the internet.\nWithgoodreason\u2014thecombinationofsocketswithINETmakestalkingtoarbitrarymachinesaroundtheworld\nunbelievablyeasy(atleastcomparedtootherschemes).\n2 Creating a Socket\nRoughlyspeaking,whenyouclickedonthelinkthatbroughtyoutothispage,yourbrowserdidsomethinglikethe\nfollowing:\n# create an INET, STREAMing socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# now connect to the web server on port 80 - the normal http port\ns.connect((\"www.python.org\", 80))\nWhen the connect completes, the socket s can be used to send in a request for the text of the page. The same\nsocketwillreadthereply,andthenbedestroyed. That\u2019sright,destroyed. Clientsocketsarenormallyonlyusedfor\noneexchange(orasmallsetofsequentialexchanges).\nWhathappensinthewebserverisabitmorecomplex. First,thewebservercreatesa\u201cserversocket\u201d:\n# create an INET, STREAMing socket\nserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# bind the socket to a public host, and a well-known port\nserversocket.bind((socket.gethostname(), 80))\n# become a server socket\nserversocket.listen(5)\nA couple things to notice: we used socket.gethostname() so that the socket would be visible to the outside\nworld. Ifwehaduseds.bind(('localhost', 80))ors.bind(('127.0.0.1', 80))wewouldstillhave\na \u201cserver\u201d socket, but one that was only visible within the same machine. s.bind(('', 80)) specifies that the\nsocketisreachablebyanyaddressthemachinehappenstohave.\nA second thing to note: low number ports are usually reserved for \u201cwell known\u201d services (HTTP, SNMP etc). If\nyou\u2019replayingaround,useanicehighnumber(4digits).\nFinally,theargumenttolistentellsthesocketlibrarythatwewantittoqueueupasmanyas5connectrequests(the\nnormalmax)beforerefusingoutsideconnections. Iftherestofthecodeiswrittenproperly,thatshouldbeplenty.\nNowthatwehavea\u201cserver\u201dsocket,listeningonport80,wecanenterthemainloopofthewebserver:\nwhile True:\n# accept connections from outside\n(clientsocket, address) = serversocket.accept()\n# now do something with the clientsocket\n# in this case, we'll pretend this is a threaded server\nct = client_thread(clientsocket)\nct.run()\nThere\u2019s actually 3 general ways in which this loop could work - dispatching a thread to handle clientsocket,\ncreateanewprocesstohandleclientsocket,orrestructurethisapptousenon-blockingsockets,andmultiplex\nbetweenour\u201cserver\u201dsocketandanyactiveclientsocketsusingselect. Moreaboutthatlater. Theimportant\nthingtounderstandnowisthis: thisisalla\u201cserver\u201dsocketdoes. Itdoesn\u2019tsendanydata. Itdoesn\u2019treceiveanydata.\n2\nIt just produces \u201cclient\u201d sockets. Each clientsocket is created in response to some other \u201cclient\u201d socket doing\naconnect()tothehostandportwe\u2019reboundto. Assoonaswe\u2019vecreatedthatclientsocket, wegobackto\nlisteningformoreconnections. Thetwo\u201cclients\u201darefreetochatitup-theyareusingsomedynamicallyallocated\nportwhichwillberecycledwhentheconversationends.\n2.1 IPC\nIfyouneedfastIPCbetweentwoprocessesononemachine,youshouldlookintopipesorsharedmemory. Ifyou\ndodecidetouseAF_INETsockets,bindthe\u201cserver\u201dsocketto'localhost'. Onmostplatforms,thiswilltakea\nshortcutaroundacoupleoflayersofnetworkcodeandbequiteabitfaster.\n(cid:181) Seealso\nThemultiprocessingintegratescross-platformIPCintoahigher-levelAPI.\n3 Using a Socket\nThefirstthingtonote,isthatthewebbrowser\u2019s\u201cclient\u201dsocketandthewebserver\u2019s\u201cclient\u201dsocketareidenticalbeasts.\nThatis,thisisa\u201cpeertopeer\u201dconversation. Ortoputitanotherway,asthedesigner,youwillhavetodecidewhat\ntherulesofetiquetteareforaconversation. Normally,theconnectingsocketstartstheconversation,bysendingin\narequest,orperhapsasignon. Butthat\u2019sadesigndecision-it\u2019snotaruleofsockets.\nNowtherearetwosetsofverbstouseforcommunication. Youcanusesendandrecv,oryoucantransformyour\nclientsocketintoafile-likebeastandusereadandwrite. ThelatteristhewayJavapresentsitssockets. I\u2019mnot\ngoingtotalkaboutithere, excepttowarnyouthatyouneedtouse flushonsockets. Thesearebuffered\u201cfiles\u201d,\nandacommonmistakeistowritesomething,andthenreadforareply. Withoutaflushinthere,youmaywait\nforeverforthereply,becausetherequestmaystillbeinyouroutputbuffer.\nNowwecometothemajorstumblingblockofsockets-sendandrecvoperateonthenetworkbuffers. Theydo\nnotnecessarilyhandleallthebytesyouhandthem(orexpectfromthem),becausetheirmajorfocusishandlingthe\nnetwork buffers. In general, they return when the associated network buffers have been filled (send) or emptied\n(recv). They then tell you how many bytes they handled. It is your responsibility to call them again until your\nmessagehasbeencompletelydealtwith.\nWhenarecvreturns0bytes,itmeanstheothersidehasclosed(orisintheprocessofclosing)theconnection. You\nwillnotreceiveanymoredataonthisconnection. Ever. Youmaybeabletosenddatasuccessfully; I\u2019lltalkmore\naboutthislater.\nAprotocollikeHTTPusesasocketforonlyonetransfer. Theclientsendsarequest,thenreadsareply. That\u2019sit.\nThesocketisdiscarded. Thismeansthataclientcandetecttheendofthereplybyreceiving0bytes.\nButifyouplantoreuseyoursocketforfurthertransfers,youneedtorealizethatthereisnoEOT(EndofTransfer)\nonasocket. Irepeat: ifasocketsendorrecvreturnsafterhandling0bytes,theconnectionhasbeenbroken. If\ntheconnectionhasnotbeenbroken,youmaywaitonarecvforever,becausethesocketwillnottellyouthatthere\u2019s\nnothing more to read (for now). Now if you think about that a bit, you\u2019ll come to realize a fundamental truth of\nsockets: messages must either be fixed length (yuck), or be delimited (shrug), or indicate how long they are (much\nbetter),orendbyshuttingdowntheconnection. Thechoiceisentirelyyours,(butsomewaysarerighterthanothers).\nAssumingyoudon\u2019twanttoendtheconnection,thesimplestsolutionisafixedlengthmessage:\nclass MySocket:\n\"\"\"demonstration class only\n- coded for clarity, not efficiency\n\"\"\"\ndef __init__(self, sock=None):\nif sock is None:\nself.sock = socket.socket(\nsocket.AF_INET, socket.SOCK_STREAM)\n(continuesonnextpage)\n3\n(continuedfrompreviouspage)\nelse:\nself.sock = sock\ndef connect(self, host, port):\nself.sock.connect((host, port))\ndef mysend(self, msg):\ntotalsent = 0\nwhile totalsent < MSGLEN:\nsent = self.sock.send(msg[totalsent:])\nif sent == 0:\nraise RuntimeError(\"socket connection broken\")\ntotalsent = totalsent + sent\ndef myreceive(self):\nchunks = []\nbytes_recd = 0\nwhile bytes_recd < MSGLEN:\nchunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))\nif chunk == b'':\nraise RuntimeError(\"socket connection broken\")\nchunks.append(chunk)\nbytes_recd = bytes_recd + len(chunk)\nreturn b''.join(chunks)\nThe sending code here is usable for almost any messaging scheme - in Python you send strings, and you can use\nlen()todetermineitslength(evenifithasembedded\\0characters). It\u2019smostlythereceivingcodethatgetsmore\ncomplex. (AndinC,it\u2019snotmuchworse,exceptyoucan\u2019tusestrlenifthemessagehasembedded\\0s.)\nTheeasiestenhancementistomakethefirstcharacterofthemessageanindicatorofmessagetype,andhavethetype\ndeterminethelength. Nowyouhavetworecvs-thefirsttoget(atleast)thatfirstcharactersoyoucanlookupthe\nlength,andthesecondinalooptogettherest. Ifyoudecidetogothedelimitedroute,you\u2019llbereceivinginsome\narbitrarychunksize,(4096or8192isfrequentlyagoodmatchfornetworkbuffersizes),andscanningwhatyou\u2019ve\nreceivedforadelimiter.\nOnecomplicationtobeawareof: ifyourconversationalprotocolallowsmultiplemessagestobesentbacktoback\n(without some kind of reply), and you pass recv an arbitrary chunk size, you may end up reading the start of a\nfollowingmessage. You\u2019llneedtoputthatasideandholdontoit,untilit\u2019sneeded.\nPrefixingthemessagewithitslength(say,as5numericcharacters)getsmorecomplex,because(believeitornot),\nyoumaynotgetall5charactersinonerecv. Inplayingaround,you\u2019llgetawaywithit;butinhighnetworkloads,\nyourcodewillveryquicklybreakunlessyouusetworecvloops-thefirsttodeterminethelength,thesecondtoget\nthedatapartofthemessage. Nasty. Thisisalsowhenyou\u2019lldiscoverthatsenddoesnotalwaysmanagetogetrid\nofeverythinginonepass. Anddespitehavingreadthis,youwilleventuallygetbitbyit!\nIntheinterestsofspace,buildingyourcharacter,(andpreservingmycompetitiveposition),theseenhancementsare\nleftasanexerciseforthereader. Letsmoveontocleaningup.\n3.1 Binary Data\nItisperfectlypossibletosendbinarydataoverasocket. Themajorproblemisthatnotallmachinesusethesame\nformatsforbinarydata. Forexample,networkbyteorderisbig-endian,withthemostsignificantbytefirst,soa16\nbitintegerwiththevalue1wouldbethetwohexbytes00 01. However,mostcommonprocessors(x86/AMD64,\nARM,RISC-V),arelittle-endian,withtheleastsignificantbytefirst-thatsame1wouldbe01 00.\nSocket libraries have calls for converting 16 and 32 bit integers - ntohl, htonl, ntohs, htons where \u201cn\u201d\nmeansnetworkand\u201ch\u201dmeanshost,\u201cs\u201dmeansshortand\u201cl\u201dmeanslong. Wherenetworkorderishostorder,thesedo\nnothing,butwherethemachineisbyte-reversed,theseswapthebytesaroundappropriately.\nIn these days of 64-bit machines, the ASCII representation of binary data is frequently smaller than the binary\n4\nrepresentation. That\u2019s because a surprising amount of the time, most integers have the value 0, or maybe 1. The\nstring\"0\"wouldbetwobytes,whileafull64-bitintegerwouldbe8. Ofcourse,thisdoesn\u2019tfitwellwithfixed-length\nmessages. Decisions,decisions.\n4 Disconnecting\nStrictlyspeaking,you\u2019resupposedtouseshutdownonasocketbeforeyoucloseit. Theshutdownisanadvisory\ntothesocketattheotherend. Dependingontheargumentyoupassit,itcanmean\u201cI\u2019mnotgoingtosendanymore,\nbutI\u2019llstilllisten\u201d,or\u201cI\u2019mnotlistening,goodriddance!\u201d. Mostsocketlibraries,however,aresousedtoprogrammers\nneglectingtousethispieceofetiquettethatnormallyacloseisthesameasshutdown(); close(). Soinmost\nsituations,anexplicitshutdownisnotneeded.\nOne way to use shutdown effectively is in an HTTP-like exchange. The client sends a request and then does a\nshutdown(1). Thistellstheserver\u201cThisclientisdonesending,butcanstillreceive.\u201d Theservercandetect\u201cEOF\u201d\nbyareceiveof0bytes. Itcanassumeithasthecompleterequest. Theserversendsareply. Ifthesendcompletes\nsuccessfullythen,indeed,theclientwasstillreceiving.\nPythontakestheautomaticshutdownastepfurther, andsaysthatwhenasocketisgarbagecollected, itwillauto-\nmaticallydoacloseifit\u2019sneeded. Butrelyingonthisisaverybadhabit. Ifyoursocketjustdisappearswithout\ndoing a close, the socket at the other end may hang indefinitely, thinking you\u2019re just being slow. Please close\nyoursocketswhenyou\u2019redone.\n4.1 When Sockets Die\nProbablytheworstthingaboutusingblockingsocketsiswhathappenswhentheothersidecomesdownhard(without\ndoingaclose). Yoursocketislikelytohang. TCPisareliableprotocol,anditwillwaitalong,longtimebefore\ngivinguponaconnection. Ifyou\u2019reusingthreads,theentirethreadisessentiallydead. There\u2019snotmuchyoucando\naboutit. Aslongasyouaren\u2019tdoingsomethingdumb, likeholdingalockwhiledoingablockingread, thethread\nisn\u2019treallyconsumingmuchinthewayofresources. Donottrytokillthethread-partofthereasonthatthreadsare\nmoreefficientthanprocessesisthattheyavoidtheoverheadassociatedwiththeautomaticrecyclingofresources. In\notherwords,ifyoudomanagetokillthethread,yourwholeprocessislikelytobescrewedup.\n5 Non-blocking Sockets\nIfyou\u2019veunderstoodthepreceding,youalreadyknowmostofwhatyouneedtoknowaboutthemechanicsofusing\nsockets. You\u2019llstillusethesamecalls,inmuchthesameways. It\u2019sjustthat,ifyoudoitright,yourappwillbealmost\ninside-out.\nIn Python, you use socket.setblocking(False) to make it non-blocking. In C, it\u2019s more complex, (for one\nthing, you\u2019ll need to choose between the BSD flavor O_NONBLOCK and the almost indistinguishable POSIX flavor\nO_NDELAY, which is completely different from TCP_NODELAY), but it\u2019s the exact same idea. You do this after\ncreatingthesocket,butbeforeusingit. (Actually,ifyou\u2019renuts,youcanswitchbackandforth.)\nThemajormechanicaldifferenceisthatsend,recv,connectandacceptcanreturnwithouthavingdoneanything.\nYouhave(ofcourse)anumberofchoices. Youcancheckreturncodeanderrorcodesandgenerallydriveyourself\ncrazy. If you don\u2019t believe me, try it sometime. Your app will grow large, buggy and suck CPU. So let\u2019s skip the\nbrain-deadsolutionsanddoitright.\nUseselect.\nInC,codingselectisfairlycomplex. InPython,it\u2019sapieceofcake,butit\u2019scloseenoughtotheCversionthatif\nyouunderstandselectinPython,you\u2019llhavelittletroublewithitinC:\nready_to_read, ready_to_write, in_error = \\\nselect.select(\npotential_readers,\npotential_writers,\npotential_errs,\ntimeout)\n5\nYou pass select three lists: the first contains all sockets that you might want to try reading; the second all the\nsocketsyoumightwanttotrywritingto,andthelast(normallyleftempty)thosethatyouwanttocheckforerrors.\nYou should note that a socket can go into more than one list. The select call is blocking, but you can give it a\ntimeout. This is generally a sensible thing to do - give it a nice long timeout (say a minute) unless you have good\nreasontodootherwise.\nInreturn,youwillgetthreelists. Theycontainthesocketsthatareactuallyreadable,writableandinerror. Eachof\ntheselistsisasubset(possiblyempty)ofthecorrespondinglistyoupassedin.\nIfasocketisintheoutputreadablelist,youcanbeas-close-to-certain-as-we-ever-get-in-this-businessthatarecv\nonthatsocketwillreturnsomething. Sameideaforthewritablelist. You\u2019llbeabletosendsomething. Maybenotall\nyouwantto,butsomethingisbetterthannothing. (Actually,anyreasonablyhealthysocketwillreturnaswritable-it\njustmeansoutboundnetworkbufferspaceisavailable.)\nIfyouhavea\u201cserver\u201dsocket,putitinthepotential_readerslist. Ifitcomesoutinthereadablelist,youracceptwill\n(almostcertainly)work. Ifyouhavecreatedanewsockettoconnecttosomeoneelse,putitinthepotential_writers\nlist. Ifitshowsupinthewritablelist,youhaveadecentchancethatithasconnected.\nActually,selectcanbehandyevenwithblockingsockets. It\u2019sonewayofdeterminingwhetheryouwillblock-the\nsocketreturnsasreadablewhenthere\u2019ssomethinginthebuffers. However,thisstilldoesn\u2019thelpwiththeproblemof\ndeterminingwhethertheotherendisdone,orjustbusywithsomethingelse.\nPortabilityalert: OnUnix,selectworksbothwiththesocketsandfiles. Don\u2019ttrythisonWindows. OnWindows,\nselectworkswithsocketsonly. AlsonotethatinC,manyofthemoreadvancedsocketoptionsaredonedifferently\nonWindows. Infact,onWindowsIusuallyusethreads(whichworkvery,verywell)withmysockets.\n6\n",
  "context": "dependingoncontext. Sofirst,let\u2019smakeadistinctionbetweena\u201cclient\u201dsocket-anendpointofaconversation,and\n1\na\u201cserver\u201dsocket,whichismorelikeaswitchboardoperator. Theclientapplication(yourbrowser,forexample)uses",
  "source_file": "resources\\Year 3\\Python\\howto-sockets.pdf",
  "line_numbers": [
    35,
    246
  ]
}
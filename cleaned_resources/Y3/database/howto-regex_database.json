{
  "title": "howto-regex",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "3.1 CompilingRegularExpressions .",
  "code": "3.4 Module-LevelFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n3.5 CompilationFlags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n4 MorePatternPower 9\n4.1 MoreMetacharacters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n4.2 Grouping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n4.3 Non-capturingandNamedGroups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n4.4 LookaheadAssertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n5 ModifyingStrings 14\n5.1 SplittingStrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n5.2 SearchandReplace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n6 CommonProblems 16\n6.1 UseStringMethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n6.2 match()versussearch() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n6.3 GreedyversusNon-Greedy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n6.4 Usingre.VERBOSE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n7 Feedback 18\nAuthor\nA.M.Kuchling<amk@amk.ca>\n1\nAbstract\nThisdocumentisanintroductorytutorialtousingregularexpressionsinPythonwiththeremodule. Itprovides\nagentlerintroductionthanthecorrespondingsectionintheLibraryReference.\n1 Introduction\nRegularexpressions(calledREs,orregexes,orregexpatterns)areessentiallyatiny,highlyspecializedprogramming\nlanguageembeddedinsidePythonandmadeavailablethroughtheremodule. Usingthislittlelanguage,youspecify\ntherulesforthesetofpossiblestringsthatyouwantto match; thissetmightcontainEnglishsentences, ore-mail\naddresses,orTeXcommands,oranythingyoulike. Youcanthenaskquestionssuchas\u201cDoesthisstringmatchthe\npattern?\u201d,or\u201cIsthereamatchforthepatternanywhereinthisstring?\u201d. YoucanalsouseREstomodifyastringor\ntosplititapartinvariousways.\nRegularexpressionpatternsarecompiledintoaseriesofbytecodeswhicharethenexecutedbyamatchingengine\nwritteninC.Foradvanceduse,itmaybenecessarytopaycarefulattentiontohowtheenginewillexecuteagiven\nRE,andwritetheREinacertainwayinordertoproducebytecodethatrunsfaster. Optimizationisn\u2019tcoveredin\nthisdocument,becauseitrequiresthatyouhaveagoodunderstandingofthematchingengine\u2019sinternals.\nTheregularexpressionlanguageisrelativelysmallandrestricted,sonotallpossiblestringprocessingtaskscanbe\ndoneusingregularexpressions. Therearealsotasksthatcanbedonewithregularexpressions,buttheexpressions\nturnouttobeverycomplicated. Inthesecases,youmaybebetteroffwritingPythoncodetodotheprocessing;while\nPythoncodewillbeslowerthananelaborateregularexpression,itwillalsoprobablybemoreunderstandable.\n2 Simple Patterns\nWe\u2019llstartbylearningaboutthesimplestpossibleregularexpressions. Sinceregularexpressionsareusedtooperate\nonstrings,we\u2019llbeginwiththemostcommontask: matchingcharacters.\nFor a detailed explanation of the computer science underlying regular expressions (deterministic and non-\ndeterministicfiniteautomata),youcanrefertoalmostanytextbookonwritingcompilers.\n2.1 Matching Characters\nMostlettersandcharacterswillsimplymatchthemselves. Forexample,theregularexpressiontestwillmatchthe\nstringtestexactly. (Youcanenableacase-insensitivemodethatwouldletthisREmatchTestorTESTaswell;\nmoreaboutthislater.)\nThereareexceptionstothisrule;somecharactersarespecialmetacharacters,anddon\u2019tmatchthemselves. Instead,\ntheysignalthatsomeout-of-the-ordinarythingshouldbematched,ortheyaffectotherportionsoftheREbyrepeating\nthemorchangingtheirmeaning. Muchofthisdocumentisdevotedtodiscussingvariousmetacharactersandwhat\ntheydo.\nHere\u2019sacompletelistofthemetacharacters;theirmeaningswillbediscussedintherestofthisHOWTO.\n. ^ $ * + ? { } [ ] \\ | ( )\nThe first metacharacters we\u2019ll look at are [ and ]. They\u2019re used for specifying a character class, which is a set of\ncharactersthatyouwishtomatch. Characterscanbelistedindividually,orarangeofcharacterscanbeindicatedby\ngivingtwocharactersandseparatingthembya'-'. Forexample,[abc]willmatchanyofthecharactersa,b,or\nc;thisisthesameas[a-c],whichusesarangetoexpressthesamesetofcharacters. Ifyouwantedtomatchonly\nlowercaseletters,yourREwouldbe[a-z].\nMetacharacters(except\\)arenotactiveinsideclasses. Forexample,[akm$]willmatchanyofthecharacters'a',\n'k','m',or'$';'$'isusuallyametacharacter,butinsideacharacterclassit\u2019sstrippedofitsspecialnature.\nYoucanmatchthecharactersnotlistedwithintheclassbycomplementingtheset. Thisisindicatedbyincludinga\n'^'asthefirstcharacteroftheclass. Forexample,[^5]willmatchanycharacterexcept'5'. Ifthecaretappears\nelsewhereinacharacterclass, itdoesnothavespecialmeaning. Forexample: [5^]willmatcheithera'5'ora\n'^'.\n2\nPerhaps the most important metacharacter is the backslash, \\. As in Python string literals, the backslash can be\nfollowed by various characters to signal various special sequences. It\u2019s also used to escape all the metacharacters\nso you canstill matchthem inpatterns; for example, if you needto matcha [ or \\, you canprecede themwith a\nbackslashtoremovetheirspecialmeaning: \\[or\\\\.\nSomeofthespecialsequencesbeginningwith'\\'representpredefinedsetsofcharactersthatareoftenuseful,such\nasthesetofdigits,thesetofletters,orthesetofanythingthatisn\u2019twhitespace.\nLet\u2019s take an example: \\w matches any alphanumeric character. If the regex pattern is expressed in bytes, this is\nequivalenttotheclass[a-zA-Z0-9_]. Iftheregexpatternisastring,\\wwillmatchallthecharactersmarkedas\nlettersintheUnicodedatabaseprovidedbytheunicodedatamodule. Youcanusethemorerestricteddefinition\nof\\winastringpatternbysupplyingthere.ASCIIflagwhencompilingtheregularexpression.\nThefollowinglistofspecialsequencesisn\u2019tcomplete. Foracompletelistofsequencesandexpandedclassdefinitions\nfor Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In\ngeneral,theUnicodeversionsmatchanycharacterthat\u2019sintheappropriatecategoryintheUnicodedatabase.\n\\d\nMatchesanydecimaldigit;thisisequivalenttotheclass[0-9].\n\\D\nMatchesanynon-digitcharacter;thisisequivalenttotheclass[^0-9].\n\\s\nMatchesanywhitespacecharacter;thisisequivalenttotheclass[ \\t\\n\\r\\f\\v].\n\\S\nMatchesanynon-whitespacecharacter;thisisequivalenttotheclass[^ \\t\\n\\r\\f\\v].\n\\w\nMatchesanyalphanumericcharacter;thisisequivalenttotheclass[a-zA-Z0-9_].\n\\W\nMatchesanynon-alphanumericcharacter;thisisequivalenttotheclass[^a-zA-Z0-9_].\nThesesequencescanbeincludedinsideacharacterclass. Forexample,[\\s,.]isacharacterclassthatwillmatch\nanywhitespacecharacter,or','or'.'.\nThefinalmetacharacterinthissectionis.. Itmatchesanythingexceptanewlinecharacter,andthere\u2019sanalternate\nmode(re.DOTALL)whereitwillmatchevenanewline. . isoftenusedwhereyouwanttomatch\u201canycharacter\u201d.\n2.2 Repeating Things\nBeingabletomatchvaryingsetsofcharactersisthefirstthingregularexpressionscandothatisn\u2019talreadypossible\nwiththemethodsavailableonstrings. However,ifthatwastheonlyadditionalcapabilityofregexes,theywouldn\u2019t\nbemuchofanadvance. AnothercapabilityisthatyoucanspecifythatportionsoftheREmustberepeatedacertain\nnumberoftimes.\nThefirstmetacharacterforrepeatingthingsthatwe\u2019lllookatis*. *doesn\u2019tmatchtheliteralcharacter'*';instead,\nitspecifiesthatthepreviouscharactercanbematchedzeroormoretimes,insteadofexactlyonce.\nForexample,ca*twillmatch'ct'(0'a'characters),'cat'(1'a'),'caaat'(3'a'characters),andsoforth.\nRepetitions such as * are greedy; when repeating a RE, the matching engine will try to repeat it as many times as\npossible. Iflaterportionsofthepatterndon\u2019tmatch,thematchingenginewillthenbackupandtryagainwithfewer\nrepetitions.\nA step-by-step example will make this more obvious. Let\u2019s consider the expression a[bcd]*b. This matches the\nletter'a',zeroormorelettersfromtheclass[bcd],andfinallyendswitha'b'. NowimaginematchingthisRE\nagainstthestring'abcbd'.\n3\nStep Matched Explanation\n1 a TheaintheREmatches.\n2 abcbd Theenginematches[bcd]*,goingasfarasitcan,whichistotheendofthestring.\n3 Failure Theenginetriestomatchb,butthecurrentpositionisattheendofthestring,soitfails.\n4 abcb Backup,sothat[bcd]*matchesonelesscharacter.\n5 Failure Trybagain,butthecurrentpositionisatthelastcharacter,whichisa'd'.\n6 abc Backupagain,sothat[bcd]*isonlymatchingbc.\n6 abcb Trybagain. Thistimethecharacteratthecurrentpositionis'b',soitsucceeds.\nTheendoftheREhasnowbeenreached,andithasmatched'abcb'. Thisdemonstrateshowthematchingengine\ngoesasfarasitcanatfirst,andifnomatchisfounditwillthenprogressivelybackupandretrytherestoftheRE\nagainandagain. Itwillbackupuntilithastriedzeromatchesfor[bcd]*,andifthatsubsequentlyfails,theengine\nwillconcludethatthestringdoesn\u2019tmatchtheREatall.\nAnother repeating metacharacter is +, which matches one or more times. Pay careful attention to the difference\nbetween * and +; * matches zero or more times, so whatever\u2019s being repeated may not be present at all, while +\nrequiresatleastoneoccurrence. Touseasimilarexample,ca+twillmatch'cat'(1'a'),'caaat'(3'a's),but\nwon\u2019tmatch'ct'.\nThere are two more repeating operators or quantifiers. The question mark character, ?, matches either once or\nzerotimes;youcanthinkofitasmarkingsomethingasbeingoptional. Forexample,home-?brewmatcheseither\n'homebrew'or'home-brew'.\nThemostcomplicatedquantifieris{m,n},wheremandnaredecimalintegers. Thisquantifiermeanstheremustbe\natleastmrepetitions,andatmostn. Forexample,a/{1,3}bwillmatch'a/b','a//b',and'a///b'. Itwon\u2019t\nmatch'ab',whichhasnoslashes,or'a////b',whichhasfour.\nYoucanomiteithermorn;inthatcase,areasonablevalueisassumedforthemissingvalue. Omittingmisinterpreted\nasalowerlimitof0,whileomittingnresultsinanupperboundofinfinity.\nThesimplestcase{m}matchestheprecedingitemexactlymtimes. Forexample,a/{2}bwillonlymatch'a//b'.\nReaders of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation.\n{0,}isthesameas*,{1,}isequivalentto+,and{0,1}isthesameas?. It\u2019sbettertouse*,+,or?whenyou\ncan,simplybecausethey\u2019reshorterandeasiertoread.\n3 Using Regular Expressions\nNowthatwe\u2019velookedatsomesimpleregularexpressions,howdoweactuallyusetheminPython? Theremodule\nprovidesaninterfacetotheregularexpressionengine, allowingyoutocompileREsintoobjectsandthenperform\nmatcheswiththem.\n3.1 Compiling Regular Expressions\nRegularexpressionsarecompiledintopatternobjects,whichhavemethodsforvariousoperationssuchassearching\nforpatternmatchesorperformingstringsubstitutions.\n>>> import re\n>>> p = re.compile('ab*')\n>>> p\nre.compile('ab*')\nre.compile()alsoacceptsanoptionalflagsargument,usedtoenablevariousspecialfeaturesandsyntaxvariations.\nWe\u2019llgoovertheavailablesettingslater,butfornowasingleexamplewilldo:\n>>> p = re.compile('ab*', re.IGNORECASE)\nTheREispassedtore.compile()asastring. REsarehandledasstringsbecauseregularexpressionsaren\u2019tpartof\nthecorePythonlanguage,andnospecialsyntaxwascreatedforexpressingthem. (Thereareapplicationsthatdon\u2019t\n4\nneedREsatall,sothere\u2019snoneedtobloatthelanguagespecificationbyincludingthem.) Instead,theremoduleis\nsimplyaCextensionmoduleincludedwithPython,justlikethesocketorzlibmodules.\nPuttingREsinstringskeepsthePythonlanguagesimpler, buthasonedisadvantagewhichisthetopicofthenext\nsection.\n3.2 The Backslash Plague\nAsstatedearlier,regularexpressionsusethebackslashcharacter('\\')toindicatespecialformsortoallowspecial\ncharacterstobeusedwithoutinvokingtheirspecialmeaning. ThisconflictswithPython\u2019susageofthesamecharacter\nforthesamepurposeinstringliterals.\nLet\u2019s say you want to write a RE that matches the string \\section, which might be found in a LaTeX file. To\nfigureoutwhattowriteintheprogramcode,startwiththedesiredstringtobematched. Next,youmustescapeany\nbackslashesandothermetacharactersbyprecedingthemwithabackslash,resultinginthestring\\\\section. The\nresultingstringthatmustbepassedtore.compile()mustbe\\\\section. However,toexpressthisasaPython\nstringliteral,bothbackslashesmustbeescapedagain.\nCharacters Stage\n\\section Textstringtobematched\n\\\\section Escapedbackslashforre.compile()\n\"\\\\\\\\section\" Escapedbackslashesforastringliteral\nInshort,tomatchaliteralbackslash,onehastowrite'\\\\\\\\'astheREstring,becausetheregularexpressionmustbe\n\\\\,andeachbackslashmustbeexpressedas\\\\insidearegularPythonstringliteral. InREsthatfeaturebackslashes\nrepeatedly,thisleadstolotsofrepeatedbackslashesandmakestheresultingstringsdifficulttounderstand.\nThesolutionistousePython\u2019srawstringnotationforregularexpressions;backslashesarenothandledinanyspecial\nwayinastringliteralprefixedwith'r',sor\"\\n\"isatwo-characterstringcontaining'\\'and'n',while\"\\n\"is\naone-characterstringcontaininganewline. RegularexpressionswilloftenbewritteninPythoncodeusingthisraw\nstringnotation.\nInaddition,specialescapesequencesthatarevalidinregularexpressions,butnotvalidasPythonstringliterals,now\nresultinaDeprecationWarningandwilleventuallybecomeaSyntaxError,whichmeansthesequenceswillbe\ninvalidifrawstringnotationorescapingthebackslashesisn\u2019tused.\nRegularString Rawstring\n\"ab*\" r\"ab*\"\n\"\\\\\\\\section\" r\"\\\\section\"\n\"\\\\w+\\\\s+\\\\1\" r\"\\w+\\s+\\1\"\n3.3 Performing Matches\nOnceyouhaveanobjectrepresentingacompiledregularexpression,whatdoyoudowithit? Patternobjectshave\nseveralmethodsandattributes. Onlythemostsignificantoneswillbecoveredhere;consulttheredocsforacomplete\nlisting.\nMethod/Attribute Purpose\nmatch() DetermineiftheREmatchesatthebeginningofthestring.\nsearch() Scanthroughastring,lookingforanylocationwherethisREmatches.\nfindall() FindallsubstringswheretheREmatches,andreturnsthemasalist.\nfinditer() FindallsubstringswheretheREmatches,andreturnsthemasaniterator.\nmatch() and search() return None if no match can be found. If they\u2019re successful, a match object instance is\nreturned,containinginformationaboutthematch: whereitstartsandends,thesubstringitmatched,andmore.\n5\nYoucanlearnaboutthisbyinteractivelyexperimentingwiththeremodule.\nThisHOWTOusesthestandardPythoninterpreterforitsexamples. First,runthePythoninterpreter,importthere\nmodule,andcompileaRE:\n>>> import re\n>>> p = re.compile('[a-z]+')\n>>> p\nre.compile('[a-z]+')\nNow,youcantrymatchingvariousstringsagainsttheRE[a-z]+. Anemptystringshouldn\u2019tmatchatall,since+\nmeans\u2018oneormorerepetitions\u2019. match()shouldreturnNoneinthiscase,whichwillcausetheinterpretertoprint\nnooutput. Youcanexplicitlyprinttheresultofmatch()tomakethisclear.\n>>> p.match(\"\")\n>>> print(p.match(\"\"))\nNone\nNow,let\u2019stryitonastringthatitshouldmatch,suchastempo. Inthiscase,match()willreturnamatchobject,so\nyoushouldstoretheresultinavariableforlateruse.\n>>> m = p.match('tempo')\n>>> m\n<re.Match object; span=(0, 5), match='tempo'>\nNow you can query the match object for information about the matching string. Match object instances also have\nseveralmethodsandattributes;themostimportantonesare:\nMethod/Attribute Purpose\ngroup() ReturnthestringmatchedbytheRE\nstart() Returnthestartingpositionofthematch\nend() Returntheendingpositionofthematch\nspan() Returnatuplecontainingthe(start,end)positionsofthematch\nTryingthesemethodswillsoonclarifytheirmeaning:\n>>> m.group()\n'tempo'\n>>> m.start(), m.end()\n(0, 5)\n>>> m.span()\n(0, 5)\ngroup() returns the substring that was matched by the RE. start() and end() return the starting and ending\nindexofthematch. span()returnsbothstartandendindexesinasingletuple. Sincethematch()methodonly\nchecksiftheREmatchesatthestartofastring,start()willalwaysbezero. However,thesearch()methodof\npatternsscansthroughthestring,sothematchmaynotstartatzerointhatcase.\n>>> print(p.match('::: message'))\nNone\n>>> m = p.search('::: message'); print(m)\n<re.Match object; span=(4, 11), match='message'>\n>>> m.group()\n'message'\n>>> m.span()\n(4, 11)\nInactualprograms,themostcommonstyleistostorethematchobjectinavariable,andthencheckifitwasNone.\nThisusuallylookslike:\n6\np = re.compile( ... )\nm = p.match( 'string goes here' )\nif m:\nprint('Match found: ', m.group())\nelse:\nprint('No match')\nTwopatternmethodsreturnallofthematchesforapattern. findall()returnsalistofmatchingstrings:\n>>> p = re.compile(r'\\d+')\n>>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n['12', '11', '10']\nThe r prefix, making the literal a raw string literal, is needed in this example because escape sequences in a nor-\nmal \u201ccooked\u201d string literal that are not recognized by Python, as opposed to regular expressions, now result in a\nDeprecationWarningandwilleventuallybecomeaSyntaxError. SeeTheBackslashPlague.\nfindall()hastocreatetheentirelistbeforeitcanbereturnedastheresult. Thefinditer()methodreturnsa\nsequenceofmatchobjectinstancesasaniterator:\n>>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n>>> iterator\n<callable_iterator object at 0x...>\n>>> for match in iterator:\n... print(match.span())\n...\n(0, 2)\n(22, 24)\n(29, 31)\n3.4 Module-Level Functions\nYoudon\u2019thavetocreateapatternobjectandcallitsmethods;theremodulealsoprovidestop-levelfunctionscalled\nmatch(), search(), findall(), sub(), and so forth. These functions take the same arguments as the corre-\nspondingpatternmethodwiththeREstringaddedasthefirstargument,andstillreturneitherNoneoramatchobject\ninstance.\n>>> print(re.match(r'From\\s+', 'Fromage amk'))\nNone\n>>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n<re.Match object; span=(0, 5), match='From '>\nUnderthehood,thesefunctionssimplycreateapatternobjectforyouandcalltheappropriatemethodonit. They\nalsostorethecompiledobjectinacache,sofuturecallsusingthesameREwon\u2019tneedtoparsethepatternagainand\nagain.\nShouldyouusethesemodule-levelfunctions,orshouldyougetthepatternandcallitsmethodsyourself? Ifyou\u2019re\naccessingaregexwithinaloop,pre-compilingitwillsaveafewfunctioncalls. Outsideofloops,there\u2019snotmuch\ndifferencethankstotheinternalcache.\n3.5 Compilation Flags\nCompilationflagsletyoumodifysomeaspectsofhowregularexpressionswork. Flagsareavailableintheremodule\nunder two names, a long name such as IGNORECASE and a short, one-letter form such as I. (If you\u2019re familiar\nwithPerl\u2019spatternmodifiers,theone-letterformsusethesameletters;theshortformofre.VERBOSEisre.X,for\nexample.) MultipleflagscanbespecifiedbybitwiseOR-ingthem; re.I | re.MsetsboththeIandMflags, for\nexample.\nHere\u2019satableoftheavailableflags,followedbyamoredetailedexplanationofeachone.\n7\nFlag Meaning\nASCII,A Makesseveralescapeslike\\w,\\b,\\sand\\dmatchonlyonASCIIcharacterswiththe\nrespectiveproperty.\nDOTALL,S Make.matchanycharacter,includingnewlines.\nIGNORECASE,I Docase-insensitivematches.\nLOCALE,L Doalocale-awarematch.\nMULTILINE,M Multi-linematching,affecting^and$.\nVERBOSE, X (for \u2018ex- EnableverboseREs,whichcanbeorganizedmorecleanlyandunderstandably.\ntended\u2019)\nre.I\nre.IGNORECASE\nPerformcase-insensitivematching;characterclassandliteralstringswillmatchlettersbyignoringcase. For\nexample,[A-Z]willmatchlowercaseletters,too. FullUnicodematchingalsoworksunlesstheASCIIflagis\nusedtodisablenon-ASCIImatches. WhentheUnicodepatterns[a-z]or[A-Z]areusedincombinationwith\ntheIGNORECASEflag,theywillmatchthe52ASCIIlettersand4additionalnon-ASCIIletters: \u2018\u0130\u2019(U+0130,\nLatincapitalletterIwithdotabove),\u2018\u0131\u2019(U+0131,Latinsmallletterdotlessi),\u2018\u017f\u2019(U+017F,Latinsmallletter\nlongs)and\u2018\u212a\u2019(U+212A,Kelvinsign). Spamwillmatch'Spam','spam','spAM',or'\u017fpam'(thelatteris\nmatchedonlyinUnicodemode). Thislowercasingdoesn\u2019ttakethecurrentlocaleintoaccount;itwillifyou\nalsosettheLOCALEflag.\nre.L\nre.LOCALE\nMake \\w, \\W, \\b, \\B and case-insensitivematchingdependentonthe currentlocaleinsteadoftheUnicode\ndatabase.\nLocales are a feature of the C library intended to help in writing programs that take account of language\ndifferences. Forexample,ifyou\u2019reprocessingencodedFrenchtext,you\u2019dwanttobeabletowrite\\w+tomatch\nwords,but\\wonlymatchesthecharacterclass[A-Za-z]inbytespatterns;itwon\u2019tmatchbytescorresponding\nto\u00e9or\u00e7. IfyoursystemisconfiguredproperlyandaFrenchlocaleisselected, certainCfunctionswilltell\ntheprogramthatthebytecorrespondingto\u00e9shouldalsobeconsideredaletter. SettingtheLOCALEflagwhen\ncompilingaregularexpressionwillcausetheresultingcompiledobjecttousetheseCfunctionsfor\\w; this\nisslower,butalsoenables\\w+tomatchFrenchwordsasyou\u2019dexpect. Theuseofthisflagisdiscouragedin\nPython3asthelocalemechanismisveryunreliable,itonlyhandlesone\u201cculture\u201datatime,anditonlyworks\nwith8-bitlocales. UnicodematchingisalreadyenabledbydefaultinPython3forUnicode(str)patterns,and\nitisabletohandledifferentlocales/languages.\nre.M\nre.MULTILINE\n(^and$haven\u2019tbeenexplainedyet;they\u2019llbeintroducedinsectionMoreMetacharacters.)\nUsually^matchesonlyatthebeginningofthestring,and$matchesonlyattheendofthestringandimmedi-\natelybeforethenewline(ifany)attheendofthestring. Whenthisflagisspecified,^matchesatthebeginning\nofthestringandatthebeginningofeachlinewithinthestring,immediatelyfollowingeachnewline. Similarly,\nthe$metacharactermatcheseitherattheendofthestringandattheendofeachline(immediatelypreceding\neachnewline).\nre.S\nre.DOTALL\nMakes the '.' special character match any character at all, including a newline; without this flag, '.' will\nmatchanythingexceptanewline.\nre.A\nre.ASCII\nMake\\w,\\W,\\b,\\B,\\sand\\SperformASCII-onlymatchinginsteadoffullUnicodematching. Thisisonly\nmeaningfulforUnicodepatterns,andisignoredforbytepatterns.\nre.X\n8\nre.VERBOSE\nThisflagallowsyoutowriteregularexpressionsthataremorereadablebygrantingyoumoreflexibilityinhow\nyoucanformatthem. Whenthisflaghasbeenspecified, whitespacewithintheREstringisignored, except\nwhenthewhitespaceisinacharacterclassorprecededbyanunescapedbackslash;thisletsyouorganizeand\nindenttheREmoreclearly. ThisflagalsoletsyouputcommentswithinaREthatwillbeignoredbytheengine;\ncommentsaremarkedbya'#'that\u2019sneitherinacharacterclassorprecededbyanunescapedbackslash.\nForexample,here\u2019saREthatusesre.VERBOSE;seehowmucheasieritistoread?\ncharref = re.compile(r\"\"\"\n&[#] # Start of a numeric entity reference\n(\n0[0-7]+ # Octal form\n| [0-9]+ # Decimal form\n| x[0-9a-fA-F]+ # Hexadecimal form\n)\n; # Trailing semicolon\n\"\"\", re.VERBOSE)\nWithouttheverbosesetting,theREwouldlooklikethis:\ncharref = re.compile(\"&#(0[0-7]+\"\n\"|[0-9]+\"\n\"|x[0-9a-fA-F]+);\")\nIn the above example, Python\u2019s automatic concatenation of string literals has been used to break up the RE\nintosmallerpieces,butit\u2019sstillmoredifficulttounderstandthantheversionusingre.VERBOSE.\n4 More Pattern Power\nSofarwe\u2019veonlycoveredapartofthefeaturesofregularexpressions. Inthissection,we\u2019llcoversomenewmetachar-\nacters,andhowtousegroupstoretrieveportionsofthetextthatwasmatched.\n4.1 More Metacharacters\nTherearesomemetacharactersthatwehaven\u2019tcoveredyet. Mostofthemwillbecoveredinthissection.\nSome of the remaining metacharacters to be discussed are zero-width assertions. They don\u2019t cause the engine to\nadvancethroughthestring;instead,theyconsumenocharactersatall,andsimplysucceedorfail. Forexample,\\b\nisanassertionthatthecurrentpositionislocatedatawordboundary;thepositionisn\u2019tchangedbythe\\batall. This\nmeansthatzero-widthassertionsshouldneverberepeated,becauseiftheymatchonceatagivenlocation,theycan\nobviouslybematchedaninfinitenumberoftimes.\n|\nAlternation,orthe\u201cor\u201doperator. IfAandBareregularexpressions,A|Bwillmatchanystringthatmatches\neitherAorB.|hasverylowprecedenceinordertomakeitworkreasonablywhenyou\u2019realternatingmulti-\ncharacter strings. Crow|Servo will match either 'Crow' or 'Servo', not 'Cro', a 'w' or an 'S', and\n'ervo'.\nTomatchaliteral'|',use\\|,orencloseitinsideacharacterclass,asin[|].\n^\nMatchesatthebeginningoflines. UnlesstheMULTILINEflaghasbeenset,thiswillonlymatchatthebeginning\nofthestring. InMULTILINEmode,thisalsomatchesimmediatelyaftereachnewlinewithinthestring.\nForexample,ifyouwishtomatchthewordFromonlyatthebeginningofaline,theREtouseis^From.\n>>> print(re.search('^From', 'From Here to Eternity'))\n<re.Match object; span=(0, 4), match='From'>\n>>> print(re.search('^From', 'Reciting From Memory'))\nNone\n9\nTomatchaliteral'^',use\\^.\n$\nMatches at the end of a line, which is defined as either the end of the string, or any location followed by a\nnewlinecharacter.\n>>> print(re.search('}$', '{block}'))\n<re.Match object; span=(6, 7), match='}'>\n>>> print(re.search('}$', '{block} '))\nNone\n>>> print(re.search('}$', '{block}\\n'))\n<re.Match object; span=(6, 7), match='}'>\nTomatchaliteral'$',use\\$orencloseitinsideacharacterclass,asin[$].\n\\A\nMatchesonlyatthestartofthestring. WhennotinMULTILINEmode,\\Aand^areeffectivelythesame. In\nMULTILINEmode,they\u2019redifferent: \\Astillmatchesonlyatthebeginningofthestring,but^maymatchat\nanylocationinsidethestringthatfollowsanewlinecharacter.\n\\Z\nMatchesonlyattheendofthestring.\n\\b\nWordboundary. Thisisazero-widthassertionthatmatchesonlyatthebeginningorendofaword. Aword\nis defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a\nnon-alphanumericcharacter.\nThe following example matches class only when it\u2019s a complete word; it won\u2019t match when it\u2019s contained\ninsideanotherword.\n>>> p = re.compile(r'\\bclass\\b')\n>>> print(p.search('no class at all'))\n<re.Match object; span=(3, 8), match='class'>\n>>> print(p.search('the declassified algorithm'))\nNone\n>>> print(p.search('one subclass is'))\nNone\nTherearetwosubtletiesyoushouldrememberwhenusingthisspecialsequence. First,thisistheworstcollision\nbetweenPython\u2019sstringliteralsandregularexpressionsequences. InPython\u2019sstringliterals,\\bisthebackspace\ncharacter,ASCIIvalue8. Ifyou\u2019renotusingrawstrings,thenPythonwillconvertthe\\btoabackspace,and\nyourREwon\u2019tmatchasyouexpectitto. ThefollowingexamplelooksthesameasourpreviousRE,butomits\nthe'r'infrontoftheREstring.\n>>> p = re.compile('\\bclass\\b')\n>>> print(p.search('no class at all'))\nNone\n>>> print(p.search('\\b' + 'class' + '\\b'))\n<re.Match object; span=(0, 7), match='\\x08class\\x08'>\nSecond,insideacharacterclass,wherethere\u2019snouseforthisassertion,\\brepresentsthebackspacecharacter,\nforcompatibilitywithPython\u2019sstringliterals.\n\\B\nAnotherzero-widthassertion,thisistheoppositeof\\b,onlymatchingwhenthecurrentpositionisnotata\nwordboundary.\n10\n4.2 Grouping\nFrequentlyyouneedtoobtainmoreinformationthanjustwhethertheREmatchedornot. Regularexpressionsare\noften used to dissect strings by writing a RE divided into several subgroups which match different components of\ninterest. Forexample,anRFC-822headerlineisdividedintoaheadernameandavalue,separatedbya':',like\nthis:\nFrom: author@example.com\nUser-Agent: Thunderbird 1.5.0.9 (X11/20061227)\nMIME-Version: 1.0\nTo: editor@example.com\nThiscanbehandledbywritingaregularexpressionwhichmatchesanentireheaderline,andhasonegroupwhich\nmatchestheheadername,andanothergroupwhichmatchestheheader\u2019svalue.\nGroups are marked by the '(', ')' metacharacters. '(' and ')' have much the same meaning as they do in\nmathematicalexpressions;theygrouptogethertheexpressionscontainedinsidethem,andyoucanrepeatthecontents\nofagroupwithaquantifier,suchas*,+,?,or{m,n}. Forexample,(ab)*willmatchzeroormorerepetitionsof\nab.\n>>> p = re.compile('(ab)*')\n>>> print(p.match('ababababab').span())\n(0, 10)\nGroupsindicatedwith'(',')'alsocapturethestartingandendingindexofthetextthattheymatch;thiscanbe\nretrievedbypassinganargumenttogroup(),start(),end(),andspan(). Groupsarenumberedstartingwith\n0. Group0isalwayspresent;it\u2019sthewholeRE,somatchobjectmethodsallhavegroup0astheirdefaultargument.\nLaterwe\u2019llseehowtoexpressgroupsthatdon\u2019tcapturethespanoftextthattheymatch.\n>>> p = re.compile('(a)b')\n>>> m = p.match('ab')\n>>> m.group()\n'ab'\n>>> m.group(0)\n'ab'\nSubgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just\ncounttheopeningparenthesischaracters,goingfromlefttoright.\n>>> p = re.compile('(a(b)c)d')\n>>> m = p.match('abcd')\n>>> m.group(0)\n'abcd'\n>>> m.group(1)\n'abc'\n>>> m.group(2)\n'b'\ngroup()canbepassedmultiplegroupnumbersatatime,inwhichcaseitwillreturnatuplecontainingthecorre-\nspondingvaluesforthosegroups.\n>>> m.group(2,1,2)\n('b', 'abc', 'b')\nThegroups()methodreturnsatuplecontainingthestringsforallthesubgroups,from1uptohowevermanythere\nare.\n>>> m.groups()\n('abc', 'b')\n11\nBackreferencesinapatternallowyoutospecifythatthecontentsofanearliercapturinggroupmustalsobefoundat\nthecurrentlocationinthestring. Forexample,\\1willsucceediftheexactcontentsofgroup1canbefoundatthe\ncurrentposition,andfailsotherwise. RememberthatPython\u2019sstringliteralsalsouseabackslashfollowedbynumbers\ntoallowincludingarbitrarycharactersinastring,sobesuretousearawstringwhenincorporatingbackreferences\ninaRE.\nForexample,thefollowingREdetectsdoubledwordsinastring.\n>>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n>>> p.search('Paris in the the spring').group()\n'the the'\nBackreferences like this aren\u2019t often useful for just searching through a string \u2014 there are few text formats which\nrepeatdatainthisway\u2014butyou\u2019llsoonfindoutthatthey\u2019reveryusefulwhenperformingstringsubstitutions.\n4.3 Non-capturing and Named Groups\nElaborateREsmayusemanygroups,bothtocapturesubstringsofinterest,andtogroupandstructuretheREitself.\nIncomplexREs,itbecomesdifficulttokeeptrackofthegroupnumbers. Therearetwofeatureswhichhelpwiththis\nproblem. Bothofthemuseacommonsyntaxforregularexpressionextensions,sowe\u2019lllookatthatfirst.\nPerl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl\ndeveloperscouldn\u2019tchoosenewsingle-keystrokemetacharactersornewspecialsequencesbeginningwith\\without\nmakingPerl\u2019sregularexpressionsconfusinglydifferentfromstandardREs. Iftheychose&asanewmetacharacter,\nforexample,oldexpressionswouldbeassumingthat&wasaregularcharacterandwouldn\u2019thaveescapeditbywriting\n\\&or[&].\nThe solution chosen by the Perl developers was to use (?...) as the extension syntax. ? immediately after a\nparenthesiswasasyntaxerrorbecausethe?wouldhavenothingtorepeat,sothisdidn\u2019tintroduceanycompatibility\nproblems. Thecharactersimmediatelyafterthe?indicatewhatextensionisbeingused,so(?=foo)isonething(a\npositivelookaheadassertion)and(?:foo)issomethingelse(anon-capturinggroupcontainingthesubexpression\nfoo).\nPython supports several of Perl\u2019s extensions and adds an extension syntax to Perl\u2019s extension syntax. If the first\ncharacterafterthequestionmarkisaP,youknowthatit\u2019sanextensionthat\u2019sspecifictoPython.\nNowthatwe\u2019velookedatthegeneralextensionsyntax,wecanreturntothefeaturesthatsimplifyworkingwithgroups\nincomplexREs.\nSometimesyou\u2019llwanttouseagrouptodenoteapartofaregularexpression,butaren\u2019tinterestedinretrievingthe\ngroup\u2019scontents. Youcanmakethisfactexplicitbyusinganon-capturinggroup: (?:...),whereyoucanreplace\nthe...withanyotherregularexpression.\n>>> m = re.match(\"([abc])+\", \"abc\")\n>>> m.groups()\n('c',)\n>>> m = re.match(\"(?:[abc])+\", \"abc\")\n>>> m.groups()\n()\nExcept for the fact that you can\u2019t retrieve the contents of what the group matched, a non-capturing group behaves\nexactlythesameasacapturinggroup;youcanputanythinginsideit,repeatitwitharepetitionmetacharactersuchas\n*,andnestitwithinothergroups(capturingornon-capturing). (?:...) isparticularlyusefulwhenmodifyingan\nexistingpattern,sinceyoucanaddnewgroupswithoutchanginghowalltheothergroupsarenumbered. Itshouldbe\nmentionedthatthere\u2019snoperformancedifferenceinsearchingbetweencapturingandnon-capturinggroups;neither\nformisanyfasterthantheother.\nAmoresignificantfeatureisnamedgroups: insteadofreferringtothembynumbers,groupscanbereferencedbya\nname.\nThesyntaxforanamedgroupisoneofthePython-specificextensions: (?P<name>...). nameis,obviously,the\nnameofthegroup. Namedgroupsbehaveexactlylikecapturinggroups, andadditionallyassociateanamewitha\ngroup. Thematchobjectmethodsthatdealwithcapturinggroupsallaccepteitherintegersthatrefertothegroupby\n12\nnumberorstringsthatcontainthedesiredgroup\u2019sname. Namedgroupsarestillgivennumbers,soyoucanretrieve\ninformationaboutagroupintwoways:\n>>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n>>> m = p.search( '(((( Lots of punctuation )))' )\n>>> m.group('word')\n'Lots'\n>>> m.group(1)\n'Lots'\nAdditionally,youcanretrievenamedgroupsasadictionarywithgroupdict():\n>>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n>>> m.groupdict()\n{'first': 'Jane', 'last': 'Doe'}\nNamedgroupsarehandybecausetheyletyouuseeasilyrememberednames,insteadofhavingtoremembernumbers.\nHere\u2019sanexampleREfromtheimaplibmodule:\nInternalDate = re.compile(r'INTERNALDATE \"'\nr'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\nr'(?P<year>[0-9][0-9][0-9][0-9])'\nr' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\nr' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\nr'\"')\nIt\u2019sobviouslymucheasiertoretrievem.group('zonem'),insteadofhavingtoremembertoretrievegroup9.\nThesyntaxforbackreferencesinanexpressionsuchas(...)\\1referstothenumberofthegroup. There\u2019snaturally\navariantthatusesthegroupnameinsteadofthenumber. ThisisanotherPythonextension: (?P=name)indicates\nthatthecontentsofthegroupcallednameshouldagainbematchedatthecurrentpoint. Theregularexpressionfor\nfindingdoubledwords,\\b(\\w+)\\s+\\1\\bcanalsobewrittenas\\b(?P<word>\\w+)\\s+(?P=word)\\b:\n>>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n>>> p.search('Paris in the the spring').group()\n'the the'\n4.4 Lookahead Assertions\nAnother zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and\nnegativeform,andlooklikethis:\n(?=...)\nPositive lookahead assertion. This succeeds if the contained regular expression, represented here by ...,\nsuccessfullymatchesatthecurrentlocation,andfailsotherwise. But,oncethecontainedexpressionhasbeen\ntried,thematchingenginedoesn\u2019tadvanceatall;therestofthepatternistriedrightwheretheassertionstarted.\n(?!...)\nNegativelookaheadassertion. Thisistheoppositeofthepositiveassertion; itsucceedsifthecontainedex-\npressiondoesn\u2019tmatchatthecurrentpositioninthestring.\nTomakethisconcrete,let\u2019slookatacasewherealookaheadisuseful. Considerasimplepatterntomatchafilename\nandsplititapartintoabasenameandanextension,separatedbya.. Forexample,innews.rc,newsisthebase\nname,andrcisthefilename\u2019sextension.\nThepatterntomatchthisisquitesimple:\n.*[.].*$\nNotice that the . needs to be treated specially because it\u2019s a metacharacter, so it\u2019s inside a character class to only\nmatchthatspecificcharacter. Alsonoticethetrailing$;thisisaddedtoensurethatalltherestofthestringmustbe\n13\nincludedintheextension. Thisregularexpressionmatchesfoo.barandautoexec.batandsendmail.cfand\nprinters.conf.\nNow,considercomplicatingtheproblemabit;whatifyouwanttomatchfilenameswheretheextensionisnotbat?\nSomeincorrectattempts:\n.*[.][^b].*$Thefirstattemptabovetriestoexcludebatbyrequiringthatthefirstcharacteroftheextensionis\nnotab. Thisiswrong,becausethepatternalsodoesn\u2019tmatchfoo.bar.\n.*[.]([^b]..|.[^a].|..[^t])$\nThe expression gets messier when you try to patch up the first solution by requiring one of the following cases to\nmatch: the first character of the extension isn\u2019t b; the second character isn\u2019t a; or the third character isn\u2019t t. This\naccepts foo.bar and rejects autoexec.bat, but it requires a three-letter extension and won\u2019t accept a filename\nwithatwo-letterextensionsuchassendmail.cf. We\u2019llcomplicatethepatternagaininanefforttofixit.\n.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$\nInthethirdattempt,thesecondandthirdlettersareallmadeoptionalinordertoallowmatchingextensionsshorter\nthanthreecharacters,suchassendmail.cf.\nThe pattern\u2019s getting really complicated now, which makes it hard to read and understand. Worse, if the problem\nchangesandyouwanttoexcludebothbatandexeasextensions,thepatternwouldgetevenmorecomplicatedand\nconfusing.\nAnegativelookaheadcutsthroughallthisconfusion:\n.*[.](?!bat$)[^.]*$Thenegativelookaheadmeans: iftheexpressionbatdoesn\u2019tmatchatthispoint,trythe\nrestofthepattern;ifbat$doesmatch,thewholepatternwillfail. Thetrailing$isrequiredtoensurethatsomething\nlike sample.batch, where the extension only starts with bat, will be allowed. The [^.]* makes sure that the\npatternworkswhentherearemultipledotsinthefilename.\nExcludinganotherfilenameextensionisnoweasy;simplyadditasanalternativeinsidetheassertion. Thefollowing\npatternexcludesfilenamesthatendineitherbatorexe:\n.*[.](?!bat$|exe$)[^.]*$\n5 Modifying Strings\nUp to this point, we\u2019ve simply performed searches against a static string. Regular expressions are also commonly\nusedtomodifystringsinvariousways,usingthefollowingpatternmethods:\nMethod/Attribute Purpose\nsplit() Splitthestringintoalist,splittingitwherevertheREmatches\nsub() FindallsubstringswheretheREmatches,andreplacethemwithadifferentstring\nsubn() Doesthesamethingassub(),butreturnsthenewstringandthenumberofreplacements\n5.1 Splitting Strings\nThesplit()methodofapatternsplitsastringapartwherevertheREmatches,returningalistofthepieces. It\u2019s\nsimilartothesplit()methodofstringsbutprovidesmuchmoregeneralityinthedelimitersthatyoucansplitby;\nstringsplit()onlysupportssplittingbywhitespaceorbyafixedstring. Asyou\u2019dexpect, there\u2019samodule-level\nre.split()function,too.\n[ ]\n.split(string ,maxsplit=0 )\nSplitstringbythematchesoftheregularexpression. IfcapturingparenthesesareusedintheRE,thentheir\ncontents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are\nperformed.\nYoucanlimitthenumberofsplitsmade,bypassingavalueformaxsplit. Whenmaxsplitisnonzero,atmostmaxsplit\nsplits will be made, and the remainder of the string is returned as the final element of the list. In the following\nexample,thedelimiterisanysequenceofnon-alphanumericcharacters.\n14\n>>> p = re.compile(r'\\W+')\n>>> p.split('This is a test, short and sweet, of split().')\n['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n>>> p.split('This is a test, short and sweet, of split().', 3)\n['This', 'is', 'a', 'test, short and sweet, of split().']\nSometimesyou\u2019renotonlyinterestedinwhatthetextbetweendelimitersis,butalsoneedtoknowwhatthedelimiter\nwas. IfcapturingparenthesesareusedintheRE,thentheirvaluesarealsoreturnedaspartofthelist. Comparethe\nfollowingcalls:\n>>> p = re.compile(r'\\W+')\n>>> p2 = re.compile(r'(\\W+)')\n>>> p.split('This... is a test.')\n['This', 'is', 'a', 'test', '']\n>>> p2.split('This... is a test.')\n['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']\nThemodule-levelfunctionre.split()addstheREtobeusedasthefirstargument,butisotherwisethesame.\n>>> re.split(r'[\\W]+', 'Words, words, words.')\n['Words', 'words', 'words', '']\n>>> re.split(r'([\\W]+)', 'Words, words, words.')\n['Words', ', ', 'words', ', ', 'words', '.', '']\n>>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n['Words', 'words, words.']\n5.2 Search and Replace\nAnothercommontaskistofindallthematchesforapattern,andreplacethemwithadifferentstring. Thesub()\nmethodtakesareplacementvalue,whichcanbeeitherastringorafunction,andthestringtobeprocessed.\n[ ]\n.sub(replacement,string ,count=0 )\nReturnsthestringobtainedbyreplacingtheleftmostnon-overlappingoccurrencesoftheREinstringbythe\nreplacementreplacement. Ifthepatternisn\u2019tfound,stringisreturnedunchanged.\nTheoptionalargumentcountisthemaximumnumberofpatternoccurrencestobereplaced;countmustbea\nnon-negativeinteger. Thedefaultvalueof0meanstoreplacealloccurrences.\nHere\u2019sasimpleexampleofusingthesub()method. Itreplacescolournameswiththewordcolour:\n>>> p = re.compile('(blue|white|red)')\n>>> p.sub('colour', 'blue socks and red shoes')\n'colour socks and colour shoes'\n>>> p.sub('colour', 'blue socks and red shoes', count=1)\n'colour socks and red shoes'\nThesubn()methoddoesthesamework,butreturnsa2-tuplecontainingthenewstringvalueandthenumberof\nreplacementsthatwereperformed:\n>>> p = re.compile('(blue|white|red)')\n>>> p.subn('colour', 'blue socks and red shoes')\n('colour socks and colour shoes', 2)\n>>> p.subn('colour', 'no colours at all')\n('no colours at all', 0)\nEmptymatchesarereplacedonlywhenthey\u2019renotadjacenttoapreviousemptymatch.\n15\n>>> p = re.compile('x*')\n>>> p.sub('-', 'abxd')\n'-a-b--d-'\nIfreplacementisastring,anybackslashescapesinitareprocessed. Thatis,\\nisconvertedtoasinglenewlinechar-\nacter,\\risconvertedtoacarriagereturn,andsoforth. Unknownescapessuchas\\&areleftalone. Backreferences,\nsuchas\\6,arereplacedwiththesubstringmatchedbythecorrespondinggroupintheRE.Thisletsyouincorporate\nportionsoftheoriginaltextintheresultingreplacementstring.\nThis example matches the word section followed by a string enclosed in {, }, and changes section to\nsubsection:\n>>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n>>> p.sub(r'subsection{\\1}','section{First} section{second}')\n'subsection{First} subsection{second}'\nThere\u2019salsoasyntaxforreferringtonamedgroupsasdefinedbythe(?P<name>...)syntax. \\g<name>willuse\nthesubstringmatchedbythegroupnamedname,and\\g<number>usesthecorrespondinggroupnumber. \\g<2>is\nthereforeequivalentto\\2,butisn\u2019tambiguousinareplacementstringsuchas\\g<2>0. (\\20wouldbeinterpretedas\nareferencetogroup20,notareferencetogroup2followedbytheliteralcharacter'0'.) Thefollowingsubstitutions\nareallequivalent,butuseallthreevariationsofthereplacementstring.\n>>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n>>> p.sub(r'subsection{\\1}','section{First}')\n'subsection{First}'\n>>> p.sub(r'subsection{\\g<1>}','section{First}')\n'subsection{First}'\n>>> p.sub(r'subsection{\\g<name>}','section{First}')\n'subsection{First}'\nreplacement canalsobeafunction,whichgivesyouevenmorecontrol. Ifreplacement isafunction,thefunctionis\ncalledforeverynon-overlappingoccurrenceofpattern. Oneachcall,thefunctionispassedamatchobjectargument\nforthematchandcanusethisinformationtocomputethedesiredreplacementstringandreturnit.\nInthefollowingexample,thereplacementfunctiontranslatesdecimalsintohexadecimal:\n>>> def hexrepl(match):\n... \"Return the hex string for a decimal number\"\n... value = int(match.group())\n... return hex(value)\n...\n>>> p = re.compile(r'\\d+')\n>>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n'Call 0xffd2 for printing, 0xc000 for user code.'\nWhenusingthemodule-levelre.sub()function, thepatternispassedasthefirstargument. Thepatternmaybe\nprovided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern\nobjectasthefirstparameter,oruseembeddedmodifiersinthepatternstring,e.g. sub(\"(?i)b+\", \"x\", \"bbbb\nBBBB\")returns'x x'.\n6 Common Problems\nRegularexpressionsareapowerfultoolforsomeapplications, butinsomewaystheirbehaviourisn\u2019tintuitiveand\nattimestheydon\u2019tbehavethewayyoumayexpectthemto. Thissectionwillpointoutsomeofthemostcommon\npitfalls.\n16\n6.1 Use String Methods\nSometimes using the re module is a mistake. If you\u2019re matching a fixed string, or a single character class, and\nyou\u2019renotusinganyrefeaturessuchastheIGNORECASEflag,thenthefullpowerofregularexpressionsmaynotbe\nrequired. Stringshaveseveralmethodsforperformingoperationswithfixedstringsandthey\u2019reusuallymuchfaster,\nbecausetheimplementationisasinglesmallCloopthat\u2019sbeenoptimizedforthepurpose,insteadofthelarge,more\ngeneralizedregularexpressionengine.\nOneexamplemightbereplacingasinglefixedstringwithanotherone; forexample,youmightreplacewordwith\ndeed. re.sub()seemslikethefunctiontouseforthis,butconsiderthereplace()method. Notethatreplace()\nwillalsoreplacewordinsidewords,turningswordfishintosdeedfish,butthenaiveREwordwouldhavedone\nthat,too. (Toavoidperformingthesubstitutiononpartsofwords,thepatternwouldhavetobe\\bword\\b,inorder\ntorequirethatwordhaveawordboundaryoneitherside. Thistakesthejobbeyondreplace()\u2019sabilities.)\nAnothercommontaskisdeletingeveryoccurrenceofasinglecharacterfromastringorreplacingitwithanother\nsinglecharacter. Youmightdothiswithsomethinglikere.sub('\\n', ' ', S),buttranslate()iscapable\nofdoingbothtasksandwillbefasterthananyregularexpressionoperationcanbe.\nIn short, before turning to the re module, consider whether your problem can be solved with a faster and simpler\nstringmethod.\n6.2 match() versus search()\nThe match() function only checks if the RE matches at the beginning of the string while search() will scan\nforwardthrough the stringfor a match. It\u2019s important to keep this distinction inmind. Remember, match() will\nonlyreportasuccessfulmatchwhichwillstartat0;ifthematchwouldn\u2019tstartatzero,match()willnotreportit.\n>>> print(re.match('super', 'superstition').span())\n(0, 5)\n>>> print(re.match('super', 'insuperable'))\nNone\nOntheotherhand,search()willscanforwardthroughthestring,reportingthefirstmatchitfinds.\n>>> print(re.search('super', 'superstition').span())\n(0, 5)\n>>> print(re.search('super', 'insuperable').span())\n(2, 7)\nSometimes you\u2019ll be tempted to keep using re.match(), and just add .* to the front of your RE. Resist this\ntemptationandusere.search()instead. TheregularexpressioncompilerdoessomeanalysisofREsinorderto\nspeeduptheprocessoflookingforamatch. Onesuchanalysisfiguresoutwhatthefirstcharacterofamatchmust\nbe; forexample,apatternstartingwithCrowmustmatchstartingwitha'C'.Theanalysisletstheenginequickly\nscanthroughthestringlookingforthestartingcharacter,onlytryingthefullmatchifa'C'isfound.\nAdding.*defeatsthisoptimization,requiringscanningtotheendofthestringandthenbacktrackingtofindamatch\nfortherestoftheRE.Usere.search()instead.\n6.3 Greedy versus Non-Greedy\nWhenrepeatinga regularexpression, asin a*, theresultingactionistoconsumeasmuchofthepatternaspossi-\nble. Thisfactoftenbitesyouwhenyou\u2019retryingtomatchapairofbalanceddelimiters,suchastheanglebrackets\nsurroundinganHTMLtag. ThenaivepatternformatchingasingleHTMLtagdoesn\u2019tworkbecauseofthegreedy\nnatureof.*.\n>>> s = '<html><head><title>Title</title>'\n>>> len(s)\n32\n>>> print(re.match('<.*>', s).span())\n(0, 32)\n(continuesonnextpage)\n17\n(continuedfrompreviouspage)\n>>> print(re.match('<.*>', s).group())\n<html><head><title>Title</title>\nTheREmatchesthe'<'in'<html>',andthe.*consumestherestofthestring. There\u2019sstillmoreleftintheRE,\nthough, andthe>can\u2019tmatchattheendofthestring, sotheregularexpressionenginehastobacktrackcharacter\nby character until it finds a match for the >. The final match extends from the '<' in '<html>' to the '>' in\n'</title>',whichisn\u2019twhatyouwant.\nIn this case, the solution is to use the non-greedy quantifiers *?, +?, ??, or {m,n}?, which match as little text as\npossible. Intheaboveexample,the'>'istriedimmediatelyafterthefirst'<'matches,andwhenitfails,theengine\nadvancesacharacteratatime,retryingthe'>'ateverystep. Thisproducesjusttherightresult:\n>>> print(re.match('<.*?>', s).group())\n<html>\n(NotethatparsingHTMLorXMLwithregularexpressionsispainful. Quick-and-dirtypatternswillhandlecommon\ncases, but HTML and XML have special cases that will break the obvious regular expression; by the time you\u2019ve\nwritten a regular expression that handles all of the possible cases, the patterns will be very complicated. Use an\nHTMLorXMLparsermoduleforsuchtasks.)\n6.4 Using re.VERBOSE\nBynowyou\u2019veprobablynoticedthatregularexpressionsareaverycompactnotation,butthey\u2019renotterriblyreadable.\nREsofmoderatecomplexitycanbecomelengthycollectionsofbackslashes,parentheses,andmetacharacters,making\nthemdifficulttoreadandunderstand.\nFor such REs, specifying the re.VERBOSE flag when compiling the regular expression can be helpful, because it\nallowsyoutoformattheregularexpressionmoreclearly.\nThere.VERBOSEflaghasseveraleffects. Whitespaceintheregularexpressionthatisn\u2019t insideacharacterclassis\nignored. Thismeansthatanexpressionsuchasdog | catisequivalenttothelessreadabledog|cat,but[a b]\nwillstillmatchthecharacters'a','b',oraspace. Inaddition,youcanalsoputcommentsinsideaRE;comments\nextendfroma#charactertothenextnewline. Whenusedwithtriple-quotedstrings,thisenablesREstobeformatted\nmoreneatly:\npat = re.compile(r\"\"\"\n\\s* # Skip leading whitespace\n(?P<header>[^:]+) # Header name\n\\s* : # Whitespace, and a colon\n(?P<value>.*?) # The header's value -- *? used to\n# lose the following trailing whitespace\n\\s*$ # Trailing whitespace to end-of-line\n\"\"\", re.VERBOSE)\nThisisfarmorereadablethan:\npat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")\n7 Feedback\nRegularexpressionsareacomplicatedtopic. Didthisdocumenthelpyouunderstandthem? Weretherepartsthat\nwereunclear,orProblemsyouencounteredthatweren\u2019tcoveredhere? Ifso,pleasesendsuggestionsforimprovements\ntotheauthor.\nThemostcompletebookonregularexpressionsisalmostcertainlyJeffreyFriedl\u2019sMasteringRegularExpressions,\npublishedbyO\u2019Reilly. Unfortunately, itexclusivelyconcentratesonPerlandJava\u2019sflavoursofregularexpressions,\nanddoesn\u2019tcontainanyPythonmaterialatall,soitwon\u2019tbeusefulasareferenceforprogramminginPython. (The\nfirsteditioncoveredPython\u2019snow-removedregexmodule,whichwon\u2019thelpyoumuch.) Considercheckingitout\nfromyourlibrary.\n18\n",
  "context": "3.1 CompilingRegularExpressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n3.2 TheBackslashPlague . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n3.3 PerformingMatches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5",
  "source_file": "resources\\Year 3\\Python\\howto-regex.pdf",
  "line_numbers": [
    16,
    824
  ]
}
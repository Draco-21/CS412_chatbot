{
  "title": "Raw Socket",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "  \ud83d\udc49\u00a0Explanation",
  "code": "In this C program, we use a raw socket to receive and read network packets. Let's break down the important parts of the code:\nHeader Files:\u00a0\nThe necessary header files are included to access socket-related functions and structures.\nSocket Creation:\u00a0\nThe socket() function is called to create a raw socket. The arguments passed are AF_INET (IPv4), SOCK_RAW (raw socket type), and IPPROTO_ICMP (the protocol we want to capture, in this case, ICMP). Raw sockets allow us to receive all packets of the specified protocol.\nPacket Reception:\u00a0\nThe program enters a while loop to continuously read packets from the raw socket using the read() system call. The function reads up to 8192 bytes of data from the socket and stores it in the buff buffer.\nPacket Analysis:\u00a0\nThe received packet is then treated as an IP packet. We cast the buffer buff to a pointer of type struct iphdr (IP header structure) named ip. This allows us to access the IP header fields directly.\nSource and Destination Printing:\u00a0\nWe extract the source and destination IP addresses from the IP header using inet_ntoa, a function that converts IP addresses from binary to a readable string format. The extracted addresses are then printed to the console.\n\n\n\ud83c\udfaf Sample Output\n[root@localhost ~]# ./a.out\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\nSource: 172.16.29.123\u00a0\nDestnation: 172.16.29.60\n\n\n\ud83c\udfaf Summary\nIn this blog post, we explored the concept of raw sockets in Unix using C programming. We learned that raw sockets provide direct access to network protocols, allowing developers to handle IP packets at a low level. The C program provided reads ICMP packets from a raw socket and prints the source and destination IP addresses from each packet.\n\n\n\ud83c\udfaf Key Points\nRaw sockets offer direct access to network protocols at the network layer.\nThey are powerful tools for building custom protocols, network monitoring, and network security applications.\nThe C program demonstrated how to create and use a raw socket to read ICMP packets and extract IP addresses.\nLayer 2 Raw Socket Programming\nWe assume\u00a0the environment\u00a0introduced in the previous lecture. In this hands-on session, we will create data link raw sockets using Linux and Python 3 and try to send/receive data using sockets.\nHands-On with Sample Code\nStep 1. Preparation\nHere\u00a0is the sample code. (This session is based on this Python sample code. If you prefer C language, please refer to\u00a0the C version.)\nOpen the terminal and type:\n$ git clone https://github.com/y-sira/pyng.git\nYou can find network interface names and MAC addresses on your virtual machine using\u00a0ip\u00a0command as follows:\n$ ip link\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:dd:d7:43 brd ff:ff:ff:ff:ff:ff\n3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:b0:d6:ff brd ff:ff:ff:ff:ff:ff\n4: enp0s9: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:e6:4d:39 brd ff:ff:ff:ff:ff:ff\n5: enp0s10: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:8e:75:44 brd ff:ff:ff:ff:ff:ff\nPlease remember interface names and corresponding MAC addresses.\nStep 2. Start Packet Capture Using Wireshark\nOpen the terminal and type:\n$ sudo wireshark\nWireshark screen will be appeared.\n\nDouble click the interface name you want to monitor, then you can see packets sent to the interface.\n\nStep 3. Send/Receive Frames Using Layer 2 Raw Sockets\nMove to\u00a0pyng\u00a0directory and run the server script:\n$ cd /path/to/pyng\n$ sudo ./pyngd $SERVER_INTERFACE_NAME\nOpen another terminal, move to\u00a0pyng\u00a0directory, and run the client script to send the frame to the server:\n$ cd /path/to/pyng\n$ sudo ./pyng $DESTINATION_MAC_ADDRESS $CLIENT_INTERFACE_NAME\nSent!\nMake sure that the data client script sent is appeared in the server side terminal.\n\nStep 4. Check Frames with Wireshark\nStop packet capture. You can filter the packet by protocol, source address, destination address, \u2026, etc. Please enter\u00a0eth.type == 0x88b5\u00a0in the filter text box to check frames you sent.\n\nVerify the Ethernet header and the payload.\nStep 5. Considerations\nPlease consider below.\nWhat data is sent?\nWhy does the payload contain many zero?\nHow do we send/receive data in the sample code?\nWhat is\u00a0struct.pack('!6s6sH', ...)\u00a0in the server side script?\nWhat does the magic number\u00a00x88b5\u00a0mean?\nWhat kinds of packets are displayed in Wireshark?\nWhat does the MAC address\u00a0ff:ff:ff:ff:ff:ff\u00a0mean?\nWhat is\u00a0select\u00a0in the server side sample code?\nWhy do not use\u00a0recv()\u00a0directly?\nHow can we handle massive requests?\n\u2026\nFor Beginners\nSocket APIs\nThe socket APIs are APIs for interprocess communication and network communication from applications. It is available on UNIX and Linux. In Linux, it is easy to handle the data link layer by using the socket API. Let\u2019s explain Linux sockets later.\nData Link Raw Sockets\nIn order to send and receive data using socket APIs, we have to generate a socket descriptor. The socket descriptor can be generated using\u00a0int socket (int family, int type, int protocol)\u00a0defined in\u00a0sys/socket.h. The first argument\u00a0family\u00a0specifies the address family. For the data link layer, specify\u00a0AF_PACKET\u00a0defined in\u00a0sys/socket.h. The second argument\u00a0type\u00a0specifies the socket type. For the data link layer, specify\u00a0SOCK_RAW\u00a0defined in\u00a0sys/socket.h. The third argument\u00a0protocol\u00a0specifies the protocol. Specify\u00a0ETH_P_ALL\u00a0to retrieve any Ethernet frames, and specify\u00a0ETH_P_IP\u00a0to retrieve Ethernet frames containing a IP packet. The protocol types of the Ethernet frame is defined in\u00a0linux/if_ether.h.\nIn Python, there is a standard library that wraps the OS level socket APIs, so we will use it to create a data link raw socket. Please be careful to\u00a0close()\u00a0after using the socket.\nimport socket\nETH_P_ALL = 3\ns = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))\ns.close()\nWe use\u00a0bind()\u00a0to bind the network interface to the socket. You can check the network interface available on your computer with the following command.\n$ ip link\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:dd:d7:43 brd ff:ff:ff:ff:ff:ff\n3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:b0:d6:ff brd ff:ff:ff:ff:ff:ff\n4: enp0s9: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:e6:4d:39 brd ff:ff:ff:ff:ff:ff\n5: enp0s10: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\n    link/ether 08:00:27:8e:75:44 brd ff:ff:ff:ff:ff:ff\nFor example, to bind the network interface enp0s3 to the socket, write as follows.\nimport socket\nETH_P_ALL = 3\ninterface = 'enp0s3'\ns = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))\ns.bind((interface, 0))\n# do something\ns.close()\nNow you are ready to send and receive raw data on the data link layer using the network interface enp0s3.\nReceive Data Using Raw Sockets\nUse\u00a0recv()\u00a0to receive data using a socket. Specify the buffer size in first argument of\u00a0recv().\u00a0recv()\u00a0will block until ready to receive data from the socket. The return value of\u00a0recv()\u00a0is the received byte sequence. This byte string consists of the header and the payload of the Ethernet frame.\nWhen receiving data sent to enp0s3, the script\u00a0server.py\u00a0is as follows:\nimport socket\nETH_P_ALL = 3\nETH_FRAME_LEN = 1514  # Max. octets in frame sans FCS\ninterface = 'enp0s3'\ns = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))\ns.bind((interface, 0))\ndata = s.recv(ETH_FRAME_LEN)\nprint(data)           # => b'\\x08\\x00\\x27\\xdd\\xd7\\x43\\x08\\x00\\x27\\x8e\\x75\\x44\\x88\\xb5Hi'\ns.close()\nNote that the data link raw sockets require a root permission. Please run the above script as root.\nWhen the data is sent to enp0s3, you can get the following output:\n$ sudo python3 server.py\nb\"\\x08\\x00'\\xdd\\xd7C\\x08\\x00'\\x8euD\\x88\\xb5Hi\"\nSend Data Using Raw Sockets\nTo send data using a socket, use\u00a0sendall(). The data to be sent must be a byte sequence containing the header and payload of the Ethernet frame.\nWhen sending data \u201cHi\u201d from enp0s10 (08:00:27:8e:75:44) to enp0s3 (08:00:27:dd:d7:43), the script\u00a0client.py\u00a0is as follows:\nimport socket\nETH_P_ALL = 3\ninterface = 'enp0s10'\ndst = b'\\x08\\x00\\x27\\xdd\\xd7\\x43'  # destination MAC address\nsrc = b'\\x08\\x00\\x27\\x8e\\x75\\x44'  # source MAC address\nproto = b'\\x88\\xb5'                # ethernet frame type\npayload = 'Hi'.encode()            # payload\ns = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))\ns.bind((interface, 0))\ns.sendall(dst + src + proto + payload)\ns.close()\nThen,\n$ sudo python3 client.py\nSent!\nMake sure that the server side terminal outputs the data you sent.\nsocket\u00a0\u2014 Low-level networking interface\nSource code:\u00a0Lib/socket.py\n\nThis module provides access to the BSD\u00a0socket\u00a0interface. It is available on all modern Unix systems, Windows, MacOS, and probably additional platforms.\nNote\n\u00a0\nSome behavior may be platform dependent, since calls are made to the operating system socket APIs.\nAvailability: not WASI.\nThis module does not work or is not available on WebAssembly. See\u00a0WebAssembly platforms\u00a0for more information.\nThe Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python\u2019s object-oriented style: the\u00a0socket()\u00a0function returns a\u00a0socket object\u00a0whose methods implement the various socket system calls. Parameter types are somewhat higher-level than in the C interface: as with\u00a0read()\u00a0and\u00a0write()\u00a0operations on Python files, buffer allocation on receive operations is automatic, and buffer length is implicit on send operations.\nSee also\nModule\u00a0socketserver\nClasses that simplify writing network servers.\nModule\u00a0ssl\nA TLS/SSL wrapper for socket objects.\nSocket families\nDepending on the system and the build options, various socket families are supported by this module.\nThe address format required by a particular socket object is automatically selected based on the address family specified when the socket object was created. Socket addresses are represented as follows:\nThe address of an\u00a0AF_UNIX\u00a0socket bound to a file system node is represented as a string, using the file system encoding and the\u00a0'surrogateescape'\u00a0error handler (see\u00a0PEP 383). An address in Linux\u2019s abstract namespace is returned as a\u00a0bytes-like object\u00a0with an initial null byte; note that sockets in this namespace can communicate with normal file system sockets, so programs intended to run on Linux may need to deal with both types of address. A string or bytes-like object can be used for either type of address when passing it as an argument.\nChanged in version 3.3:\u00a0Previously,\u00a0AF_UNIX\u00a0socket paths were assumed to use UTF-8 encoding.\nChanged in version 3.5:\u00a0Writable\u00a0bytes-like object\u00a0is now accepted.\nA pair\u00a0(host,\u00a0port)\u00a0is used for the\u00a0AF_INET\u00a0address family, where\u00a0host\u00a0is a string representing either a hostname in internet domain notation like\u00a0'daring.cwi.nl'\u00a0or an IPv4 address like\u00a0'100.50.200.5', and\u00a0port\u00a0is an integer.\nFor IPv4 addresses, two special forms are accepted instead of a host address:\u00a0''\u00a0represents\u00a0INADDR_ANY, which is used to bind to all interfaces, and the string\u00a0'<broadcast>'\u00a0represents\u00a0INADDR_BROADCAST. This behavior is not compatible with IPv6, therefore, you may want to avoid these if you intend to support IPv6 with your Python programs.\nFor\u00a0AF_INET6\u00a0address family, a four-tuple\u00a0(host,\u00a0port,\u00a0flowinfo,\u00a0scope_id)\u00a0is used, where\u00a0flowinfo\u00a0and\u00a0scope_id\u00a0represent the\u00a0sin6_flowinfo\u00a0and\u00a0sin6_scope_id\u00a0members in\u00a0struct\u00a0sockaddr_in6\u00a0in C. For\u00a0socket\u00a0module methods,\u00a0flowinfo\u00a0and\u00a0scope_id\u00a0can be omitted just for backward compatibility. Note, however, omission of\u00a0scope_id\u00a0can cause problems in manipulating scoped IPv6 addresses.\nChanged in version 3.7:\u00a0For multicast addresses (with\u00a0scope_id\u00a0meaningful)\u00a0address\u00a0may not contain\u00a0%scope_id\u00a0(or\u00a0zone\u00a0id) part. This information is superfluous and may be safely omitted (recommended).\nAF_NETLINK\u00a0sockets are represented as pairs\u00a0(pid,\u00a0groups).\nLinux-only support for TIPC is available using the\u00a0AF_TIPC\u00a0address family. TIPC is an open, non-IP based networked protocol designed for use in clustered computer environments. Addresses are represented by a tuple, and the fields depend on the address type. The general tuple form is\u00a0(addr_type,\u00a0v1,\u00a0v2,\u00a0v3\u00a0[,\u00a0scope]), where:\naddr_type\u00a0is one of\u00a0TIPC_ADDR_NAMESEQ,\u00a0TIPC_ADDR_NAME, or\u00a0TIPC_ADDR_ID.\nscope\u00a0is one of\u00a0TIPC_ZONE_SCOPE,\u00a0TIPC_CLUSTER_SCOPE, and\u00a0TIPC_NODE_SCOPE.\nIf\u00a0addr_type\u00a0is\u00a0TIPC_ADDR_NAME, then\u00a0v1\u00a0is the server type,\u00a0v2\u00a0is the port identifier, and\u00a0v3\u00a0should be 0.\nIf\u00a0addr_type\u00a0is\u00a0TIPC_ADDR_NAMESEQ, then\u00a0v1\u00a0is the server type,\u00a0v2\u00a0is the lower port number, and\u00a0v3\u00a0is the upper port number.\nIf\u00a0addr_type\u00a0is\u00a0TIPC_ADDR_ID, then\u00a0v1\u00a0is the node,\u00a0v2\u00a0is the reference, and\u00a0v3\u00a0should be set to 0.\nA tuple\u00a0(interface,\u00a0)\u00a0is used for the\u00a0AF_CAN\u00a0address family, where\u00a0interface\u00a0is a string representing a network interface name like\u00a0'can0'. The network interface name\u00a0''\u00a0can be used to receive packets from all network interfaces of this family.\nCAN_ISOTP\u00a0protocol require a tuple\u00a0(interface,\u00a0rx_addr,\u00a0tx_addr)\u00a0where both additional parameters are unsigned long integer that represent a CAN identifier (standard or extended).\nCAN_J1939\u00a0protocol require a tuple\u00a0(interface,\u00a0name,\u00a0pgn,\u00a0addr)\u00a0where additional parameters are 64-bit unsigned integer representing the ECU name, a 32-bit unsigned integer representing the Parameter Group Number (PGN), and an 8-bit integer representing the address.\nA string or a tuple\u00a0(id,\u00a0unit)\u00a0is used for the\u00a0SYSPROTO_CONTROL\u00a0protocol of the\u00a0PF_SYSTEM\u00a0family. The string is the name of a kernel control using a dynamically assigned ID. The tuple can be used if ID and unit number of the kernel control are known or if a registered ID is used.\nAdded in version 3.3.\nAF_BLUETOOTH\u00a0supports the following protocols and address formats:\nBTPROTO_L2CAP\u00a0accepts\u00a0(bdaddr,\u00a0psm)\u00a0where\u00a0bdaddr\u00a0is the Bluetooth address as a string and\u00a0psm\u00a0is an integer.\nBTPROTO_RFCOMM\u00a0accepts\u00a0(bdaddr,\u00a0channel)\u00a0where\u00a0bdaddr\u00a0is the Bluetooth address as a string and\u00a0channel\u00a0is an integer.\nBTPROTO_HCI\u00a0accepts a format that depends on your OS.\nOn Linux it accepts a tuple\u00a0(device_id,)\u00a0where\u00a0device_id\u00a0is an integer specifying the number of the Bluetooth device.\nOn FreeBSD, NetBSD and DragonFly BSD it accepts\u00a0bdaddr\u00a0where\u00a0bdaddr\u00a0is the Bluetooth address as a string.\nChanged in version 3.2:\u00a0NetBSD and DragonFlyBSD support added.\nChanged in version 3.13.3:\u00a0FreeBSD support added.\nBTPROTO_SCO\u00a0accepts\u00a0bdaddr\u00a0where\u00a0bdaddr\u00a0is the Bluetooth address as a string or a\u00a0bytes\u00a0object. (ex.\u00a0'12:23:34:45:56:67'\u00a0or\u00a0b'12:23:34:45:56:67') This protocol is not supported under FreeBSD.\nAF_ALG\u00a0is a Linux-only socket based interface to Kernel cryptography. An algorithm socket is configured with a tuple of two to four elements\u00a0(type,\u00a0name\u00a0[,\u00a0feat\u00a0[,\u00a0mask]]), where:\ntype\u00a0is the algorithm type as string, e.g.\u00a0aead,\u00a0hash,\u00a0skcipher\u00a0or\u00a0rng.\nname\u00a0is the algorithm name and operation mode as string, e.g.\u00a0sha256,\u00a0hmac(sha256),\u00a0cbc(aes)\u00a0or\u00a0drbg_nopr_ctr_aes256.\nfeat\u00a0and\u00a0mask\u00a0are unsigned 32bit integers.\nAvailability: Linux >= 2.6.38.\nSome algorithm types require more recent Kernels.\nAdded in version 3.6.\nAF_VSOCK\u00a0allows communication between virtual machines and their hosts. The sockets are represented as a\u00a0(CID,\u00a0port)\u00a0tuple where the context ID or CID and port are integers.\nAvailability: Linux >= 3.9\nSee\u00a0vsock(7)\nAdded in version 3.7.\nAF_PACKET\u00a0is a low-level interface directly to network devices. The addresses are represented by the tuple\u00a0(ifname,\u00a0proto[,\u00a0pkttype[,\u00a0hatype[,\u00a0addr]]])\u00a0where:\nifname\u00a0- String specifying the device name.\nproto\u00a0- The Ethernet protocol number. May be\u00a0ETH_P_ALL\u00a0to capture all protocols, one of the\u00a0ETHERTYPE_* constants\u00a0or any other Ethernet protocol number.\npkttype\u00a0- Optional integer specifying the packet type:\nPACKET_HOST\u00a0(the default) - Packet addressed to the local host.\nPACKET_BROADCAST\u00a0- Physical-layer broadcast packet.\nPACKET_MULTICAST\u00a0- Packet sent to a physical-layer multicast address.\nPACKET_OTHERHOST\u00a0- Packet to some other host that has been caught by a device driver in promiscuous mode.\nPACKET_OUTGOING\u00a0- Packet originating from the local host that is looped back to a packet socket.\nhatype\u00a0- Optional integer specifying the ARP hardware address type.\naddr\u00a0- Optional bytes-like object specifying the hardware physical address, whose interpretation depends on the device.\nAvailability: Linux >= 2.2.\nAF_QIPCRTR\u00a0is a Linux-only socket based interface for communicating with services running on co-processors in Qualcomm platforms. The address family is represented as a\u00a0(node,\u00a0port)\u00a0tuple where the\u00a0node\u00a0and\u00a0port\u00a0are non-negative integers.\nAvailability: Linux >= 4.7.\nAdded in version 3.8.\nIPPROTO_UDPLITE\u00a0is a variant of UDP which allows you to specify what portion of a packet is covered with the checksum. It adds two socket options that you can change.\u00a0self.setsockopt(IPPROTO_UDPLITE,\u00a0UDPLITE_SEND_CSCOV,\u00a0length)\u00a0will change what portion of outgoing packets are covered by the checksum and\u00a0self.setsockopt(IPPROTO_UDPLITE,\u00a0UDPLITE_RECV_CSCOV,\u00a0length)\u00a0will filter out packets which cover too little of their data. In both cases\u00a0length\u00a0should be in\u00a0range(8,\u00a02**16,\u00a08).\nSuch a socket should be constructed with\u00a0socket(AF_INET,\u00a0SOCK_DGRAM,\u00a0IPPROTO_UDPLITE)\u00a0for IPv4 or\u00a0socket(AF_INET6,\u00a0SOCK_DGRAM,\u00a0IPPROTO_UDPLITE)\u00a0for IPv6.\nAvailability: Linux >= 2.6.20, FreeBSD >= 10.1\nAdded in version 3.9.\nAF_HYPERV\u00a0is a Windows-only socket based interface for communicating with Hyper-V hosts and guests. The address family is represented as a\u00a0(vm_id,\u00a0service_id)\u00a0tuple where the\u00a0vm_id\u00a0and\u00a0service_id\u00a0are UUID strings.\nThe\u00a0vm_id\u00a0is the virtual machine identifier or a set of known VMID values if the target is not a specific virtual machine. Known VMID constants defined on\u00a0socket\u00a0are:\nHV_GUID_ZERO\nHV_GUID_BROADCAST\nHV_GUID_WILDCARD\u00a0- Used to bind on itself and accept connections from all partitions.\nHV_GUID_CHILDREN\u00a0- Used to bind on itself and accept connection from child partitions.\nHV_GUID_LOOPBACK\u00a0- Used as a target to itself.\nHV_GUID_PARENT\u00a0- When used as a bind accepts connection from the parent partition. When used as an address target it will connect to the parent partition.\nThe\u00a0service_id\u00a0is the service identifier of the registered service.\nAdded in version 3.12.\nIf you use a hostname in the\u00a0host\u00a0portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. For deterministic behavior use a numeric address in\u00a0host\u00a0portion.\nAll errors raise exceptions. The normal exceptions for invalid argument types and out-of-memory conditions can be raised. Errors related to socket or address semantics raise\u00a0OSError\u00a0or one of its subclasses.\nNon-blocking mode is supported through\u00a0setblocking(). A generalization of this based on timeouts is supported through\u00a0settimeout().\nModule contents\nThe module\u00a0socket\u00a0exports the following elements.\nExceptions\nexception\u00a0socket.error\nA deprecated alias of\u00a0OSError.\nChanged in version 3.3:\u00a0Following\u00a0PEP 3151, this class was made an alias of\u00a0OSError.\nexception\u00a0socket.herror\nA subclass of\u00a0OSError, this exception is raised for address-related errors, i.e. for functions that use\u00a0h_errno\u00a0in the POSIX C API, including\u00a0gethostbyname_ex()\u00a0and\u00a0gethostbyaddr(). The accompanying value is a pair\u00a0(h_errno,\u00a0string)\u00a0representing an error returned by a library call.\u00a0h_errno\u00a0is a numeric value, while\u00a0string\u00a0represents the description of\u00a0h_errno, as returned by the\u00a0hstrerror()\u00a0C function.\nChanged in version 3.3:\u00a0This class was made a subclass of\u00a0OSError.\nexception\u00a0socket.gaierror\nA subclass of\u00a0OSError, this exception is raised for address-related errors by\u00a0getaddrinfo()\u00a0and\u00a0getnameinfo(). The accompanying value is a pair\u00a0(error,\u00a0string)\u00a0representing an error returned by a library call.\u00a0string\u00a0represents the description of\u00a0error, as returned by the\u00a0gai_strerror()\u00a0C function. The numeric\u00a0error\u00a0value will match one of the\u00a0EAI_*\u00a0constants defined in this module.\nChanged in version 3.3:\u00a0This class was made a subclass of\u00a0OSError.\nexception\u00a0socket.timeout\nA deprecated alias of\u00a0TimeoutError.\nA subclass of\u00a0OSError, this exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to\u00a0settimeout()\u00a0(or implicitly through\u00a0setdefaulttimeout()). The accompanying value is a string whose value is currently always \u201ctimed out\u201d.\nChanged in version 3.3:\u00a0This class was made a subclass of\u00a0OSError.\nChanged in version 3.10:\u00a0This class was made an alias of\u00a0TimeoutError.\nConstants\nThe AF_* and SOCK_* constants are now\u00a0AddressFamily\u00a0and\u00a0SocketKind\u00a0IntEnum\u00a0collections.\nAdded in version 3.4.\nsocket.AF_UNIX\nsocket.AF_INET\nsocket.AF_INET6\nThese constants represent the address (and protocol) families, used for the first argument to\u00a0socket(). If the\u00a0AF_UNIX\u00a0constant is not defined then this protocol is unsupported. More constants may be available depending on the system.\nsocket.AF_UNSPEC\nAF_UNSPEC\u00a0means that\u00a0getaddrinfo()\u00a0should return socket addresses for any address family (either IPv4, IPv6, or any other) that can be used.\nsocket.SOCK_STREAM\nsocket.SOCK_DGRAM\nsocket.SOCK_RAW\nsocket.SOCK_RDM\nsocket.SOCK_SEQPACKET\nThese constants represent the socket types, used for the second argument to\u00a0socket(). More constants may be available depending on the system. (Only\u00a0SOCK_STREAM\u00a0and\u00a0SOCK_DGRAM\u00a0appear to be generally useful.)\nsocket.SOCK_CLOEXEC\nsocket.SOCK_NONBLOCK\nThese two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).\nSee also\n\u00a0\nSecure File Descriptor Handling\u00a0for a more thorough explanation.\nAvailability: Linux >= 2.6.27.\nAdded in version 3.2.\nSO_*\nsocket.SOMAXCONN\nMSG_*\nSOL_*\nSCM_*\nIPPROTO_*\nIPPORT_*\nINADDR_*\nIP_*\nIPV6_*\nEAI_*\nAI_*\nNI_*\nTCP_*\nMany constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module. They are generally used in arguments to the\u00a0setsockopt()\u00a0and\u00a0getsockopt()\u00a0methods of socket objects. In most cases, only those symbols that are defined in the Unix header files are defined; for a few symbols, default values are provided.\nChanged in version 3.6:\u00a0SO_DOMAIN,\u00a0SO_PROTOCOL,\u00a0SO_PEERSEC,\u00a0SO_PASSSEC,\u00a0TCP_USER_TIMEOUT,\u00a0TCP_CONGESTION\u00a0were added.\nChanged in version 3.6.5:\u00a0On Windows,\u00a0TCP_FASTOPEN,\u00a0TCP_KEEPCNT\u00a0appear if run-time Windows supports.\nChanged in version 3.7:\u00a0TCP_NOTSENT_LOWAT\u00a0was added.\nOn Windows,\u00a0TCP_KEEPIDLE,\u00a0TCP_KEEPINTVL\u00a0appear if run-time Windows supports.\nChanged in version 3.10:\u00a0IP_RECVTOS\u00a0was added. Added\u00a0TCP_KEEPALIVE. On MacOS this constant can be used in the same way that\u00a0TCP_KEEPIDLE\u00a0is used on Linux.\nChanged in version 3.11:\u00a0Added\u00a0TCP_CONNECTION_INFO. On MacOS this constant can be used in the same way that\u00a0TCP_INFO\u00a0is used on Linux and BSD.\nChanged in version 3.12:\u00a0Added\u00a0SO_RTABLE\u00a0and\u00a0SO_USER_COOKIE. On OpenBSD and FreeBSD respectively those constants can be used in the same way that\u00a0SO_MARK\u00a0is used on Linux. Also added missing TCP socket options from Linux:\u00a0TCP_MD5SIG,\u00a0TCP_THIN_LINEAR_TIMEOUTS,\u00a0TCP_THIN_DUPACK,\u00a0TCP_REPAIR,\u00a0TCP_REPAIR_QUEUE,\u00a0TCP_QUEUE_SEQ,\u00a0TCP_REPAIR_OPTIONS,\u00a0TCP_TIMESTAMP,\u00a0TCP_CC_INFO,\u00a0TCP_SAVE_SYN,\u00a0TCP_SAVED_SYN,\u00a0TCP_REPAIR_WINDOW,\u00a0TCP_FASTOPEN_CONNECT,\u00a0TCP_ULP,\u00a0TCP_MD5SIG_EXT,\u00a0TCP_FASTOPEN_KEY,\u00a0TCP_FASTOPEN_NO_COOKIE,\u00a0TCP_ZEROCOPY_RECEIVE,\u00a0TCP_INQ,\u00a0TCP_TX_DELAY. Added\u00a0IP_PKTINFO,\u00a0IP_UNBLOCK_SOURCE,\u00a0IP_BLOCK_SOURCE,\u00a0IP_ADD_SOURCE_MEMBERSHIP,\u00a0IP_DROP_SOURCE_MEMBERSHIP.\nChanged in version 3.13:\u00a0Added\u00a0SO_BINDTOIFINDEX. On Linux this constant can be used in the same way that\u00a0SO_BINDTODEVICE\u00a0is used, but with the index of a network interface instead of its name.\nsocket.AF_CAN\nsocket.PF_CAN\nSOL_CAN_*\nCAN_*\nMany constants of these forms, documented in the Linux documentation, are also defined in the socket module.\nAvailability: Linux >= 2.6.25, NetBSD >= 8.\nAdded in version 3.3.\nChanged in version 3.11:\u00a0NetBSD support was added.\nChanged in version 3.13.3 (unreleased):\u00a0Restored missing\u00a0CAN_RAW_ERR_FILTER\u00a0on Linux.\nsocket.CAN_BCM\nCAN_BCM_*\nCAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) protocol. Broadcast manager constants, documented in the Linux documentation, are also defined in the socket module.\nAvailability: Linux >= 2.6.25.\nNote\n\u00a0\nThe\u00a0CAN_BCM_CAN_FD_FRAME\u00a0flag is only available on Linux >= 4.8.\nAdded in version 3.4.\nsocket.CAN_RAW_FD_FRAMES\nEnables CAN FD support in a CAN_RAW socket. This is disabled by default. This allows your application to send both CAN and CAN FD frames; however, you must accept both CAN and CAN FD frames when reading from the socket.\nThis constant is documented in the Linux documentation.\nAvailability: Linux >= 3.6.\nAdded in version 3.5.\nsocket.CAN_RAW_JOIN_FILTERS\nJoins the applied CAN filters such that only CAN frames that match all given CAN filters are passed to user space.\nThis constant is documented in the Linux documentation.\nAvailability: Linux >= 4.1.\nAdded in version 3.9.\nsocket.CAN_ISOTP\nCAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. ISO-TP constants, documented in the Linux documentation.\nAvailability: Linux >= 2.6.25.\nAdded in version 3.7.\nsocket.CAN_J1939\nCAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 constants, documented in the Linux documentation.\nAvailability: Linux >= 5.4.\nAdded in version 3.9.\nsocket.AF_DIVERT\nsocket.PF_DIVERT\nThese two constants, documented in the FreeBSD divert(4) manual page, are also defined in the socket module.\nAvailability: FreeBSD >= 14.0.\nAdded in version 3.12.\nsocket.AF_PACKET\nsocket.PF_PACKET\nPACKET_*\nMany constants of these forms, documented in the Linux documentation, are also defined in the socket module.\nAvailability: Linux >= 2.2.\nsocket.ETH_P_ALL\nETH_P_ALL\u00a0can be used in the\u00a0socket\u00a0constructor as\u00a0proto\u00a0for the\u00a0AF_PACKET\u00a0family in order to capture every packet, regardless of protocol.\nFor more information, see the\u00a0packet(7)\u00a0manpage.\nAvailability: Linux.\nAdded in version 3.12.\nsocket.AF_RDS\nsocket.PF_RDS\nsocket.SOL_RDS\nRDS_*\nMany constants of these forms, documented in the Linux documentation, are also defined in the socket module.\nAvailability: Linux >= 2.6.30.\nAdded in version 3.3.\nsocket.SIO_RCVALL\nsocket.SIO_KEEPALIVE_VALS\nsocket.SIO_LOOPBACK_FAST_PATH\nRCVALL_*\nConstants for Windows\u2019 WSAIoctl(). The constants are used as arguments to the\u00a0ioctl()\u00a0method of socket objects.\nChanged in version 3.6:\u00a0SIO_LOOPBACK_FAST_PATH\u00a0was added.\nTIPC_*\nTIPC related constants, matching the ones exported by the C socket API. See the TIPC documentation for more information.\nsocket.AF_ALG\nsocket.SOL_ALG\nALG_*\nConstants for Linux Kernel cryptography.\nAvailability: Linux >= 2.6.38.\nAdded in version 3.6.\nsocket.AF_VSOCK\nsocket.IOCTL_VM_SOCKETS_GET_LOCAL_CID\nVMADDR*\nSO_VM*\nConstants for Linux host/guest communication.\nAvailability: Linux >= 4.8.\nAdded in version 3.7.\nsocket.AF_LINK\nAvailability: BSD, macOS.\nAdded in version 3.4.\nsocket.has_ipv6\nThis constant contains a boolean value which indicates if IPv6 is supported on this platform.\nsocket.BDADDR_ANY\nsocket.BDADDR_LOCAL\nThese are string constants containing Bluetooth addresses with special meanings. For example,\u00a0BDADDR_ANY\u00a0can be used to indicate any address when specifying the binding socket with\u00a0BTPROTO_RFCOMM.\nsocket.HCI_FILTER\nsocket.HCI_TIME_STAMP\nsocket.HCI_DATA_DIR\nFor use with\u00a0BTPROTO_HCI.\u00a0HCI_FILTER\u00a0is only available on Linux and FreeBSD.\u00a0HCI_TIME_STAMP\u00a0and\u00a0HCI_DATA_DIR\u00a0are only available on Linux.\nsocket.AF_QIPCRTR\nConstant for Qualcomm\u2019s IPC router protocol, used to communicate with service providing remote processors.\nAvailability: Linux >= 4.7.\nsocket.SCM_CREDS2\nsocket.LOCAL_CREDS\nsocket.LOCAL_CREDS_PERSISTENT\nLOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT sends for each read, SCM_CREDS2 must be then used for the latter for the message type.\nAdded in version 3.11.\nAvailability: FreeBSD.\nsocket.SO_INCOMING_CPU\nConstant to optimize CPU locality, to be used in conjunction with\u00a0SO_REUSEPORT.\nAdded in version 3.11.\nAvailability: Linux >= 3.9\nsocket.AF_HYPERV\nsocket.HV_PROTOCOL_RAW\nsocket.HVSOCKET_CONNECT_TIMEOUT\nsocket.HVSOCKET_CONNECT_TIMEOUT_MAX\nsocket.HVSOCKET_CONNECTED_SUSPEND\nsocket.HVSOCKET_ADDRESS_FLAG_PASSTHRU\nsocket.HV_GUID_ZERO\nsocket.HV_GUID_WILDCARD\nsocket.HV_GUID_BROADCAST\nsocket.HV_GUID_CHILDREN\nsocket.HV_GUID_LOOPBACK\nsocket.HV_GUID_PARENT\nConstants for Windows Hyper-V sockets for host/guest communications.\nAvailability: Windows.\nAdded in version 3.12.\nsocket.ETHERTYPE_ARP\nsocket.ETHERTYPE_IP\nsocket.ETHERTYPE_IPV6\nsocket.ETHERTYPE_VLAN\nIEEE 802.3 protocol number. constants.\nAvailability: Linux, FreeBSD, macOS.\nAdded in version 3.12.\nsocket.SHUT_RD\nsocket.SHUT_WR\nsocket.SHUT_RDWR\nThese constants are used by the\u00a0shutdown()\u00a0method of socket objects.\nAvailability: not WASI.\nFunctions\nCreating sockets\nThe following functions all create\u00a0socket objects.\nclass\u00a0socket.socket(family=AF_INET,\u00a0type=SOCK_STREAM,\u00a0proto=0,\u00a0fileno=None)\nCreate a new socket using the given address family, socket type and protocol number. The address family should be\u00a0AF_INET\u00a0(the default),\u00a0AF_INET6,\u00a0AF_UNIX,\u00a0AF_CAN,\u00a0AF_PACKET, or\u00a0AF_RDS. The socket type should be\u00a0SOCK_STREAM\u00a0(the default),\u00a0SOCK_DGRAM,\u00a0SOCK_RAW\u00a0or perhaps one of the other\u00a0SOCK_\u00a0constants. The protocol number is usually zero and may be omitted or in the case where the address family is\u00a0AF_CAN\u00a0the protocol should be one of\u00a0CAN_RAW,\u00a0CAN_BCM,\u00a0CAN_ISOTP\u00a0or\u00a0CAN_J1939.\nIf\u00a0fileno\u00a0is specified, the values for\u00a0family,\u00a0type, and\u00a0proto\u00a0are auto-detected from the specified file descriptor. Auto-detection can be overruled by calling the function with explicit\u00a0family,\u00a0type, or\u00a0proto\u00a0arguments. This only affects how Python represents e.g. the return value of\u00a0socket.getpeername()\u00a0but not the actual OS resource. Unlike\u00a0socket.fromfd(),\u00a0fileno\u00a0will return the same socket and not a duplicate. This may help close a detached socket using\u00a0socket.close().\nThe newly created socket is\u00a0non-inheritable.\nRaises an\u00a0auditing event\u00a0socket.__new__\u00a0with arguments\u00a0self,\u00a0family,\u00a0type,\u00a0protocol.\nChanged in version 3.3:\u00a0The AF_CAN family was added. The AF_RDS family was added.\nChanged in version 3.4:\u00a0The CAN_BCM protocol was added.\nChanged in version 3.4:\u00a0The returned socket is now non-inheritable.\nChanged in version 3.7:\u00a0The CAN_ISOTP protocol was added.\nChanged in version 3.7:\u00a0When\u00a0SOCK_NONBLOCK\u00a0or\u00a0SOCK_CLOEXEC\u00a0bit flags are applied to\u00a0type\u00a0they are cleared, and\u00a0socket.type\u00a0will not reflect them. They are still passed to the underlying system\u00a0socket()\u00a0call. Therefore,\nCopy\nsock = socket.socket(\n    socket.AF_INET,\n    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)\nwill still create a non-blocking socket on OSes that support\u00a0SOCK_NONBLOCK, but\u00a0sock.type\u00a0will be set to\u00a0socket.SOCK_STREAM.\nChanged in version 3.9:\u00a0The CAN_J1939 protocol was added.\nChanged in version 3.10:\u00a0The IPPROTO_MPTCP protocol was added.\nsocket.socketpair([family[,\u00a0type[,\u00a0proto]]])\nBuild a pair of connected socket objects using the given address family, socket type, and protocol number. Address family, socket type, and protocol number are as for the\u00a0socket()\u00a0function above. The default family is\u00a0AF_UNIX\u00a0if defined on the platform; otherwise, the default is\u00a0AF_INET.\nThe newly created sockets are\u00a0non-inheritable.\nChanged in version 3.2:\u00a0The returned socket objects now support the whole socket API, rather than a subset.\nChanged in version 3.4:\u00a0The returned sockets are now non-inheritable.\nChanged in version 3.5:\u00a0Windows support added.\nsocket.create_connection(address,\u00a0timeout=GLOBAL_DEFAULT,\u00a0source_address=None,\u00a0*,\u00a0all_errors=False)\nConnect to a TCP service listening on the internet\u00a0address\u00a0(a 2-tuple\u00a0(host,\u00a0port)), and return the socket object. This is a higher-level function than\u00a0socket.connect(): if\u00a0host\u00a0is a non-numeric hostname, it will try to resolve it for both\u00a0AF_INET\u00a0and\u00a0AF_INET6, and then try to connect to all possible addresses in turn until a connection succeeds. This makes it easy to write clients that are compatible to both IPv4 and IPv6.\nPassing the optional\u00a0timeout\u00a0parameter will set the timeout on the socket instance before attempting to connect. If no\u00a0timeout\u00a0is supplied, the global default timeout setting returned by\u00a0getdefaulttimeout()\u00a0is used.\nIf supplied,\u00a0source_address\u00a0must be a 2-tuple\u00a0(host,\u00a0port)\u00a0for the socket to bind to as its source address before connecting. If host or port are \u2018\u2019 or 0 respectively the OS default behavior will be used.\nWhen a connection cannot be created, an exception is raised. By default, it is the exception from the last address in the list. If\u00a0all_errors\u00a0is\u00a0True, it is an\u00a0ExceptionGroup\u00a0containing the errors of all attempts.\nChanged in version 3.2:\u00a0source_address\u00a0was added.\nChanged in version 3.11:\u00a0all_errors\u00a0was added.\nsocket.create_server(address,\u00a0*,\u00a0family=AF_INET,\u00a0backlog=None,\u00a0reuse_port=False,\u00a0dualstack_ipv6=False)\nConvenience function which creates a TCP socket bound to\u00a0address\u00a0(a 2-tuple\u00a0(host,\u00a0port)) and returns the socket object.\nfamily\u00a0should be either\u00a0AF_INET\u00a0or\u00a0AF_INET6.\u00a0backlog\u00a0is the queue size passed to\u00a0socket.listen(); if not specified , a default reasonable value is chosen.\u00a0reuse_port\u00a0dictates whether to set the\u00a0SO_REUSEPORT\u00a0socket option.\nIf\u00a0dualstack_ipv6\u00a0is true,\u00a0family\u00a0is\u00a0AF_INET6\u00a0and the platform supports it the socket will be able to accept both IPv4 and IPv6 connections, else it will raise\u00a0ValueError. Most POSIX platforms and Windows are supposed to support this functionality. When this functionality is enabled the address returned by\u00a0socket.getpeername()\u00a0when an IPv4 connection occurs will be an IPv6 address represented as an IPv4-mapped IPv6 address. If\u00a0dualstack_ipv6\u00a0is false it will explicitly disable this functionality on platforms that enable it by default (e.g. Linux). This parameter can be used in conjunction with\u00a0has_dualstack_ipv6():\nCopy\nimport socket\n\naddr = (\"\", 8080)  # all interfaces, port 8080\nif socket.has_dualstack_ipv6():\n    s = socket.create_server(addr, family=socket.AF_INET6, dualstack_ipv6=True)\nelse:\n    s = socket.create_server(addr)\nNote\n\u00a0\nOn POSIX platforms the\u00a0SO_REUSEADDR\u00a0socket option is set in order to immediately reuse previous sockets which were bound on the same\u00a0address\u00a0and remained in TIME_WAIT state.\nAdded in version 3.8.\nsocket.has_dualstack_ipv6()\nReturn\u00a0True\u00a0if the platform supports creating a TCP socket which can handle both IPv4 and IPv6 connections.\nAdded in version 3.8.\nsocket.fromfd(fd,\u00a0family,\u00a0type,\u00a0proto=0)\nDuplicate the file descriptor\u00a0fd\u00a0(an integer as returned by a file object\u2019s\u00a0fileno()\u00a0method) and build a socket object from the result. Address family, socket type and protocol number are as for the\u00a0socket()\u00a0function above. The file descriptor should refer to a socket, but this is not checked \u2014 subsequent operations on the object may fail if the file descriptor is invalid. This function is rarely needed, but can be used to get or set socket options on a socket passed to a program as standard input or output (such as a server started by the Unix inet daemon). The socket is assumed to be in blocking mode.\nThe newly created socket is\u00a0non-inheritable.\nChanged in version 3.4:\u00a0The returned socket is now non-inheritable.\nsocket.fromshare(data)\nInstantiate a socket from data obtained from the\u00a0socket.share()\u00a0method. The socket is assumed to be in blocking mode.\nAvailability: Windows.\nAdded in version 3.3.\nsocket.SocketType\nThis is a Python type object that represents the socket object type. It is the same as\u00a0type(socket(...)).\nOther functions\nThe\u00a0socket\u00a0module also offers various network-related services:\nsocket.close(fd)\nClose a socket file descriptor. This is like\u00a0os.close(), but for sockets. On some platforms (most noticeable Windows)\u00a0os.close()\u00a0does not work for socket file descriptors.\nAdded in version 3.7.\nsocket.getaddrinfo(host,\u00a0port,\u00a0family=AF_UNSPEC,\u00a0type=0,\u00a0proto=0,\u00a0flags=0)\nThis function wraps the C function\u00a0getaddrinfo\u00a0of the underlying system.\nTranslate the\u00a0host/port\u00a0argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service.\u00a0host\u00a0is a domain name, a string representation of an IPv4/v6 address or\u00a0None.\u00a0port\u00a0is a string service name such as\u00a0'http', a numeric port number or\u00a0None. By passing\u00a0None\u00a0as the value of\u00a0host\u00a0and\u00a0port, you can pass\u00a0NULL\u00a0to the underlying C API.\nThe\u00a0family,\u00a0type\u00a0and\u00a0proto\u00a0arguments can be optionally specified in order to provide options and limit the list of addresses returned. Pass their default values (AF_UNSPEC, 0, and 0, respectively) to not limit the results. See the note below for details.\nThe\u00a0flags\u00a0argument can be one or several of the\u00a0AI_*\u00a0constants, and will influence how results are computed and returned. For example,\u00a0AI_NUMERICHOST\u00a0will disable domain name resolution and will raise an error if\u00a0host\u00a0is a domain name.\nThe function returns a list of 5-tuples with the following structure:\n(family,\u00a0type,\u00a0proto,\u00a0canonname,\u00a0sockaddr)\nIn these tuples,\u00a0family,\u00a0type,\u00a0proto\u00a0are all integers and are meant to be passed to the\u00a0socket()\u00a0function.\u00a0canonname\u00a0will be a string representing the canonical name of the\u00a0host\u00a0if\u00a0AI_CANONNAME\u00a0is part of the\u00a0flags\u00a0argument; else\u00a0canonname\u00a0will be empty.\u00a0sockaddr\u00a0is a tuple describing a socket address, whose format depends on the returned\u00a0family\u00a0(a\u00a0(address,\u00a0port)\u00a02-tuple for\u00a0AF_INET, a\u00a0(address,\u00a0port,\u00a0flowinfo,\u00a0scope_id)\u00a04-tuple for\u00a0AF_INET6), and is meant to be passed to the\u00a0socket.connect()\u00a0method.\nNote\n\u00a0\nIf you intend to use results from\u00a0getaddrinfo()\u00a0to create a socket (rather than, for example, retrieve\u00a0canonname), consider limiting the results by\u00a0type\u00a0(e.g.\u00a0SOCK_STREAM\u00a0or\u00a0SOCK_DGRAM) and/or\u00a0proto\u00a0(e.g.\u00a0IPPROTO_TCP\u00a0or\u00a0IPPROTO_UDP) that your application can handle.\nThe behavior with default values of\u00a0family,\u00a0type,\u00a0proto\u00a0and\u00a0flags\u00a0is system-specific.\nMany systems (for example, most Linux configurations) will return a sorted list of all matching addresses. These addresses should generally be tried in order until a connection succeeds (possibly tried in parallel, for example, using a\u00a0Happy Eyeballs\u00a0algorithm). In these cases, limiting the\u00a0type\u00a0and/or\u00a0proto\u00a0can help eliminate unsuccessful or unusable connection attempts.\nSome systems will, however, only return a single address. (For example, this was reported on Solaris and AIX configurations.) On these systems, limiting the\u00a0type\u00a0and/or\u00a0proto\u00a0helps ensure that this address is usable.\nRaises an\u00a0auditing event\u00a0socket.getaddrinfo\u00a0with arguments\u00a0host,\u00a0port,\u00a0family,\u00a0type,\u00a0protocol.\nThe following example fetches address information for a hypothetical TCP connection to\u00a0example.org\u00a0on port 80 (results may differ on your system if IPv6 isn\u2019t enabled):\nCopy\n>>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n[(socket.AF_INET6, socket.SOCK_STREAM,\n 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n (socket.AF_INET, socket.SOCK_STREAM,\n 6, '', ('93.184.216.34', 80))]\nChanged in version 3.2:\u00a0parameters can now be passed using keyword arguments.\nChanged in version 3.7:\u00a0for IPv6 multicast addresses, string representing an address will not contain\u00a0%scope_id\u00a0part.\nsocket.getfqdn([name])\nReturn a fully qualified domain name for\u00a0name. If\u00a0name\u00a0is omitted or empty, it is interpreted as the local host. To find the fully qualified name, the hostname returned by\u00a0gethostbyaddr()\u00a0is checked, followed by aliases for the host, if available. The first name which includes a period is selected. In case no fully qualified domain name is available and\u00a0name\u00a0was provided, it is returned unchanged. If\u00a0name\u00a0was empty or equal to\u00a0'0.0.0.0', the hostname from\u00a0gethostname()\u00a0is returned.\nsocket.gethostbyname(hostname)\nTranslate a host name to IPv4 address format. The IPv4 address is returned as a string, such as\u00a0'100.50.200.5'. If the host name is an IPv4 address itself it is returned unchanged. See\u00a0gethostbyname_ex()\u00a0for a more complete interface.\u00a0gethostbyname()\u00a0does not support IPv6 name resolution, and\u00a0getaddrinfo()\u00a0should be used instead for IPv4/v6 dual stack support.\nRaises an\u00a0auditing event\u00a0socket.gethostbyname\u00a0with argument\u00a0hostname.\nAvailability: not WASI.\nsocket.gethostbyname_ex(hostname)\nTranslate a host name to IPv4 address format, extended interface. Return a 3-tuple\u00a0(hostname,\u00a0aliaslist,\u00a0ipaddrlist)\u00a0where\u00a0hostname\u00a0is the host\u2019s primary host name,\u00a0aliaslist\u00a0is a (possibly empty) list of alternative host names for the same address, and\u00a0ipaddrlist\u00a0is a list of IPv4 addresses for the same interface on the same host (often but not always a single address).\u00a0gethostbyname_ex()\u00a0does not support IPv6 name resolution, and\u00a0getaddrinfo()\u00a0should be used instead for IPv4/v6 dual stack support.\nRaises an\u00a0auditing event\u00a0socket.gethostbyname\u00a0with argument\u00a0hostname.\nAvailability: not WASI.\nsocket.gethostname()\nReturn a string containing the hostname of the machine where the Python interpreter is currently executing.\nRaises an\u00a0auditing event\u00a0socket.gethostname\u00a0with no arguments.\nNote:\u00a0gethostname()\u00a0doesn\u2019t always return the fully qualified domain name; use\u00a0getfqdn()\u00a0for that.\nAvailability: not WASI.\nsocket.gethostbyaddr(ip_address)\nReturn a 3-tuple\u00a0(hostname,\u00a0aliaslist,\u00a0ipaddrlist)\u00a0where\u00a0hostname\u00a0is the primary host name responding to the given\u00a0ip_address,\u00a0aliaslist\u00a0is a (possibly empty) list of alternative host names for the same address, and\u00a0ipaddrlist\u00a0is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). To find the fully qualified domain name, use the function\u00a0getfqdn().\u00a0gethostbyaddr()\u00a0supports both IPv4 and IPv6.\nRaises an\u00a0auditing event\u00a0socket.gethostbyaddr\u00a0with argument\u00a0ip_address.\nAvailability: not WASI.\nsocket.getnameinfo(sockaddr,\u00a0flags)\nTranslate a socket address\u00a0sockaddr\u00a0into a 2-tuple\u00a0(host,\u00a0port). Depending on the settings of\u00a0flags, the result can contain a fully qualified domain name or numeric address representation in\u00a0host. Similarly,\u00a0port\u00a0can contain a string port name or a numeric port number.\nFor IPv6 addresses,\u00a0%scope_id\u00a0is appended to the host part if\u00a0sockaddr\u00a0contains meaningful\u00a0scope_id. Usually this happens for multicast addresses.\nFor more information about\u00a0flags\u00a0you can consult\u00a0getnameinfo(3).\nRaises an\u00a0auditing event\u00a0socket.getnameinfo\u00a0with argument\u00a0sockaddr.\nAvailability: not WASI.\nsocket.getprotobyname(protocolname)\nTranslate an internet protocol name (for example,\u00a0'icmp') to a constant suitable for passing as the (optional) third argument to the\u00a0socket()\u00a0function. This is usually only needed for sockets opened in \u201craw\u201d mode (SOCK_RAW); for the normal socket modes, the correct protocol is chosen automatically if the protocol is omitted or zero.\nAvailability: not WASI.\nsocket.getservbyname(servicename[,\u00a0protocolname])\nTranslate an internet service name and protocol name to a port number for that service. The optional protocol name, if given, should be\u00a0'tcp'\u00a0or\u00a0'udp', otherwise any protocol will match.\nRaises an\u00a0auditing event\u00a0socket.getservbyname\u00a0with arguments\u00a0servicename,\u00a0protocolname.\nAvailability: not WASI.\nsocket.getservbyport(port[,\u00a0protocolname])\nTranslate an internet port number and protocol name to a service name for that service. The optional protocol name, if given, should be\u00a0'tcp'\u00a0or\u00a0'udp', otherwise any protocol will match.\nRaises an\u00a0auditing event\u00a0socket.getservbyport\u00a0with arguments\u00a0port,\u00a0protocolname.\nAvailability: not WASI.\nsocket.ntohl(x)\nConvert 32-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.\nsocket.ntohs(x)\nConvert 16-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.\nChanged in version 3.10:\u00a0Raises\u00a0OverflowError\u00a0if\u00a0x\u00a0does not fit in a 16-bit unsigned integer.\nsocket.htonl(x)\nConvert 32-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.\nsocket.htons(x)\nConvert 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.\nChanged in version 3.10:\u00a0Raises\u00a0OverflowError\u00a0if\u00a0x\u00a0does not fit in a 16-bit unsigned integer.\nsocket.inet_aton(ip_string)\nConvert an IPv4 address from dotted-quad string format (for example, \u2018123.45.67.89\u2019) to 32-bit packed binary format, as a bytes object four characters in length. This is useful when conversing with a program that uses the standard C library and needs objects of type\u00a0in_addr, which is the C type for the 32-bit packed binary this function returns.\ninet_aton()\u00a0also accepts strings with less than three dots; see the Unix manual page\u00a0inet(3)\u00a0for details.\nIf the IPv4 address string passed to this function is invalid,\u00a0OSError\u00a0will be raised. Note that exactly what is valid depends on the underlying C implementation of\u00a0inet_aton().\ninet_aton()\u00a0does not support IPv6, and\u00a0inet_pton()\u00a0should be used instead for IPv4/v6 dual stack support.\nsocket.inet_ntoa(packed_ip)\nConvert a 32-bit packed IPv4 address (a\u00a0bytes-like object\u00a0four bytes in length) to its standard dotted-quad string representation (for example, \u2018123.45.67.89\u2019). This is useful when conversing with a program that uses the standard C library and needs objects of type\u00a0in_addr, which is the C type for the 32-bit packed binary data this function takes as an argument.\nIf the byte sequence passed to this function is not exactly 4 bytes in length,\u00a0OSError\u00a0will be raised.\u00a0inet_ntoa()\u00a0does not support IPv6, and\u00a0inet_ntop()\u00a0should be used instead for IPv4/v6 dual stack support.\nChanged in version 3.5:\u00a0Writable\u00a0bytes-like object\u00a0is now accepted.\nsocket.inet_pton(address_family,\u00a0ip_string)\nConvert an IP address from its family-specific string format to a packed, binary format.\u00a0inet_pton()\u00a0is useful when a library or network protocol calls for an object of type\u00a0in_addr\u00a0(similar to\u00a0inet_aton()) or\u00a0in6_addr.\nSupported values for\u00a0address_family\u00a0are currently\u00a0AF_INET\u00a0and\u00a0AF_INET6. If the IP address string\u00a0ip_string\u00a0is invalid,\u00a0OSError\u00a0will be raised. Note that exactly what is valid depends on both the value of\u00a0address_family\u00a0and the underlying implementation of\u00a0inet_pton().\nAvailability: Unix, Windows.\nChanged in version 3.4:\u00a0Windows support added\nsocket.inet_ntop(address_family,\u00a0packed_ip)\nConvert a packed IP address (a\u00a0bytes-like object\u00a0of some number of bytes) to its standard, family-specific string representation (for example,\u00a0'7.10.0.5'\u00a0or\u00a0'5aef:2b::8').\u00a0inet_ntop()\u00a0is useful when a library or network protocol returns an object of type\u00a0in_addr\u00a0(similar to\u00a0inet_ntoa()) or\u00a0in6_addr.\nSupported values for\u00a0address_family\u00a0are currently\u00a0AF_INET\u00a0and\u00a0AF_INET6. If the bytes object\u00a0packed_ip\u00a0is not the correct length for the specified address family,\u00a0ValueError\u00a0will be raised.\u00a0OSError\u00a0is raised for errors from the call to\u00a0inet_ntop().\nAvailability: Unix, Windows.\nChanged in version 3.4:\u00a0Windows support added\nChanged in version 3.5:\u00a0Writable\u00a0bytes-like object\u00a0is now accepted.\nsocket.CMSG_LEN(length)\nReturn the total length, without trailing padding, of an ancillary data item with associated data of the given\u00a0length. This value can often be used as the buffer size for\u00a0recvmsg()\u00a0to receive a single item of ancillary data, but\u00a0RFC 3542\u00a0requires portable applications to use\u00a0CMSG_SPACE()\u00a0and thus include space for padding, even when the item will be the last in the buffer. Raises\u00a0OverflowError\u00a0if\u00a0length\u00a0is outside the permissible range of values.\nAvailability: Unix, not WASI.\nMost Unix platforms.\nAdded in version 3.3.\nsocket.CMSG_SPACE(length)\nReturn the buffer size needed for\u00a0recvmsg()\u00a0to receive an ancillary data item with associated data of the given\u00a0length, along with any trailing padding. The buffer space needed to receive multiple items is the sum of the\u00a0CMSG_SPACE()\u00a0values for their associated data lengths. Raises\u00a0OverflowError\u00a0if\u00a0length\u00a0is outside the permissible range of values.\nNote that some systems might support ancillary data without providing this function. Also note that setting the buffer size using the results of this function may not precisely limit the amount of ancillary data that can be received, since additional data may be able to fit into the padding area.\nAvailability: Unix, not WASI.\nmost Unix platforms.\nAdded in version 3.3.\nsocket.getdefaulttimeout()\nReturn the default timeout in seconds (float) for new socket objects. A value of\u00a0None\u00a0indicates that new socket objects have no timeout. When the socket module is first imported, the default is\u00a0None.\nsocket.setdefaulttimeout(timeout)\nSet the default timeout in seconds (float) for new socket objects. When the socket module is first imported, the default is\u00a0None. See\u00a0settimeout()\u00a0for possible values and their respective meanings.\nsocket.sethostname(name)\nSet the machine\u2019s hostname to\u00a0name. This will raise an\u00a0OSError\u00a0if you don\u2019t have enough rights.\nRaises an\u00a0auditing event\u00a0socket.sethostname\u00a0with argument\u00a0name.\nAvailability: Unix, not Android.\nAdded in version 3.3.\nsocket.if_nameindex()\nReturn a list of network interface information (index int, name string) tuples.\u00a0OSError\u00a0if the system call fails.\nAvailability: Unix, Windows, not WASI.\nAdded in version 3.3.\nChanged in version 3.8:\u00a0Windows support was added.\nNote\n\u00a0\nOn Windows network interfaces have different names in different contexts (all names are examples):\nUUID:\u00a0{FB605B73-AAC2-49A6-9A2F-25416AEA0573}\nname:\u00a0ethernet_32770\nfriendly name:\u00a0vEthernet\u00a0(nat)\ndescription:\u00a0Hyper-V\u00a0Virtual\u00a0Ethernet\u00a0Adapter\nThis function returns names of the second form from the list,\u00a0ethernet_32770\u00a0in this example case.\nsocket.if_nametoindex(if_name)\nReturn a network interface index number corresponding to an interface name.\u00a0OSError\u00a0if no interface with the given name exists.\nAvailability: Unix, Windows, not WASI.\nAdded in version 3.3.\nChanged in version 3.8:\u00a0Windows support was added.\nSee also\n\u00a0\n\u201cInterface name\u201d is a name as documented in\u00a0if_nameindex().\nsocket.if_indextoname(if_index)\nReturn a network interface name corresponding to an interface index number.\u00a0OSError\u00a0if no interface with the given index exists.\nAvailability: Unix, Windows, not WASI.\nAdded in version 3.3.\nChanged in version 3.8:\u00a0Windows support was added.\nSee also\n\u00a0\n\u201cInterface name\u201d is a name as documented in\u00a0if_nameindex().\nsocket.send_fds(sock,\u00a0buffers,\u00a0fds[,\u00a0flags[,\u00a0address]])\nSend the list of file descriptors\u00a0fds\u00a0over an\u00a0AF_UNIX\u00a0socket\u00a0sock. The\u00a0fds\u00a0parameter is a sequence of file descriptors. Consult\u00a0sendmsg()\u00a0for the documentation of these parameters.\nAvailability: Unix, Windows, not WASI.\nUnix platforms supporting\u00a0sendmsg()\u00a0and\u00a0SCM_RIGHTS\u00a0mechanism.\nAdded in version 3.9.\nsocket.recv_fds(sock,\u00a0bufsize,\u00a0maxfds[,\u00a0flags])\nReceive up to\u00a0maxfds\u00a0file descriptors from an\u00a0AF_UNIX\u00a0socket\u00a0sock. Return\u00a0(msg,\u00a0list(fds),\u00a0flags,\u00a0addr). Consult\u00a0recvmsg()\u00a0for the documentation of these parameters.\nAvailability: Unix, Windows, not WASI.\nUnix platforms supporting\u00a0sendmsg()\u00a0and\u00a0SCM_RIGHTS\u00a0mechanism.\nAdded in version 3.9.\nNote\n\u00a0\nAny truncated integers at the end of the list of file descriptors.\nSocket Objects\nSocket objects have the following methods. Except for\u00a0makefile(), these correspond to Unix system calls applicable to sockets.\nChanged in version 3.2:\u00a0Support for the\u00a0context manager\u00a0protocol was added. Exiting the context manager is equivalent to calling\u00a0close().\nsocket.accept()\nAccept a connection. The socket must be bound to an address and listening for connections. The return value is a pair\u00a0(conn,\u00a0address)\u00a0where\u00a0conn\u00a0is a\u00a0new\u00a0socket object usable to send and receive data on the connection, and\u00a0address\u00a0is the address bound to the socket on the other end of the connection.\nThe newly created socket is\u00a0non-inheritable.\nChanged in version 3.4:\u00a0The socket is now non-inheritable.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.bind(address)\nBind the socket to\u00a0address. The socket must not already be bound. (The format of\u00a0address\u00a0depends on the address family \u2014 see above.)\nRaises an\u00a0auditing event\u00a0socket.bind\u00a0with arguments\u00a0self,\u00a0address.\nAvailability: not WASI.\nsocket.close()\nMark the socket closed. The underlying system resource (e.g. a file descriptor) is also closed when all file objects from\u00a0makefile()\u00a0are closed. Once that happens, all future operations on the socket object will fail. The remote end will receive no more data (after queued data is flushed).\nSockets are automatically closed when they are garbage-collected, but it is recommended to\u00a0close()\u00a0them explicitly, or to use a\u00a0with\u00a0statement around them.\nChanged in version 3.6:\u00a0OSError\u00a0is now raised if an error occurs when the underlying\u00a0close()\u00a0call is made.\nNote\n\u00a0\nclose()\u00a0releases the resource associated with a connection but does not necessarily close the connection immediately. If you want to close the connection in a timely fashion, call\u00a0shutdown()\u00a0before\u00a0close().\nsocket.connect(address)\nConnect to a remote socket at\u00a0address. (The format of\u00a0address\u00a0depends on the address family \u2014 see above.)\nIf the connection is interrupted by a signal, the method waits until the connection completes, or raise a\u00a0TimeoutError\u00a0on timeout, if the signal handler doesn\u2019t raise an exception and the socket is blocking or has a timeout. For non-blocking sockets, the method raises an\u00a0InterruptedError\u00a0exception if the connection is interrupted by a signal (or the exception raised by the signal handler).\nRaises an\u00a0auditing event\u00a0socket.connect\u00a0with arguments\u00a0self,\u00a0address.\nChanged in version 3.5:\u00a0The method now waits until the connection completes instead of raising an\u00a0InterruptedError\u00a0exception if the connection is interrupted by a signal, the signal handler doesn\u2019t raise an exception and the socket is blocking or has a timeout (see the\u00a0PEP 475\u00a0for the rationale).\nAvailability: not WASI.\nsocket.connect_ex(address)\nLike\u00a0connect(address), but return an error indicator instead of raising an exception for errors returned by the C-level\u00a0connect()\u00a0call (other problems, such as \u201chost not found,\u201d can still raise exceptions). The error indicator is\u00a00\u00a0if the operation succeeded, otherwise the value of the\u00a0errno\u00a0variable. This is useful to support, for example, asynchronous connects.\nRaises an\u00a0auditing event\u00a0socket.connect\u00a0with arguments\u00a0self,\u00a0address.\nAvailability: not WASI.\nsocket.detach()\nPut the socket object into closed state without actually closing the underlying file descriptor. The file descriptor is returned, and can be reused for other purposes.\nAdded in version 3.2.\nsocket.dup()\nDuplicate the socket.\nThe newly created socket is\u00a0non-inheritable.\nChanged in version 3.4:\u00a0The socket is now non-inheritable.\nAvailability: not WASI.\nsocket.fileno()\nReturn the socket\u2019s file descriptor (a small integer), or -1 on failure. This is useful with\u00a0select.select().\nUnder Windows the small integer returned by this method cannot be used where a file descriptor can be used (such as\u00a0os.fdopen()). Unix does not have this limitation.\nsocket.get_inheritable()\nGet the\u00a0inheritable flag\u00a0of the socket\u2019s file descriptor or socket\u2019s handle:\u00a0True\u00a0if the socket can be inherited in child processes,\u00a0False\u00a0if it cannot.\nAdded in version 3.4.\nsocket.getpeername()\nReturn the remote address to which the socket is connected. This is useful to find out the port number of a remote IPv4/v6 socket, for instance. (The format of the address returned depends on the address family \u2014 see above.) On some systems this function is not supported.\nsocket.getsockname()\nReturn the socket\u2019s own address. This is useful to find out the port number of an IPv4/v6 socket, for instance. (The format of the address returned depends on the address family \u2014 see above.)\nsocket.getsockopt(level,\u00a0optname[,\u00a0buflen])\nReturn the value of the given socket option (see the Unix man page\u00a0getsockopt(2)). The needed symbolic constants (SO_* etc.) are defined in this module. If\u00a0buflen\u00a0is absent, an integer option is assumed and its integer value is returned by the function. If\u00a0buflen\u00a0is present, it specifies the maximum length of the buffer used to receive the option in, and this buffer is returned as a bytes object. It is up to the caller to decode the contents of the buffer (see the optional built-in module\u00a0struct\u00a0for a way to decode C structures encoded as byte strings).\nAvailability: not WASI.\nsocket.getblocking()\nReturn\u00a0True\u00a0if socket is in blocking mode,\u00a0False\u00a0if in non-blocking.\nThis is equivalent to checking\u00a0socket.gettimeout()\u00a0!=\u00a00.\nAdded in version 3.7.\nsocket.gettimeout()\nReturn the timeout in seconds (float) associated with socket operations, or\u00a0None\u00a0if no timeout is set. This reflects the last call to\u00a0setblocking()\u00a0or\u00a0settimeout().\nsocket.ioctl(control,\u00a0option)\nPlatform:\nWindows\nThe\u00a0ioctl()\u00a0method is a limited interface to the WSAIoctl system interface. Please refer to the\u00a0Win32 documentation\u00a0for more information.\nOn other platforms, the generic\u00a0fcntl.fcntl()\u00a0and\u00a0fcntl.ioctl()\u00a0functions may be used; they accept a socket object as their first argument.\nCurrently only the following control codes are supported:\u00a0SIO_RCVALL,\u00a0SIO_KEEPALIVE_VALS, and\u00a0SIO_LOOPBACK_FAST_PATH.\nChanged in version 3.6:\u00a0SIO_LOOPBACK_FAST_PATH\u00a0was added.\nsocket.listen([backlog])\nEnable a server to accept connections. If\u00a0backlog\u00a0is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen.\nAvailability: not WASI.\nChanged in version 3.5:\u00a0The\u00a0backlog\u00a0parameter is now optional.\nsocket.makefile(mode='r',\u00a0buffering=None,\u00a0*,\u00a0encoding=None,\u00a0errors=None,\u00a0newline=None)\nReturn a\u00a0file object\u00a0associated with the socket. The exact returned type depends on the arguments given to\u00a0makefile(). These arguments are interpreted the same way as by the built-in\u00a0open()\u00a0function, except the only supported\u00a0mode\u00a0values are\u00a0'r'\u00a0(default),\u00a0'w',\u00a0'b', or a combination of those.\nThe socket must be in blocking mode; it can have a timeout, but the file object\u2019s internal buffer may end up in an inconsistent state if a timeout occurs.\nClosing the file object returned by\u00a0makefile()\u00a0won\u2019t close the original socket unless all other file objects have been closed and\u00a0socket.close()\u00a0has been called on the socket object.\nNote\n\u00a0\nOn Windows, the file-like object created by\u00a0makefile()\u00a0cannot be used where a file object with a file descriptor is expected, such as the stream arguments of\u00a0subprocess.Popen().\nsocket.recv(bufsize[,\u00a0flags])\nReceive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by\u00a0bufsize. A returned empty bytes object indicates that the client has disconnected. See the Unix manual page\u00a0recv(2)\u00a0for the meaning of the optional argument\u00a0flags; it defaults to zero.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.recvfrom(bufsize[,\u00a0flags])\nReceive data from the socket. The return value is a pair\u00a0(bytes,\u00a0address)\u00a0where\u00a0bytes\u00a0is a bytes object representing the data received and\u00a0address\u00a0is the address of the socket sending the data. See the Unix manual page\u00a0recv(2)\u00a0for the meaning of the optional argument\u00a0flags; it defaults to zero. (The format of\u00a0address\u00a0depends on the address family \u2014 see above.)\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nChanged in version 3.7:\u00a0For multicast IPv6 address, first item of\u00a0address\u00a0does not contain\u00a0%scope_id\u00a0part anymore. In order to get full IPv6 address use\u00a0getnameinfo().\nsocket.recvmsg(bufsize[,\u00a0ancbufsize[,\u00a0flags]])\nReceive normal data (up to\u00a0bufsize\u00a0bytes) and ancillary data from the socket. The\u00a0ancbufsize\u00a0argument sets the size in bytes of the internal buffer used to receive the ancillary data; it defaults to 0, meaning that no ancillary data will be received. Appropriate buffer sizes for ancillary data can be calculated using\u00a0CMSG_SPACE()\u00a0or\u00a0CMSG_LEN(), and items which do not fit into the buffer might be truncated or discarded. The\u00a0flags\u00a0argument defaults to 0 and has the same meaning as for\u00a0recv().\nThe return value is a 4-tuple:\u00a0(data,\u00a0ancdata,\u00a0msg_flags,\u00a0address). The\u00a0data\u00a0item is a\u00a0bytes\u00a0object holding the non-ancillary data received. The\u00a0ancdata\u00a0item is a list of zero or more tuples\u00a0(cmsg_level,\u00a0cmsg_type,\u00a0cmsg_data)\u00a0representing the ancillary data (control messages) received:\u00a0cmsg_level\u00a0and\u00a0cmsg_type\u00a0are integers specifying the protocol level and protocol-specific type respectively, and\u00a0cmsg_data\u00a0is a\u00a0bytes\u00a0object holding the associated data. The\u00a0msg_flags\u00a0item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. If the receiving socket is unconnected,\u00a0address\u00a0is the address of the sending socket, if available; otherwise, its value is unspecified.\nOn some systems,\u00a0sendmsg()\u00a0and\u00a0recvmsg()\u00a0can be used to pass file descriptors between processes over an\u00a0AF_UNIX\u00a0socket. When this facility is used (it is often restricted to\u00a0SOCK_STREAM\u00a0sockets),\u00a0recvmsg()\u00a0will return, in its ancillary data, items of the form\u00a0(socket.SOL_SOCKET,\u00a0socket.SCM_RIGHTS,\u00a0fds), where\u00a0fds\u00a0is a\u00a0bytes\u00a0object representing the new file descriptors as a binary array of the native C\u00a0int\u00a0type. If\u00a0recvmsg()\u00a0raises an exception after the system call returns, it will first attempt to close any file descriptors received via this mechanism.\nSome systems do not indicate the truncated length of ancillary data items which have been only partially received. If an item appears to extend beyond the end of the buffer,\u00a0recvmsg()\u00a0will issue a\u00a0RuntimeWarning, and will return the part of it which is inside the buffer provided it has not been truncated before the start of its associated data.\nOn systems which support the\u00a0SCM_RIGHTS\u00a0mechanism, the following function will receive up to\u00a0maxfds\u00a0file descriptors, returning the message data and a list containing the descriptors (while ignoring unexpected conditions such as unrelated control messages being received). See also\u00a0sendmsg().\nCopy\nimport socket, array\n\ndef recv_fds(sock, msglen, maxfds):\n    fds = array.array(\"i\")   # Array of ints\n    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))\n    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:\n            # Append data, ignoring any truncated integers at the end.\n            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])\n    return msg, list(fds)\nAvailability: Unix.\nMost Unix platforms.\nAdded in version 3.3.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.recvmsg_into(buffers[,\u00a0ancbufsize[,\u00a0flags]])\nReceive normal data and ancillary data from the socket, behaving as\u00a0recvmsg()\u00a0would, but scatter the non-ancillary data into a series of buffers instead of returning a new bytes object. The\u00a0buffers\u00a0argument must be an iterable of objects that export writable buffers (e.g.\u00a0bytearray\u00a0objects); these will be filled with successive chunks of the non-ancillary data until it has all been written or there are no more buffers. The operating system may set a limit (sysconf()\u00a0value\u00a0SC_IOV_MAX) on the number of buffers that can be used. The\u00a0ancbufsize\u00a0and\u00a0flags\u00a0arguments have the same meaning as for\u00a0recvmsg().\nThe return value is a 4-tuple:\u00a0(nbytes,\u00a0ancdata,\u00a0msg_flags,\u00a0address), where\u00a0nbytes\u00a0is the total number of bytes of non-ancillary data written into the buffers, and\u00a0ancdata,\u00a0msg_flags\u00a0and\u00a0address\u00a0are the same as for\u00a0recvmsg().\nExample:\nCopy\n>>> import socket\n>>> s1, s2 = socket.socketpair()\n>>> b1 = bytearray(b'----')\n>>> b2 = bytearray(b'0123456789')\n>>> b3 = bytearray(b'--------------')\n>>> s1.send(b'Mary had a little lamb')\n22\n>>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n(22, [], 0, None)\n>>> [b1, b2, b3]\n[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]\nAvailability: Unix.\nMost Unix platforms.\nAdded in version 3.3.\nsocket.recvfrom_into(buffer[,\u00a0nbytes[,\u00a0flags]])\nReceive data from the socket, writing it into\u00a0buffer\u00a0instead of creating a new bytestring. The return value is a pair\u00a0(nbytes,\u00a0address)\u00a0where\u00a0nbytes\u00a0is the number of bytes received and\u00a0address\u00a0is the address of the socket sending the data. See the Unix manual page\u00a0recv(2)\u00a0for the meaning of the optional argument\u00a0flags; it defaults to zero. (The format of\u00a0address\u00a0depends on the address family \u2014 see above.)\nsocket.recv_into(buffer[,\u00a0nbytes[,\u00a0flags]])\nReceive up to\u00a0nbytes\u00a0bytes from the socket, storing the data into a buffer rather than creating a new bytestring. If\u00a0nbytes\u00a0is not specified (or 0), receive up to the size available in the given buffer. Returns the number of bytes received. See the Unix manual page\u00a0recv(2)\u00a0for the meaning of the optional argument\u00a0flags; it defaults to zero.\nsocket.send(bytes[,\u00a0flags])\nSend data to the socket. The socket must be connected to a remote socket. The optional\u00a0flags\u00a0argument has the same meaning as for\u00a0recv()\u00a0above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this topic, consult the\u00a0Socket Programming HOWTO.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.sendall(bytes[,\u00a0flags])\nSend data to the socket. The socket must be connected to a remote socket. The optional\u00a0flags\u00a0argument has the same meaning as for\u00a0recv()\u00a0above. Unlike\u00a0send(), this method continues to send data from\u00a0bytes\u00a0until either all data has been sent or an error occurs.\u00a0None\u00a0is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.\nChanged in version 3.5:\u00a0The socket timeout is no longer reset each time data is sent successfully. The socket timeout is now the maximum total duration to send all data.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.sendto(bytes,\u00a0address)\nsocket.sendto(bytes,\u00a0flags,\u00a0address)\nSend data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by\u00a0address. The optional\u00a0flags\u00a0argument has the same meaning as for\u00a0recv()\u00a0above. Return the number of bytes sent. (The format of\u00a0address\u00a0depends on the address family \u2014 see above.)\nRaises an\u00a0auditing event\u00a0socket.sendto\u00a0with arguments\u00a0self,\u00a0address.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.sendmsg(buffers[,\u00a0ancdata[,\u00a0flags[,\u00a0address]]])\nSend normal and ancillary data to the socket, gathering the non-ancillary data from a series of buffers and concatenating it into a single message. The\u00a0buffers\u00a0argument specifies the non-ancillary data as an iterable of\u00a0bytes-like objects\u00a0(e.g.\u00a0bytes\u00a0objects); the operating system may set a limit (sysconf()\u00a0value\u00a0SC_IOV_MAX) on the number of buffers that can be used. The\u00a0ancdata\u00a0argument specifies the ancillary data (control messages) as an iterable of zero or more tuples\u00a0(cmsg_level,\u00a0cmsg_type,\u00a0cmsg_data), where\u00a0cmsg_level\u00a0and\u00a0cmsg_type\u00a0are integers specifying the protocol level and protocol-specific type respectively, and\u00a0cmsg_data\u00a0is a bytes-like object holding the associated data. Note that some systems (in particular, systems without\u00a0CMSG_SPACE()) might support sending only one control message per call. The\u00a0flags\u00a0argument defaults to 0 and has the same meaning as for\u00a0send(). If\u00a0address\u00a0is supplied and not\u00a0None, it sets a destination address for the message. The return value is the number of bytes of non-ancillary data sent.\nThe following function sends the list of file descriptors\u00a0fds\u00a0over an\u00a0AF_UNIX\u00a0socket, on systems which support the\u00a0SCM_RIGHTS\u00a0mechanism. See also\u00a0recvmsg().\nCopy\nimport socket, array\n\ndef send_fds(sock, msg, fds):\n    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(\"i\", fds))])\nAvailability: Unix, not WASI.\nMost Unix platforms.\nRaises an\u00a0auditing event\u00a0socket.sendmsg\u00a0with arguments\u00a0self,\u00a0address.\nAdded in version 3.3.\nChanged in version 3.5:\u00a0If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an\u00a0InterruptedError\u00a0exception (see\u00a0PEP 475\u00a0for the rationale).\nsocket.sendmsg_afalg([msg,\u00a0]*,\u00a0op[,\u00a0iv[,\u00a0assoclen[,\u00a0flags]]])\nSpecialized version of\u00a0sendmsg()\u00a0for\u00a0AF_ALG\u00a0socket. Set mode, IV, AEAD associated data length and flags for\u00a0AF_ALG\u00a0socket.\nAvailability: Linux >= 2.6.38.\nAdded in version 3.6.\nsocket.sendfile(file,\u00a0offset=0,\u00a0count=None)\nSend a file until EOF is reached by using high-performance\u00a0os.sendfile\u00a0and return the total number of bytes which were sent.\u00a0file\u00a0must be a regular file object opened in binary mode. If\u00a0os.sendfile\u00a0is not available (e.g. Windows) or\u00a0file\u00a0is not a regular file\u00a0send()\u00a0will be used instead.\u00a0offset\u00a0tells from where to start reading the file. If specified,\u00a0count\u00a0is the total number of bytes to transmit as opposed to sending the file until EOF is reached. File position is updated on return or also in case of error in which case\u00a0file.tell()\u00a0can be used to figure out the number of bytes which were sent. The socket must be of\u00a0SOCK_STREAM\u00a0type. Non-blocking sockets are not supported.\nAdded in version 3.5.\nsocket.set_inheritable(inheritable)\nSet the\u00a0inheritable flag\u00a0of the socket\u2019s file descriptor or socket\u2019s handle.\nAdded in version 3.4.\nsocket.setblocking(flag)\nSet blocking or non-blocking mode of the socket: if\u00a0flag\u00a0is false, the socket is set to non-blocking, else to blocking mode.\nThis method is a shorthand for certain\u00a0settimeout()\u00a0calls:\nsock.setblocking(True)\u00a0is equivalent to\u00a0sock.settimeout(None)\nsock.setblocking(False)\u00a0is equivalent to\u00a0sock.settimeout(0.0)\nChanged in version 3.7:\u00a0The method no longer applies\u00a0SOCK_NONBLOCK\u00a0flag on\u00a0socket.type.\nsocket.settimeout(value)\nSet a timeout on blocking socket operations. The\u00a0value\u00a0argument can be a nonnegative floating-point number expressing seconds, or\u00a0None. If a non-zero value is given, subsequent socket operations will raise a\u00a0timeout\u00a0exception if the timeout period\u00a0value\u00a0has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If\u00a0None\u00a0is given, the socket is put in blocking mode.\nFor further information, please consult the\u00a0notes on socket timeouts.\nChanged in version 3.7:\u00a0The method no longer toggles\u00a0SOCK_NONBLOCK\u00a0flag on\u00a0socket.type.\nsocket.setsockopt(level,\u00a0optname,\u00a0value:\u00a0int)\nsocket.setsockopt(level,\u00a0optname,\u00a0value:\u00a0buffer)\nsocket.setsockopt(level,\u00a0optname,\u00a0None,\u00a0optlen:\u00a0int)\nSet the value of the given socket option (see the Unix manual page\u00a0setsockopt(2)). The needed symbolic constants are defined in this module (SO_* etc. <socket-unix-constants>). The value can be an integer,\u00a0None\u00a0or a\u00a0bytes-like object\u00a0representing a buffer. In the later case it is up to the caller to ensure that the bytestring contains the proper bits (see the optional built-in module\u00a0struct\u00a0for a way to encode C structures as bytestrings). When\u00a0value\u00a0is set to\u00a0None,\u00a0optlen\u00a0argument is required. It\u2019s equivalent to call\u00a0setsockopt()\u00a0C function with\u00a0optval=NULL\u00a0and\u00a0optlen=optlen.\nChanged in version 3.5:\u00a0Writable\u00a0bytes-like object\u00a0is now accepted.\nChanged in version 3.6:\u00a0setsockopt(level, optname, None, optlen: int) form added.\nAvailability: not WASI.\nsocket.shutdown(how)\nShut down one or both halves of the connection. If\u00a0how\u00a0is\u00a0SHUT_RD, further receives are disallowed. If\u00a0how\u00a0is\u00a0SHUT_WR, further sends are disallowed. If\u00a0how\u00a0is\u00a0SHUT_RDWR, further sends and receives are disallowed.\nAvailability: not WASI.\nsocket.share(process_id)\nDuplicate a socket and prepare it for sharing with a target process. The target process must be provided with\u00a0process_id. The resulting bytes object can then be passed to the target process using some form of interprocess communication and the socket can be recreated there using\u00a0fromshare(). Once this method has been called, it is safe to close the socket since the operating system has already duplicated it for the target process.\nAvailability: Windows.\nAdded in version 3.3.\nNote that there are no methods\u00a0read()\u00a0or\u00a0write(); use\u00a0recv()\u00a0and\u00a0send()\u00a0without\u00a0flags\u00a0argument instead.\nSocket objects also have these (read-only) attributes that correspond to the values given to the\u00a0socket\u00a0constructor.\nsocket.family\nThe socket family.\nsocket.type\nThe socket type.\nsocket.proto\nThe socket protocol.\nNotes on socket timeouts\nA socket object can be in one of three modes: blocking, non-blocking, or timeout. Sockets are by default always created in blocking mode, but this can be changed by calling\u00a0setdefaulttimeout().\nIn\u00a0blocking mode, operations block until complete or the system returns an error (such as connection timed out).\nIn\u00a0non-blocking mode, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately: functions from the\u00a0select\u00a0module can be used to know when and whether a socket is available for reading or writing.\nIn\u00a0timeout mode, operations fail if they cannot be completed within the timeout specified for the socket (they raise a\u00a0timeout\u00a0exception) or if the system returns an error.\nNote\n\u00a0\nAt the operating system level, sockets in\u00a0timeout mode\u00a0are internally set in non-blocking mode. Also, the blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. This implementation detail can have visible consequences if e.g. you decide to use the\u00a0fileno()\u00a0of a socket.\nTimeouts and the\u00a0connect\u00a0method\nThe\u00a0connect()\u00a0operation is also subject to the timeout setting, and in general it is recommended to call\u00a0settimeout()\u00a0before calling\u00a0connect()\u00a0or pass a timeout parameter to\u00a0create_connection(). However, the system network stack may also return a connection timeout error of its own regardless of any Python socket timeout setting.\nTimeouts and the\u00a0accept\u00a0method\nIf\u00a0getdefaulttimeout()\u00a0is not\u00a0None, sockets returned by the\u00a0accept()\u00a0method inherit that timeout. Otherwise, the behaviour depends on settings of the listening socket:\nif the listening socket is in\u00a0blocking mode\u00a0or in\u00a0timeout mode, the socket returned by\u00a0accept()\u00a0is in\u00a0blocking mode;\nif the listening socket is in\u00a0non-blocking mode, whether the socket returned by\u00a0accept()\u00a0is in blocking or non-blocking mode is operating system-dependent. If you want to ensure cross-platform behaviour, it is recommended you manually override this setting.\nExample\nHere are four minimal example programs using the TCP/IP protocol: a server that echoes all data that it receives back (servicing only one client), and a client using it. Note that a server must perform the sequence\u00a0socket(),\u00a0bind(),\u00a0listen(),\u00a0accept()\u00a0(possibly repeating the\u00a0accept()\u00a0to service more than one client), while a client only needs the sequence\u00a0socket(),\u00a0connect(). Also note that the server does not\u00a0sendall()/recv()\u00a0on the socket it is listening on but on the new socket returned by\u00a0accept().\nThe first two examples support IPv4 only.\nCopy\n# Echo server program\nimport socket\n\nHOST = ''                 # Symbolic name meaning all available interfaces\nPORT = 50007              # Arbitrary non-privileged port\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.bind((HOST, PORT))\n    s.listen(1)\n    conn, addr = s.accept()\n    with conn:\n        print('Connected by', addr)\n        while True:\n            data = conn.recv(1024)\n            if not data: break\n            conn.sendall(data)\nCopy\n# Echo client program\nimport socket\n\nHOST = 'daring.cwi.nl'    # The remote host\nPORT = 50007              # The same port as used by the server\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect((HOST, PORT))\n    s.sendall(b'Hello, world')\n    data = s.recv(1024)\nprint('Received', repr(data))\nThe next two examples are identical to the above two, but support both IPv4 and IPv6. The server side will listen to the first address family available (it should listen to both instead). On most of IPv6-ready systems, IPv6 will take precedence and the server may not accept IPv4 traffic. The client side will try to connect to all the addresses returned as a result of the name resolution, and sends traffic to the first one connected successfully.\nCopy\n# Echo server program\nimport socket\nimport sys\n\nHOST = None               # Symbolic name meaning all available interfaces\nPORT = 50007              # Arbitrary non-privileged port\ns = None\nfor res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n    af, socktype, proto, canonname, sa = res\n    try:\n        s = socket.socket(af, socktype, proto)\n    except OSError as msg:\n        s = None\n        continue\n    try:\n        s.bind(sa)\n        s.listen(1)\n    except OSError as msg:\n        s.close()\n        s = None\n        continue\n    break\nif s is None:\n    print('could not open socket')\n    sys.exit(1)\nconn, addr = s.accept()\nwith conn:\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data: break\n        conn.send(data)\nCopy\n# Echo client program\nimport socket\nimport sys\n\nHOST = 'daring.cwi.nl'    # The remote host\nPORT = 50007              # The same port as used by the server\ns = None\nfor res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):\n    af, socktype, proto, canonname, sa = res\n    try:\n        s = socket.socket(af, socktype, proto)\n    except OSError as msg:\n        s = None\n        continue\n    try:\n        s.connect(sa)\n    except OSError as msg:\n        s.close()\n        s = None\n        continue\n    break\nif s is None:\n    print('could not open socket')\n    sys.exit(1)\nwith s:\n    s.sendall(b'Hello, world')\n    data = s.recv(1024)\nprint('Received', repr(data))\nThe next example shows how to write a very simple network sniffer with raw sockets on Windows. The example requires administrator privileges to modify the interface:\nCopy\nimport socket\n\n# the public network interface\nHOST = socket.gethostbyname(socket.gethostname())\n\n# create a raw socket and bind it to the public interface\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\ns.bind((HOST, 0))\n\n# Include IP headers\ns.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n# receive all packets\ns.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n\n# receive a packet\nprint(s.recvfrom(65565))\n\n# disabled promiscuous mode\ns.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\nThe next example shows how to use the socket interface to communicate to a CAN network using the raw socket protocol. To use CAN with the broadcast manager protocol instead, open a socket with:\nCopy\nsocket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)\nAfter binding (CAN_RAW) or connecting (CAN_BCM) the socket, you can use the\u00a0socket.send()\u00a0and\u00a0socket.recv()\u00a0operations (and their counterparts) on the socket object as usual.\nThis last example might require special privileges:\nCopy\nimport socket\nimport struct\n\n\n# CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n\ncan_frame_fmt = \"=IB3x8s\"\ncan_frame_size = struct.calcsize(can_frame_fmt)\n\ndef build_can_frame(can_id, data):\n    can_dlc = len(data)\n    data = data.ljust(8, b'\\x00')\n    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n\ndef dissect_can_frame(frame):\n    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n    return (can_id, can_dlc, data[:can_dlc])\n\n\n# create a raw socket and bind it to the 'vcan0' interface\ns = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\ns.bind(('vcan0',))\n\nwhile True:\n    cf, addr = s.recvfrom(can_frame_size)\n\n    print('Received: can_id=%x, can_dlc=%x, data=%s' % dissect_can_frame(cf))\n\n    try:\n        s.send(cf)\n    except OSError:\n        print('Error sending CAN frame')\n\n    try:\n        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n    except OSError:\n        print('Error sending CAN frame')\nRunning an example several times with too small delay between executions, could lead to this error:\nCopy\nOSError: [Errno 98] Address already in use\nThis is because the previous execution has left the socket in a\u00a0TIME_WAIT\u00a0state, and can\u2019t be immediately reused.\nThere is a\u00a0socket\u00a0flag to set, in order to prevent this,\u00a0socket.SO_REUSEADDR:\nCopy\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\ns.bind((HOST, PORT))\nthe\u00a0SO_REUSEADDR\u00a0flag tells the kernel to reuse a local socket in\u00a0TIME_WAIT\u00a0state, without waiting for its natural timeout to expire.\npcpp::RawSocketDevice Class Reference\n#include <RawSocketDevice.h>\nInheritance diagram for pcpp::RawSocketDevice:\n\n\nDetailed Description\nA class that wraps the raw socket functionality. A raw socket is a network socket that allows direct sending and receiving of IP packets without any protocol-specific transport layer formatting (taken from Wikipedia:\u00a0https://en.wikipedia.org/wiki/Network_socket#Raw_socket). This wrapper class enables creation of a raw socket, binding it to a network interface, and then receiving and sending packets on it. Current implementation supports only Windows and Linux because other platforms provide poor support for raw sockets making them practically unusable. There are also major differences between Linux and Windows in raw socket implementation, let's mention some of the:\nOn Windows administrative privileges are required for raw sockets creation, meaning the process running the code has to have these privileges. In Linux 'sudo' is required\nOn Windows raw sockets are implemented in L3, meaning the L2 (Ethernet) layer is omitted by the socket and only L3 and up are visible to the user. On Linux raw sockets are implemented on L2, meaning all layers (including the Ethernet data) are visible to the user.\nOn Windows sending packets is not supported, a raw socket can only receive packets. On Linux both send and receive are supported\nLinux doesn't require binding to a specific network interface for receiving packets, but it does require binding for sending packets. Windows requires binding for receiving packets. For the sake of keeping a unified and simple cross-platform interface this class requires binding for both Linux and Windows, on both send and receive\nMore details about opening the raw socket, receiving and sending packets are explained in the corresponding class methods. Raw sockets are supported for both IPv4 and IPv6, so you can create and bind raw sockets to each of the two. Also, there is no limit on the number of sockets opened for a specific IP address or network interface, so you can create multiple instances of this class and bind all of them to the same interface and IP address.\nMember Enumeration Documentation\n\u25c6\u00a0RecvPacketResult\nAn enum for reporting packet receive results\nConstructor & Destructor Documentation\n\u25c6\u00a0~RawSocketDevice()\nA d'tor for this class. It closes the raw socket if not previously closed by calling\u00a0close()\nMember Function Documentation\n\u25c6\u00a0close()\nClose the raw socket\nImplements\u00a0pcpp::IDevice.\n\u25c6\u00a0open()\nOpen the device by creating a raw socket and binding it to the network interface specified in the c'tor\nReturns\nTrue if device was opened successfully, false otherwise with a corresponding error log message\nImplements\u00a0pcpp::IDevice.\n\u25c6\u00a0receivePacket()\nReceive a packet on the raw socket. This method has several modes of operation:\nBlocking/non-blocking - in blocking mode the method will not return until a packet is received on the socket or until the timeout expires. In non-blocking mode it will return immediately and in case no packets are on the receive queue\u00a0RawSocketDevice::RecvWouldBlock\u00a0will be returned. Unless specified otherwise, the default value is blocking mode\nReceive timeout - in blocking mode, the user can set a timeout to wait until a packet is received. If the timeout expires and no packets were received, the method will return\u00a0RawSocketDevice::RecvTimeout. The default value is a negative value which means no timeout\nThere is a slight difference on this method's behavior between Windows and Linux around how packets are received. On Linux the received packet contains all layers starting from the L2 (Ethernet). However on Windows raw socket are integrated in L3 level so the received packet contains only L3 (IP) layer and up.\nParameters\nReturns\nThe method returns one on the following values:\nRawSocketDevice::RecvSuccess\u00a0is returned if a packet was received successfully\nRawSocketDevice::RecvTimeout\u00a0is returned if in blocking mode and timeout expired\nRawSocketDevice::RecvWouldBlock\u00a0is returned if in non-blocking mode and no packets were captured\nRawSocketDevice::RecvError\u00a0is returned if an error occurred such as device is not opened or the recv operation returned some error. A log message will be followed specifying the error and error code\n\u25c6\u00a0receivePackets()\nReceive packets into a packet vector for a certain amount of time. This method starts a timer and invokes the\u00a0receivePacket()\u00a0method in blocking mode repeatedly until the timeout expires. All packets received successfully are put into a packet vector\nParameters\nReturns\nThe number of packets received successfully\n\u25c6\u00a0sendPacket()\nSend an Ethernet packet to the network. L2 protocols other than Ethernet are not supported in raw sockets. The entire packet is sent as is, including the original Ethernet and IP data. This method is only supported in Linux as Windows doesn't allow sending packets from raw sockets. Using it from other platforms will also return \"false\" with a corresponding error log message\nParameters\nReturns\nTrue if packet was sent successfully or false if the socket is not open, if the packet is not Ethernet or if there was a failure sending the packet\n\u25c6\u00a0sendPackets()\nSend a set of Ethernet packets to the network. L2 protocols other than Ethernet are not supported by raw sockets. The entire packet is sent as is, including the original Ethernet and IP data. This method is only supported in Linux as Windows doesn't allow sending packets from raw sockets. Using it from other platforms will return \"false\" with an appropriate error log message\nParameters\nReturns\nThe number of packets sent successfully. For packets that weren't sent successfully there will be a corresponding error message printed to log\n",
  "context": "\n\n\ud83d\udc49\u00a0Explanation",
  "source_file": "resources\\Year 3\\Socket Programming\\Raw Socket.docx",
  "line_numbers": [
    741,
    1829
  ]
}
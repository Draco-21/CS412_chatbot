{
  "title": "howto-timerfd",
  "language": "python",
  "topics": [
    "database",
    "networking",
    "data_structures",
    "fundamentals"
  ],
  "purpose": "1.13 ThisHOWTOdiscussesPython\u2019ssupportforthelinuxtimerfiledescriptor.",
  "code": "Thefollowingexampleshowshowtouseatimerfiledescriptortoexecuteafunctiontwiceasecond:\n# Practical scripts should use really use a non-blocking timer,\n# we use a blocking timer here for simplicity.\nimport os, time\n# Create the timer file descriptor\nfd = os.timerfd_create(time.CLOCK_REALTIME)\n# Start the timer in 1 second, with an interval of half a second\nos.timerfd_settime(fd, initial=1, interval=0.5)\ntry:\n# Process timer events four times.\nfor _ in range(4):\n# read() will block until the timer expires\n_ = os.read(fd, 8)\nprint(\"Timer expired\")\nfinally:\n# Remember to close the timer file descriptor!\nos.close(fd)\nToavoidtheprecisionlosscausedbythefloattype, timerfiledescriptorsallowspecifyinginitialexpirationand\nintervalinintegernanosecondswith_nsvariantsofthefunctions.\nThisexampleshowshowepoll()canbeusedwithtimerfiledescriptorstowaituntilthefiledescriptorisreadyfor\nreading:\n1\nimport os, time, select, socket, sys\n# Create an epoll object\nep = select.epoll()\n# In this example, use loopback address to send \"stop\" command to the server.\n#\n# $ telnet 127.0.0.1 1234\n# Trying 127.0.0.1...\n# Connected to 127.0.0.1.\n# Escape character is '^]'.\n# stop\n# Connection closed by foreign host.\n#\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind((\"127.0.0.1\", 1234))\nsock.setblocking(False)\nsock.listen(1)\nep.register(sock, select.EPOLLIN)\n# Create timer file descriptors in non-blocking mode.\nnum = 3\nfds = []\nfor _ in range(num):\nfd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\nfds.append(fd)\n# Register the timer file descriptor for read events\nep.register(fd, select.EPOLLIN)\n# Start the timer with os.timerfd_settime_ns() in nanoseconds.\n# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\nfor i, fd in enumerate(fds, start=1):\none_sec_in_nsec = 10**9\ni = i * one_sec_in_nsec\nos.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\ntimeout = 3\ntry:\nconn = None\nis_active = True\nwhile is_active:\n# Wait for the timer to expire for 3 seconds.\n# epoll.poll() returns a list of (fd, event) pairs.\n# fd is a file descriptor.\n# sock and conn[=returned value of socket.accept()] are socket objects,\u2423\n,\u2192not file descriptors.\n# So use sock.fileno() and conn.fileno() to get the file descriptors.\nevents = ep.poll(timeout)\n# If more than one timer file descriptors are ready for reading at once,\n# epoll.poll() returns a list of (fd, event) pairs.\n#\n# In this example settings,\n# 1st timer fires every 0.25 seconds in 0.25 seconds. (0.25, 0.5, 0.75,\u2423\n,\u21921.0, ...)\n# 2nd timer every 0.5 seconds in 0.5 seconds. (0.5, 1.0, 1.5, 2.0, ...)\n# 3rd timer every 0.75 seconds in 0.75 seconds. (0.75, 1.5, 2.25, 3.0, .\n(continuesonnextpage)\n2\n(continuedfrompreviouspage)\n,\u2192..)\n#\n# In 0.25 seconds, only 1st timer fires.\n# In 0.5 seconds, 1st timer and 2nd timer fires at once.\n# In 0.75 seconds, 1st timer and 3rd timer fires at once.\n# In 1.5 seconds, 1st timer, 2nd timer and 3rd timer fires at once.\n#\n# If a timer file descriptor is signaled more than once since\n# the last os.read() call, os.read() returns the number of signaled\n# as host order of class bytes.\nprint(f\"Signaled events={events}\")\nfor fd, event in events:\nif event & select.EPOLLIN:\nif fd == sock.fileno():\n# Check if there is a connection request.\nprint(f\"Accepting connection {fd}\")\nconn, addr = sock.accept()\nconn.setblocking(False)\nprint(f\"Accepted connection {conn} from {addr}\")\nep.register(conn, select.EPOLLIN)\nelif conn and fd == conn.fileno():\n# Check if there is data to read.\nprint(f\"Reading data {fd}\")\ndata = conn.recv(1024)\nif data:\n# You should catch UnicodeDecodeError exception for safety.\ncmd = data.decode()\nif cmd.startswith(\"stop\"):\nprint(f\"Stopping server\")\nis_active = False\nelse:\nprint(f\"Unknown command: {cmd}\")\nelse:\n# No more data, close connection\nprint(f\"Closing connection {fd}\")\nep.unregister(conn)\nconn.close()\nconn = None\nelif fd in fds:\nprint(f\"Reading timer {fd}\")\ncount = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\nprint(f\"Timer {fds.index(fd) + 1} expired {count} times\")\nelse:\nprint(f\"Unknown file descriptor {fd}\")\nfinally:\nfor fd in fds:\nep.unregister(fd)\nos.close(fd)\nep.close()\nThisexampleshowshowselect()canbeusedwithtimerfiledescriptorstowaituntilthefiledescriptorisready\nforreading:\nimport os, time, select, socket, sys\n# In this example, use loopback address to send \"stop\" command to the server.\n(continuesonnextpage)\n3\n(continuedfrompreviouspage)\n#\n# $ telnet 127.0.0.1 1234\n# Trying 127.0.0.1...\n# Connected to 127.0.0.1.\n# Escape character is '^]'.\n# stop\n# Connection closed by foreign host.\n#\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind((\"127.0.0.1\", 1234))\nsock.setblocking(False)\nsock.listen(1)\n# Create timer file descriptors in non-blocking mode.\nnum = 3\nfds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\nfor _ in range(num)]\nselect_fds = fds + [sock]\n# Start the timers with os.timerfd_settime() in seconds.\n# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\nfor i, fd in enumerate(fds, start=1):\nos.timerfd_settime(fd, initial=i/4, interval=i/4)\ntimeout = 3\ntry:\nconn = None\nis_active = True\nwhile is_active:\n# Wait for the timer to expire for 3 seconds.\n# select.select() returns a list of file descriptors or objects.\nrfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, timeout)\nfor fd in rfd:\nif fd == sock:\n# Check if there is a connection request.\nprint(f\"Accepting connection {fd}\")\nconn, addr = sock.accept()\nconn.setblocking(False)\nprint(f\"Accepted connection {conn} from {addr}\")\nselect_fds.append(conn)\nelif conn and fd == conn:\n# Check if there is data to read.\nprint(f\"Reading data {fd}\")\ndata = conn.recv(1024)\nif data:\n# You should catch UnicodeDecodeError exception for safety.\ncmd = data.decode()\nif cmd.startswith(\"stop\"):\nprint(f\"Stopping server\")\nis_active = False\nelse:\nprint(f\"Unknown command: {cmd}\")\nelse:\n# No more data, close connection\nprint(f\"Closing connection {fd}\")\nselect_fds.remove(conn)\n(continuesonnextpage)\n4\n(continuedfrompreviouspage)\nconn.close()\nconn = None\nelif fd in fds:\nprint(f\"Reading timer {fd}\")\ncount = int.from_bytes(os.read(fd, 8), byteorder=sys.byteorder)\nprint(f\"Timer {fds.index(fd) + 1} expired {count} times\")\nelse:\nprint(f\"Unknown file descriptor {fd}\")\nfinally:\nfor fd in fds:\nos.close(fd)\nsock.close()\nsock = None\n5\n",
  "context": "1.13\nThisHOWTOdiscussesPython\u2019ssupportforthelinuxtimerfiledescriptor.\n1 Examples",
  "source_file": "resources\\Year 3\\Python\\howto-timerfd.pdf",
  "line_numbers": [
    13,
    215
  ]
}
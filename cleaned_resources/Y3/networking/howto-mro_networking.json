{
  "title": "howto-mro",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "networking",
    "algorithms",
    "data_structures"
  ],
  "purpose": "whowanttounderstandthereasonsforthechange.",
  "code": "breakingofoldcodeforclassicclasses;andevenifinprincipletherecouldbebreakingofcodeforPython2.2new\nstyle classes, in practice the cases in which the C3 resolution order differs from the Python 2.2 method resolution\norderaresorarethatnorealbreakingofcodeisexpected. Therefore:\nDon\u2019tbescared!\nMoreover,unlessyoumakestronguseofmultipleinheritanceandyouhavenon-trivialhierarchies,youdon\u2019tneed\ntounderstandtheC3algorithm,andyoucaneasilyskipthispaper. Ontheotherhand,ifyoureallywanttoknow\nhowmultipleinheritanceworks,thenthispaperisforyou. Thegoodnewsisthatthingsarenotascomplicatedas\nyoumightexpect.\nLetmebeginwithsomebasicdefinitions.\n1) GivenaclassCinacomplicatedmultipleinheritancehierarchy,itisanon-trivialtasktospecifytheorderin\nwhichmethodsareoverridden,i.e. tospecifytheorderoftheancestorsofC.\n2) ThelistoftheancestorsofaclassC,includingtheclassitself,orderedfromthenearestancestortothefurthest,\niscalledtheclassprecedencelistorthelinearizationofC.\n3) TheMethodResolutionOrder(MRO)isthesetofrulesthatconstructthelinearization. InthePythonliterature,\ntheidiom\u201ctheMROofC\u201disalsousedasasynonymousforthelinearizationoftheclassC.\n4) Forinstance,inthecaseofsingleinheritancehierarchy,ifCisasubclassofC1,andC1isasubclassofC2,\nthenthelinearizationofCissimplythelist[C,C1,C2]. However,withmultipleinheritancehierarchies,the\nconstructionofthelinearizationismorecumbersome,sinceitismoredifficulttoconstructalinearizationthat\nrespectslocalprecedenceorderingandmonotonicity.\n5) Iwilldiscussthelocalprecedenceorderinglater,butIcangivethedefinitionofmonotonicityhere. AMRO\nismonotonicwhenthefollowingistrue: ifC1precedesC2inthelinearizationofC,thenC1precedesC2inthe\nlinearizationofanysubclass ofC. Otherwise, theinnocuousoperationofderivinga newclasscouldchange\ntheresolutionorderofmethods,potentiallyintroducingverysubtlebugs. Exampleswherethishappenswill\nbeshownlater.\n6) Notallclassesadmitalinearization. Therearecases, incomplicatedhierarchies, whereitisnotpossibleto\nderiveaclasssuchthatitslinearizationrespectsallthedesiredproperties.\nHereIgiveanexampleofthissituation. Considerthehierarchy\n>>> O = object\n>>> class X(O): pass\n>>> class Y(O): pass\n>>> class A(X,Y): pass\n>>> class B(Y,X): pass\n1Thethreadonpython-devstartedbySamuelePedroni:https://mail.python.org/pipermail/python-dev/2002-October/029035.html\n2ThepaperAMonotonicSuperclassLinearizationforDylan:https://doi.org/10.1145/236337.236343\n2\nwhichcanberepresentedwiththefollowinginheritancegraph,whereIhavedenotedwithOtheobjectclass,which\nisthebeginningofanyhierarchyfornewstyleclasses:\n-----------\n| |\n| O |\n| / \\ |\n- X Y /\n| / | /\n| / |/\nA B\n\\ /\n?\nInthiscase,itisnotpossibletoderiveanewclassCfromAandB,sinceXprecedesYinA,butYprecedesXinB,\nthereforethemethodresolutionorderwouldbeambiguousinC.\nPython2.3raisesanexceptioninthissituation(TypeError: MROconflictamongbasesY,X)forbiddingthenaive\nprogrammerfromcreatingambiguoushierarchies. Python2.2insteaddoesnotraiseanexception,butchoosesanad\nhocordering(CABXYOinthiscase).\n2 The C3 Method Resolution Order\nLet me introduce a few simple notations which will be useful for the following discussion. I will use the shortcut\nnotation:\nC1 C2 ... CN\ntoindicatethelistofclasses[C1,C2,\u2026,CN].\nTheheadofthelistisitsfirstelement:\nhead = C1\nwhereasthetailistherestofthelist:\ntail = C2 ... CN.\nIshallalsousethenotation:\nC + (C1 C2 ... CN) = C C1 C2 ... CN\ntodenotethesumofthelists[C]+[C1,C2,\u2026,CN].\nNowIcanexplainhowtheMROworksinPython2.3.\nConsideraclassCinamultipleinheritancehierarchy,withCinheritingfromthebaseclassesB1,B2,\u2026,BN.We\nwanttocomputethelinearizationL[C]oftheclassC.Theruleisthefollowing:\nthelinearizationofCisthesumofCplusthemergeofthelinearizationsoftheparentsandthelistofthe\nparents.\nInsymbolicnotation:\nL[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)\nInparticular,ifCistheobjectclass,whichhasnoparents,thelinearizationistrivial:\nL[object] = object.\nHowever,ingeneralonehastocomputethemergeaccordingtothefollowingprescription:\n3\ntaketheheadofthefirstlist,i.eL[B1][0];ifthisheadisnotinthetailofanyoftheotherlists,thenaddit\ntothelinearizationofCandremoveitfromthelistsinthemerge,otherwiselookattheheadofthenextlist\nandtakeit,ifitisagoodhead. Thenrepeattheoperationuntilalltheclassareremovedoritisimpossible\ntofindgoodheads. Inthiscase,itisimpossibletoconstructthemerge,Python2.3willrefusetocreatethe\nclassCandwillraiseanexception.\nThisprescriptionensuresthatthemergeoperationpreservestheordering,iftheorderingcanbepreserved. Onthe\notherhand,iftheordercannotbepreserved(asintheexampleofseriousorderdisagreementdiscussedabove)then\nthemergecannotbecomputed.\nThecomputationofthemergeistrivialifChasonlyoneparent(singleinheritance);inthiscase:\nL[C(B)] = C + merge(L[B],B) = C + L[B]\nHowever,inthecaseofmultipleinheritancethingsaremorecumbersomeandIdon\u2019texpectyoucanunderstandthe\nrulewithoutacoupleofexamples;-)\n3 Examples\nFirstexample. Considerthefollowinghierarchy:\n>>> O = object\n>>> class F(O): pass\n>>> class E(O): pass\n>>> class D(O): pass\n>>> class C(D,F): pass\n>>> class B(D,E): pass\n>>> class A(B,C): pass\nInthiscasetheinheritancegraphcanbedrawnas:\n6\n---\nLevel 3 | O | (more general)\n/ --- \\\n/ | \\ |\n/ | \\ |\n/ | \\ |\n--- --- --- |\nLevel 2 3 | D | 4| E | | F | 5 |\n--- --- --- |\n\\ \\ _ / | |\n\\ / \\ _ | |\n\\ / \\ | |\n--- --- |\nLevel 1 1 | B | | C | 2 |\n--- --- |\n\\ / |\n\\ / \\ /\n---\nLevel 0 0 | A | (more specialized)\n---\nThelinearizationsofO,D,EandFaretrivial:\nL[O] = O\nL[D] = D O\nL[E] = E O\nL[F] = F O\n4\nThelinearizationofBcanbecomputedas:\nL[B] = B + merge(DO, EO, DE)\nWeseethatDisagoodhead,thereforewetakeitandwearereducedtocomputemerge(O,EO,E).NowOisnot\na good head, since it is in the tail of the sequence EO. In this case the rule says that we have to skip to the next\nsequence. ThenweseethatEisagoodhead;wetakeitandwearereducedtocomputemerge(O,O)whichgives\nO.Therefore:\nL[B] = B D E O\nUsingthesameprocedureonefinds:\nL[C] = C + merge(DO,FO,DF)\n= C + D + merge(O,FO,F)\n= C + D + F + merge(O,O)\n= C D F O\nNowwecancompute:\nL[A] = A + merge(BDEO,CDFO,BC)\n= A + B + merge(DEO,CDFO,C)\n= A + B + C + merge(DEO,DFO)\n= A + B + C + D + merge(EO,FO)\n= A + B + C + D + E + merge(O,FO)\n= A + B + C + D + E + F + merge(O,O)\n= A B C D E F O\nInthisexample,thelinearizationisorderedinaprettynicewayaccordingtotheinheritancelevel,inthesensethat\nlowerlevels(i.e. morespecializedclasses)havehigherprecedence(seetheinheritancegraph). However,thisisnot\nthegeneralcase.\nIleaveasanexerciseforthereadertocomputethelinearizationformysecondexample:\n>>> O = object\n>>> class F(O): pass\n>>> class E(O): pass\n>>> class D(O): pass\n>>> class C(D,F): pass\n>>> class B(E,D): pass\n>>> class A(B,C): pass\nTheonlydifferencewiththepreviousexampleisthechangeB(D,E)\u2013>B(E,D);howeverevensuchalittlemodifi-\ncationcompletelychangestheorderingofthehierarchy:\n6\n---\nLevel 3 | O |\n/ --- \\\n/ | \\\n/ | \\\n/ | \\\n--- --- ---\nLevel 2 2 | E | 4 | D | | F | 5\n--- --- ---\n\\ / \\ /\n\\ / \\ /\n\\ / \\ /\n--- ---\n(continuesonnextpage)\n5\n(continuedfrompreviouspage)\nLevel 1 1 | B | | C | 3\n--- ---\n\\ /\n\\ /\n---\nLevel 0 0 | A |\n---\nNoticethattheclassE,whichisinthesecondlevelofthehierarchy,precedestheclassC,whichisinthefirstlevel\nofthehierarchy,i.e. EismorespecializedthanC,evenifitisinahigherlevel.\nAlazyprogrammercanobtaintheMROdirectlyfromPython2.2,sinceinthiscaseitcoincideswiththePython2.3\nlinearization. Itisenoughtoinvokethemro()methodofclassA:\n>>> A.mro()\n[<class 'A'>, <class 'B'>, <class 'E'>,\n<class 'C'>, <class 'D'>, <class 'F'>,\n<class 'object'>]\nFinally, let me consider the example discussed in the first section, involving a serious order disagreement. In this\ncase,itisstraightforwardtocomputethelinearizationsofO,X,Y,AandB:\nL[O] = 0\nL[X] = X O\nL[Y] = Y O\nL[A] = A X Y O\nL[B] = B Y X O\nHowever,itisimpossibletocomputethelinearizationforaclassCthatinheritsfromAandB:\nL[C] = C + merge(AXYO, BYXO, AB)\n= C + A + merge(XYO, BYXO, B)\n= C + A + B + merge(XYO, YXO)\nAtthispointwecannotmergethelistsXYOandYXO,sinceXisinthetailofYXOwhereasYisinthetailofXYO:\nthereforetherearenogoodheadsandtheC3algorithmstops. Python2.3raisesanerrorandrefusestocreatethe\nclassC.\n4 Bad Method Resolution Orders\nAMROisbad whenitbreakssuchfundamentalpropertiesaslocalprecedenceorderingandmonotonicity. Inthis\nsection,IwillshowthatboththeMROforclassicclassesandtheMROfornewstyleclassesinPython2.2arebad.\nItiseasiertostartwiththelocalprecedenceordering. Considerthefollowingexample:\n>>> F=type('Food',(),{'remember2buy':'spam'})\n>>> E=type('Eggs',(F,),{'remember2buy':'eggs'})\n>>> G=type('GoodFood',(F,E),{}) # under Python 2.3 this is an error!\nwithinheritancediagram\nO\n|\n(buy spam) F\n| \\\n| E (buy eggs)\n| /\n(continuesonnextpage)\n6\n(continuedfrompreviouspage)\nG\n(buy eggs or spam ?)\nWeseethatclassGinheritsfromFandE,withFbeforeE:thereforewewouldexpecttheattributeG.remember2buy\ntobeinheritedbyF.remember2buyandnotbyE.remember2buy: neverthelessPython2.2gives\n>>> G.remember2buy\n'eggs'\nThisisabreakingoflocalprecedenceorderingsincetheorderinthelocalprecedencelist,i.e. thelistoftheparents\nofG,isnotpreservedinthePython2.2linearizationofG:\nL[G,P22]= G E F object # F *follows* E\nOnecouldarguethatthereasonwhyFfollowsEinthePython2.2linearizationisthatFislessspecializedthanE,\nsinceFisthesuperclassofE;neverthelessthebreakingoflocalprecedenceorderingisquitenon-intuitiveanderror\nprone. Thisisparticularlytruesinceitisadifferentfromoldstyleclasses:\n>>> class F: remember2buy='spam'\n>>> class E(F): remember2buy='eggs'\n>>> class G(F,E): pass\n>>> G.remember2buy\n'spam'\nInthiscasetheMROisGFEFandthelocalprecedenceorderingispreserved.\nAsageneralrule,hierarchiessuchasthepreviousoneshouldbeavoided,sinceitisunclearifFshouldoverrideE\norvice-versa. Python2.3solvestheambiguitybyraisinganexceptioninthecreationofclassG,effectivelystopping\ntheprogrammerfromgeneratingambiguoushierarchies. ThereasonforthatisthattheC3algorithmfailswhenthe\nmerge:\nmerge(FO,EFO,FE)\ncannotbecomputed,becauseFisinthetailofEFOandEisinthetailofFE.\nTherealsolutionistodesignanon-ambiguoushierarchy,i.e. toderiveGfromEandF(themorespecificfirst)and\nnotfromFandE;inthiscasetheMROisGEFwithoutanydoubt.\nO\n|\nF (spam)\n/ |\n(eggs) E |\n\\ |\nG\n(eggs, no doubt)\nPython2.3forcestheprogrammertowritegoodhierarchies(or,atleast,lesserror-proneones).\nOnarelatednote,letmepointoutthatthePython2.3algorithmissmartenoughtorecognizeobviousmistakes,as\ntheduplicationofclassesinthelistofparents:\n>>> class A(object): pass\n>>> class C(A,A): pass # error\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nTypeError: duplicate base class A\n7\nPython2.2(bothforclassicclassesandnewstyleclasses)inthissituation,wouldnotraiseanyexception.\nFinally,Iwouldliketopointouttwolessonswehavelearnedfromthisexample:\n1. despitethename,theMROdeterminestheresolutionorderofattributes,notonlyofmethods;\n2. thedefaultfoodforPythonistasisspam! (butyoualreadyknewthat;-)\nHavingdiscussedtheissueoflocalprecedenceordering,letmenowconsidertheissueofmonotonicity. Mygoalis\ntoshowthatneithertheMROforclassicclassesnorthatforPython2.2newstyleclassesismonotonic.\nTo prove that the MRO for classic classes is non-monotonic is rather trivial, it is enough to look at the diamond\ndiagram:\nC\n/ \\\n/ \\\nA B\n\\ /\n\\ /\nD\nOneeasilydiscernstheinconsistency:\nL[B,P21] = B C # B precedes C : B's methods win\nL[D,P21] = D A C B C # B follows C : C's methods win!\nOntheotherhand,therearenoproblemswiththePython2.2and2.3MROs,theygiveboth:\nL[D] = D A B C\nGuido points out in his essay3 that the classic MRO is not so bad in practice, since one can typically avoids dia-\nmonds for classic classes. But all new style classes inherit from object, therefore diamonds are unavoidable and\ninconsistenciesshowsupineverymultipleinheritancegraph.\nTheMROofPython2.2makesbreakingmonotonicitydifficult,butnotimpossible. Thefollowingexample,originally\nprovidedbySamuelePedroni,showsthattheMROofPython2.2isnon-monotonic:\n>>> class A(object): pass\n>>> class B(object): pass\n>>> class C(object): pass\n>>> class D(object): pass\n>>> class E(object): pass\n>>> class K1(A,B,C): pass\n>>> class K2(D,B,E): pass\n>>> class K3(D,A): pass\n>>> class Z(K1,K2,K3): pass\nHerearethelinearizationsaccordingtotheC3MRO(thereadershouldverifytheselinearizationsasanexerciseand\ndrawtheinheritancediagram;-)\nL[A] = A O\nL[B] = B O\nL[C] = C O\nL[D] = D O\nL[E] = E O\nL[K1]= K1 A B C O\nL[K2]= K2 D B E O\nL[K3]= K3 D A O\nL[Z] = Z K1 K2 K3 D A B C E O\n3GuidovanRossum\u2019sessay,UnifyingtypesandclassesinPython2.2:https://web.archive.org/web/20140210194412/http://www.python.org/\ndownload/releases/2.2.2/descrintro\n8\nPython2.2givesexactlythesamelinearizationsforA,B,C,D,E,K1,K2andK3,butadifferentlinearizationforZ:\nL[Z,P22] = Z K1 K3 A K2 D B C E O\nItisclearthatthislinearizationiswrong,sinceAcomesbeforeDwhereasinthelinearizationofK3Acomesafter\nD.Inotherwords,inK3methodsderivedbyDoverridemethodsderivedbyA,butinZ,whichstillisasubclassof\nK3,methodsderivedbyAoverridemethodsderivedbyD!Thisisaviolationofmonotonicity. Moreover,thePython\n2.2linearizationofZisalsoinconsistentwithlocalprecedenceordering,sincethelocalprecedencelistoftheclass\nZis[K1,K2,K3](K2precedesK3),whereasinthelinearizationofZK2followsK3. Theseproblemsexplainwhy\nthe2.2rulehasbeendismissedinfavoroftheC3rule.\n5 The end\nThissectionisfortheimpatientreader,whoskippedalltheprevioussectionsandjumpedimmediatelytotheend. This\nsectionisforthelazyprogrammertoo,whodidn\u2019twanttoexerciseher/hisbrain. Finally,itisfortheprogrammerwith\nsomehubris,otherwises/hewouldnotbereadingapaperontheC3methodresolutionorderinmultipleinheritance\nhierarchies;-)Thesethreevirtuestakenalltogether(andnotseparately)deserveaprize: theprizeisashortPython\n2.2scriptthatallowsyoutocomputethe2.3MROwithoutrisktoyourbrain. Simplychangethelastlinetoplay\nwiththevariousexamplesIhavediscussedinthispaper.:\n#<mro.py>\n\"\"\"C3 algorithm by Samuele Pedroni (with readability enhanced by me).\"\"\"\nclass __metaclass__(type):\n\"All classes are metamagically modified to be nicely printed\"\n__repr__ = lambda cls: cls.__name__\nclass ex_2:\n\"Serious order disagreement\" #From Guido\nclass O: pass\nclass X(O): pass\nclass Y(O): pass\nclass A(X,Y): pass\nclass B(Y,X): pass\ntry:\nclass Z(A,B): pass #creates Z(A,B) in Python 2.2\nexcept TypeError:\npass # Z(A,B) cannot be created in Python 2.3\nclass ex_5:\n\"My first example\"\nclass O: pass\nclass F(O): pass\nclass E(O): pass\nclass D(O): pass\nclass C(D,F): pass\nclass B(D,E): pass\nclass A(B,C): pass\nclass ex_6:\n\"My second example\"\nclass O: pass\nclass F(O): pass\nclass E(O): pass\nclass D(O): pass\nclass C(D,F): pass\n(continuesonnextpage)\n9\n(continuedfrompreviouspage)\nclass B(E,D): pass\nclass A(B,C): pass\nclass ex_9:\n\"Difference between Python 2.2 MRO and C3\" #From Samuele\nclass O: pass\nclass A(O): pass\nclass B(O): pass\nclass C(O): pass\nclass D(O): pass\nclass E(O): pass\nclass K1(A,B,C): pass\nclass K2(D,B,E): pass\nclass K3(D,A): pass\nclass Z(K1,K2,K3): pass\ndef merge(seqs):\nprint '\\n\\nCPL[%s]=%s' % (seqs[0][0],seqs),\nres = []; i=0\nwhile 1:\nnonemptyseqs=[seq for seq in seqs if seq]\nif not nonemptyseqs: return res\ni+=1; print '\\n',i,'round: candidates...',\nfor seq in nonemptyseqs: # find merge candidates among seq heads\ncand = seq[0]; print ' ',cand,\nnothead=[s for s in nonemptyseqs if cand in s[1:]]\nif nothead: cand=None #reject candidate\nelse: break\nif not cand: raise \"Inconsistent hierarchy\"\nres.append(cand)\nfor seq in nonemptyseqs: # remove cand\nif seq[0] == cand: del seq[0]\ndef mro(C):\n\"Compute the class precedence list (mro) according to C3\"\nreturn merge([[C]]+map(mro,C.__bases__)+[list(C.__bases__)])\ndef print_mro(C):\nprint '\\nMRO[%s]=%s' % (C,mro(C))\nprint '\\nP22 MRO[%s]=%s' % (C,C.mro())\nprint_mro(ex_9.Z)\n#</mro.py>\nThat\u2019sallfolks,\nenjoy!\n6 Resources\n10\n",
  "context": "whowanttounderstandthereasonsforthechange.\nFirstofall, letmepointoutthatwhatIamgoingtosayonlyappliestothenewstyleclassesintroducedinPython\n2.2: classicclassesmaintaintheiroldmethodresolutionorder,depthfirstandthenlefttoright. Therefore,thereisno",
  "source_file": "resources\\Year 3\\Python\\howto-mro.pdf",
  "line_numbers": [
    44,
    447
  ]
}
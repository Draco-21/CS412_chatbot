{
  "title": "raw socket 02",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "Telecooperation Report No.",
  "code": "http://www.tk.informatik.tu\u00addarmstadt.de/de/publications/\nIntroduction to RAW-sockets\nby\nHeuschkel, Jens\nHofmann, Tobias\nHollstein, Thorsten\nKuepper, Joel\nMay 17, 2017\nAbstract\nThis document is intended to give an introduction into the programming with RAW-sockets and the related\nPACKET-sockets. RAW-socketsareanadditionaltypeofInternetsocketavailableinadditiontothewellknown\nDATAGRAM- and STREAM-sockets. They do allow the user to see and manipulate the information used for\ntransmitting the data instead of hiding these details, like it is the case with the usually used STREAM- or\nDATAGRAM sockets. To give the reader an introduction into the subject we will first give an overview about\nthe different APIs provided by Windows, Linux and Unix (FreeBSD, Mac OS X) and additional libraries that\ncan be used OS-independent. In the next section we show general problems that have to be addressed by the\nprogrammer when working with RAW-sockets. We will then provide an introduction into the steps necessary to\nuse the APIs or libraries, which functionality the different concepts provide to the programmer and what they\nprovidetosimplifyusingRAWandPACKET-sockets. Thissectionincludesexamplesofhowtousethedifferent\nfunctions provided by the APIs. Finally in the additional material we will give some complete examples that\nshow the concepts and can be used as a basis to write own programs. The examples are programmed in C++\nandweassumethatthereaderhasbasicprogrammingskillsandnetworkingknowledgetobeabletounderstand\nthe listings and content of this document.\n1\nContents\n1 Introduction 8\n1.1 RAW-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.2 PACKET-sockets and Data Link Layer APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2 Implementations for different Operating Systems 10\n2.1 Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.1.1 Winsock-API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.1.2 winpcap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.2 Linux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.2.1 RAW-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.2.2 PACKET-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.3 Unix (FreeBSD, Mac OS X) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.3.1 RAW-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.3.2 Berkeley Packet Filter (BPF) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.4 OS independent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.4.1 pcap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.4.2 libnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3 Programming with the APIs 13\n3.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.1.1 Byte Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.1.2 Checksum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.1.3 Type-Casting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nLinux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n3.1.4 Header-Positions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n3.2 RAW-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.2.1 socket() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n3.2.2 setsockopt() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n3.2.3 getsockopt() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n3.2.4 bind() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n3.2.5 getsockname() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.2.6 connect(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.2.7 Read . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nread() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nrecv() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nrecvfrom() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nflags and errors for the recv()- and recvfrom()-functions . . . . . . . . . . . . . . . . . . . 21\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n3.2.8 Write . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nwrite() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nsend() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nsendto() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nFlags and errnos for the send() and sendto() functions . . . . . . . . . . . . . . . . . . . . 23\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n3.2.9 close() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n3.2.10 inet_ntop() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n3.2.11 inet_pton() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n3.2.12 Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n3.2.13 Layer 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n2\nUnix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nRead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nWrite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n3.2.14 Layer 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nRead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\nWrite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n3.2.15 Layer 2 - PACKET-sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nPromiscuous Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nMAC-Address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nRead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nWrite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n3.3 Berkeley Packet Filter (BPF) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n3.3.1 BPF Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n3.3.2 Buffer Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n3.3.3 IOCTLS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n3.3.4 SYSCTL Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n3.3.5 Filter Maschine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n3.3.6 Read . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n3.3.7 Write . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n3.4 Winsock-API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n3.4.1 Preparations and Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n4 Programming with the libraries 47\n4.1 Libnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n4.1.1 Preparations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n4.1.2 Process of packet creation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nLibrary initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nPacket building . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\nPacket write . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\nPacket destruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n4.1.3 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nLibrary initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nBuild Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nWrite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\nDestruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\nOther functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n4.2 libpcap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.2.1 Preparation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.2.2 Process of packet capturing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nInterface Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nInitialize libpcap session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nDefine Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nInitiate Sniffing process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\nIdentification of the header size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\nCasting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nByte order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nClose libpcap session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n4.2.3 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nInterface Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\nInitialize libpcap session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\nDefine Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\nInitiate Sniffing process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nClose Session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\nOther functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n4.3 libpcap in Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n4.3.1 Installation and Preparation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.3.2 Process of packet capturing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.3.3 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n5 Literature 67\n3\nA Appendix: Listings 69\nA.1 rfc1071 checksum cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\nA.2 win socket cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\nA.3 libnet tcp c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\nA.4 sendpack c. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nA.5 dump c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\nB Appendix: Tables 80\nB.1 Protocol Types of <netinet/in.h> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\nB.2 Linux Protocol Types defined in linux if_ether.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\nB.3 Socket level options for setsocketopt() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\nB.4 IP level options for setsockopt() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nB.5 Errno flags for connect() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\nB.6 ioctl() flags defined in bpf.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\n4\nList of Figures\n1 Socket provided by the operating system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n2 Overview over the layers and access possibilities. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3 Structure of a RAW-socket layer 4 Read Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n4 Structure of a RAW-socket layer 4 Write Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n5 Structure of a RAW-socket layer 3 Read Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n6 Structure of a RAW-socket layer 3 Write Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n7 Structure of a PACKET-socket layer 2 Read Operation . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n8 Structure of a PACKET-socket layer 2 Write Operation . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n9 Structure of a BPF device layer 2 Read Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n10 Structure of a BPF device layer 2 Write Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n11 Overview of the packet construction in libnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n12 Overview of the packet construction in libnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n5\nList of Tables\n1 Byte-Order Transformation Functions [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2 C-Header-Files for Network Headers [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n3 Address family constants provided in <sys/socket.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . 15\n4 Errno flags for socket() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n5 The socket types are defined in <sys/socket.h>[8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n6 Errno flags for setsockopt() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . 17\n7 Errno flags for getsockopt() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . 18\n8 Errno flags for bind() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n9 Errno flags for UNIX-bind() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . 18\n10 Errno flags for getsocketname() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . 19\n11 Errno flags for read() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n12 Flags for recv() and recvfrom() defined in <sys/socket.h> [8] . . . . . . . . . . . . . . . . . . 21\n13 Errno flags for recv() and recvfrom() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . 21\n14 Errno flags for write() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n15 Flags for send() and sendto() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . 24\n16 Errno flags for send() and sendto() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . 24\n17 Errno flags for close() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n18 Errno flags for ntop() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n19 Errno flags for pton() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n20 ioctl() flags defined in <bpf.h> [2] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n21 Overview of libnet_init() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n22 Overview of libnet_build_udp() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n23 Overview of libnet_build_ipv4() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n24 Overview of libnet_build_ethernet() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n25 Overview of libnet_autobuild_ipv4() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n26 Overview of libnet_write() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n27 Overview of libnet_name2addr4() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n28 Overview of libnet_addr2name4() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n29 Overview of libnet_toggle_checksum() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n30 Overview of libnet_stats() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n31 Overview of libnet_geterror() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n32 Overview of Network Layer Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n33 Overview of Transport Layer Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n34 Overview of pcap_lookupdev() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n35 Overview of pcap_lookupnet() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n36 Overview of pcap_findalldevs() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n37 Overview of the pcap_if_t header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n38 Overview of the pcap_addr header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n39 Overview of the sockaddr header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n40 Overview of pcap_open_live() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n41 Overview of pcap_compile() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n42 Overview of pcap_setfilter() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n43 Overview of pcap_next() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n44 Overview of pcap_loop() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n45 Overview of callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n46 Common data link types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n47 Protocol Types defined in <netinet/in.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n48 Linux Protocol Types defined in <linux/if_ether.h> . . . . . . . . . . . . . . . . . . . . . . . . . 81\n49 Socket level options for setsockopt() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . 82\n50 IP level options for setsockopt() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . 83\n51 Errno flags for connect() as defined in <errno.h> [8] . . . . . . . . . . . . . . . . . . . . . . . . . 84\n52 ioctl() flags defined in <bpf.h> [2] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\n6\nList of Listings\n1 sockaddr in cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2 sockaddr in6 cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n3 sockaddr init cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n4 sockaddr ll cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5 ifreq cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n6 ifreq init cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n7 mac cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n8 bpf cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n9 bpf2 cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n10 bpf structs cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n11 bpf structs filter cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n12 rfc1071 checksum cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n13 win socket cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n14 libnet tcp c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n15 sendpack c. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n16 dump c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n7\n1 Introduction\nFirst of all we want to define the basic wordings and concepts used. Then the reader is given a short overview about\nthe possibilities and restrictions the available APIs impose on the user.\nInternet sockets are the common way to perform network communication implemented in most operating systems.\nThey are usually provided by a socket API and are based upon the same principles as reading and writing a file.\nA program can get a socket via a function provided by the operating system. This function then returns a socket\ndescriptor, usually a simple integer, similar to the ones provided by most operating systems for Read- and Write-\nOperations on files. This socket descriptor then can be used to write or read data from the socket. The data written\ntothesocketisencapsulatedbytheoperatingsystembyaddingheadersandtrailersandthenthecompletepacketis\nsent via the network interface over the network to the target host. The data that has been received from the socket\nispresentedtotheprogramwithouttheheadersandtrailers,onlytheuserdataispresentedtotheuser. Thesockets\nthat work this way are the DATAGRAM- or STREAM-sockets provided via the Berkeley socket API. The user is\nunaware of the communication between the lower layers. All network communication steps, like for example the\nconnection establishment, are taken care of without knowledge of the user. The user is only responsible for creating\nthe socket and then providing the data that he wants to send to the correct function.\nFigure 1: Socket provided by the operating system\nThe only parameters the user has to set are:\n\u2022 The source socket address, a combination of IP address and port number can be set usually via the bind()\nfunction or defined directly with one of the send() functions.\n\u2022 BychoosingeithertheDATAGRAM-orSTREAM-socketwecanchooseifwewanttohaveaseparatedatagrams\nor a byte stream. This also chooses the Transport Layer Protocol that is being used (UDP or TCP).\nIfwewanttogainaccesstothedataofthelowerlayerswehaveseveralpossibilities: RAW-sockets,PACKET-sockets,\nnetwork drivers and Data Link layer APIs. The programming of Network Drivers will not be discussed further in\nthis work, since we want to have a look at portable solutions that work for different operating systems. What can\nbe accessed by the APIs we will present is shown in figure 2 on the following page.\nWith these APIs it is possible for an application to change and access the fields of the Network layers that are\nused for sending the data. This might be seen as a break with the traditional layering model, since we can influence\nthe service the lower layers provide.\n1.1 RAW-sockets\nRAW-sockets are part of the standard Berkeley sockets and the socket API that is based upon it [1]. They are\nanotheroptioninadditiontothealreadymentionedDATAGRAM-orSTREAM-socketstocreatedatapacketswith\nthe socket API [1]. In addition to simply sending data and defining address information the RAW-socket allows\nthe user to access and manipulate the header and trailer information of the lower layers, more specifically with\nRAW-sockets to the Network and Transport layer (layer 3 and 4 of the OSI model). Since RAW-sockets are part of\nthe Internet socket API they can only be used to generate and receive IP-Packets.\n8\nFigure 2: Overview over the layers and access possibilities\nThe biggest problem with RAW-sockets (also the PACKET-sockets we discuss later) is that there is no uniform API\nfor using RAW-sockets under different operating systems:\n\u2022 TheprovidedAPIsdifferinregardtotheusedbyteorder. Dependingontheoperatingsystemthefieldsofthe\npackets have to be filled with data in network- or host-byte-order.\n\u2022 Differences also exists in the types of packets and protocols that can be created using the RAW-socket API.\n\u2022 The usage and functionality of the APIs is also different for each operating system.\n\u2022 Some operating systems do not allow certain packet types to be received using the RAW-socket API.\n\u2022 There are also differences in the definitions and paths of the necessary header files provided by each operating\nsystem.\n\u2022 The required access levels for using the RAW-socket API can also differ. However most operating systems\nrequire root or admin access permissions to use them.\nThe user has to keep these things in mind if he wants to use the RAW-socket API, especially if he plans to use them\nacross different operating systems.\n1.2 PACKET-sockets and Data Link Layer APIs\nIf the user also wants to access the header and trailer of the Data Link layer then a Data Link Layer API has to\nbe used. Under Linux (and Unix as well) this a functionality is provided by the operating system as the so called\nPACKET-socket and can be seen as a special form of RAW-sockets, so the limitations and problems of the previous\nsection also apply to them [1]. But since this is not a standardized functionality there might be a different API\nprovided by the operating system to perform these operations. For example under BSD the so called BSD Packet\nFilter (BPF) not the PACKET-socket API provides access to the Data Link Layer [2]. In general all of these APIs\nusually allow access to the whole packet from the Data Link Layer (OSI Layer 2), the Network Layer (OSI Layer 3)\nup to the Transport layer (OSI Layer 4). Not all operating systems provide a simple interface to access the Data\nLink Layer. As an alternative we introduce a library that can be used to provide this functionality.\n9\n2 Implementations for different Operating Systems\nFirst we want to give a short overview over some of the APIs and libraries that are available for RAW-socket and\nData Link Layer network programming. In general we want to split the available libraries into two parts, the APIs\nprovided by the operating systems and independent libraries that are available for multiple operating systems.\n2.1 Windows\nWindows as a operating system is pretty restricted when it comes to RAW-socket, PACKET-socket and Data Link\nLayer programming. In general it is difficult to get the programs running under Windows and the available options\nare pretty limited. For that reason in general 3rd party libraries are recommended if the user wants to do network\nprogramming on Windows systems and still write portable code.\n2.1.1 Winsock-API\nWinsock, currently available in version 2, is the Windows implementation of the Berkeley socket. Winsock is based\non the implementation of sockets on Linux and BSD and allows both sending and receiving of RAW-Packets, but\nadds additional functionality.\nNevertheless, in the latest operating system versions (Windows XP and newer), there are the some restrictions\nthe programmer has to consider according to the MSDN-library [3] for developers:\n\u2022 Like in most operating system the Winsock-API also need admin access permits to work properly for RAW-\nsockets.\n\u2022 A call to the bind function with a RAW-socket for the TCP protocol is not allowed, in fact TCP data cannot\nbe sent over a RAW-socket at all.\n\u2022 UDP datagrams with an invalid source address cannot be sent over RAW-sockets.\n\u2022 The IP source address for any outgoing UDP datagram must exist on a network interface or the datagram is\ndropped. This change was made to limit the ability of malicious code to create distributed denial-of-service\nattacks and to limit the ability to send spoofed packets (TCP/IP packets with a forged source IP address).\n\u2022 Especially receiving is much slower with RAW-sockets than using a customized driver based on the lower\nnetwork layers, since all traffic is received (this consideration is the same for any other operating system).\n2.1.2 winpcap\nTheabilityofWinsocktoalsomanipulatetheDataLinkLayerwasremovedinthecurrentversions. InsteadWindows\ndoesrequiretoprogramadriverwiththerequiredfunctionality. WithNetworkDriverInterfaceSpecification(NDIS)\nversion6.40(currently)theOperatingsystemprovidesanAPItodothisifneeded. Thisisnowthepreferredwayto\nwrite own applications that want to access the Data Link Layer on Windows. Since want to only look at APIs and\nlibraries provided by the operating system, we want to point to winpcap and libnet at this point as an alternative\nto the Winsock-API. Winpcap is the windows port of libpcap and allows generation and receiving of packets from\nthe Data Link Layer upwards. Libnet is a network programming library available for many operating systems that\nallow easy sending of RAW-packets. All further details of winpcap and libnet can be found under their sections, if\nthere are differences using the windows versions of the libraries they will be pointed out accordingly [4].\n2.2 Linux\nLinux is one of the operating systems for which it is easy to do RAW-socket and Data Link Layer Programming. It\nprovides the APIs to do both, but the kernel has to be compiled with the option to support the options.\n2.2.1 RAW-sockets\nThe RAW-socket is included in the socket-API as we already discussed. It allows both sending and receiving of\nRAW-packets, however the following items still have to be observed:\n\u2022 Due to essential nature of header information for networking functionality and security using RAW-sockets\nrequires root access permissions [5].\n\u2022 TheportsofthenetworklayerarenotendpointsanymoresinceRAW-socketsworkonthelayersbelow. Filtering\nbased on ports has to be done manually [5].\n10\n\u2022 The bind() and connect() functions are no longer necessary [5]. bind() and textttconnect() can still be\nusedtothedefinesourceaddressandtargetaddresstobeenteredautomaticallybythekernel[5]. Additionally\na raw socket can be bound to a network device using SO_BINDTODEVICE.\n\u2022 The listen() and accept() functions are without function, since the client-Server-Semantic is no longer\npresent [5]. When we use RAW-sockets we are sending unconnected packets [5].\n\u2022 IP-headers of RAW sockets can be manually created by the programmer if the option IP_HDRINCL is enabled\n[1]. This way, Raw sockets allow a programmer to implement new IP based protocols. If IP_HDRINCL is not\nenabled the IP header will be generated automatically.\n\u2022 WhenaRAWsocketiscreatedanyIPbasedprotocolcanbespecified[1]. Thisresultsinasocketonlyreceiving\nmessages of the type of the specified protocol.\n\u2022 If a programmer does not want to specify a protocol when creating a RAW-socket he can also use the\nIPPROTO_RAW protocol (which implies that the headers will be created manually) [1]. This way he can\nsend any IP based protocol. However this socket is not able to receive any IP packets, to receive all IP based\npackets a PACKET-socket has to be used.\n2.2.2 PACKET-sockets\nPACKET-sockets are a special type of RAW-sockets that allow access to the fields of the Data Link Layer. To use\nthem there are some definitions required that not part of the socket-API, but are provided by the Linux Kernel. So\nwhile they are integrated in the socket-API of Linux, they are dependent on our operating system [5].\nSimilar restrictions than for the RAW-sockets have to be considered:\n\u2022 SimilartoRAW-sockets,duetoessentialnatureofheaderinformationfornetworkingfunctionalityandsecurity\nreasons using PACKET-sockets also requires root access permission [5].\n\u2022 The ports of the Network layer are not endpoints anymore, since RAW-sockets work on the layers below [5].\nFiltering based on ports has to be done manually.\n\u2022 The bind() and connect() functions are no longer necessary [5]. bind() can still be used to define the\ninterface over which the Data Link Layer packet should be sent [5]. connect() has no function anymore [5].\n\u2022 Thelisten()andaccept()functionsarenouseatallsincetheClient-Server-Semanticisnolongerpresent\n[5]. When we use RAW-sockets we are sending unconnected packets.\n2.3 Unix (FreeBSD, Mac OS X)\nLike Linux under Unix operating systems there are also RAW-sockets provided with the Unix kernel. RAW-sockets\nare however more restricted than under Linux. Access to the Data Link Layer is possible in Unix via the Berkeley\nPacket Filters (BPF) provided by the operating system.\n2.3.1 RAW-sockets\nRAW-sockets are included in the socket-API in Unix like they are in Linux. In Unix there are different header files\navailable and needed than in Linux, that makes some considerations necessary to keep code portable between these\ntwo operating systems [1]. Also there are some differences to the functionality.\nSimilar to Linux there are some restrictions to take into consideration:\n\u2022 It is not possible to read packets for anything that has a handler (like TCP or UDP), but it is possible to read\npackets for other protocols like ICMP [6].\n\u2022 For BSD and its ports it could be that the Packets are modified by the operating system before sending. For\nexample with the release 10 the IP length is modified to the actual size of the IP header regardless of what is\nset by the programmer.\n\u2022 Due to essential nature of header information for networking functionality and security reasons using RAW-\nsockets requires root access permission [5].\n\u2022 The ports of the Network layer are not endpoints anymore, since RAW-sockets work on the layers below [5].\nFiltering based on ports has to be done manually.\n\u2022 Thebind()andconnect()functionsarenolongernecessary[5]. bind()andconnect()canstillbeused\nto define source address and target address to be entered automatically by the kernel [5].\n11\n\u2022 Thelisten()andaccept()functionsarenouseatallsincetheClient-Server-Semanticisnolongerpresent\n[5]. When we use RAW-sockets we are sending unconnected packets.\n2.3.2 Berkeley Packet Filter (BPF)\nThe Berkeley Packet Filter is the API provided by Unix operating systems to allow the user access to the Data\nLink Layer. It is compiled into the kernel of Unix-like hosts and allows access to all packets received at the Network\nInterface Controller (NIC) [7]. It has a built in filtering mechanism that allows the user to filter the received traffic\nfor the packets he is interested in [7]. Since the RAW-socket implementation does not support receiving of packets\nthat have a handler (like TCP or UDP) the Berkeley Packet Filter has to be used if the user wants to receive these\npackets [7].\n2.4 OS independent\nOther than the OS dependent APIs and the standard APIs provided by the standard Berkey socket API there are\nalso universal packet capturing and creation libraries. Of those we want to introduce two libraries, namely libpcap\nand libnet which are available for many operating systems (e.g. Windows, OS X, BSD, Linux) and therefore can\nmake programming with RAW-sockets more portable. The libraries complement each other pcap is usually used to\nreceive the packets while libnet provides easy mechanisms to send packets.\n2.4.1 pcap\nPcap is an open library for packet capture. It allows the user to receive and filter all packets received at the network\ninterface from the Data Link Layer upwards. It is available across different platforms, for Unix and Linux systems\nthereexistslibpcap(libraryforpacketcapture),thelibraryforWindowsiscalledWinpcap. Italsosupportsinjection\nof layer 2 packets, but the use of this functionality is very limited and not very comfortable. The use of the library\nmight require admin or root permissions to work, depending on the operating system. One of the most well known\nprograms that uses pcap is Wireshark.\n2.4.2 libnet\nLibnet is a library for constructing and sending packets from the Data Link Layer upwards. It is intended as the\ncounterpart for pcap. What it does provide is a simple, modular interface for packet construction and injection. It\ngives programmers many helpful functions to make the construction of own packets very easy. Currently over 30+\nprotocols are supported by the library and it is available for many operating systems.\n12\n3 Programming with the APIs\n3.1 General\nWe start by discussing some general topics that have to be considered for the development with any of the following\nAPIs. Other than the topics presented here, it should be noted that the programmer also has to observe the\nparticularities of the network protocols he wants to use. If these are not observed, like for example the correct order\nin that protocol information has to be exchanged, it cannot be ensured that we are able to communicate with the\nother host since the results than can be very different based on the implementation of the the target host.\n3.1.1 Byte Order\nIn network communication the byte-order, also known as endianness, is essential for setting and interpreting the\nfields correctly. It comes into play whenever a value does need more than 1 byte of storage space. Whenever this\nis the case we have to translate between network-byte-order and host-byte-order. The network-byte-order and host-\nbyte-order may may be different depending on the used protocol and operating system. For the IP-protocol the\nnetwork-byte-order is big-endian, so we have to translate whenever the byte-order of the host is not big-endian [5].\nSo we have two cases:\n\u2022 Whenwesendnetworkpacketsalldatathatneedsmorethan1byteithastobetranslatedfromhost-byte-order\nto network-byte-order.\n\u2022 When we receive data on a socket all data that needs more than 1 byte it has to be translated from network-\nbyte-order to host-byte-order.\nFor the transformations used for the IP-protocol the Berkeley socket API provides a set of standard functions\nwhich are available in the header file <arpa/inet.h>:\nFunction Description\nuint32_t htonl(uint32_t hostlong) host-to-network\nuint16_t htons(uint16_t hostshort) host-to-network\nuint32_t ntohl(uint32_t netlong) network-to-host\nuint16_t ntohs(uint16_t netshort) network-to-host\nTable 1: Byte-Order Transformation Functions [8]\nWith Linux we can be sure that the data receive/sent over a socket always is in network-byte-order [5].\nFor Unix it can be the case that some fields of the header are in host-byte-order depending of the release (for\nexample BSD) [5].\n3.1.2 Checksum\nMany protocols used for network communication use a checksum to be able to detect transmission errors. There are\ndifferent ways to calculate a checksum. If we choose to generate the packet headers completely by our self we have\nto calculate and set the applicable header fields manually. There are some points to take into consideration if we do\nthis:\n\u2022 Which algorithm has to be used to compute the checksum.\n\u2022 Which fields of the header, sometimes even of multiple headers, have to be included in the calculation of the\nchecksum [5]. Of course the user data might have to be included in the calculation as well.\n\u2022 If we want to calculate the checksum all header information already has to be set with the correct data.\n\u2022 Do we have to calculate the checksum or can it be calculated automatically by the network driver/hardware\n(for example the Ethernet checksum), the operating system or a predefined function call [5].\nAs a possible code example for the calculation of a checksum here is the listing for computing the Internet-checksum\nwhich was provided with the RFC 1071 which can be found in the appendix.\n13\n3.1.3 Type-Casting\nOne of the basic functionalities of the C programming language is that it supports Type-Casting. The ability to\ncast binary data to a data structure struct in C is essential to make working with header data easier for the\nprogrammer. To perform type casting we simply create a pointer to the desired structure:\nstruct header* protocolHeader;\nThen we do need a pointer to the memory space where the binary data of the packet is stored, in our examples\nmostly a char-Array with a fixed SIZE[5]:\nchar buffer[SIZE];\nFinally we can cast the binary data to our struct and afterwards are able to access the header fields[5]:\nprotocolHeader = (struct header*) buffer;\nWhenaccessingtheheader-fieldwestillhavetotakecareofthebyteorderlikementionedbefore. Forthemajority\nof the well known protocols there are predefined structs available in the header files included in the libraries. Some\noftheavailableheadersareshowninthetablebelow, butitdoesonlyshowapartoftheavailableheaderstructures.\nMore headers may be available depending on the operating system and the library.\nLinux Under Linux typically the following header files are available:\nHeader-File Description\n<netinet/ip.h> Defines macros, variables, and structures for IP.\n<netinet/ip_icmp.h> Defines macros, variables, and structures for ICMP.\n<netinet/udp.h> Defines macros, variables, and structures for UDP.\n<netinet/tcp.h> Defines macros, variables, and structures for TCP.\n<netns/idp.h> Defines IPX packet headers.\n<netns/sp.h> Defines SPX packet header.\n<ssl.h> Defines SSL prototypes, macros, variables, and structures.\nTable 2: C-Header-Files for Network Headers [8]\n3.1.4 Header-Positions\nAnother issue that has to be taken into consideration is the position of the packet headers in the binary data. The\nfollowing has to be taken into consideration:\n\u2022 Like it was shown in the beginning the header of a lower layer always encapsulate the header of the higher\nlayers and the data.\n\u2022 The header of the lowest layer can always be found at the beginning of the binary data packet. It might be\nthe case that not all fields are present, for example this is the case for the Ethernet-Protocol in the Data Link\nlayer. For the Ethernet-Protocol the preamble, start of frame delimiter and the frame checksum are removed\nby the network driver since they do belong more to the Physical Layer (OSI Layer 1)[5].\n\u2022 If we type cast binary data to structs we have to add the length of the last header to the data pointer to get\nthe beginning of the next header [5]:\nnext_header = (struct header*) (buffer + sizeof(struct header));\n\u2022 To find the correct start position might be a bit more difficult than a simple add operation as shown here if\nthe last header has a variable length with optional fields (like for example the IP-header or the TCP-header).\nIn that case we must first get the fixed part of the header, then access the length field and finally compute the\nlength of the optional header. Only after doing this we are able to find the start of the next header. If we are\ninterested in the content of the optional fields we also have to access the header field containing the type of\noptional fields and cast it to the correct type accordingly.\n14\n3.2 RAW-sockets\nThe first API discussed here is the RAW-socket. It is available on Linux and Unix Systems. As already mentioned\nthe PACKET-sockets can be seen as a specialized form of RAW-sockets and just allow access a lower layer then the\nnormal RAW-socket. RAW-sockets allow access to the Network (OSI layer 4) and Internet (OSI layer 3) layer of the\nnetworkstack[5]. TheuseofRAW-socketsislimitedtoprocesseswithaneffectiveuserIDof0ortheCAP_NET_RAW\ncapability since they require root-access permissions [1]. In the following we will start by giving a generic overview\nover the functions available and necessary to create and work with RAW-sockets. After that we show the structure\nof different protocol level write and read operations.\n3.2.1 socket()\nBoth the read and write to a RAW-socket require the socket to be created first. For the creation of a socket the\nsame function as for normal sockets is used. It is available in the <netinet/in.h> header and has the following\nform [8]:\nint socket(int family, int type, int protocol)\nThe following parameters have to be defined:\n\u2022 family expects a constant value that describes the used address family [8]. The following values are defined\nin <sys/socket.h>:\nConstant Description\nAF_LOCAL Local communication\nAF_UNIX Unix domain sockets\nAF_INET IP version 4\nAF_INET6 IP version 6\nAF_IPX Novell IPX\nAF_NETLINK Kernel user interface device\nAF_X25 Reserved for X.25 project\nAF_AX25 Amateur Radio AX.25\nAF_APPLETALK Appletalk DDP\nAF_PACKET Low level packet interface\nAF_ALG Interface to kernel crypto API\nTable 3: Address family constants provided in <sys/socket.h>\n[8]\nThe function only passes errors originating from the network to the user when the socket is connected. In that\ncaseonlyEMSGSIZEandEPROTOarepassedforcompatibility. IftheIP_RECVERRflagisenabled,allnetwork\nerrors are saved in the error queue. It returns a non-negative socket-descriptor if it was created successful and\n-1 if an error occurred during creation of the socket. Additionally the variable errno defined in <errno.h>\nis set and can have the following values [8]:\nFlag Description\nEACCES User tried to send to a broadcast address without having the broadcast flag set on the\nsocket.\nEFAULT An invalid memory address was supplied.\nEINVAL Invalid argument.\nEMSGSIZE Packet too big. Either Path MTU Discovery is enabled or the packet size exceeds the\nmaximum allowed IPv4 packet size of 64KB.\nEOPNOTSUPP Invalid flag has been passed to a socket call.\nEPERM The user doesn\u2019t have permission to open raw sockets.\nEPROTO An ICMP error has arrived reporting a parameter problem.\nTable 4: Errno flags for socket() as defined in <errno.h> [8]\nUsershavetobeawarethatsettingthefamilyofcoursealsoinfluenceswhichprotocolcanbechosenlater.\nThe usual option to use with RAW-sockets is the AF_INET to send and receive IP version 4 packets.\n15\n\u2022 type defines the socket type. The following values are defined in <sys/socket.h>:\nConstant Description\nSOCK_STREAM Stream (connection) socket\nSOCK_DGRAM Datagram (connection-less) socket\nSOCK_RAW RAW socket\nSOCK_RDM Reliably-delivered message\nSOCK_SEQPACKET Sequential packet socket\nSOCK_PACKET Linux specific way of getting packets at the dev level.\nTable 5: The socket types are defined in <sys/socket.h>[8]\nSince we want to work with RAW-sockets we only use the SOCK_RAW constant in the following sections.\nFromLinuxkernel2.6.27, thereisasecondpurposeforthetypeargument, itadditionallyallowstomodifythe\nbehavior of the socket by including the following options with bit-wise OR [8]:\n\u2013 SOCK_NONBLOCK: Sets the O_NONBLOCK file status flag on the new open socket descriptor. Using this\nchanges the socket to a non-blocking one.\n\u2013 SOCK_CLOEXEC: Sets the close-on-exec flag for the new socket descriptor. Useful if the program creates\nchild processes which use exec() to run another program. In that case this flag will prevent the other\nprogram from using this socket descriptor.\n\u2022 protocol defines like the name implies the protocol of the packets that can be sent and received with the\nsocket [8]. The protocol numbers are defined by the IANA (Internet Assigned Numbers Authority) and a\ncomplete list can be found on their website. The table ?? shows the constants for protocols which are defined\nin the <netinet/in.h> header file.\nAgain, users have to be aware of which family was chosen for the first option, since only protocols of that\nfamily can be chosen as protocol. So with our usual AF_INET option selected we can only use IP-based\nprotocols [8].\nAlso it should already be noted here that the IPPROTO_RAW constant in for most operating system (depends\non the Linux/Unix distribution) does imply that the socket also expects an IP header to be manually created\nby the user [8]. If we chose this constant we have layer 3 write access as a result. The regular way to do\nthis is to use another constant and then to change the socket options with setsockopt() as described in\nsection 3.2.3 on the next page.\nIn addition to these constants we could also use constants that are defined for layer 2 (PACKET-sockets) to\naccesstheirprotocolinformation. Theseconstantsareoperatingsystemdependentandthereforecodethatuses\nthemcannotbeportedaseasyasthegeneralconstantsfromtheprevioustable. Asanexample,table48inthe\nappendixshowstheconstantsinLinuxforEthernetprotocolswhicharedefinedinthe<linux/if_ether.h>\nheader.\nUnix The socket() function is POSIX and 4.4BSD conform [8]. The SOCK_NONBLOCK and SOCK_CLOEXEC\nflags are Linux-specific [8]. The function is generally portable to BSD systems, but some systems require the\n<sys/types.h> header to work [8]. The manifest constants might also be different under some BSD versions.\n3.2.2 setsockopt()\nThe setsockopt() function like the name implies can be used to change the options that are selected for the\nsocket. The function can manipulate the options for different protocol levels such as IP or TCP, but also for the\nsockets level API by setting the level to SOL_socket. The function which is defined in the <sys/socket.h>\nheader has the following form [8]:\nint setsockopt(int sockfd, int level, int optname, const void * optval, socklen_t\noptlen)\nThe following parameter can be set [8]:\n\u2022 sockfd - Specifies the socket for which the options should be set.\n\u2022 level - The protocol level of the option we want to set.\n16\n\u2022 optname - The name of the option we want to set. Together with the optval and optlen it is passed\nuninterpreted to the protocol module for processing.\n\u2022 optval-Thebufferfortheoptionwewanttospecify,usuallyanInteger. Itshouldthenbenon-zerotoenable\na Boolean option and zero to disable it.\n\u2022 optlen - The length of the buffer that optval points to in bytes.\nWe want to only give an short overview over the most interesting options for us, the socket level and the IP\nprotocol level, which can be set with the setsockfunction() function. Additional information about the use\nand meaning of the options can be found in the programmer manuals for the protocols. They exist for all protocols\navailable for the respective operating system or distribution.\nFor the socket level API that can be accessed with SOL_socket as the level, the options in table 49 in the\nappendix are supported and already included in the <sys/socket.h> header.\nFor the IP level API that can be accessed with IPPROTO_IP as the level, table 50 in this appendix shows the\nfollowing options supported and already included in the <netinet/ip.h> header.\nThe function returns zero on success and -1 on an error [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the following values:\nFlag Description\nEBADF The argument sockfd is not a valid descriptor.\nEFAULT The address pointed to by optval is not in a valid part of the process address space.\nEINVAL optlen invalid or invalid optval.\nENOPROTOOPT The option is unknown at the level indicated.\nENOTSOCK The argument sockfd is a file, not a socket.\nTable6: Errnoflagsforsetsockopt()asdefinedin<errno.h>\n[8]\nUnix ThefunctionisPOSIXand4.4BSDconform[8]. AccordingtothePOSIX-standardtheuseofsetsockopt()\ndoes only require to include <sys/socket.h> header, so under Linux it can be used by only including this single\nheader [8]. To use it under Unix also require the <sys/types.h> header to be included [8]. For portability it is\ngenerally recommended to include both.\n3.2.3 getsockopt()\nForretrievinganspecifiedoptionofthesocketthegetsockopt()functiondefinedinthe<sys/socket.h>header\ncan be used [8]:\nint getsockopt(int sockfd, int level, int optname, void * optval, socklen_t *\noptlen)\nThe following parameter have to be set [8]:\n\u2022 sockfd - Specifies the socket for which the options should be retrieved.\n\u2022 level - The protocol level of the option we want to retrieve.\n\u2022 optname - The name of the option we want to retrieve. Together with the optval and optlen it is passed\nuninterpreted to the protocol module for processing.\n\u2022 optval - The buffer for the option we want to retrieve.\n\u2022 optlen -Thelength ofthebufferthat optvalpointstoin bytes. Initiallyitshouldcontain thelengthofthe\nbuffer, after the call it indicates the actual size of the value returned. In case no value is supplied or returned\nit might return NULL.\nThe function returns zero on success and -1 on an error [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the following values:\n17\nFlag Description\nEBADF The argument sockfd is not a valid descriptor.\nEFAULT The address pointed to by optval or optlen is not in a valid part of the process address space.\nEINVAL optlen invalid or invalid optval.\nENOPROTOOPT The option is unknown at the level indicated.\nENOTSOCK The argument sockfd is a file, not a socket.\nTable7: Errnoflagsforgetsockopt()asdefinedin<errno.h>\n[8]\nUnix ThefunctionisPOSIXand4.4BSDconform[8]. AccordingtothePOSIX-standardtheuseofgetsockopt()\ndoes only require to include <sys/socket.h> header, so under Linux it can be used by only including this single\nheader [8]. To use it under Unix also require the <sys/types.h> header to be included [8]. For portability it is\ngenerally recommended to include both.\n3.2.4 bind()\nAfter creating a socket like discussed in the previous section 3.2.1 on page 15, we can bind the created socket to\na specific address. Traditionally this is also called assigning a name to a socket. For RAW-sockets and PACKET-\nsockets this is optional, but we use it to define the source address of our packets with it and also define from which\nnetwork-interfacewewanttoreadpackets. Othersockettypesmightrequiretobeboundtoaspecificaddressbefore\nthey can be used. For binding the socket to an IP-address we can use the bind() function which is defined in the\n<sys/socket.h> header and has the following form [8]:\nint bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen)\nThe following parameters can be set [8]:\n\u2022 sockfd - Specifies the socket for which the address should be set.\n\u2022 addr - The address structure containing the address to be set.\n\u2022 addrlen - The length of the address structure in bytes.\nThe function returns zero on success and -1 on an error [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the following values:\nFlag Description\nEACCES The address is protected, and the user is not the superuser.\nEADDRINUSE The given address is already in use.\nEADDRINUSE All port numbers in the port range are currently in use.\nEBADF sockfd is not a valid file descriptor.\nEINVAL The socket is already bound to an address.\nEINVAL addrlen is wrong, or addr is not a valid address for this socket\u2019s domain.\nENOTSOCK The file descriptor sockfd does not refer to a socket.\nTable 8: Errno flags for bind() as defined in <errno.h> [8]\nUnix AccordingtothePOSIX-standardtheuseof bind()doesonlyrequiretoinclude<sys/socket.h>header,\nso under Linux it can be used by only including this single header [8]. To use it under Unix also requires the\n<sys/types.h> header to be included [8]. For portability it is generally recommended to include both. For a\nUNIX domain (AF_UNIX) the following errno are additionally defined [8]:\nFlag Description\nEADDRNOTAVAILA Nonexistent interface was requested or the requested address was not local.\nENAMETOOLONG addr is too long.\nENOMEM Insufficient kernel memory was available.\nTable 9: Errno flags for UNIX-bind() as defined in <errno.h>\n[8]\n18\n3.2.5 getsockname()\nTo get the currently defined name of a socket the getsocketname() function can be used. It is defined in the\n<sys/socket.h> and has the following form [8]:\nint getsocketname(int sockfd, struct sockaddr * addr, socklen_t * addrlen)\nThe following parameters can be set [8]:\n\u2022 sockfd - Specifies the socket for which the address should be retrieved.\n\u2022 addr - The address structure for the returned address that is set for the socket. The returned address is\ntruncated if the buffer is too small.\n\u2022 addrlen-Thelengthoftheaddressstructureinbytes. Itshouldbeinitializedtothesizeofthebufferpointed\nto by addr. Contains the actual size of the socket address after return.\nThe function returns zero on success and -1 on an error [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the following values:\nFlag Description\nEBADF The argument sockfd is not a valid file descriptor.\nEFAULT The addr argument points to memory not in a valid part of the process address space.\nEINVAL addrlen is invalid.\nENOBUFS Insufficient resources were available in the system to perform the operation.\nENOTSOCK The file descriptor sockfd does not refer to a socket.\nTable 10: Errno flags for getsocketname() as defined in\n<errno.h> [8]\nUnix The function is compliant to POSIX and 4.4BSD [8]. In some distributions the third argument is in reality\na pointer to an int[8]. This could still be the case in some distributions.\n3.2.6 connect()\nThis function can be used to initiates a connection to a specific destination host and is required for the write(),\nsend(), read() and recv() functions. For connection based protocols like SOCK_STREAM this function also will\ntrytoconnecttothehostontheotherside[8]. ForDatagrambasedprotocolsonlythedefaultdestinationisdefined\nwith this function [8]. To use this function the header <sys/socket.h> (for the function) has to be included. The\nfunction is called like this [8]:\nint connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen)\nWith the following parameters that can be set [8]:\n\u2022 sockfd - Specifies the socket for which the address should be set.\n\u2022 addr - The function specifies a struct sockaddr * with this parameter that contains the socket address\nfamily and the protocol address for that family. With this the address to connect to can be defined.\n\u2022 addrlen - Defines how long the address that is passed to the function is.\nThe function returns zero on success and -1 on an error [8]. Additionally the variable errno defined in <errno.h>\nis set and can have the values sown in table 51 in the appendix.\nUnix The connect() function might require the <sys/types.h> header for some BSD systems [8]. Also the\nthird argument might be an int depending on the system version [8].\n3.2.7 Read\nWecanaccessthesocketwiththreedifferentfunctiontoretrievedatafromit. Fortheread()andrecv()usually\nthe source address is defined by connecting the socket to a specific host. This can be done by using the connect()\nfunction as described in section 3.2.6.\n19\nread() The read function works identical to the read() on a file. As already said the the socket can be con-\nnected to a specific host first by using the connect function as described in section 3.2.6 on the preceding page. For\ntheread()functionthedefinitionscanbefoundinthe<unistd.h>header. Thefunctionhasthefollowingform[8]:\nint read(int fd, char * Buff, int NumBytes)\nThe following parameters have to be set [8]:\n\u2022 fd - Takes a file descriptor from which the data should be read, for RAW-sockets we can use the socket\ndescriptor instead.\n\u2022 Buff - Defines the memory space for the binary data we want to read from the socket.\n\u2022 NumBytes - How many bytes should be read from the socket, usually initialized with the size of our memory\nspace.\nA usual call of the read function for our purposes would look like this:\nssize_t = read(socket, packet, sizeof(packet));\nOn success the number of bytes is returned and on an error -1 [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the following values:\nFlag Description\nEAGAIN The file descriptor fd refers to a file other than a socket and has been marked non-blocking\n(O_NONBLOCK) and the read would block.\nEWOULDBLOCK The file descriptor fd refers to a socket and has been marked non-blocking (O_NONBLOCK) and\nthe read would block.\nEBADF fd is not a valid file descriptor or is not open for reading.\nEFAULT buf is outside your accessible address space.\nEINTR The call was interrupted by a signal before any data was read.\nEINVAL fd is attached to an object which is unsuitable for reading or the file was opened with the\nO_DIRECT flag.\nEIO I/O error.\nTable 11: Errno flags for read() as defined in <errno.h> [8]\nThe possible return values and error flags can be found in section 13 on the next page.\nrecv() Therecv(functionisanotherpossibilitytotoretrievedatafromasocketanddoesnotrequireanaddress\ntobedefinedaswell. Asalreadysaidthethesocketcanbeconnectedtoaspecifichostfirstbyusingtheconnect()\nfunctionasdescribedinsection3.2.6ontheprecedingpage.Tousetherecv()functiontheheaders<sys/types.h>\n(forthedatatypes)and<sys/socket.h>(forthefunction)havetobeincluded. Thefunctioniscalledlikethis[8]:\nssize_t recv(int sockfd, void * buf, size_t len, int flags)\nThe recv() function normally is used on a connected socket (after connecting with the connect() function),\nbut also works with RAW-sockets. Similar parameters to the read function have to be set [8]:\n\u2022 sockfd - Specifies the socket from which data should be read.\n\u2022 buf - Defines the memory space for the binary data we want to read from the socket.\n\u2022 len - How many bytes should be read from the socket, usually initialized with the size of our memory space.\n\u2022 flags - The flags that can be set for the function are listed in table 12 on the next page.\nrecvfrom() The recvfrom() function also allows us to define the address of a host we want to receive data\nfrom. To use this function the headers <sys/types.h> (for the data types) and <sys/socket.h> (for the func-\ntion) have to be included. The function is called like this [8]:\n20\nssize_t recvfrom(int sockfd, void * buf, size_t len, int flags, struct sockaddr *\nsrc_addr, socklen_t * addrlen)\nThe parameters are identical to the recv() function, it only has two additional parameters [8]:\n\u2022 sockfd - Specifies the socket from which data should be read.\n\u2022 buf - Defines the memory space for the binary data we want to read from the socket.\n\u2022 len - How many bytes should be read from the socket, usually initialized with the size of our memory space.\n\u2022 src_addr - The function returns a struct sockaddr * with this parameter that contains the socket\naddress family and the protocol address for that family. The address is filled in by the called protocol and\ncontains the source address of the packet received. The address will be truncated in case it is too long for the\nprovided buffer. The parameter can be set to NULL, then it will not be filled by the protocol.\n\u2022 addrlen-Thelengthoftheaddress. Incasethesrc_addrparameterwastoosmallforthereturnedaddress\nan address length greater than the one provided to the function will be returned.\n\u2022 flags - The flags that can be set for the function are listed in table 12.\nThe possible return values and error flags can be found in section 13.\nflags and errors for the recv()- and recvfrom()-functions Herearethepossibleflagsfortherevc()and\nrecvfrom() functions:\nFlag Description\nMSG_DONTWAIT Enables non-blocking operation, if the operation would block the call fails with the error\nEAGAIN or EWOULDBLOCK.\nMSG_ERRQUEUE Specifies that queued errors should be received from the socket error queue, the buffer has to\nbe supplied by the user.\nMSG_OOB This flag requests receipt of out-of-band data that would not be received in the normal data\nstream.\nMSG_PEEK This flag causes the receive operation to return data from the beginning of the receive queue\nwithout removing that data from the queue.\nMSG_TRUNC Forraw(AF_PACKET),Internetdatagram,netlinkandUNIXdatagram: returnthereallength\nof the packet or datagram even when it was longer than the passed buffer.\nMSG_WAITALL This flag requests that the operation block until the full request is satisfied. However the call\nmay still return less data than requested if a signal is caught, an error or disconnect occurs or\nthe next data to be received is of a different type than that returned.\nTable 12: Flags for recv() and recvfrom() defined in\n<sys/socket.h> [8]\nThe functions recv and recvfrom() returns the count of bytes read on success and -1 on an error [8]. Addi-\ntionally the variable errno defined in <errno.h> is set and can have the values shown in the following table:\nFlag Description\nEAGAIN The socket is marked non-blocking and the receive operation would block, or a receive timeout\nhad been set and the timeout expired before data was received.\nEWOULDBLOCK The socket is marked non-blocking and the receive operation would block, or a receive timeout\nhad been set and the timeout expired before data was received.\nEBADF The argument sockfd is an invalid descriptor.\nEFAULT The receive buffer pointer(s) point outside the processes address space.\nEINTR The receive was interrupted by delivery of a signal before any data were available.\nEINVAL Invalid argument passed.\nENOTSOCK The argument sockfd does not refer to a socket.\nTable 13: Errno flags for recv() and recvfrom() as defined in\n<errno.h> [8]\n21\nUnix The read() function is POSIX and 4.3BSD conform and should be available as described [8]. The recv()\nand recvfrom() are also conform to POSIX, but only the MSG_OOB, MSG_PEEK and MSG_WAITALL flags are de-\nscribed in the standard [8]. It is also conform to 4.4BSD, but there might be differences in the data types depending\non the library used in the system [8].\n3.2.8 Write\nWe can send data over the socket with three different functions. The write() and send() functions we discuss\nin the beginning both require a destination address to be defined first. This can be done by using the connect()\nfunction described section 3.2.6 on page 19. The last function we discuss, sendto(), has the option to define the\ndestination address, but it can also be set by using the connect() function. For all functions we must take the\nbufferconstraintsintoconsideration, sinceotherwisethewriteconnectionwillbeclosedbeforealldataistransferred\ncompletely.\nwrite() Identical to how we use a the read() function to get data from a socket descriptor instead of a file\ndescriptor, we can also use the write() function that is usually used for data output to a file for sending data over\na socket. As already mentioned to use write() with a socket a valid destination address has to be provided to the\nsocket first for it to work. That can be done by using the connect() function which is discussed in section 3.2.6\non page 19. The write() function is defined in <unistd.h> and has the following from [8]:\nssize_t write(int fd, const void * buf, size_t count)\nThe parameters are:\n\u2022 fd - In our case specifies the socket to which we want to write data.\n\u2022 buf - Defines the memory space for the binary data we want to write.\n\u2022 count - How many bytes should be written from the buffer to the socket. If there is not enough free space on\nthephysicalmediumused, lessbytesmightbewritten. Alsoiftheprocessisinterruptedbyasignal, therealso\nmight be less bytes written than specified.\nThe function returns the amount of bytes written on success and -1 on an error [8]. Additionally the variable\nerrno defined in <errno.h> is set and can have the following values:\nFlag Description\nEAGAIN The file descriptor refers to a file other than a socket and has been marked non-blocking, and\nthe write would block.\nEWOULDBLOCK The file descriptor fd refers to a socket and has been marked non-blocking (O_NONBLOCK),\nand the write would block.\nEBADF fd is not a valid file descriptor or is not open for writing.\nEDESTADDRREQ fd refers to a datagram socket for which a peer address has not been set using connect().\nEFAULT buf is outside your accessible address space.\nEINTR The call was interrupted by a signal before any data was written.\nEINVAL fd is attached to an object which is unsuitable for writing or the file was opened with the\nO_DIRECT flag and either the address specified in buf, the value specified in count or the\ncurrent file offset is not suitably aligned.\nEIO A low-level I/O error occurred while modifying the inode.\nENOSPC The device containing the file referred to by fd has no room for the data.\nEPIPE fd is connected to a pipe or socket whose reading end is closed.\nTable 14: Errno flags for write() as defined in <errno.h> [8]\nsend() The send() function is another function to send data over a socket. Like write() it does require that\na destination address is specified first before it can be used, since it does require the socket to be in a connected\nstate [8]. This can be achieved by using the connect() function discussed in section 3.2.6 on page 19. There is no\nindication of a failure implicitly shown when using send(), only locally detected errors are indicated by returning\n-1 [8]. If send() is used to transmit messages, then it will block (if not set otherwise) if a message does not fit in\nthe buffer [8]. To use this function the headers <sys/types.h> (for the data types) and <sys/socket.h> (for\n22\nthe function) have to be included. The function is called like this [8]:\nssize_t send(int sockfd, void * buf, size_t len, int flags)\nWith the following parameters that can be set [8]:\n\u2022 sockfd - Specifies the socket over which the data should be sent.\n\u2022 buf - Defines the memory space for the binary data we want to send over the socket.\n\u2022 len - How many bytes should be read from the memory space given by the parameter buffer.\n\u2022 flags - The flags that can be set for the function are listed in table 15 on the next page\nLike already mentioned, the function only indicates local errors by setting the return value to -1 on an error\nand returning the number of characters (bytes) sent on success [8]. Additionally the variable errno defined in\n<errno.h> is set and can have the values described in the table 16 on the following page. Other errors might be\nreported by the used protocol modules.\nsendto() In comparison to the possibilities to send data we discussed so far, the sendto() function allows us\nto define a specific address to which the data should be sent without having to call connect() first to set the\ndestination address [8]. It should be noted that if the sendto() function is used on a connection-mode socket the\nadditional address information is ignored and an EISCONN error might be returned in errno, if they are not set\nto NULL and zero respectively [8]. This is the case since for such a socket the destination is already implied by the\nconnection type. To use this function the headers <sys/types.h> (for the data types) and <sys/socket.h>\n(for the function) have to be included. The function is called like this [8]:\nssize_t sendto(int sockfd, void * buf, size_t len, int flags, struct sockaddr *\ndest_addr, socklen_t addrlen)\nWith the following parameters that can be set [8]:\n\u2022 sockfd - Specifies the socket over which the data should be sent.\n\u2022 buf - Defines the memory space for the binary data we want to send over the socket.\n\u2022 len - How many bytes should be read from the memory space given by the parameter buffer.\n\u2022 dest_addr - The function defines a struct sockaddr * with this parameter that contains the socket\naddress family and the protocol address for that family. The parameter can be set to NULL, then it will not\nbe filled in.\n\u2022 addrlen - The length of the address provided to the socket.\n\u2022 flags - The flags that can be set for the function are listed in table 15 on the next page.\nLike already mentioned, the function only indicates local errors by setting the return value to -1 on an error and\nreturning the number of characters sent on success [8]. Additionally the variable errno defined in <errno.h> is\nset and can have the values described in the table 16 on the following page. Other errors might be reported by the\nused protocol modules.\nFlagsanderrnosforthesend()andsendto()functions Thefollowingflagscanbesetforboththesend()\nand sendto() functions:\n23\nFlag Description\nMSG_CONFIRM Only valid on SOCK_DGRAM and SOCK_RAW. Tell the layer 2 that you got a successful reply\nfrom the other side.\nMSG_DONTROUTE Don\u2019tuseagatewaytosendoutthepacket,onlysendtohostsondirectlyconnectednetworks.\nMSG_DONTWAIT Enables non-blocking operation, if the operation would block EAGAIN or EWOULDBLOCK is\nreturned.\nMSG_EOR Terminates a record (when this notion is supported).\nMSG_MORE The caller has more data to send. This flag is used with UDP/TCP sockets.\nMSG_NOSIGNAL Requests not to send SIGPIPE on errors on stream oriented sockets when the other end\nbreaks the connection. The EPIPE error is still returned.\nMSG_OOB Sends out-of-band data on sockets that support this notion, the underlying protocol must\nalso support out-of-band data.\nTable 15: Flags for send() and sendto() as defined in\n<errno.h> [8]\nThe following errno constants are defined in <errno.h> for both the send() and sendto() functions:\nFlag Description\nEAGAIN The socket is marked non-blocking and the requested operation would block.\nEWOULDBLOCK The socket is marked non-blocking and the requested operation would block.\nEBADF An invalid descriptor was specified.\nECONNRESET Connection reset by peer.\nEDESTADDRREQ The socket is not connection-mode, and no peer address is set.\nEFAULT An invalid user space address was specified for an argument.\nEINTR A signal occurred before any data was transmitted.\nEINVAL Invalid argument passed.\nEISCONN The connection-mode socket was connected already but a recipient was specified.\nEMSGSIZE The socket type requires that message be sent atomically, and the size of the message to be\nsent made this impossible.\nENOBUFS The output queue for a network interface was full. This generally indicates that the interface\nhas stopped sending, but may be caused by transient congestion.\nENOMEM No memory available.\nENOTCONN The socket is not connected, and no target has been given.\nENOTSOCK The argument sockfd is not a socket.\nEOPNOTSUPP Some bit in the flags argument is inappropriate for the socket type.\nEPIPE The local end has been shut down on a connection oriented socket. In this case the process\nwill also receive a SIGPIPE unless MSG_NOSIGNAL is set.\nTable 16: Errno flags for send() and sendto() as defined in\n<errno.h> [8]\nUnix The write() function is POSIX and 4.3BSD compliant, so it should work in BSD based systems without\nany changes [8]. The send() and sendto() are also conform to POSIX, but only the MSG_OOB, MSG_PEEK and\nMSG_WAITALL flags are described in the standard [8]. It is also conform to 4.4BSD, but there might be differences\nin the data types depending on the library used in the system [8].\n3.2.9 close()\nAfter we are finished with our network communication, we can close the socket like we would do it for a file. The\nclose() function is defined in the <unistd.h> and looks like this [8]:\nint close(int fd)\nThe only parameter is the socket descriptor that should be closed [8]. All locks held by the associated process\nare released as well [8]. The function returns zero on success and -1 on an error [8]. Additionally the variable errno\ndefined in <errno.h> is set and can have the following values:\n24\nFlag Description\nEBADF fd is not a valid file descriptor.\nEINTR The close() call was interrupted by a signal.\nEIO An I/O error occurred.\nTable 17: Errno flags for close() as defined in <errno.h> [8]\nUnix Since the close() function is part of the POSIX-standard there is no difference to the call between Linux-\ndistributions and Unix-systems [8].\n3.2.10 inet_ntop()\ninet_ntop() is a helper function to convert from a network address to a human readable character string. It\ncurrently supports IP version 4 and version 6 addresses [8]. The function is defined in the <arpa/inet.h> and\nlooks like this [8]:\nconst char * inet_ntop(int af, const void * src, char *dst, socklen_t size)\nWith the following parameters that can be set [8]:\n\u2022 af - The address family we want to convert from. Currently only AF_INET for IP version 4 and AF_INET6\nfor IP version 6 addresses are supported.\n\u2022 src - The network address structure we want to convert.\n\u2022 dst - A pointer to a buffer for the resulting character string.\n\u2022 size - The size of the buffer.\nOn success the dst parameter will contain the human readable form of the address [8]. If an error occurs NULL\nis returned [8]. Additionally the variable errno defined in <errno.h> is set and can have the following values:\nFlag Description\nEAFNOSUPPORT The parameter af was not a valid address family.\nENOSPC The converted address string would exceed the size given by size.\nTable 18: Errno flags for ntop() as defined in <errno.h> [8]\nUnix The function is a part of the POSIX standard and should work as described on all Linux and Unix systems\n[8].\n3.2.11 inet_pton()\ninet_pton() is a helper function to convert from a human readable character string to a network address. It\ncurrently supports IP version 4 and version 6 addresses [8]. The function is defined in the <arpa/inet.h> and\nlooks like this [8]:\nint inet_ntop(int af, const char * src, void *dst)\nWith the following parameters that can be set [8]:\n\u2022 af - The address family we want to convert from. Currently only AF_INET for IP version 4 and AF_INET6\nfor IP version 6 addresses are supported.\n\u2022 src - The character string we want to convert. For the AF_INET address family the preferred format is the\ndotted-decimal format, \"ddd.ddd.ddd.ddd\". For the AF_INET6 address family the preferred format is the\nhexadecimal format \u201dx:x:x:x:x:x:x:x\u201d, but the usual abbreviation forms are also supported.\n\u2022 dst - A pointer to the resulting network address structure.\n25\nOn success the dst parameter will contain the network address structure and the return value is set to 1 [8]. If\nthe src parameter did not contain a valid address string 0 is returned [8]. If an error occurred -1 is returned and\nadditionally the variable errno defined in <errno.h> is set and can have the following values:\nFlag Description\nEAFNOSUPPORT The parameter af was not a valid address family.\nTable 19: Errno flags for pton() as defined in <errno.h> [8]\nUnix The function is a part of the POSIX standard and should work as described on all Linux and Unix systems\n[8].\n3.2.12 Data Types\nThere are several structures that we use for all system calls and functions we use when working with network func-\ntions. Herewewanttoshowthesestructuresandshowawaytoinitializethem. Thefirststuctswewanttointroduce\nare the sockaddr structs that are use to hold a layer 3 address and are defined in the <netinet/in.h> header.\nThe struct sockaddr is the basic definition of an address that many of the functions discussed so far take as a\nparameter. It is possible to cast a pointer to one of these structures into each other without any harm [9].\nSee listing ?? in the appendix.\nThe struct sockaddr_in is the struct we use to hold an IP version 4 address. Note the sin_zero field, for\nwhich it sometimes recommended is that it should be set to zero, even though it is not even mentioned in the Linux\nprogrammer\u2019s manual [9]. We recommend to initialize the whole struct with 0 using the memset() function. The\nother fields are usual information for IP version 4 addresses.\nListing 1: sockaddr in cpp\n1\n2 struct sockaddr_in {\n3 short sin_family; // e.g. AF_INET, AF_INET6\n4 unsigned short sin_port; // e.g. htons(3490)\n5 struct in_addr sin_addr; // see struct in_addr, below\n6 char sin_zero[8]; // zero this if you want to\n7 };\nThe struct sockaddr_in is the struct we use to hold an IP version 6 address. Similar to the struct for the\nIP version 4 address it contains all the required fields for the protocol information.\nListing 2: sockaddr in6 cpp\n1 struct sockaddr_in6 {\n2 u_int16_t sin6_family; // address family, AF_INET6\n3 u_int16_t sin6_port; // port number, Network Byte Order\n4 u_int32_t sin6_flowinfo; // IPv6 flow information\n5 struct in6_addr sin6_addr; // IPv6 address\n6 u_int32_t sin6_scope_id; // Scope ID\n7 };\nThe following example adapted from [9] shows exemplary how to init an IP version 4 address:\nListing 3: sockaddr init cpp\n1 // the struct for the socket-address\n2 struct sockaddr_in ip4addr;\n3\n4 // init the address family to internet addresses\n5 ip4addr.sin_family = AF_INET;\n6\n7 // fill out the port\n8 ip4addr.sin_port = htons(3490);\n9\n10 // fill in the ethernet address\n11 inet_pton(AF_INET, \"10.0.0.1\", &ip4addr.sin_addr);\n26\nThere is also a structure we can use to define a layer 2 address, for example a MAC-address or an index for one\nof the network interfaces of the host. It is available in the <linux/if_packet.h> header.\nListing 4: sockaddr ll cpp\n1 struct sockaddr_ll {\n2 unsigned short sll_family; // family is always AF_PACKET\n3 unsigned short sll_protocol; // physical layer protocol\n4 int sll_ifindex; // interface number\n5 unsigned short sll_hatype; // header type\n6 unsigned char sll_pkttype; // packet type\n7 unsigned char sll_halen; // length of the address\n8 unsigned char sll_addr[8]; // physical layer address\n9 };\nManyioctl()callsweusetogetnetworkdeviceinformationreturnanifreqstructure[10]. Weusuallyspecify\nwhich device to affect by setting ifr_name to the name of the interface [10]. It is defined in the <net/if.h>\nheader.\nListing 5: ifreq cpp\n1 struct ifreq {\n2 char ifr_name[IFNAMSIZ]; /* Interface name */\n3 union {\n4 struct sockaddr ifr_addr;\n5 struct sockaddr ifr_dstaddr;\n6 struct sockaddr ifr_broadaddr;\n7 struct sockaddr ifr_netmask;\n8 struct sockaddr ifr_hwaddr;\n9 short ifr_flags;\n10 int ifr_ifindex;\n11 int ifr_metric;\n12 int ifr_mtu;\n13 struct ifmap ifr_map;\n14 char ifr_slave[IFNAMSIZ];\n15 char ifr_newname[IFNAMSIZ];\n16 char *ifr_data;\n17 };\n18 };\nOneexampleistheuseoftheifreqforgettingthedeviceindexofannetworkinterfaceasshowninthefollowing\ncode:\nListing 6: ifreq init cpp\n1 // struct for the interface definition\n2 struct ifreq ifr;\n3\n4 // the name of the device we want to use\n5 char * device = \"wlan0\";\n6\n7 // set the structs to zero\n8 bzero(&ifr , sizeof(ifr));\n9\n10 // define the name of the interface we want to set\n11 strncpy((char *)ifr.ifr_name ,device , IFNAMSIZ);\n12\n13 // get device index\n14 ioctl(sockfd , SIOCGIFINDEX , &ifr)\n27\n3.2.13 Layer 4\nNow we can start with describing the different layers we can access and write with the RAW-sockets. We start by\ndiscussing working with RAW-sockets for Transport layer (OSI layer 4) access. The basic operation is generally very\nsimilar for all layers we want to work with. For example the basic call to create a RAW-socket for IP looks like this\n[5]:\nsockfd = socket(AF_INET, SOCK_RAW, int protocol )\nInthisexampletheAF_INETspecifiesIPastheprotocol,theSOCK_RAWdefinesthesockettypeasaRAW-Socket\nand the protocol can be used to specify any layer 4 protocol we want to use, so for example IPPROTO_IP is not\nsupported as the protocol since it is a dummy layer 3 protocol. Note that we can only send and receive a single\nprotocol using this, it is not possible to receive data for all protocols with a RAW-socket [1]. We also have to be\naware that the kernel still also receives all protocol data and will act accordingly [1]. If we do not want the kernel to\nalso react to the packets we have to take additional steps to prevent this.\nUnix RAW-sockets work as described in Linux distributions. For Unix based systems there are some limitations\nwe have to observe.\n\u2022 The Write-commands work for layer 3 and 4 work for Unix as well.\n\u2022 The Read-commands for layer 3 and 4 only work with some limitations. TCP and UDP packets cannot be\nreceived with RAW-sockets, they are only delivered to the kernel [6]. Copies of ICMP packets are delivered to\ntheRAW-socketaswellastothekernel[6]. AllIGMPpacketsaredeliveredtotheRAW-socket, aswellasany\nother protocol packets [6].\n\u2022 UnixdoesnotsupportthePACKET-socketasdescribedforlayer2later. InsteadUnixhastheBerkeleyPacket\nFilter (BPF) interface that can be used for layer 2 communication [2]. We will give a short introduction in a\nlater section.\n\u2022 Some of the functions that are used in this section are requiring additional headers to work under Unix. The\nadditional headers are noted in the last section were the functions were introduced.\n\u2022 Other than these limitations we can work with the RAW-socket under Unix in the same way as in Linux [8].\nRead The structure of the complete Read operation for a basic layer 4 RAW-socket is shown in figure 3 on the\nnext page.\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. Like mentioned, if we only\nwant to create layer 4 headers later we can choose any protocol family we want to receive data for except the\nIPPROTO_RAW [1]. Also even if we just read data to the buffer it makes sense to also reserve buffer space and\ninitialize it with zero to have defined data in the buffer.\n\u2022 Asanoptionalstepwecandefinetheinterfacewewanttoreceivethenetworkdatafrombydefiningthesource\naddress using the bind() function.\n\u2022 Additionallywecan, asanoption, usetheconnect()functiontodefineastandardsourcewewanttoreceive\ndata from or we want to connect to in case of connection-oriented protocols [8].\n\u2022 Thenwecanreadbinarydatafromthesocketwithoneofthefunctiondescribedinsection3.2.7onpage19. We\ncan either read data using the read() or recv() functions. As an alternative we can use the revcfrom()\nfunction which also returns the source address of the packet we did receive. It is recommended to check the\nreturn value to know how many bytes were received to be able to react accordingly.\n\u2022 Optionally we can close() the socket now if we received all the data we want to receive.\n\u2022 Then we can type-cast the binary data onto our headers as it is described in section . We have to be aware\nthat the Buffer of a RAW-socket includes the headers as well as the data . The included headers start at the\nNetworklayer(OSIlayer3)[1]. SincewedonotwanttousetheinformationoftheNetworklayeratthispoint,\nwe have to add the length of its header to the data pointer to get the Transport layer (OSI layer 4) header\ninformation [5]. When doing this we have to be aware that there can be variable network layer headers as\ndescribed in section 3.1.4 on page 14. Depending on the protocol and possibly additional variable headers we\ncan compute the start positions of the next header (or headers) and type-cast them into structures.\n28\nFigure 3: Structure of a RAW-socket layer 4 Read Operation\n29\n\u2022 After all headers are handled the remainder of the packet is the user data and can also be extracted.\n\u2022 Then we can access the extracted headers or data. When accessing the headers we have to observer the\nbyte-order, as discussed in the section 3.1.1 on page 13.\nAsthegeneralprogrammingparadigmssuggest,theusershouldhandlepossibleerrorsthatmightoccurinthesteps.\nPossibleerrorvaluesarepresentedintheintroductionsoftheavailablefunctions. Thisisevenmoreimportantwhen\nworking with RAW-sockets, since working with them is very error prone.\nWrite When we use the layer 4 Write access, the operating system will take over most function required to send\nthe packet. We only have to start to create our packet at layer 4 and supply the required destination address to the\nAPI to send the packet. All layer 3 headers will be filled in by the operating system accordingly [1].\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. Like mentioned if we only\nwanttocreatelayer4headers,wecanchooseanyprotocolfamilyexcepttheIPPROTO_RAW[1]. Alsowereserve\nbuffer space for the packet we want to create and initialize it with zero to have defined data in the buffer [5].\n\u2022 As an optional step we can define the interface we want to use to send the network data from by defining the\nsource address using the bind() function.\n\u2022 Then we can type-cast the buffer to our layer 4 headers like it is described in section 3.3.7 on page 44. We\nhave to take into consideration variable header lengths if we want to use optional fields and compute the start\nof the next header accordingly as described in section 3.1.4 on page 14. The remaining buffer can be used for\nthe user data we might want to pass along.\n\u2022 As the next step we set the data of our header as required. We have to consider the byte-order in case of fields\nthat span multiple bytes and change the byte-order according to the requirements of the protocol we want to\nuse [5]. Additional information about this can be found in section 3.1.1 on page 13.\n\u2022 If the protocol does use a checksum to protect the header from changes we also have to compute the checksum\nfor the layer 4 ourselves [5]. Only for the layers below, the operating system will take care of computing the\nchecksum. We have to see in the documentation which kind of checksum is required by the protocol we want\nto use. Additional information about checksum computation can be found in the section 3.1.2 on page 13.\n\u2022 In the next step we have the choice to use one of two possibilities. We can use the sendto() function, which\nallowsustopassadestinationaddressalongwiththedata. Optionallywecanasanoptionusetheconnect()\nfunctiontodefineastandardsourcewewanttosenddatatoorwanttoconnecttoincaseofconnection-oriented\nprotocols. If we define the destination with connect() the destination address of sento() might be left\nempty, then the already defined address is used [8]. The other possibility is to use write() or send() which\nboth require the socket to be in a connected state, so we have to call connect() first to use one of these\nfunctions [8]. All functions have the same result, the data is being sent. The result these functions return is\nthe number of bytes that were sent. It is recommended to check the return value and match it with the length\nof the data that should have been sent to make sure the function was not interrupted during the call and all\ndata has been sent as intended [8].\n\u2022 Optionally we can close() the socket now if we already sent all the data we want to transmit.\n3.2.14 Layer 3\nUsing RAW-sockets to also access the layer 3 of a network packet is very similar to the layer 4 access we discussed\nin the previous section. The most significant differences are that we need to set a different option to get write\naccess to the complete layer 3 header. We also now have to take the structure and lengths of multiple headers into\nconsideration. For example the basic call to create a raw-socket for IP could look like this [5]:\nsockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)\nInthisexampletheAF_INETspecifiesIPastheprotocol,theSOCK_RAWdefinesthesockettypeasaRAW-Socket\nand the IPPROTO_RAW specifies that we are interested in sending any type of protocol with this socket. Note that\nwe can only send any protocol with this, it is not possible to receive any data with this socket [1]. If we want to still\nreceive packets we could specify a single protocol in the last parameter of the socket() call and then have to set\nthe IP_HDRINCL with the setsockopt() function to be able to write and receive with the same socket. We also\nhave to be aware that the kernel still also receives all protocol data and will act accordingly [1]. If we do not want\nthe kernel to also react to the packets we have to take additional steps to prevent this.\n30\nFigure 4: Structure of a RAW-socket layer 4 Write Operation\n31\nRead For the Read operation the structure and commands are the same as for the layer 4 read access. As already\ndiscussed we simply ignored the layer 3 information before since we did not want to use it. Nevertheless the same\ncommand already gave us the possibility to read-out the header information. Also if we also want to have write\naccess to the layer 3 headers for the write operation later it is a possible simplification to create a socket and then\nset the IP_HDRINCL flag as already discussed. This is not necessary for the Read operation we want to discuss first\nonly for the Write later. Details on this option will follow in the layer 3 Write section. It should be noted again that\nreceiving data of all IP-protocols is not possible with with RAW-sockets, only the data for a single protocol can be\nreceived at a time [1]. A possible solution for this are the PACKET-sockets discussed in the next section.\nThestructureofthecompleteReadoperationforabasiclayer3RAW-socketisshowninfigure5onthenextpage.\nAsalreadymentionedthereareonlyslightdifferencesduetothehandlingofmultiplelayersincomparisontothe\nlayer 4 read.\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. Like mentioned if we want to\ncreate layer 3 headers we can additionally set the IP_HDRINCL flag with the setsockopt() function. Also\neven if we just read data to the buffer it makes sense to also reserve buffer space and initialize it with zero to\nhave defined data in the buffer [5].\n\u2022 Asanoptionalstepwecandefinetheinterfacewewanttoreceivethenetworkdatafrombydefiningthesource\naddress using the bind() function.\n\u2022 Additionally we can as an option use the connect() function to define a standard source we want to receive\ndata from or we want to connect to in case of connection-oriented protocols.\n\u2022 Thenwecanreadbinarydatafromthesocketwithoneofthefunctiondescribedinsection3.2.7onpage19. We\ncan either read data using the read() or recv() functions. As an alternative we can use the revcfrom()\nfunctionwhichalsoreturnsthesourceaddressofthepacketwereceived. Itisrecommendedtocheckthereturn\nvalue to know how many bytes were received to be able to react accordingly [8].\n\u2022 Optionally we can close() the socket now, if we received all the data we want to receive.\n\u2022 Then we can type-cast the binary data into our headers like it is described in section 3.3.7 on page 44. We\nhave to be aware that the buffer of a RAW-socket includes the headers as well as the data [1]. The included\nheaders start at the network layer (OSI layer 3). Since we want to use the information of the network layer\nat this point, we can typecast the header onto a struct to get access to all the fields. We still have to add the\nlength of its header to the data pointer to get the Transport layer (OSI layer 4) header information. When\ndoingthiswehavetobeawarethattherecanbevariablenetworklayerheadersasdescribedinsection3.1.4on\npage 14. Also depending on which functions we used for reading data from the socket, we might want to filter\nfrom which source and/or for which target address we want to receive data from. Depending on the protocol\nand possibly additional variable headers we can compute the start positions of the next header (or headers)\nand type-cast them into structs.\n\u2022 After all headers are handled the remainder of the packet is the user data that can also be extracted.\n\u2022 Then we can access the extracted headers or data. When accessing the headers we have to observer the\nbyte-order, as discussed in the section 3.1.1 on page 13.\nWrite Likealreadynoted,togetwriteaccesstothelayer3,wehavetoeithercreateanIPPROTO_RAWsocketwhen\nchoosing our protocol for the socket() function or set the IP_HDRINCL with the setsockopt() to deactivate\nautomatic IP-header generation by the operating system and be able to manually fill the fields [5]. It should be\nnoted here that IPPROTO_RAW socket does not include the IP_HDRINCL flag for all operating systems since this is\nnot defined in the POSIX-Standard [11]. So if you want to be sure that the code works regardless of the distribution\nused, it is recommended to set the protocol option to the protocol that can be found in the layer 3 protocol header\nand use setsockopt() to tell the OS that we want to generate the header manually [11].\nThe Structure of the complete Write operation for a basic layer 3 RAW-socket is shown in figure 6 on page 34.\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. Like mentioned we have to\nuse either IPPROTO_RAW when choosing our protocol for the socket() function, or set the IP_HDRINCL\nwith the setsockopt() function to deactive automatic IP-header generation as already discussed [5]. Also\nwe reserve buffer space and initialize it with zero to have definded data in the buffer [5].\n32\nFigure 5: Structure of a RAW-socket layer 3 Read Operation\n33\nFigure 6: Structure of a RAW-socket layer 3 Write Operation\n34\n\u2022 As an optional step we can define the interface we want to use to send the network data with by defining the\nsource address using the bind() function.\n\u2022 Then we can type-cast the buffer to our headers like it is described in section 3.3.7 on page 44. The included\nheaders start at the Network layer (OSI layer 3). We have to take into consideration variable header lengths,\nif we want to optional fields and compute the start of the next header accordingly as described in section 3.1.4\non page 14. The remaining buffer is reserved for the user data we might want to pass along.\n\u2022 As the next step we set the data of our headers as required. However, we do not need to fill the checksum and\ntotal length of the IP-packets, since the operating system will fill in the values automatically [1]. Optionally\nwe can also fill in zero in the fields source address and packet ID [1]. If we do this then the operating system\nalso will fill in the values automatically. When we fill in the values of the header fields we have to consider the\nbyte-order in case of fields that span multiple bytes and change the byte-order according to the requirements\nof the protocol we want to use. Additional information about this can be found in section 3.1.1 on page 13.\n\u2022 Iftheprotocoldoesuseachecksumtoprotecttheheaderfromchanges, wealsohavetocomputethechecksum\nfor the layer 4 ourselves [5]. Only for the layers below, the operating system will take care of computing them.\nFor the IP-Protocol for example the Operating System will always fill in the value for the checksum. We have\nto see in the documentation which kind of checksum is required by the protocol we want to use. Additional\ninformation about computing the checksum can be found in the section 3.1.2 on page 13.\n\u2022 In the next step we have the choice to use one of two possibilities. We can use the sendto() function, which\nallowsustopassadestinationaddressalongwiththedata. Optionallywecanasanoptionusetheconnect()\nfunction to define a standard source we want to send data to, or want to connect to in case of connection-\noriented protocols. If we define the destination with connect() the destination address of sento() might\nbe left empty, then the already defined address is used. The other possibility is to use write() or send()\nwhich both require the socket to be in a connected state, so we have to call connect() first to use one of\nthese functions [8]. All functions have the same result, the data is being sent. It is recommended to check the\nreturn value and match it with the length of the data that should have been sent to make sure the function\nwas not interrupted during the call and all data has been sent as intended [8].\n\u2022 Optionally we can close() the socket now, if we already sent all the data we want to transmit.\n35\n3.2.15 Layer 2 - PACKET-sockets\nInadditiontothelayerswediscussedsofar,itisalsopossibleunderLinuxtoaccesstheData-Link-layerwithRAW-\nsockets. Inearlierversionstherewasaspecialtypeofsocketsforthis, thePACKET_socket[5]. Nowadaystheuse\nof packet sockets is no longer recommended, instead we can use a normal RAW_socket with a different protocol\nsupplied to the socket() function, like shown in section 3.2.1 on page 15[5]. The possible socket types we can use\naretheSOCK_RAWtogetaccesstothewholepacketincludingtheData-Link-layerheaderortheSOCK_DGRAMwhich\noperatesontheData-Link-layerpacketwithouttheheaders[12]. TheprotocolsforEthernetwecanuseinLinuxare\nshown in the table 48 on page 81. One common option might be the ETH_P_ALL protocol constant which results in\nall incoming and outgoing Ethernet packets to be accessed with the RAW-socket. A typical call looks like this, note\nthehtonsfunctionusedtochangethebyte-orderofthesuppliedprotocolconstantsinceitisamulti-byteconstant[5]:\ns = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));\nWith this all headers down to the Data-Link-layer can now be accessed and all data received on all interfaces\ncan be received. However as already mentioned, parts of the Data-Link-layer header might not be accessible, for\nexample for the Ethernet frames the CRC (Cyclic Redundancy Check) checksum, the Preamble and the Start-of-\nFrame Delimiter are not accessible since these fields are more part of the Physical-layer and therefore handled by\nthe network driver [5]. Also with PACKET-socket the connect() function has lost its purpose, only the bind()\nfunction still makes sense to define the network interface [5]. We have to be aware that the kernel still also receives\nall protocol data and will act accordingly [1].\nPromiscuous Mode The promiscuous mode is a special mode of a network card in which all network traffic of\nan interface is received, in contrast to the usual case where only the traffic addressed to the interface is received [5].\nPACKET-sockets work similar to the promiscuous mode, but receive all traffic for all interfaces of the host, but can\nbe configured to only receive the traffic on a single interface by using the bind() function [5]. If it is necessary to\nactivate the promiscuous mode for some reason it can be done by setting the IFF_PROMISC using the ioctl()\nsystemcall [5].\nMAC-Address Sincewenowworkonthelayer2wealsohavetoworkwiththeaddressesofthelayer,forexample\nthe MAC-addresses used for example in Ethernet. The MAC-address of the interface we want to use as a source can\nbeaccessedwithacalloftheioctlfunction. Wedemonstratethecallinthefollowinglisting. Notethatthelisting\ndoes not include any protection against errors.\nListing 7: mac cpp\n1 struct ifreq ifr; // struct for the interface information\n2 char * eth = \"wlan0\"; // name of the interface\n3\n4 // copy the name to the struct\n5 memcpy(ifr.ifr_name,if_name,IFNAMSIZ);\n6\n7 //create a socket descriptor\n8 int sockfd = socket( AF_PACKET , SOCK_RAW , htons(ETH_P_ALL)) ;\n9\n10 //get the information\n11 ioctl(sockfd,SIOCGIFHWADDR,&ifr)\n12\n13 //extract the mac\n14 const unsigned char* mac = (unsigned char*) ifr.ifr_hwaddr.sa_data;\nRead Except for the creation of the packet socket, the missing connect() statements and the handling of more\nlayers, the layer 2 read is not much different from the other read operations and share the same basic structure.\nTheStructureofthecompleteReadoperationforabasiclayer2PACKET-socketisshowninfigure7onthenextpage.\nFor a read of the layer 2 the general structure we discussed until now is the same, only some steps are different\ndue to different initialization we need and the handling of Data-Link-layer data:\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. As already discussed the\npossible socket types we can use are the SOCK_RAW or the SOCK_DGRAM. The protocols for Ethernet we can\n36\nFigure 7: Structure of a PACKET-socket layer 2 Read Operation\n37\nuse in Linux are shown in the table 48 on page 81. Since they could be multi-byte constants we have to use\nfunctions to change the byte-order as discussed in the section 3.1.1 on page 13. Also even if we just read data\nto the buffer it makes sense to also reserve buffer space and initialize it with zero to have defined data in the\nbuffer [5].\n\u2022 Asanoptionalstepwecandefinetheinterfacewewanttoreceivethenetworkdatafrombydefiningthesource\naddress using the bind() function.\n\u2022 Then we can read binary data from the socket with one of the function described in section 3.2.7 on page 19.\nWecaneitherreaddatausingtheread(), recv()functions, orwecanusetherevcfrom()functionwhich\nalso returns the source address of the packet we did receive. It is recommended to check the return value to\nknow how many bytes were received to be able to adapt accordingly [8].\n\u2022 Optionally we can close() the socket now, if we received all the data we want to receive.\n\u2022 Then we can type-cast the binary data into our headers like it is described in section . Since we did start at\nthe Data-Link-layer, there could be different layer 3 protocols included in the frame. This is why we have to\naccess the correct field in the header to find out what is encapsulated in the frame and which header structure\nwe have to handle. When doing this we have to be aware that there can be variable network layer headers\nas described in section 3.1.4 on page 14. Also depending on which functions we used for reading data from\nthe socket we need to filter from which source and/or for which target address we want to receive data from.\nDepending on the protocol and possibly additional variable headers we can compute the start positions of the\nnext header (or headers) and type-cast them into structs.\n\u2022 After all headers are handled the remainder of the packet is the user data that can also be extracted.\n\u2022 Then we can access the extracted headers or data. When accessing the headers we have to observer the\nbyte-order, as discussed in the section 3.1.1 on page 13.\nWrite The Write on a PACKET-socket differs from from the Write on a RAW-socket in some important parts.\nTheIP-headerfieldsthatwerefilledbytheoperatingsystemwhenusingaRAW-sockethavetobefilledinmanually\nwhen using a PACKET-socket. The only layer where the operating system still helps the user is on the Data Link\nLayer,weresomefieldsareautomaticallygenerated[5]. ThatisthecaseforexamplewhencreatingEthernetframes,\nthen the Padding field of the frame, the Preamble, the Start-of-Frame Delimiter and the CRC checksum [5]. These\nfields are still generated automatically by the network driver.\nThe Structure of the complete Write operation for a basic layer 2 PACKET-socket is shown in figure 8 on the\nfollowing page.\n\u2022 We first have to create the socket as it was discussed in section 3.2.1 on page 15. As already discussed the\npossible socket types we can use are the SOCK_RAW or the SOCK_DGRAM. The protocols for Ethernet we can\nuse in Linux are shown in the table 48 on page 81. Since they could be multi-byte constants we have to use\nfunctions to change the byte-order as discussed in the section 3.1.1 on page 13. Also we reserve buffer space\nand initialize it with zero to have defined data in the buffer.\n\u2022 Even if packets sent over PACKET-sockets have to be generated completely manual it is still required for\nthe send functions to define a socket-address. The necessary struct sockaddr_ll can be found in the header\n<linux/if_packet.h>. Theonlypartofthestructwehavetofillinisthenetworkinterfacesll_ifindex[5].\nNow to find the network interface, in Linux usually denoted as f.e. eth1 we can use the so called Netdevice-\nInterface[10]. Itdescribestheioctl()-systemcallsthatcanbeusedtoaccessdifferentpropertiesofnetwork\ninterfacesinLinux,forexamplethecallcodeSIOCGIFINDEXhastobeusedtogetthedesiredinformation. The\naccess can be done on all socket types with the data structure ifreq that is defined in <linux/net/if.h>.\nThe complete call we have to use looks like this [5]:\nioctl(socketfd, SIOCGIFINDEX, &ifr)\nThesocketfdagainisoursocketdescriptor,theSIOCGIFINDEXistheparametertoretrievetheinformation\nwe need and ifr is the ifreq that after the call has the information we need. With the information we can\nlater call the bind() or sendto().\n\u2022 Then we can type-cast the buffer to our headers like it is described in section . The included headers start at\nthe Data-Link-layer (OSI layer 2). It is necessary to include or define additional headers to have structs for\nthe Data-Link-layer header. We have to take into consideration variable header lengths, if we want to optional\nfields and compute the start of the next header accordingly as described in section 3.1.4 on page 14. The\nremaining buffer is reserved for the user data we might want to pass along.\n38\nFigure 8: Structure of a PACKET-socket layer 2 Write Operation\n39\n\u2022 As the next step we set the data of our headers as required. We have to fill in all fields since the operating\nsystem does not automatically create fields for PACKET-sockets [5]. When we fill in the values of the header\nfields have to consider the byte-order in case of fields that span multiple bytes and change the byte-order\naccording to the requirements of the protocol we want to use. Additional information about this can be found\nin section 3.1.1 on page 13.\n\u2022 If the protocol does use a checksum to protect the header from changes, we have to compute them and set the\nfields accordingly [5]. We have to see in the documentation which kind of checksum is required by the protocol\nwe want to use. Additional information about computing a checksum can be found in the section 3.1.2 on\npage 13.\n\u2022 In the next step we have the choice to use one of two possibilities. We can use the sendto() function, which\nallows us to pass the socket address of the interface we created along with the data. Optionally we can as an\noption use the bind() function to define a standard socket address for the interface we want to send data\nwith. If we define the destination with bind() the destination address of sento() might be left empty, then\nthealreadydefinedaddressisused[8]. Theotherpossibilityistousewrite()orsend()whichbothrequire\na call of bind() first. All functions have the same result, the data is being sent. It is recommended to check\nthereturnvalueandmatchitwiththelengthofthedatathatshouldhavebeensenttomakesurethefunction\nwas not interrupted during the call and all data has been sent as intended [8].\n\u2022 Optionally we can close() the socket now, if we already sent all the data we want to transmit.\n3.3 Berkeley Packet Filter (BPF)\nThe Berkeley Packet Filter (BPF) provides us with the same functionality we have introduced for the PACKET-\nsocket in Linux, it provides full access to the data link layer for read and write [2]. So as it is the case for the\nPACKET-socket we can receive any packet received by any interface regardless if it is meant for our host or not\n[2]. Additionally to these functions the BPF also includes an advanced filtering mechanism that we can use to filter\nincoming packets according to different criteria [2]. We will only give a short overview over this function since our\nmain focus is not to give an introduction on how to program a network sniffer, but how to send and receive data\nincluding the protocol headers.\nTo use the BPF we have to use a distribution that has the device bpf in its kernel [7]. Only than can we\ncreate a BPF device. The BPF appears as a special character device /dev/bpf. To open it we have to use the well\nknown open() function which is defined in <fnctl.h> and looks like this:\nint open(const char * pathname, int flags)\nWe have to set the following parameters:\n\u2022 pathname takes the path of a file. In our case the path has to be /dev/bpfn where n is the number of the\ndevice depending on how many other programs use a BPF [7].\n\u2022 flags takes a flag as the name implies, the most useful for us is the O_RDWR flag that gives us read and write\naccess.\n\u2022 After we have done this we have to associate the BPF device to a network interface [7]. This works similar to\nthe bind() function used for the RAW- or PACKET-socket, but is realized with a ioctl() call with the flag\nBIOCSETIF. The completed command looks like this, note the ifreq structure:\nListing 8: bpf cpp\n1 // define the name of the interface\n2 const char* interface = \"fxp0\";\n3\n4 // create the struct for the interface\n5 struct ifreq bound_if;\n6\n7 // copy the name into the struct\n8 strcpy(bound_if.ifr_name, interface);\n9\n10 // associate the bpf to the interface\n11 ioctl( bpf, BIOCSETIF, &bound_if )\nAfterwards we just have to set the BPF to immediate mode, since a read() would otherwise block until the\nkernel buffer becomes full or a timeout occurs [2]. We also have to get the buffer size, since the BPF might return\nus more than one packet at a time [7]. The code for this is shown in the listing below:\n40\nListing 9: bpf2 cpp\n1 // initialize buffer length\n2 int buf_len = 1;\n3\n4 // activate immediate mode\n5 ioctl( bpf, BIOCIMMEDIATE, &buf_len )\n6\n7 // request buffer length\n8 ioctl( bpf, BIOCGBLEN, &buf_len )\nAfter this we can read and write to the BPF like we did it before. Note that we only can use the read() and\nwrite() functions since the BPF is handled like a file. Before we introduce these operations we want to show some\nBPF specialties and give an overview over some preferences that can be set for the BPD subsystem.\n3.3.1 BPF Header\nTheBPFdeviceaddsanadditionalheaderwithinformationaboutthereceivedpacket[2]. Oneoftheheadersshown\nin the following listing is appended to each packet, bpf_xhdr is used by default, bpf_hdr is used only when the\ntimestamp format is set to certain values using the ioctl() function [2].\nListing 10: bpf structs cpp\n1 struct bpf_xhdr {\n2 struct bpf_ts bh_tstamp; /* time stamp */\n3 uint32_t bh_caplen; /* length of captured portion */\n4 uint32_t bh_datalen; /* original length of packet */\n5 u_short bh_hdrlen; /* length of bpf header (this struct\n6 plus alignment padding) */\n7 };\n8\n9 struct bpf_hdr {\n10 struct timeval bh_tstamp; /* time stamp */\n11 uint32_t bh_caplen; /* length of captured portion */\n12 uint32_t bh_datalen; /* original length of packet */\n13 u_short bh_hdrlen; /* length of bpf header (this struct\n14 plus alignment padding) */\n15 };\nThe bh_hdrlen is used for padding between the header and the link layer protocol, additionally each packet is\npadded so that it starts on a word [2]. A macro BPF_WORDALIGN() is defined in the header that allows us to\ncompute the header-position correctly when we compute the header-positions.\n3.3.2 Buffer Modes\nBPFdevicescandeliverpacketdatatotheapplicationsintwodifferentmodes,BufferedreadmodeandZero-copy\nmode[2]. Themodecanbesetbyusingtheioctl()functionusingtheBIOCSETBUFMODEflag. Thedefaultmode\nistheBuffered read modewhichcanalsobesetusingtheBPF_BUFFMODE_BUFFERflag. Inthismodethepacket\ndatacanbeaccessedbyexplicitlycalltheread()function. Afixedbuffersizeisusedforallinternalbuffersaswell\nasfortheread()functionwhichcanbequeriedusingtheBIOOCGBLENflagfortheioctl()callandsetbyusing\nthe BIOCSBLEN flag in the iotl() call [2]. Note that packets longer than this buffer size are truncated. The other\nmode is the Zero-copy buffer mode that can be set using the ioctl() call and the BPF_BUFMODE_ZEROCOPY\nflag. In this mode the user process registers two equal sized buffers using the BIOSETZBUF flag with the ioctl\nfunction in which the packet data is directly stored [2]. The user process than has to use atomic operations to check\nif it can read data from a buffer and than return it to the kernel for storing the next data as fast as possible [2]. See\nthe Unix MAN-pages for detailed information how to use this mode.\n3.3.3 IOCTLS\nThefollowingflagscanbeusedtochangethebehavioroftheBPFdevice. Allconstantsaredefinedinthe<bpf.h>\nheader, except for the BIOGETIF and BIOSETIF which also require the <sys/socket.h> and <net/if.h>\nheaders. They can be set using the ioctl() function for any open BPF file, with the type indicated as the third\nargument of the function. See table 52 in the appendix.\n41\n3.3.4 SYSCTL Variables\nA set of sysctl-Variables for controlling the behavior of the BPF subsystem exist [2]:\nVariable Description\nnet.bpf.optimize_writers Turning this option on makes new BPF users to be attached to write-only\ninterfacelistuntilprogramexplicitlyspecifiesreadfilterviapcap_set_filter().\nnet.bpf.stats Binary interface for retrieving general statistics.\nnet.bpf.zerocopy_enable Permits zero-copy to be used with net BPF readers.\nnet.bpf.maxinsns Maximum number of instructions that BPF program can contain.\nnet.bpf.maxbufsize Maximum buffer size to allocate for packets buffer.\nnet.bpf.bufsize Default buffer size to allocate for packets buffer.\nTable 20: ioctl() flags defined in <bpf.h> [2]\n3.3.5 Filter Maschine\nAn additional capability we have is the Filter machine we want to just show here. It allows to filter the incoming\npacketsforspecificpackettypes. Todothiswecandefineanarrayofinstructionswhichisexecutedforeveryreceived\npacketandwhichdoesconsistsofanaccumulator,indexregister,scratchmemorystore,andimplicitprogramcounter\n[2]. The following listing shows the struct:\nListing 11: bpf structs filter cpp\n1 struct bpf_insn {\n2 u_short code;\n3 u_char jt;\n4 u_char jf;\n5 u_long k;\n6 };\nThe k field is used in different ways by different instructions, and the jt and jf fields are used as offsets by the\nbranch instructions [2]. There are eight classes of instructions like for example jump and value copy [2]. Various\nothermodeandoperatorbitsareinsertedintotheclasstogivetheactualinstructions[2]. Furtherinformationabout\nthe filters can be found in the Unix manpages.\n3.3.6 Read\nThe read of a packet using an BPF device is similar to the same operation in a packet socket. The basic structure\nis shown in figure 9 on the next page.\nFor a read operation with the BPF we have to do the following:\n\u2022 We first have to create the BPF device as discussed in the beginning of this section. Also even if we just read\ndata to the buffer it makes sense to also reserve buffer space and initialize it with zero to have defined data in\nthe buffer.\n\u2022 We then have to attach the BPF device to a interface as discussed in the beginning of this chapter to be able\nto receive frames [7]. We use a ioctl() call to achieve this.\n\u2022 Then we can set options, like the BIOCIMMEDIATE mode which was discussed earlier, using ioctl() calls\n[7]. We also could set a filter to only receive certain packets we are interested in [2].\n\u2022 As the next step we retrieve the buffer length from the kernel to know how many bytes are received per packet\n[7]. That is necessary since the received packet also includes a BPF header containing information about the\npacket received as discussed in the earlier sections.\n\u2022 Thenwecanreadbinarydatafromthesocketwiththereadfunctiondescribedinsection3.2.7onpage19. Itis\nrecommendedtocheckthereturnvaluetoknowhowmanybyteswerereceivedtobeabletoadaptaccordingly\n[7]. If we want to read multiple packets from the BPF device we have to use the BPF_WORDALIGN()-macro\nto align the pointer for the next header correctly [7].\n\u2022 Optionally we can close() the BPF device now, if we received all the data we want to receive.\n42\nFigure 9: Structure of a BPF device layer 2 Read Operation\n43\n\u2022 Then we can type-cast the binary data into our headers like it is described in section . We have to take into\nconsideration that there is an additional BPF header attached to the received packet which has to be retrieved\nfirst [7]. Since we did start at the Data-Link-layer, there also could be different layer 3 protocols included in\nthe frame. This is why we have to access the correct field in the header to find out what is encapsulated in the\nframe and which header structure we have to handle. When doing this we have to be aware that there can be\nvariable network layer headers as described in section 3.1.4 on page 14. Also depending on which functions we\nused for reading data from the socket we need to filter from which source and/or for which target address we\nwanttoreceivedatafrom. Dependingontheprotocolandpossiblyadditionalvariableheaderswecancompute\nthe start positions of the next header (or headers) and type-cast them into structs.\n\u2022 After all headers are handled the remainder of the packet is the user data that can also be extracted.\n\u2022 Then we can access the extracted headers or data. When accessing the headers we have to observer the\nbyte-order, as discussed in the section 3.1.1 on page 13.\n3.3.7 Write\nAs figure 9 on the previous page shows the basic structure, the write operation of a packet using an BPF device is\nalso similar to the same operation in a packet socket.\n\u2022 We first have to create the BPF device as discussed in the beginning of this section [7]. Also even if we just\nread data to the buffer it makes sense to also reserve buffer space and initialize it with zero to have defined\ndata in the buffer.\n\u2022 We then have to attach the BPF device to a interface as discussed in the beginning of this chapter to be able\nto receive frames [7]. We use a ioctl() call to achieve this.\n\u2022 Then we can set options, like the BIOCIMMEDIATE mode which was discussed earlier, using ioctl() calls.\nIt also is possible to set the BIOCGHDRCMPLT option, which select if the operating system should auto fill in\nthe data link headers[2].\n\u2022 Then we can type-cast the buffer to our headers like it is described in section . The included headers start at\ntheData-Link-layer(OSIlayer2). Itisnecessarytoincludeordefineadditionalheaderstohavestructsforthe\nData-Link-layerheader. Wehavetotakeintoconsiderationvariableheaderlengthsifwewanttooptionalfields\nand compute the start of the next header accordingly as described in section 3.1.4 on page 14. The remaining\nbuffer is reserved for the user data we might want to pass along.\n\u2022 Asthenextstepwesetthedataofourheadersasrequired. Wecanhavethekernelautofillthedatalinklayer\naddresses if we used the BIOCGHDRCMPLT option [2]. When we fill in the values of the header fields have to\nconsider the byte-order in case of fields that span multiple bytes and change the byte-order according to the\nrequirements of the protocol we want to use. Additional information about this can be found in section 3.1.1\non page 13.\n\u2022 If the protocol does usea checksum to protect the header from changes, we have to compute them and set the\nfields accordingly [5]. We have to see in the documentation which kind of checksum is required by the protocol\nwe want to use. Additional information about computing a checksum can be found in the section 3.1.2 on\npage 13.\n\u2022 In the next step we send the data using the write() function as discussed earlier.\n\u2022 Optionally we can close() the BPF device now, if we already sent all the data we want to transmit.\n3.4 Winsock-API\nAsmentionedinsection2.1.1onpage10theWinsock-APIdoesnotallowanyuserinteractionbyitself,whichwould\njustify the usage of RAW-sockets. The rolled out Winsock-API is designed to be used with usual sockets using\npredefined protocols. Indeed, there is the possibility to use SOCKET_RAW, but it is mostly used for diagnostics. The\nlimits, as also shown above are limiting to internet procotols IP, UDP and SCTP.\nTo write own protocols using Windows, or to receive packtes, which are netiher known or specified, there is the\nneed to used libraries (npcap, libnet) to be able to support the Windows infrastructure. Otherwise the invalid or\nmore falsely marked as invalid packtes will be dropped by driver and OS.\n44\nFigure 10: Structure of a BPF device layer 2 Write Operation\n45\n3.4.1 Preparations and Usage\nIf anyway there is no possibility to use the libraries, sockets of type SOCK_RAW can be created, despite being\nrestricked as mentioned. A call to the socket function with address family set to AF_INET or AF_IP6 and type to\nSOCK_RAW will return a raw ip socket. For the netork layer one of the mentioned rescricted protocols need to be set\nin protocol parameter. The following listing provides an extended example of this socket-function call. It also gives\nvalidexamplevaluesforthetype,family andprotocol. Completedescreptionofthesocket-functionisfoundatmsdn:\nhttps://msdn.microsoft.com/en-us/library/windows/desktop/ms740506(v=vs.85).aspx\nSee listing 13 in the appendix.\n46\n4 Programming with the libraries\nThischapterwillcoverthetwolibrariesthatprovidepacketinjectionandcapturingmechanismsforthemostcommon\noperatingsystems. First,libnet,whichisusedforthepacketinjection,isintroducedthenwecontinuewiththepacket\ncapture library, called pcap.\n4.1 Libnet\nLibnet is a library, mainly written in C, that defines an high-level portable interface for low-level network packet\nconstruction and injection. When libnet was designed the goal was to abstract out the pedantic architecture-specific\ndetails of low-level network packet tasks and provide some kind of platform-independent standard. It is under the\nBSD Licence and offers the ability to create and manipulate network packets from the link layer upwards. For\neach network layer libnet supports the manipulation of a set of protocols which are listed in figure 11. Libnet only\nsupports the creation and sending of packets. It does not provide any functionalities to receive these packets. For\nlatter purpose, one has to rely on an additional library called pcap.\nThelistofsupportedOperatingPlatformsisunfortunatelynolongermaintained. Thelateststatewasthatlibnet\nsupports the following OS [13]:\n\u2022 Linux\n\u2022 Windows\n\u2022 FreeBSD\n\u2022 OS X\n\u2022 Solaris\nThe current version of libnet is 1.2. It is important to note that code from version 1.0.x will not work anymore\nas the syntax was simplified with version 1.1. Libnet was originally maintained on packetfactory.net by Mike D.\nSchiffman until 2004. However this page does not exist anymore and the author is also unreachable.\nSince 2009 Sam Roberts maintains libnet on GitHub. As of today (December, 2016) the latest release is already\nfour years ago but is still actively used [14].\n4.1.1 Preparations\nLibnet can be downloaded from the official libnet GitHub repository [14]. Alternatively, the currently latest version\n1.2isalsoavailableatsourceforge[15]. Toinstalllibnet,gotothedirectory,unzipitandrunthefollowingcommands:\n1. ./configure\n2. make\n3. make install (might require root permissions)\nNow <libnet.h>can be included in a C program. In order to successfully compile the program, run:\n1. gcc -Wall -g \u2018libnet-config \u2013defines\u2018 -c foo.c\n2. gcc -Wall foo.o -o output \u2018libnet-config \u2013libs\u2018\n4.1.2 Process of packet creation\nIn order to build and inject a network packet in libnet, there is a standard order of four operations:\n1. Library initialization\n2. Packet Building\n3. Packet Writing\n4. (Optional) Packet destruction\nLibrary initialization The first step is to initialize the libnet library and to set up the environment. Doing so,\nthe programmer receives a so called libnet context. This context maintains the state for the entire session which\ntracks all memory usage and packet construction. The libnet context is also often required as parameter for several\nfunctions such as packet building or injection.\nNote that, the libnet library initialization can only be successfully executed with root permissions.\n47\nFigure 11: Overview of the packet construction in libnet\n48\nPacket building The second step is about the core functionality of libnet - the packet creation. In this phase the\nprogrammer calls a set of functions which are all of the structure libnet_build_*.\nFor every protocol header that libnet supports there is an own build function. Each libnet_build() function\nbuildsjustapieceofthewholepacket-namelytheheaderofasingleprotocol. Whileitispossibletobuildanentire,\nready-to-transmit packet with a single call to a libnet_build() function, normally more than one builder-class\nfunction call is required to construct a full packet. Every build function takes a series of arguments corresponding\nto the protocol header values as they appear on the wire. Thus, a programmer does not have to worry too much\nabout low-level network details such as putting the bytes at the correct header position as this is done by the build\nfunction internally. Instead, he simply has to fill in the parameters of the function correctly. This process is very\nstraight-forwardbutleadstolibnet_build()functionswhichsometimeshaveahugenumberofparameterswhich\nmost of can be filled in with default values.\nOneimportantfactisthatthesebuildfunctionsmustbecalledinorder,correspondingtohowtheyshouldappear\nontheOSIlayermodel(fromthehighestprotocollayerdownwards). Forexample,tobuildaNetworkTimeProtocol\n(NTP) packet, the programmer would call the libnet_build() functions in the following order:\n1. libnet_build_ntp()\n2. libnet_build_udp()\n3. libnet_build_ipv4()\n4. libnet_build_ethernet()\nThis process is also illustrated in figure 12. This ordering was not required until version 1.1.x where it became\nessential to properly link together the packet internally. Thus, source code of libnet before version 1.1.x is outdated\nand cannot be used anymore.\nIn case old source code shall be easily and quickly refactored one can refer to the MIGRATION file within the\nGitHub repository which gives instructions on how to update outdated source code.[16]\nPacket write After having initialized the libnet_session and built the packet, the programmer can send it to the\nnetwork.\nPacket destruction The last step is optional. The programmer can decide to shut down the libnet session he\ncreated with the init function. Doing so, he closes the network interface and frees all internal memory structures\nused by the created packets.\n49\nFigure 12: Overview of the packet construction in libnet\n50\n4.1.3 Functions\nThis section will have a deeper look at the exact syntax of the functions which perform the steps mentioned above.\nThe definition of the functions is mainly retrieved from the official documentation of libnet.[17]\nLibrary initialization The function to initialize the libnet environment is defined as follows:\nlibnet_t* libnet_init(int injection_type, char* device, char* err_buf)\nArgument Description\n@SUCCESS Returns libnet context.\n@FAILURE Returns NULL, err_buf will contain the reason.\nint injection_type The type of socket that will be used.\nchar* device Use the specified network device for packet injection.\nchar* err_buf Error message. Will only be filled in if function fails.\nTable 21: Overview of libnet_init()\nlibnet_init() initializes the libnet library and creates the environment to work in. One important decision\nthat the programmer has to make during this step is to decide whether libnet shall work with Link Layer sockets or\nNetwork-layer sockets (also called raw sockets). For this purpose the argument injection_type must be filled in\nwith one of the following possible values: (values are all defined in libnet\u2019s header file[18])\n\u2022 LIBNET_LINK for Link Layer sockets\n\u2022 LIBNET_RAW4 for raw sockets using IPv4\n\u2022 LIBNET_RAW6 for raw sockets using IPv6\nIf the programmer decides to use link layer sockets, he must later ensure to manually build a protocol header\n(such as Ethernet) in the link layer for his packet. In case he chooses raw sockets he can skip building a protocol\nheader in the link layer and must only build headers down to the network layer.\nIn case of success libnet_init() returns the so-called libnet context which is important to save in a variable\nas it is required as an argument for nearly all the other functions of libnet.\nFor choosing the desired network device (char* device) following formats are possible:\n\u2022 Canonical string that references the device (such as eth0 or fxp0).\n\u2022 A dots and decimals representation of the device\u2019s IP address (such as 192.168.0.1).\n\u2022 NULL. In this case the function will select the first device available.\nFor the creation of err_buf the constant LIBNET_ERRBUF_SIZE (defined in the libnet headerfile) can be used\nto ensure a fitting size of the character array.\nBuild Functions Asalreadystatedthereisonebuildfunctionforeachprotocolthatlibnetsupports. Sometimesa\nprotocol has different types which results in a protocol having more than one build function. For example for ICMP\nthere are the following build functions available:\n\u2022 libnet_build_icmpv4_echo()\n\u2022 libnet_build_icmpv4_mask()\n\u2022 libnet_build_icmpv4_unreach()\n\u2022 libnet_build_icmpv4_redirec()\n\u2022 libnet_build_icmpv4_timeexceed()\n\u2022 libnet_build_icmpv4_timestamp()\nAs it would be simply too much to introduce each of the available build functions we will cover just three of the\nmost frequently used. If the reader wants to learn more about how to use a specific build function he can refer to\nthe libnet-functions.h file under libnet/include/libnet/ where each build function is documented. For now, let\u2019s\nfurther investigate on how to build a UDP, IPv4 and an Ethernet packet.\n51\nThe UDP build function is defined as follows:\nlibnet_ptag_t libnet_build_udp(u_int16_t sp, u_int16_t dp, u_int16_t len,\nu_int16_t sum, u_int8_t* payload, u_int32_t payload_s, libnet_t* l, libnet_ptag_t\nptag)\nArgument Description\n@SUCCESS Returns a ptag identifier referring to the UDP packet.\n@FAILURE Returns -1 and libnet_get_error() returns the error reason.\nu_int16_t sp The UDP port of the source.\nu_int16_t dp The UDP port of the destination.\nu_int16_t len The length of the UDP packet (including payload).\nu_int16_t sum The checksum of the packet. If 0, libnet will autofill.\nu_int8_t* payload The optional payload. Can be NULL.\nu_int32_t payload_s The length of the payload. Is 0 if payload is NULL.\nlibnet_t* l The pointer to a libnet context\nlibnet_ptag_t ptag The protocol tag of the packet. It must be 0 if this is a new packet\nTable 22: Overview of libnet_build_udp()\nThe IPv4 build function is defined as follows:\nlibnet_ptag_t libnet_build_ipv4(uint16_t ip_len, uint8_t tos, uint16_t id,\nuint16_t frag, uint8_t ttl, uint8_t prot, uint16_t sum, uint32_t src, uint32_t dst,\nconst uint8_t* payload, uint32_t payload_s, libnet_t* l, libnet_ptag_t ptag)\nArgument Description\n@SUCCESS Returns a ptag identifier referring to the IPv4 packet.\n@FAILURE Returns -1 and libnet_get_error() can tell you why\nuint16_t ip_len The length of the IPv4 packet (including payload)\nuint8_t tos The type of service bits\nuint16_t id IP identification\nuint16_t frag Fragmentation bits\nuint8_t ttl Time to live\nuint8_t prot The upper layer protocol (above the ip header)\nuint16_t sum The checksum, 0 for libnet autofill\nuint32_t src The source IP address (in little endian)\nuint32_t dst The destination IP address (in little endian)\nconst uint8_t* payload The optional payload. Can be NULL.\nuint32_t payload_s The length of the payload. Is 0 if payload is NULL.\nlibnet_t* l The pointer to the libnet context.\nlibnet_ptag_t ptag The protocol tag of the packet. It must be 0 if this is a new packet\nTable 23: Overview of libnet_build_ipv4()\nThe Ethernet build function is defined as follows:\nlibnet_ptag_t libnet_build_ethernet(const uint8_t* dst, const uint8_t*\nsrc, uint16_t type, const uint8_t* payload, uint32_t payload_s, libnet_t* l,\nlibnet_ptag_t ptag)\n52\nArgument Description\n@SUCCESS Returns a ptag identifier referring to the IPv4 packet.\n@FAILURE -1 and libnet_get_error() can tell you why\nconst uint8_t* dst The destination MAC address\nconst uint8_t* src The source MAC address\nuint16_t type The upper layer protocol type\nconst uint8_t* payload The optional payload. Can be NULL.\nuint32_t payload_s The length of the payload. Is 0 if payload is NULL.\nlibnet_t* l The pointer to a libnet context.\nlibnet_ptag_t ptag The protocol tag of the packet. It must be 0 if this is a new packet.\nTable 24: Overview of libnet_build_ethernet()\nWhen examining these three libnet_build() function examples, we discover the following:\nAll build functions return a protocol tag ptag on success and have an argument for this ptag. Ptag is used\nto identify a packet header after being created. The programmer must save this ptag if he intends to modify the\npacket later. To do so, he must call the same build function but with the respective ptag as argument. The\nlibnet_build() function will then search for the existing packet and override the old values rather than creating\na new one. In case the programmer wants to create a new packet he simply puts a \"0\" as argument for ptag.\nEachbuildfunctioncontainsanargumentfieldforthelibnetcontextwhichisusuallythesecondlastargumentof\nthe function. This field simply has to be filled in with the libnet context that is returned after the libnet_init()\nfunction.\nAlso, each build function has an argument for the payload that comes after the header data and, respectively,\nan argument for the size of that payload data. It is a simple interface to append arbitrary payloads to packets. It\nis completely up to the user to define which data exactly he or she wants to add to the packet header. Hence, the\npayload argument is a good possibility to implement an own type of protocol header. There is even an own build\nfunction for just adding raw payload data. It is defined as:\nlibnet_ptag_t libnet_build_data(const uint8_t* payload, uint32_t payload_s,\nlibnet_t* l, libnet_ptag_t ptag)\nThe build_data() function can be used at any place to create additional, user-defined payload in between the\nother build functions.\nSome functions contain an argument for the checksum. By default, checksums will be automatically calculated if\n\"0\" is put as parameter. In case it is desired to compute the checksum manually, please refer to function\nlibnet_toggle_checksum() under section 4.1.3.\nSome build functions require a length argument which indicates the whole length of the packet. The length of\nthe whole packet is defined as the sum of the following components:\n\u2022 Length of the header itself\n\u2022 Length of the additional payload size\n\u2022 Length of the encapsulated packets\nForexample,anIPv4PacketwhichencapsulatesaUDPheaderhasthefollowingsize: thesizeoftheIPv4Header\n(20bytes)+thesizeofitsownpayload(ifitexists)+thesizeoftheUDPheader(8bytes)+thesizeofthepayload\nof UDP (if it exists).\nIn order to avoid to look up the size of each protocol header, libnet offers constants for the size of each header\nthat it supports. They are saved in libnet-headers.h inside the libnet repository. The structure of the constant is\nLIBNET_name_of_protocol_H, e.g. LIBNET_UDP_H for the size of a UDP header or LIBNET_IPV4_H for the\nsize of an IPv4 header respectively.\nSome functions, such as libnet_build_ipv4() or libnet_build_ethernet(), require an argument that\nspecifies the upper-layer protocol. Once again, there are constants available for this purpose. For example, IP\nProtocol types can be IPPROTO_ICMP, IPPROTO_UDP and IPPROTO_TCP. Libnet itself does not have a headerfile\nin its repository which defines these constants. Instead it retrieves them from a file called netinet/in.h. So, in\nordertoretrieveafulllistofavailableconstants, pleaserefertothisfile. ThesameapproachisusedfortheEthernet\nprotocoltypeswhichisrequiredbythelibnet_build_ethernet(). Thistimetherespectiveheaderfilewiththe\nconstants is netinet/if_ether.h. If, for instance, the IP protocol is used above the link layer interface then the\nargument would be ETHERTYPE_IP.\n53\nTherearealsoso-calledauto-buildfunctions. Thesearesimplybuildfunctionwhichrequirelessparametersthan\nthenormalbuildfunctions. Thesefunctionsareusefulwhenoneintendstobuildaheaderquicklybecauseagranular\nlevel of control is not desired or required. Auto-build functions exist for the following header packets:\n\u2022 Ethernet\n\u2022 FDDI\n\u2022 ARP\n\u2022 IPv4\n\u2022 IPv6\n\u2022 Tokenring\n\u2022 LinkLayer\nAs an example the autobuild function of IPv4 looks as follows:\nlibnet_ptag_t libnet_autobuild_ipv4(uint16_t len, uint8_t prot, uint32_t dst,\nlibnet_t* l)\nArgument Description\n@SUCCESS Returns a ptag identifer.\n@FAILURE Returns -1.\nuint16_t len , Total length of the IP packet including all subsequent data\nuint8_t prot Upper layer protocol\nuint32_t dst Destination IPv4 address in little endian\nlibnet_t* l Pointer to a libnet context\nTable 25: Overview of libnet_autobuild_ipv4()\nComparing this function to the normal IPv4 we can see that the function takes the same length, protocol, and\ndestination arguments as libnet_build_ipv4(). The function does not accept a ptag argument, but it does\nreturn a ptag. Thus, it can be used to build a new IP header but not to modify an existing one.\nFor more information on how the other autobuild functions look like, please refer to the libnet-functions.h file\nunder the GitHub repository.[17]\nWrite The write function is defined as follows:\nint libnet_write(libnet_t* l)\nArgument Description\n@SUCCESS Returns the number of bytes written\n@FAILURE Returns -1\nlibnet_t* l Pointer to a libnet context\nTable 26: Overview of libnet_write()\nThe function assumes that a libnet_context has been properly initialized with libnet_init() and that a\npreviously constructed packet has been built inside this context via one or more calls to the libnet_build()\nfunctions. The write-function will then assemble the packet from the protocol blocks and send the packet either to\nthe IP address for an injection at the LIBNET_RAW level or to a network hardware address if the LIBNET_LINK\nlevel was chosen during the initialization step.\nDestruction The command to shut down a libnet context looks as follows:\nvoid libnet_destroy(libnet_t* l)\nIt shuts down the libnet session referenced by l. It closes the network interface and frees all internal memory\nstructures associated with l.\n54\nOther functions Besides the core functions introduced above, there are other interesting functions which can be\nuseful. These are:\n\u2022 Addressresolutionfunctions: WhenbuildingtheIPprotocolheader,itrequiresbothasourceandadestination\nIP address in little endian order with decimal values. As a programmer usually works with IP addresses in\noctetformatandBigEndianorder(suchas192.168.1.100)theaddresseshavetobeconvertedbeforehand. For\nthis purpose, there are specific functions provided by libnet.\nThe definition of the function which converts from presentation format to address format is:\nuint32_t libnet_name2addr4(libnet_t* l, char* host_name, uint8_t use_name)\nArgument Description\n@SUCCESS An IP number suitable for use with libnet_build() functions.\n@FAILURE Returns -1, which is technically \u201c255.255.255.255\u201d\nlibnet_t* l The libnet context pointer\nchar* host_name The presentation format address.\nuint8_t use_name Turn on/off address resolution (LIBNET_RESOLVE, LIBNET_DONT_RESOLVE)\nTable 27: Overview of libnet_name2addr4()\nThis function takes a dotted decimal string (such as 192.168.19.1) or a canonical DNS name as argument for\nhost_name and returns a decimal, little-endian ordered IPv4 address. In the official documentation, it says\nthat the return value is network byte ordered. Network byte order however nearly always corresponds to big\nendian which is not the case here. A test of libnet_name2addr4() resulted in converting the IPv4 address\n192.168.1.100 into 1677830336 which corresponds to a little endian order of previous IPv4 address. So the\nofficial documentation is misleading at this point.\nIf a DNS name is used, then LIBNET_RESOLVE must be used as argument for use_name so that a DNS\nlookup is performed. The function can fail if DNS lookup fails or if mode is set to LIBNET_DONT_RESOLVE\nand host_name refers to a canonical DNS name.\nThe counterpart to the previous function is the address to name conversion:\nchar* libnet_addr2name4(uint32_t in, uint8_t use_name)\nArgument Description\n@SUCCESS Returns a string of dots and decimals or a hostname\n@FAILURE This function cannot fail\nuint32_t in IPv4 address\nuint8_t use_name Turn on/off address resolution LIBNET_RESOLVE, LIBNET_DONT_RESOLVE\nTable 28: Overview of libnet_addr2name4()\nThis function takes a little-endian ordered IPv4 address (e.g. the output of the previous function) and returns\na string to either a canonical DNS name (if it has one) or a string of dotted decimals. This may incur a DNS\nlookup if the hostname and mode is set to LIBNET_RESOLVE. If mode is set to LIBNET_DONT_RESOLVE, no\nDNS lookup will be performed and the function will return a pointer to a dotted decimal string. The function\ncannot fail even if no canonical name exists. In this case it will simply return the dotted decimal string.\nAddress resolution functions do not only exist for IP addresses but also for MAC addresses. The function\nlibnet_hex_aton()convertsacolonseparatedhexadecimaladdressMACaddressandreturnsabytestring\nsuitable for use in a libnet_build() function.\nuint8_t* libnet_hex_aton(const char* s, int* len)\nThe argument s corresponds to a MAC address such as 00:80:41:ae:fd:7e, and len defines the length of\nthe MAC address.\n\u2022 The possibility to let the checksum of a packet calculate automatically or manually. The respective function\nfor this purpose is defined as follows:\n55\nint libnet_toggle_checksum(libnet_t* l, libnet_ptag_t ptag, int mode)\nArgument Description\n@SUCCESS Returns 1\n@FAILURE Returns -1\nlibnet_t* l Pointer to a libnet context\nlibnet_ptag_t ptag The ptag reference number\nint mode LIBNET_ON or LIBNET_OFF\nTable 29: Overview of libnet_toggle_checksum()\nBy default, if a given protocol header contains the checksum field and it is set to \"0\", libnet will calculate\nthe header checksum prior to injection. If the header is set to any other value, libnet will not calculate\nthe header checksum. Libnet_toggle_checksum() enables the programmer to over-ride this behavior.\nMode LIBNET_ON switches auto-checksumming on for the specified ptag whereas LIBNET_OFF turns auto-\nchecksumming off for the specified ptag. This assumes that the ptag of course refers to a protocol that has a\nchecksum field. If the mode is set to LIBNET_OFF, libnet will clear the checksum flag and no checksum will\nbe computed prior to injection. This assumes that the programmer will assign a value (zero or otherwise) to\nthe checksum field. Often times this is useful if a precomputed checksum or some other predefined value is\ngoing to be used. Please note that when libnet is initialized with LIBNET_RAW4, the IPv4 header checksum\nwill always be computed by the kernel prior to injection, regardless of what the programmer sets.\n\u2022 Retrieve the total size of the constructed packet:\nuint32_t libnet_getpacket_size(libnet_t* l)\nThis function returns the sum of the size of all of the headers that were built inside of l.\n\u2022 Determine the name of the network device:\nconst char* libnet_getdevice(libnet_t* l)\nThis function will return the name of the network device which was used for packet injection. This function is\nespecially useful if NULL was set as device parameter for the init function and the programmer wants to know\nwhich device has been selected now. Note it can be NULL without being an error. In this case there was no\ninterface found.\nItisnotonlypossibletoretrievethenameofnetworkdevice. Forinstance,onecanalsoretrievetheIP-address\n(both IPv4 and IPv6) of the device libnet was initialized with:\nuint32_t libnet_get_ipaddr4(libnet_t* l)\nThe return value of libnet_get_ipaddr4() is in Big Endian order.\nA similar function exists for the retrieval of the MAC address: struct libnet_ether_addr*\nlibnet_get_hwaddr(libnet_t* l)\n\u2022 Retrieve information about statistics.\nvoid libnet_stats(libnet_t* l, struct libnet_stats* ls)\nArgument Description\nlibnet_t* l Pointer to a libnet context\nstruct libnet_stats* ls Pointer to a libnet statistics structure\nTable 30: Overview of libnet_stats()\n56\nIn libnet there is a way to get statistics about the libnet context. These information cover the amount of\npackets written, amount of bytes written and the number of packet sending errors. These information will be\nretrievedinastructurewhichispassedasapointertothefunction. Thestructureiscalledlibnet_stats()\nand is defined under libnet-structures.h.\n\u2022 Retrieve the error message:\nchar* libnet_geterror(libnet_t* l)\nArgument Description\n@SUCCESS Returns an error string, NULL if none occurred\n@FAILURE This function cannot fail\nlibnet_t* l Pointer to a libnet context\nTable 31: Overview of libnet_geterror()\nReturns the last error message that occurred during a libnet_build() function call. Remember there is a\nconstant (LIBNET_ERRBUF_SIZE) that can be used to determine the optimal size for the array in which\nthe error message shall be stored in.\n57\n4.2 libpcap\nLibpcap is a portable library for network packet capturing written in C/C++. Similar to libnet, the goal of libpcap\nwas to provide system-independent tools for packet filtering and capturing as almost every single OS-vendor had its\nown interface for this task. Captured packets via libpcap can be read from the data link layer upwards. Although it\nis written in C/C++ there are also wrappers for other common programming languages such as Java or Python.[19]\nLibpcap is maintained by the developers behind tcdump.org. It has an own GitHub repository where the whole\nsource code is available as well as very detailed manpage where each function is documented.[20]\nThe latest release of libpcap is version 1.8.1 which was published in October 2016. Although libpcap considers\nitselftobesystem-independentitonlysupportsUNIX-likeoperatingsystemsincludingLinux,BSDandMacOS.For\nWindows there are special implementations of libpcap to ensure compatibility. Basically, they work very similar to\nlibpcap however there are some minor differences. This topic will be covered in section 4.3. For now, we will focus\non the basic libpcap implementation.\n4.2.1 Preparation\nTo download libpcap go to the official site of tcdump.org and unzip the file after the download.[21] To be able to\nuse the functions provided by libpcap, include the headerfile pcap/pcap.h inside your C/C++ program. Libpcap\nrequiresrootpermission. FurtherdetailsforeachOStotakecareofarementionedintheREADMEfilesintheGitHub\nrepository.\n4.2.2 Process of packet capturing\nThe structure of a libpcap program can be divided into five stages:\n1. Interface Selection\n2. Initialize libpcap session\n3. Define Filters\n4. Initiate Sniffing process\n5. Close libpcap session\nInterface Selection First of all the programmer must determine an interface where packets shall be captured.\nTheselectioncaneitherbedonemanuallybyauserorautomaticallybylibpcap. Inlattercasethereisafunctionin\nlibpcapwhichwillsimplychoosethefirstnetworkdevicethatissuitabletobesniffedon. InterfacesinLinuxusually\nhave a name such as eth0 or wlan0.\nInitializelibpcapsession Inordertosniffforpackets,aprogrammermustfirstinitializealibpcapsession. During\nthis initialization a network device is defined where the programmer actually wants to sniff for packets. However,\nit is also possible to listen to all available devices of the host at once. (on Linux systems with 2.2 or later kernels)\nUsually the initialized device corresponds with the selected interface in the previous step.\nOn top of that further decisions are made such as the maximum size that shall be received per packet or whether\nwe want to capture all packets on the selected network interface or only those that are destined to the host. It is no\nproblem to initialize more than one libpcap session for different network devices at the same time. The initialization\nstep can be compared to the opening of a file for read/write operations.\nDefine Filters Sniffing on a network interface can result in receiving a lot of packets where many are not of\ninterest for the user. Thus, there is the possibility to filter incoming packets. The filtering is done inside the kernel\nwhich makes the filtering process very efficient. Reason behind this that a kernel has to copy a received packet from\nkernel space to user space for further processing. This copy process however is very CPU intensive. With in-kernel\nfiltering this process can be skipped. So if a programmer sets an in-kernel filter only the packets that pass the filter\nrequirements will be copied to the user space resulting in a much faster performance. Setting filters is optional and\nnot required if a programmer intends to receive all packets on the specified network device.\nEveryOShasitsownpacketfilteringmechanismhowevermanyrelyontheBSDPacketFilter(BPF)architecture.\n[22] Platforms that use this architecture are for example: BSD Operating Systems, MacOS and Linux. Libpcap also\nreliesonBPFtofilteritspackets. IncaseaplatformdoesnotsupportBPFthepacketscanstillbemanuallyfiltered\nby the programmer in the user space which results in much higher overhead.\nSetting a filter in libpcap consists of three steps:\n1. Constructing filter expression\n58\n2. Compiling filter expression into BPF program\n3. Applying filter to libpcap session\nNormally, one has to write a BPF program, whose language is similar to assembly, to define a filter expression.\nHowever libpcap provides a high-level language that abstracts the actual language and makes the creation of the\nfilter much easier. The exact syntax of the BPF Filter expression will be covered in the functions section. For now,\nit is sufficient to know that the filter expression is just a simple string. As the computer cannot understand this, it\nmust be compiled into a BPF program afterwards. In order for the filter to come into action, it must be applied to\na libpcap session as the final step.\nInitiate Sniffing process After having done all the pre-requirements one is now ready to start waiting for and\nreceivingpackets. Bydefault,libpcapbothcapturestheincomingaswellastheoutgoingpacketsofthehostmachine.\nThere are two possibilities to capture packets in libpcap:\n1. Possibility is to call a function that simply checks if there is a packet available and returns the content of this\npacket.\n2. Possibilityistorunaloopthatprocesseseachpacketthatwillbereceived. Itwillnotstopuntilauserdefined\namount of packets has been processed. It is also possible to let the loop run indefinitely.\nIndependently from what possibility the programmer chooses, the data inside the packets must be somehow\nread. However, when a packet is captured, all what the application has got, is just one big array of character bytes\nand along with that a few information such as the time of reception and the total size of captured bytes. For this\nreason the programmer must work through the single OSI layers starting from the Data Link Layer and identify the\nprotocols used in each layer. It is important to note that the captured bytes always start from the data link layer,\ne.g. Ethernet or Wi-Fi 802.11.\nIn order to deal with the packets in a proper way the programmer must take care of the following:\n\u2022 Identify the size of each header so that he or she can jump to the beginning of each header\n\u2022 Cast the bytes to a struct which corresponds to the protocol header.\n\u2022 Incasethebytesofthepacketsshallbeprinteditmustbetakencarethatthebytesareconvertedfromnetwork\nbyte order to host byte order.\nIdentification of the header size Normally, the programmer expects to receive a specific type of packet\nbecausehehassetafilterandthereforedoesnotneedto\"blindly\"readapacket. However, insomecasesthismight\nbe inevitable. Then the following approach can be used to safely identify the single headers that are hiding inside\nthe packet.\nFor the Data Link Layer the programmer can most of the time assume that it will be Ethernet but this is not\nalways given since not all devices provide the same type of Data Link Layer headers. For this purpose libpcap\nprovides a function (pcap_datalink()) that returns the Link Layer type of the device which was used for the\ninitialization in the second step (Initialize libpcap session).\nAssumingtheDataLinklayertypewasEthernettheidentificationoftheupperlayerprotocolsisstraight-forward.\nTheEthernetheaderhasafieldcalledethertypewhichisa16-bitlongvaluethatspecifiestheupper-layerprotocol\nsuch as IPv4. Table 32 contains a list of the three most common values. For a full list, please refer to:[23]\nNetwork Layer Protocol Ethertype Value\nIPv4 0x0800\nIPv6 0x86DD\nAddress Resolution Protocol (ARP) 0x0806\nTable 32: Overview of Network Layer Protocols\nIf the network layer of the received packet is IPv4, the specification of the next higher layer (transport layer) is\nalso easy. In this case there is a protocol field which contains a hexadecimal value. Again, the three most common\nones can be found in table 33.[24]\nProtocol Value\nICMP 0x01\nTCP 0x06\nUDP 0x11\nTable 33: Overview of Transport Layer Protocols\n59\nCasting Once a header has been identified, it is much more convenient to work with it when the bytes are\ncast so that they match with the structure of the header protocol. This way a programmer is able to easily access a\nspecific field of the header. A programmer can decide to write its own structure in case he already knows how the\nheader will look like or he can refer to predefined structures which usually exist for all common protocols, such as\nTCP, IPv4, or Ethernet. In Linux/Unix for instance there are a couple of header files already available that contain\nthese common structures. For example, netinet/tcp.h has a structure for the TCP header. netinet/if_ether.h\nfor Ethernet header.\nByte order Thereceivedbytesinsidethepacketsarealwaysinnetworkbyteorder. Whenworkingwithbytes,\nit is more convenient for them to be in host byte order. In the arpa/inet.h or netinet/in.h header files which are\nby default available in Linux/Unix, there are four functions which can be used for the conversion from network byte\norder into host byte order or vice versa. They are:\n\u2022 htonl() and htons(): from host to network byte order whereas the function ending with l is for 32 bits and s\nfor 16.\n\u2022 ntohs() and ntohl(): from network to host byte order whereas the function ending with l is for 32 bits and s\nfor 16.\nDuring this step it might also be necessary to filter the packets in case one chooses to not use the BPF Filter for\nany reason such as the OS does not support BPF.\nWhen working with raw packets one must always keep in mind that the packets might be malformed which\nmeans that the data inside is not reliable. Dealing with these malformed packets can quickly lead to errors such as\nsegmentation fault. To avoid these errors as best as possible one can perform the following checks for a packet:\n\u2022 Check the whole size of the packet and compare it to the expected size.\n\u2022 If the packets are TCP/IP, one can check the checksum.\n\u2022 Any data inside the packet that is intended to be used (like an IP address) should be checked beforehand.\nClose libpcap session in the last step the libpcap session can be closed once sniffing is completed.\n4.2.3 Functions\nAfterhavingcoveredthebasicflowofhowalibpcapprogramworks,wewillnowhaveadeeperlookatthefunctions.\nInterface Selection For the interface selection it might be the case that no function provided by libpcap is re-\nquirediftheuserdecidestosetthedevicebyhimself. Ingeneral, itisbetterpracticetoletlibpcapchooseasuitable\ninterface to ensure portability across different platforms. For this purpose, there is the function:\nchar* pcap_lookupdev(char* errbuf)\nArgument Description\n@SUCCESS Returns a network interface name\n@FAILURE Returns NULL, reason is in errbuf.\nchar* errbuf Buffer in which in case of an error the reason is filled in\nTable 34: Overview of pcap_lookupdev()\npcap_lookupdev() will return an interface suitable for packet sniffing which is not a loopback device. In\ncase of an error the return value will be NULL and the error buffer will contain the reason. In the pcap headerfile\n(pcap.h) there is the constant PCAP_ERRBUF_SIZE which contains the optimal size for the error buffer.\nAs soon as the network device is selected, one can call another useful function which is:\nint pcap_lookupnet(const char* device, bpf_u_int32* netp, bpf_u_int32* maskp,\nchar* errbuf)\n60\nArgument Description\n@SUCCESS Returns 0\n@FAILURE Returns -1, reason is in errbuf\nchar* device Name of the network device\nbpf_u_int32* netp Buffer for the IP address\nbpf_u_int32* maskp Buffer for the network mask\nchar* errbuf Buffer in which in case of an error the reason is filled in\nTable 35: Overview of pcap_lookupnet()\nThis function saves the network IP address and the network mask of the selected device in two extra buffers.\nIf it fails, it will fill in the error buffer just like the function pcap_lookupdev(). Especially the network mask\nbuffer can be useful later when we want to set the filter so that it will only receive packets addressed to the host\u2019s\nnetworkmask. NotethattheorderofthenetworkmaskandIPaddressisnotinhumanreadableform. Seethecode\nexamples on how to convert it properly.\nAnother possibility is to retrieve a full list of all available devices with:\nint pcap_findalldevs(pcap_if_t** alldevsp, char* errbuf)\nArgument Description\n@SUCCESS Returns 0\n@FAILURE Returns -1. Reason is inside errbuf\npcap_if_t** alldevsp Pointer to a linked list containing all found devices\nchar* errbuf Buffer to save the error message in case of failure\nTable 36: Overview of pcap_findalldevs()\nOn success it returns 0 and it fills the buffer alldevsp with elements of type: pcap_if_t that represent one\ndiscovered device. It can occur that a program is not able to find all the available devices because it lacks of\nsufficient permission to open them for capturing. In this case they will not even be displayed in the list. The\nreturned list of devices can also be NULL if no device has been found. The pcap_if_t structure contains four fields:\nMember of Header Description\nstruct pcap_if* next Points to the next device in the list unless its NULL.\nchar* name A character array containing the name of the device (e.g. eth0)\nchar* description Ahuman-readabledescriptionofthedevice. Ifthereisnoneprovided,itisNULL.\nstruct pcap_addr* addresses A pointer to the first element of a list of network addresses for the device, it can\nbe NULL if the device has no address.\nbpf_u_int32 flags One of three possible device flags: PCAP_IF_LOOPBACK if device is a loopback\ninterface, PCAP_IF_UP if device is up or PCAP_IF_RUNNING if the device is\nrunning.\nTable 37: Overview of the pcap_if_t header\nThe field address itself has a specific structure type defined within pcap.h.[25] It contains the following fields:\nMember of Header Description\nstruct pcap_addr* next Points to the next device in the list unless its NULL.\nstruct sockaddr* addr Points to a struct sockaddr containing an address.\nstruct sockaddr* netmask Points to a struct sockaddr that contains the netmask corresponding to the\naddress pointed to by addr\nstruct sockaddr* broadaddr Points to a struct sockaddr that contains the broadcast address corresponding\ntotheaddresspointedtobyaddr. ItmaybeNULLifthedevicedoesnotsupport\nbroadcasts.\nstruct sockaddr* dstaddr Points to a struct sockaddr that contains the destination address corresponding\nto the address pointed to by addr. It may be NULL if the device is not a point-\nto-point interface.\nTable 38: Overview of the pcap_addr header\nThe structure sockaddr is defined in netinet.h/in.h:\n61\nMember of Header Description\nunsigned short sa_family The address family (usually of type AF_XXX)\nchar sa_data[14] 14 bytes of protocol address\nTable 39: Overview of the sockaddr header\nIt is important to note that the addresses in the list of addresses might be any type of address such as IPv4 or\nIPv6. For this reason it is necessary to check the sa_family member of the struct sockaddr before working with\nthe content. IPv4 addresses have the sa_family value AF_INET, IPv6 addresses have AF_INET6. Also, one should\nnot forget that the addresses are received in network byte order and might need to be converted to host byte order.\nIf the data about the devices is no longer required it can be deleted with:\nvoid pcap_freealldevs(pcap_if_t* alldevs)\nwhere alldevs is a pointer to the list of devices that was returned by pcap_findalldevs().\nInitialize libpcap session To initialize a libpcap session the following function has to be called:\npcap_t* pcap_open_live(const char* device, int snaplen, int promisc, int to_ms,\nchar* errbuf)\nArgument Description\n@SUCCESS Returns pcap_t* handler\n@FAILURE Returns NULL\nconst char* device Name of the network device\nint snaplen Specifies the snapshot length to be set on the handle\nint promisc Flag to set the promiscuous mode on/off\nint to_ms Read timeout in milliseconds\nchar* errbuf Buffer in which in case of an error the reason is filled in\nTable 40: Overview of pcap_open_live()\nOn success, the function returns a handler which is used for setting the filter and to start reading packets from\nthe interface. Therefore it is important to save the return value of the function. If the function however fails, the\nerror buffer will contain the reason and NULL is returned. The device argument contains the name of the selected\ndevice which was either returned by pcap_lookupdev() or which was entered manually. If the value NULL or\nany is chosen for this argument, then all packets from all interfaces are captured.\nThe snaplen argument specifies how many bytes shall be captured at most per packet. To ensure that the size\nis sufficient one can define a size of 2048 bytes. That should be sufficient for each captured packet. The promiscuous\nmode is turned off for the value 0 and turned on for each other value (usually 1). When the session is initialized in\npromiscuous mode it will also accept all packets that are not destined to the network card.\nTheargumentto_msspecifieshowmanymillisecondsthekernelshouldwaitbeforecopyingcapturedinformation\nfrom kernel space to user space. 0 will wait until enough packets have arrived to the network interface. A list of\ncommon values are: 1000, 512, 10 or 0.\nDefine Filters As already outlined the definition and applying of filters consists of three steps. The first step is\nthe construction of a filter expression which has a specific syntax.\nOne filter expression is made out of three parts called qualifiers. These qualifiers describe an identifier. An\nidentifier is a value which usually is a IP address or a portnumber depending on the kind of qualifiers used. The\nthree qualifiers that exist are:[26]\n\u2022 Type: specifies the kind of thing the ID name or number refers to. Possible values are: host, net, port and\nportrange. Default is host.\n\u2022 Dir: specifies a particular transfer direction to and/or from id. Possible values are: src, dst, src or dst,\nsrc and dst. Default is src or dst which means that all packets are captured that go to the identifier (dst)\nand all packets that come from the identifier (src). If IEEE 802.11 Wireless LAN link layers are used then the\nfollowing headers are also valid: ra, ta, addr1, addr2, addr3, and addr4.\n\u2022 Proto: this qualifier ensures that only packets of a specific protocol are captured. Possible protos are: ether,\nfddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp and udp. Default is that all protocols are captured.\n62\nThe structure of the filter expression looks as follows: [proto] + [dir] + [type] + identifier whereas the\nidentifier usually is an IP address or a port number. Note that not every qualifier must be used. If a qualifier is not\nspecified in the filter expression the default values mentioned above are simply used.\nTo get a better understanding of how to construct a filter expression, here is a list of a few examples:\n\u2022 src host 192.168.1.77: This filter returns packets whose source address is 192.168.1.71.\n\u2022 dst port 80: This filter returns all packets that are sent to port 80.\n\u2022 ip[8]==5: This filter returns packets whose IP TTL value equals 5.\n\u2022 tcp[13]==0x02 and (dst port 22 or dst port 23): This filter returns TCP packets with SYN Flag and whose\ndestination is either port 22 or 23.\nNote that the last example uses logical operators to combine multiple filter expressions. Allowed logical operator\nare: and, or, not. A filter expression is always saved in a character buffer. For more information about the\nconstruction of filter expression and more examples one can refer to the pcap filter man page.[26]\nThe next step is to compile that character buffer into the BPF format which libpcap is able to read. The partic-\nular function is:\nint pcap_compile(pcap_t* p, struct bpf_program* fp, const char* str, int\noptimize, bpf_u_int32 netmask)\nArgument Description\n@SUCCESS Returns 0\n@FAILURE Returns -1.\npcap_t* p Pointer to libpcap session\nstruct bpf_program* fp Buffer where the compiled program will be filled in\nconst char* str Filter expression which shall be compiled\nint optimize Flag to optimize the resulting code or not.\nbpf_u_int32 netmask IPv4 netmask on which packets shall be captured\nTable 41: Overview of pcap_compile()\nThefirstargumentisthefieldforthepointerthatisreturned after havinginitiatedalibpcapsessionsuccessfully\nwith pcap_open_live. The second argument is the buffer where the compiled code will be put in. The string\nargument is the filter expression. The optimize flag will optimize the compiled BPF program during compilation if\nset to true (any value other than 0). The last argument is the IPv4 netmask of the network on which the packets\nshall be captured. The pcap_lookupnet() function returns the netmask of a device in the appropriate type. If\nno network mask filtering is desired, then this parameter can simply set to PCAP_NETMASK_UNKNOWN which is a\nconstant defined in the pcap header. It equals the netmask 255.255.255.255. On success the fp buffer will contain a\ncompiled version of the filter. Otherwise the function pcap_geterr() can be called to learn about the failure.\nWith a compiled BPF filter we can apply the filter to the pcap session with:\nint pcap_setfilter(pcap_t* p, struct bpf_program* fp)\nArgument Description\n@SUCCESS Returns 0\n@FAILURE Returns -1.\npcap_t* p Pointer to libpcap session\nstruct bpf_program* fp Buffer where the compiled program will be filled in\nTable 42: Overview of pcap_setfilter()\nThe two arguments are the fp buffer which is the compiled version of the filter expression as well as the pointer\nto the pcap session to which the filter shall be applied. Once again, if anything fails, the error message can be found\nwith the pcap_geterr() function.\nOf course, it is possible to set more than one filter for one pcap session by calling the pcap_setfilter function\nmore than once.\nInitiate Sniffing process As already mentioned there are two possibilities to receive and process the incoming\npackets. Thefirstoneistocallafunctionwhichsimplyreadsthenextavailablepacketandreturnsit. Thisfunctionis:\n63\nconst u_char* pcap_next(pcap_t* p, struct pcap_pkthdr* h)\nArgument Description\n@SUCCESS Returns the packet\n@FAILURE Returns NULL\npcap_t* p Pointer to libpcap session\nstruct pcap_pkthdr* h Pointer to packet header structure\nTable 43: Overview of pcap_next()\nThe first argument is the libpcap session which the packet shall be read from. The second argument is the\npcap_pkthdr structure which is defined within the pcap header file pcap/pcap.h as follows:\n\u2022 struct timeval ts: the timestamp when the packet was received.\n\u2022 bpf_u_int32 caplen: the length of the information captured.\n\u2022 bpf_u_int32 len: the length of the total packet.\nThe difference between caplen and len is that len is the size of the full packet whereas caplen is only the part\nof the packet that was really captured and therefore is available. This could be the case if during the initialization\nof the pcap session a small value for the maximum size per packet was chosen.\nOn success the packet is returned as a string of character values. On failure NULL is returned. Unfortunately,\nthere is no way to figure out the exact reason of failure. Reasons could be:\n\u2022 Packet was discarded because it did not pass the filter\n\u2022 The system has a standard read timeout which was triggered\n\u2022 The system is non-blocking and there simply was no packet available at the time of the function call.\nThe second possibility to capture packets is with the help of the loop. This way, the capture does not need\nto be called over and over again if it is intended to receive a larger amount of packets. The respective function is\npcap_loop:\nint pcap_loop(pcap_t* p, int cnt, pcap_handler callback, u_char* user)\nArgument Description\n@SUCCESS Returns 0\n@FAILURE Returns -1\npcap_t* p Pointer to libpcap session\nint cnt Number of packets to be captured\npcap_handler callback Callback for each captured packet\nu_char* user Arguments for the callback function\nTable 44: Overview of pcap_loop()\nThe first difference between the loop function and pcap_next() is that it does not directly return the packets\u2019\ncontents. Instead an integer value is returned which is 0 if the loop finished because the number of packets to be\nreceived represented by cnt was reached. Other return values are -1 if an error interrupted the loop or -2 if the loop\nwas shut by a call of the function:\nvoid pcap_breakloop(pcap_t* p).\n(Argument is the handler of the pcap session) If pcap_loop shall run infinitely then cnt must be set to -1.\nSince the return value does not provide the content of a packet anymore, there is another way how to retrieve\nthe packet\u2019s content. This is the purpose of the callback argument which will be called every time a packet is ready\nto be read. The problem with callbacks is that the user cannot pass any arguments. This is the reason why the last\nargument (user) exists which enables the programmer to include arguments for the callback function. The callback\nfunction must have a specific prototype because otherwise pcap_loop() would not know how to deal with it. It\nlooks as follows:\nvoid function_name(u_char* userarg, const struct pcap_pkthdr* pkthdr, const u_char*\npacket)\n64\nArgument Description\nu_char* userarg Pointer to the user arguments\nconst struct pcap_pkthdr* pkthdr Pointer to packet header\nconst u_char* packet Pointer to the captured packet\nTable 45: Overview of callback\nThe first argument of the callback function is identical to the user pointer of pcap_loop(). The second one\nis the same packet header structure that is also used in pcap_next(). It contains information about the captured\npacket. The last argument is the captured packet itself. It is important to note that the usearg pointer is of type\nu_char. This means that the pointer must most likely be cast two times: One time when calling the pcap_loop()\nfunction and once again when using the argument inside the callback function. See the sample code section for an\nexample which shows how to use pcap_loop() along with the user arguments. See line 143 of listing 16 in the\nappendix.\nDuringtheprocessionofthepacketsaprogrammermustadditionallycallthepcap_datalink()functionincase\nhe does not know for sure which type of packet was received. This function returns the link layer type of the packet.\nThis way, the programmer can safely read the packet as he knows the structure of the received packet. The full\nspecification of the function is: int pcap_datalink(pcap_t* p) where p is the handler of the pcap session.\nIt returns an integer value which identifies the type of link layer header. Libpcap can distinguish more than 180\ndifferent link types. As it would be too much to list all of them here, the table 46 lists the two most common types.\nFor a full list, please refer to URL.[27]\nData Link Type Returned Integer value Pcap Alias\nEthernet 10/100/1000 Mbs 1 DLT_EN10MB\nWi-Fi 802.11 6 DLT_IEEE802\nTable 46: Common data link types\nThe field pcap alias refers to the name of constants representing the integer value which are defined within pcap.\nClose Session Last but not least a programmer can close the session when no more packets shall be captured.\nThis can be done with:\nvoid pcap_close(pcap_t* p)\nwhere p is the session handler. It frees all resources that were allocated by the session.\nOther functions Thefunctionsabovecanbeseenaslibpcap\u2019smainroutinesthataremainlyused. Howeverthere\nare some further functions which provide depending on the intended use useful functions. These include:\n\u2022 Packet injection: Libpcap also provides packet injecting methods. However these are limited to two functions\nonly where simply one large string is sent. In other words libpcap does not provide any functions to build the\npackets layer-by-layer as libnet does which makes packet injection in libpcap much harder. Therefore in our\nopinion it makes no sense to use the libpcap methods if you can also rely on libnet.\n\u2022 Statistics: Libpcap provides a function which returns capture statistics of a pcap session. The function is\ndefined as:\nint pcap_stats(pcap_t* p, struct pcap_stat* ps)\nThe required structure pcap_stat is defined in pcap/pcap.h. It contains information like number of packets\nreceived/dropped or lost.\n\u2022 Saving Packets: The content of a packet can be written to a so called savefile to preserve it for later use.\nTheadvantageofsavingpacketsthiswayisthatitcanbereadagainwiththesamefunctionsintroducedabove.\nFor a full list of all the available functions and their documentation, please refer to the official manpage of\nlibpcap.[28]\nA slightly modified example of an example-file, which shows the basic usage of the send-operation is in listing 14\nin the appendix.\n4.3 libpcap in Windows\nWhen searching for libpcap under Windows one will quickly discover WinPcap. WinPcap is a special adaption of\nlibpcap to also work on Windows. On its official site WinPcap even claims to be the \"industry-standard windows\n65\npacket capture library\".[29] The problem with Winpcap however is that its latest release was published in March\n2013(version4.1.3). InthisreleasethedevelopersaddedsupportforWindows8andWindowsServer2012. However\nfor the currently latest Windows 10 there is no official support which leads to the situation that WinPcap does\nnot work on some builds under Windows 10 because the outdated NDIS5 API (which WinPcap relies on) has been\nremoved. OntopofthatthedevelopersofWinpcapstatedinoneofthelastpublishedannouncementsthattheyhave\nlittle time to continue work on Winpcap. Although Winpcap considers itself as the industry standard, it is unsure\nwhether the work on WinPcap will be continued in the near future.[29] For this reason, it makes more sense to focus\non Npcap which is a codefork from WinPcap and still actively maintained. Npcap solves some of the disadvantages\nwith Winpcap and provides new features including:\n\u2022 Windows10support: NpcapreliesonthenewNDIS6insteadofthedeprecatedNDIS5. ThereforeNpcapalso\nworks on Windows 10.\n\u2022 Raw 802.11 packet capture: Npcap is able to capture Wi-Fi packets which was not possible under WinPcap.\n\u2022 Security: Npcap can be restricted so that only administrators can sniff packets.\n\u2022 WinPcap Compatibility: Older programs that were written for WinPcap are still compatible and can be run\nin Npcap as well.\n\u2022 Loopback Packet Capture: Npcap is able to capture packets from the loopback interface. For this purpose\nNpcap will create an adapter named Npcap Loopback Adapter after installation.\n\u2022 Performance: Overall better performance than WinPcap.\n4.3.1 Installation and Preparation\nThe installation of the npcap library is straightforward. An executatble and an SKD can be found here: https:\n//nmap.org/npcap/. Theexecutablewillplacetherequiredfilesonthesystemandaprecompiledexample(some\ncan be found in the SDK examples folder) can be run. For developing applciations, the SDK must be downloaded,\nextracted and be included into the C/C++ Project. Using an IDE, it is enough to point to the *.lib and *.h files\nfor compiling and linking. Note: to be sure, that no packets are filteres by the Windows-Firewall it is recommended\nto disable it, since packets wich are not usual TCP/IP packets, are seen as invalid and being dropped.\nInstalling the npcap executable is recommended here, because it will not interfere with a possible installation of\nWireshark. Modified examples of an showing the basic usage of the send-operation is in listing 15 and showing the\nreceive / dump option in listing 16 in the appendix.\n4.3.2 Process of packet capturing\nThe process of packet capturing is entirely identical to the libnet process. Refer to 4.2.2.\n4.3.3 Functions\nThe syntax of Npcap is identical to the syntax of Winpcap, e.g. Winpcap and Npcap provide the exact same\nfunctions. ThesyntaxofWinPcapinturnreliesonlibpcap. SolibpcapprogramsthatarewrittenunderLinux/Unix\nare also portable to Windows. Because of this nearly all functions are identical to those that were introduced in\nthe previous libpcap section. In fact, all of the above mentioned functions can be used in Winpcap as well. On\ntop of that Npcap/WinPcap offer some extended functions that only work on Windows. These functions extends\nthe capability of libpcap by providing remote packet capture, packet buffer size variation or high-precision packet\ninjection. To learn about these functions in detail please visit:[4]\n66\n5 Literature\nReferences\n[1] Linux man pages - raw-sockets. http://man7.org/linux/man-pages/man7/raw.7.html, 2014. visited\non 2017-01-02.\n[2] Bpf manpage. https://www.freebsd.org/cgi/man.cgi?bpf(4), 2010. visited on 2017-01-21.\n[3] Tcp / ip raw sockets. https://msdn.microsoft.com/en-us/library/windows/desktop/\nms740548(v=vs.85).aspx. visited on 2017-03-15.\n[4] Winpcap\u2019s user manual. http://www.winpcap.org/docs/docs_412/html/group__wpcapfunc.\nhtml, 2009. visited on 2017-03-20.\n[5] Andr\u00e9Volk. RAWSocketProgrammierungundEinsatzfelder. Master\u2019sthesis,Universit\u00e4tKoblenz,theNether-\nlands, 2008.\n[6] Ip spoofing with bsd raw sockets interface. http://www.enderunix.org/docs/en/rawipspoof/, 2007.\nvisited on 2017-01-21.\n[7] Using freebsd\u2019s bpf device with c/c++. http://bastian.rieck.ru/howtos/bpf/, 2010. visited on 2017-\n01-21.\n[8] Linux man pages. https://linux.die.net/man/, 2014. visited on 2017-01-02.\n[9] Beej\u2019s network programming guide. http://beej.us/guide/bgnet/output/html/multipage/\nsockaddr_inman.html, 2017. visited on 2017-01-21.\n[10] Linux man pages - netdevice. http://man7.org/linux/man-pages/man7/netdevice.7.html, 2014.\nvisited on 2017-01-02.\n[11] Microhowto.http://www.microhowto.info/howto/send_an_arbitrary_ipv4_datagram_using_\na_raw_socket_in_c.html, 2017. visited on 2017-01-21.\n[12] Linux man pages - packet-sockets. http://man7.org/linux/man-pages/man7/packet.7.html, 2014.\nvisited on 2017-01-02.\n[13] Libnet supported os. https://github.com/sam-github/libnet/blob/master/libnet/doc/\nPORTED, 2012. visited on 2017-03-12.\n[14] Libnet github repository. https://github.com/sam-github/libnet, 2016. visited on 2017-03-12.\n[15] Libnet download sourceforge. https://sourceforge.net/projects/libnet-dev/, 2014. visited on\n2017-03-12.\n[16] Libnet migration instructions. https://github.com/sam-github/libnet/blob/master/libnet/\ndoc/MIGRATION, 2013. visited on 2017-03-12.\n[17] Libnet function file. https://github.com/sam-github/libnet/blob/master/libnet/include/\nlibnet/libnet-functions.h, 2013. visited on 2017-03-12.\n[18] Libnet header file. https://github.com/sam-github/libnet/blob/master/libnet/include/\nlibnet/libnet-headers.h, 2012. visited on 2017-03-12.\n[19] Pcap supported libraries. https://wiki.wireshark.org/Development/LibpcapFileFormat#\nLibraries, 2015. visited on 2017-03-12.\n[20] Pcap github. https://github.com/the-tcpdump-group/libpcap, 2017. visited on 2017-03-12.\n[21] Tcpdump homepage. http://www.tcpdump.org/, 2017. visited on 2017-03-12.\n[22] S. McCanne and V. Jacobson. The bsd packet filter: A new architecture for user-level packet capture. http:\n//www.tcpdump.org/, 1992. visited on 2017-03-12.\n[23] Ethernet types. http://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.\nxhtml#ieee-802-numbers-1, 2017. visited on 2017-03-12.\n67\n[24] Assigned internet protocol numbers. https://www.iana.org/assignments/protocol-numbers/\nprotocol-numbers.xhtml, 2016. visited on 2017-03-12.\n[25] Pcapheaderfile.https://github.com/the-tcpdump-group/libpcap/blob/master/pcap/pcap.h,\n2017. visited on 2017-03-12.\n[26] Pcap filter mechanism. http://www.tcpdump.org/manpages/pcap-filter.7.html, 2015. visited on\n2017-03-12.\n[27] Link-layer header types. http://www.tcpdump.org/linktypes.html, 2015. visited on 2017-03-12.\n[28] Pcap man page. http://www.tcpdump.org/manpages/pcap.3pcap.html, 2017. visited on 2017-03-12.\n[29] Winpcap homepage. http://www.winpcap.org/, 2013. visited on 2017-03-12.\n68\nA Appendix: Listings\nA.1 rfc1071 checksum cpp\nListing 12: rfc1071 checksum cpp\n1 unsigned short comp_chksum( unsigned short *addr, int len )\n2 {\n3 /**\n4 * Quelle: RFC 1071\n5 * Calculates the Internet-checksum\n6 * Valid for the IP, ICMP, TCP or UDP header\n7 *\n8 * *addr : Pointer to the Beginning of the data\n9 * (Checksummenfeld muss Null sein)\n10 * len : length of the data (in bytes)\n11 *\n12 * Return : Checksum in network-byte-order\n13 **/\n14\n15 long sum = 0;\n16\n17 while( len > 1 ) {\n18 sum += *(addr++);\n19 len -= 2;\n20 }\n21\n22 if( len > 0 )\n23 sum += * addr;\n24\n25 while (sum >> 16)\n26 sum = ( ( sum & 0xffff ) + ( sum >> 16 ) );\n27\n28 sum = ~sum;\n29\n30 return ( ( u_short ) sum );\n31 }\n69\nA.2 win socket cpp\nListing 13: win socket cpp\n1 #ifndef UNICODE\n2 #define UNICODE 1\n3 #endif\n4\n5 // link with Ws2_32.lib\n6 #pragma comment(lib,\"Ws2_32.lib\")\n7\n8 #include <winsock2.h>\n9 #include <ws2tcpip.h>\n10 #include <stdio.h>\n11 #include <stdlib.h> // Needed for _wtoi\n12\n13\n14 int __cdecl wmain(int argc, wchar_t **argv)\n15 {\n16\n17 //-----------------------------------------\n18 // Declare and initialize variables\n19 WSADATA wsaData = {0};\n20 int iResult = 0;\n21\n22 // int i = 1;\n23\n24 SOCKET sock = INVALID_SOCKET;\n25 int iFamily = AF_UNSPEC;\n26 int iType = 0;\n27 int iProtocol = 0;\n28\n29 // Validate the parameters\n30 if (argc != 4) {\n31 wprintf(L\"usage: %s <addressfamily> <type> <protocol>\\n\", argv[0]);\n32 wprintf(L\"socket opens a socket for the specified family, type, & protocol\\n\");\n33 wprintf(L\"%ws example usage\\n\", argv[0]);\n34 wprintf(L\" %ws 0 2 17\\n\", argv[0]);\n35 wprintf(L\" where AF_UNSPEC=0 SOCK_DGRAM=2 IPPROTO_UDP=17\\n\", argv[0]);\n36 return 1;\n37 }\n38\n39 iFamily = _wtoi(argv[1]);\n40 iType = _wtoi(argv[2]);\n41 iProtocol = _wtoi(argv[3]);\n42\n43 // Initialize Winsock\n44 iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n45 if (iResult != 0) {\n46 wprintf(L\"WSAStartup failed: %d\\n\", iResult);\n47 return 1;\n48 }\n49\n50 wprintf(L\"Calling socket with following parameters:\\n\");\n51 wprintf(L\" Address Family = \");\n52 switch (iFamily) {\n53 case AF_UNSPEC:\n54 wprintf(L\"Unspecified\");\n55 break;\n56 case AF_INET:\n57 wprintf(L\"AF_INET (IPv4)\");\n58 break;\n59 case AF_INET6:\n60 wprintf(L\"AF_INET6 (IPv6)\");\n61 break;\n62 case AF_NETBIOS:\n63 wprintf(L\"AF_NETBIOS (NetBIOS)\");\n64 break;\n65 case AF_BTH:\n66 wprintf(L\"AF_BTH (Bluetooth)\");\n67 break;\n68 default:\n69 wprintf(L\"Other\");\n70 break;\n71 }\n72 wprintf(L\" (%d)\\n\", iFamily);\n70\n73\n74 wprintf(L\" Socket type = \");\n75 switch (iType) {\n76 case 0:\n77 wprintf(L\"Unspecified\");\n78 break;\n79 case SOCK_STREAM:\n80 wprintf(L\"SOCK_STREAM (stream)\");\n81 break;\n82 case SOCK_DGRAM:\n83 wprintf(L\"SOCK_DGRAM (datagram)\");\n84 break;\n85 case SOCK_RAW:\n86 wprintf(L\"SOCK_RAW (raw)\");\n87 break;\n88 case SOCK_RDM:\n89 wprintf(L\"SOCK_RDM (reliable message datagram)\");\n90 break;\n91 case SOCK_SEQPACKET:\n92 wprintf(L\"SOCK_SEQPACKET (pseudo-stream packet)\");\n93 break;\n94 default:\n95 wprintf(L\"Other\");\n96 break;\n97 }\n98 wprintf(L\" (%d)\\n\", iType);\n99\n100 wprintf(L\" Protocol = %d = \", iProtocol);\n101 switch (iProtocol) {\n102 case 0:\n103 wprintf(L\"Unspecified\");\n104 break;\n105 case IPPROTO_ICMP:\n106 wprintf(L\"IPPROTO_ICMP (ICMP)\");\n107 break;\n108 case IPPROTO_IGMP:\n109 wprintf(L\"IPPROTO_IGMP (IGMP)\");\n110 break;\n111 case IPPROTO_TCP:\n112 wprintf(L\"IPPROTO_TCP (TCP)\");\n113 break;\n114 case IPPROTO_UDP:\n115 wprintf(L\"IPPROTO_UDP (UDP)\");\n116 break;\n117 case IPPROTO_ICMPV6:\n118 wprintf(L\"IPPROTO_ICMPV6 (ICMP Version 6)\");\n119 break;\n120 default:\n121 wprintf(L\"Other\");\n122 break;\n123 }\n124 wprintf(L\" (%d)\\n\", iProtocol);\n125\n126 sock = socket(iFamily, iType, iProtocol);\n127 if (sock == INVALID_SOCKET)\n128 wprintf(L\"socket function failed with error = %d\\n\", WSAGetLastError() );\n129 else {\n130 wprintf(L\"socket function succeeded\\n\");\n131\n132 // Close the socket to release the resources associated\n133 // Normally an application calls shutdown() before closesocket\n134 // to disables sends or receives on a socket first\n135 // This isn\u2019t needed in this simple sample\n136 iResult = closesocket(sock);\n137 if (iResult == SOCKET_ERROR) {\n138 wprintf(L\"closesocket failed with error = %d\\n\", WSAGetLastError() );\n139 WSACleanup();\n140 return 1;\n141 }\n142 }\n143\n144 WSACleanup();\n145\n146 return 0;\n147 }\n71\nA.3 libnet tcp c\nListing 14: libnet tcp c\n1 #include \"libnet_test.h\"\n2\n3 int\n4 main(int argc, char *argv[]){\n5 int c;\n6 char *cp;\n7 libnet_t *l;\n8 libnet_ptag_t t;\n9 char *payload;\n10 u_short payload_s;\n11 u_long src_ip, dst_ip;\n12 u_short src_prt, dst_prt;\n13 char errbuf[LIBNET_ERRBUF_SIZE];\n14\n15 printf(\"libnet 1.1 packet shaping: TCP + options[link]\\n\");\n16\n17 /*\n18 * Initialize the library. Root priviledges are required.\n19 */\n20 l = libnet_init(\n21 LIBNET_LINK, /* injection type */\n22 NULL, /* network interface */\n23 errbuf); /* error buffer */\n24\n25 if (l == NULL) {\n26 fprintf(stderr, \"libnet_init() failed: %s\", errbuf);\n27 exit(EXIT_FAILURE);\n28 }\n29\n30 src_ip = 0;\n31 dst_ip = 0;\n32 src_prt = 0;\n33 dst_prt = 0;\n34 payload = NULL;\n35 payload_s = 0;\n36 while ((c = getopt(argc, argv, \"d:s:p:\")) != EOF){\n37 switch (c)\n38 {\n39 /*\n40 * We expect the input to be of the form \u2018ip.ip.ip.ip.port\u2018. We\n41 * point cp to the last dot of the IP address/port string and\n42 * then seperate them with a NULL byte. The optarg now points to\n43 * just the IP address, and cp points to the port.\n44 */\n45 case \u2019d\u2019:\n46 if (!(cp = strrchr(optarg, \u2019.\u2019)))\n47 {\n48 usage(argv[0]);\n49 }\n50 *cp++ = 0;\n51 dst_prt = (u_short)atoi(cp);\n52 if ((dst_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n53 {\n54 fprintf(stderr, \"Bad destination IP address: %s\\n\", optarg);\n55 exit(EXIT_FAILURE);\n56 }\n57 break;\n58 case \u2019s\u2019:\n59 if (!(cp = strrchr(optarg, \u2019.\u2019)))\n60 {\n61 usage(argv[0]);\n62 }\n63 *cp++ = 0;\n64 src_prt = (u_short)atoi(cp);\n65 if ((src_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)\n66 {\n67 fprintf(stderr, \"Bad source IP address: %s\\n\", optarg);\n68 exit(EXIT_FAILURE);\n69 }\n70 break;\n71 case \u2019p\u2019:\n72 payload = optarg;\n72\n73 payload_s = strlen(payload);\n74 break;\n75 default:\n76 exit(EXIT_FAILURE);\n77 }\n78 }\n79\n80 if (!src_ip || !src_prt || !dst_ip || !dst_prt)\n81 {\n82 usage(argv[0]);\n83 exit(EXIT_FAILURE);\n84 }\n85\n86 t = libnet_build_tcp_options(\n87 (uint8_t*) \"\\003\\003\\012\\001\\002\\004\\001\\011\\010\\012\\077\\077\\077\\077\\000\\000\\000\\000\\000\\000\",\n88 20,\n89 l,\n90 0);\n91 if (t == -1)\n92 {\n93 fprintf(stderr, \"Can\u2019t build TCP options: %s\\n\", libnet_geterror(l));\n94 goto bad;\n95 }\n96\n97 t = libnet_build_tcp(\n98 src_prt, /* source port */\n99 dst_prt, /* destination port */\n100 0x01010101, /* sequence number */\n101 0x02020202, /* acknowledgement num */\n102 TH_SYN, /* control flags */\n103 32767, /* window size */\n104 0, /* checksum */\n105 10, /* urgent pointer */\n106 LIBNET_TCP_H + 20 + payload_s, /* TCP packet size */\n107 (uint8_t*)payload, /* payload */\n108 payload_s, /* payload size */\n109 l, /* libnet handle */\n110 0); /* libnet id */\n111 if (t == -1)\n112 {\n113 fprintf(stderr, \"Can\u2019t build TCP header: %s\\n\", libnet_geterror(l));\n114 goto bad;\n115 }\n116\n117 t = libnet_build_ipv4(\n118 LIBNET_IPV4_H + LIBNET_TCP_H + 20 + payload_s,/* length */\n119 0, /* TOS */\n120 242, /* IP ID */\n121 0, /* IP Frag */\n122 64, /* TTL */\n123 IPPROTO_TCP, /* protocol */\n124 0, /* checksum */\n125 src_ip, /* source IP */\n126 dst_ip, /* destination IP */\n127 NULL, /* payload */\n128 0, /* payload size */\n129 l, /* libnet handle */\n130 0); /* libnet id */\n131 if (t == -1)\n132 {\n133 fprintf(stderr, \"Can\u2019t build IP header: %s\\n\", libnet_geterror(l));\n134 goto bad;\n135 }\n136\n137 t = libnet_build_ethernet(\n138 enet_dst, /* ethernet destination */\n139 enet_src, /* ethernet source */\n140 ETHERTYPE_IP, /* protocol type */\n141 NULL, /* payload */\n142 0, /* payload size */\n143 l, /* libnet handle */\n144 0); /* libnet id */\n145 if (t == -1)\n146 {\n147 fprintf(stderr, \"Can\u2019t build ethernet header: %s\\n\", libnet_geterror(l));\n148 goto bad;\n73\n149 }\n150\n151 /*\n152 * Write it to the wire.\n153 */\n154 c = libnet_write(l);\n155 if (c == -1)\n156 {\n157 fprintf(stderr, \"Write error: %s\\n\", libnet_geterror(l));\n158 goto bad;\n159 }\n160 else\n161 {\n162 fprintf(stderr, \"Wrote %d byte TCP packet; check the wire.\\n\", c);\n163 }\n164\n165 libnet_destroy(l);\n166 return (EXIT_SUCCESS);\n167 bad:\n168 libnet_destroy(l);\n169 return (EXIT_FAILURE);\n170 }\n171\n172 void\n173 usage(char *name)\n174 {\n175 fprintf(stderr,\n176 \"usage: %s -s source_ip.source_port -d destination_ip.destination_port\"\n177 \" [-p payload]\\n\",\n178 name);\n179 }\n74\nA.4 sendpack c\nListing 15: sendpack c\n1 #include <stdlib.h>\n2 #include <stdio.h>\n3 #include <pcap.h>\n4\n5 int main(int argc, char **argv){\n6 pcap_t *fp;\n7 char errbuf[PCAP_ERRBUF_SIZE];\n8 u_char packet[100];\n9 int i;\n10\n11 /* Check the validity of the command line */\n12 if (argc != 2){\n13 printf(\"usage: %s interface\", argv[0]);\n14 return 1;\n15 }\n16\n17 /* Open the adapter */\n18 if ((fp = pcap_open_live(\n19 argv[1], // name of the device\n20 65536, // portion of the packet to capture. It doesn\u2019t matter in this case\n21 1, // promiscuous mode (nonzero means promiscuous)\n22 1000, // read timeout\n23 errbuf // error buffer\n24 )) == NULL){\n25 fprintf(stderr,\"\\nUnable to open the adapter. %s is not supported by WinPcap\\n\", argv[1]);\n26 return 2;\n27 }\n28\n29 /* Setting DMAC to B4 - B6 - 76 - D1 - 0F - C9\n30 This is an example and does not need to be a valid MAC */\n31 packet[0]=0xB4;\n32 packet[1]=0xB6;\n33 packet[2]=0x76;\n34 packet[3]=0xD1;\n35 packet[4]=0x0F;\n36 packet[5]=0xC9;\n37\n38 /* set SMAC to 2:2:2:2:2:2 */\n39 packet[6]=2;\n40 packet[7]=2;\n41 packet[8]=2;\n42 packet[9]=2;\n43 packet[10]=2;\n44 packet[11]=2;\n45\n46 /* Fill the rest of the packet with data */\n47 for(i = 12; i < 100; i++){\n48 packet[i]= (u_char)i;\n49 }\n50\n51 /* Send down the packet */\n52 if (pcap_sendpacket(\n53 fp, // Adapter\n54 packet, // buffer with the packet\n55 100 // size\n56 ) != 0){\n57 fprintf(stderr,\"\\nError sending the packet: %s\\n\", pcap_geterr(fp));\n58 return 3;\n59 }\n60 printf(\"Packet sent.\");\n61 pcap_close(fp);\n62 return 0;\n63 }\n75\nA.5 dump c\nListing 16: dump c\n1 #ifdef _MSC_VER\n2 /*\n3 * we do not want the warnings about the old deprecated and unsecure CRT functions\n4 * since these examples can be compiled under *nix as well\n5 */\n6 #define _CRT_SECURE_NO_WARNINGS\n7 #endif\n8\n9 #include \"pcap.h\"\n10\n11 /* 4 bytes IP address */\n12 typedef struct ip_address{\n13 u_char byte1;\n14 u_char byte2;\n15 u_char byte3;\n16 u_char byte4;\n17 }ip_address;\n18\n19 /* IPv4 header */\n20 typedef struct ip_header{\n21 u_char ver_ihl; // Version (4 bits) + Internet header length (4 bits)\n22 u_char tos; // Type of service\n23 u_short tlen; // Total length\n24 u_short identification; // Identification\n25 u_short flags_fo; // Flags (3 bits) + Fragment offset (13 bits)\n26 u_char ttl; // Time to live\n27 u_char proto; // Protocol\n28 u_short crc; // Header checksum\n29 ip_address saddr; // Source address\n30 ip_address daddr; // Destination address\n31 u_int op_pad; // Option + Padding\n32 }ip_header;\n33\n34 /* UDP header*/\n35 typedef struct udp_header{\n36 u_short sport; // Source port\n37 u_short dport; // Destination port\n38 u_short len; // Datagram length\n39 u_short crc; // Checksum\n40 }udp_header;\n41\n42 /* UDP header*/\n43 typedef struct eth_header{\n44 u_char hwdes[6]; // Destination MAC\n45 u_char hwsrc[6]; // Source MAC\n46 u_char etherType[2]; // Ether Type 08 00 for ipv4\n47\n48 }eth_header;\n49\n50 enum FORMAT {BIN, DEC, HEX}; //For custom print function\n51\n52 /* prototype of the packet handler */\n53 void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);\n54\n55 /* protortypes for printfunctions */\n56 void print_bytes(char* text, void *object, size_t size, enum FORMAT f);\n57 void print_bytes_noInc(char* text, void *object, size_t size, enum FORMAT f);\n58\n59 int main(){\n60 struct sockaddr_in *saServer;\n61 char errbuf[PCAP_ERRBUF_SIZE];\n62 char packet_filter[] = \"\"; //kernel packet filter, \"ip and udp\" would be valid, iff only valid ip/udp\npackets are sent\n63 u_int netmask;\n64 pcap_t *adhandle; //for initializing device, whill hold the chosen one\n65 pcap_if_t *alldevs; //for initializing device, will hold all\n66 pcap_if_t *d; //for initializing device, iterator\n67 int inum, i=0; //for initializing device, iterator for printing, choosing\n68 struct bpf_program fcode;\n69\n70\n71 /* Retrieve the device list */\n76\n72 if(pcap_findalldevs(&alldevs, errbuf) == -1){\n73 fprintf(stderr,\"Error in pcap_findalldevs: %s\\n\", errbuf);\n74 exit(1);\n75 }\n76\n77 /* Print the list */\n78 for(d=alldevs; d; d=d->next){\n79 printf(\"%d. %s\", ++i, d->name);\n80 if (d->description)\n81 printf(\" (%s)\\n\", d->description);\n82 else\n83 printf(\" (No description available)\\n\");\n84 }\n85\n86 if(i==0){\n87 printf(\"\\nNo interfaces found! Make sure WinPcap is installed.\\n\");\n88 return -1;\n89 }\n90\n91 printf(\"Enter the interface number (1-%d):\",i);\n92 scanf(\"%d\", &inum);\n93\n94 /* Check if the user specified a valid adapter */\n95 if(inum < 1 || inum > i){\n96 printf(\"\\nAdapter number out of range.\\n\");\n97 pcap_freealldevs(alldevs);/* Free the device list */\n98 return -1;\n99 }\n100\n101 /* Jump to the selected adapter */\n102 for(d=alldevs, i=0; i< inum-1 ;d=d->next, i++);\n103\n104 /* Open the adapter */\n105 if ((adhandle= pcap_open_live(d->name, // name of the device\n106 65536, // portion of the packet to capture: 65536 grants that the whole packet will be captured on\nall the MACs.\n107 1, // promiscuous mode (nonzero means promiscuous)\n108 1000, // read timeout\n109 errbuf // error buffer\n110 )) == NULL){\n111 fprintf(stderr,\"\\nUnable to open the adapter. %s is not supported by WinPcap\\n\");\n112 pcap_freealldevs(alldevs);\n113 return -1;\n114 }\n115\n116 if(d->addresses != NULL)\n117 /* Retrieve the mask of the first address of the interface */\n118 netmask=((struct sockaddr_in *)(d->addresses->netmask))->sin_addr.S_un.S_addr;\n119 else\n120 /* If the interface is without addresses we suppose to be in a C class network */\n121 netmask=0xffffff;\n122\n123 /* compile the filter */\n124 if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) <0 ){\n125 fprintf(stderr,\"\\nUnable to compile the packet filter. Check the syntax.\\n\");\n126 pcap_freealldevs(alldevs);\n127 return -1;\n128 }\n129\n130 /* set the filter */\n131 if (pcap_setfilter(adhandle, &fcode)<0){\n132 fprintf(stderr,\"\\nError setting the filter.\\n\");\n133 pcap_freealldevs(alldevs);\n134 return -1;\n135 }\n136\n137 printf(\"\\nlistening on %s...\\n\", d->description);\n138\n139 /* At this point, we don\u2019t need any more the device list. Free it */\n140 pcap_freealldevs(alldevs);\n141\n142 /* start the capture */\n143 pcap_loop(adhandle, 0, packet_handler, NULL);\n144 return 0;\n145 }\n146\n77\n147 /* Callback function invoked by libpcap for every incoming packet */\n148 void packet_handler(u_char *param, const struct pcap_pkthdr* header, const u_char *pkt_data){\n149\n150 /* bufers for time */\n151 struct tm *ltime;\n152 char timestr[16];\n153 time_t local_tv_sec;\n154\n155 /* buffers for header data */\n156 ip_header *ih;\n157 udp_header *uh;\n158 eth_header* eh;\n159 u_int ip_len;\n160 u_short sport, dport;\n161\n162 (VOID)(param); //unused parameter\n163\n164 /* convert the timestamp to readable format */\n165 local_tv_sec = header->ts.tv_sec;\n166 ltime = localtime(&local_tv_sec);\n167 strftime( timestr, sizeof timestr, \"%H:%M:%S\", ltime);\n168\n169 /* print timestamp and length of the packet */\n170 printf(\"%s.%.6d len:%d Ethernet Data:\\n\", timestr, header->ts.tv_usec, header->len);\n171 print_bytes(\"Whole Data\", pkt_data, header->len, HEX);\n172 eh = (eth_header*)pkt_data;\n173\n174 /* Ethernet (DLL) Header */\n175 print_bytes(\"\\nMAC Dest\\t\\t\", &(eh->hwdes), 6, HEX);\n176 print_bytes(\"MAC Source\\t\\t\",&(eh->hwsrc), 6, HEX);\n177 print_bytes(\"Ethertype\\t\\t\", &(eh->etherType), 2, HEX);\n178\n179 ih = (ip_header *) (pkt_data + 14); //length of ethernet header\n180\n181 /* position of udp (Network) header */\n182 ip_len = (ih->ver_ihl & 0xf) * 4;\n183 uh = (udp_header *) ((u_char*)ih + ip_len);\n184\n185 /* convert network to host byte order */\n186 sport = ntohs( uh->sport );\n187 dport = ntohs( uh->dport );\n188\n189\n190 /* Transport (IP) Header */\n191 print_bytes_noInc(\"\\nVersion (H), IHL (L)\\t\", &(ih->ver_ihl), 1, BIN);\n192 print_bytes_noInc(\"TypeOfService DSCP:6; ECN:2\", &(ih->tos), 1, BIN);\n193 print_bytes_noInc(\"Total Lenth\\t\\t\", &(ih->tlen), 2, DEC);\n194 print_bytes_noInc(\"Identification\\t\\t\", &(ih->identification), 2, HEX);\n195 print_bytes_noInc(\"Flags:3, FragOff:13\\t\", &(ih->flags_fo), 2, BIN);\n196 print_bytes_noInc(\"TTL\\t\\t\\t\", &(ih->ttl), 1, DEC);\n197 print_bytes_noInc(\"Protocol\\t\\t\", &(ih->proto), 1, BIN);\n198 print_bytes_noInc(\"Checksum\\t\\t\", &(ih->crc), 2, DEC);\n199\n200 /* print ip addresses and udp ports */\n201 printf(\"Source IP \\t\\t\\t[ %d.%d.%d.%d ]\\n\",\n202 ih->saddr.byte1,\n203 ih->saddr.byte2,\n204 ih->saddr.byte3,\n205 ih->saddr.byte4);\n206 printf(\"Destination IP\\t\\t\\t[ %d.%d.%d.%d ]\\n\",\n207 ih->daddr.byte1,\n208 ih->daddr.byte2,\n209 ih->daddr.byte3,\n210 ih->daddr.byte4);\n211 print_bytes_noInc(\"\\nSource Port\\t\\t\", &sport, 2, DEC);\n212 print_bytes_noInc(\"Destination Port\\t\", &dport, 2, DEC);\n213 print_bytes_noInc(\"datagram Length\\t\\t\", &(uh->len), 2, DEC);\n214\n215 printf(\"\\n\\n\");\n216 }\n217\n218 void print_bytes(char* text, void *object, size_t size, enum FORMAT f){\n219 /* buffers */\n220 const u_char * const bytes = object;\n221 size_t i;\n222\n78\n223 printf(\"%s \\t[ \", text);\n224 switch (f){\n225 case BIN:\n226 for (i = 0; i < size; i++){\n227 for (int j = 128; j > 0; j >>= 1) {\n228 printf(\"%d\", (bytes[i] & j) == j ? 1 : 0);\n229 if(j == 16)\n230 printf(\" \");\n231 }\n232 printf(\" \");\n233 }\n234 break;\n235 case DEC:\n236 if (size == 1){\n237 printf(\"%d \", bytes[0]);\n238 break;\n239 }\n240 for (i = 0; i+1 < size; i+=2)\n241 printf(\"%d \", bytes[i + 1] + bytes[i] * 265);\n242 break;\n243 case HEX:\n244 for (i = 0; i < size; i++){\n245 printf(\"%02X \", bytes[i]);\n246 }\n247 break;\n248 default:\n249 break;\n250 }\n251 printf(\"]\\n\");\n252 }\n253\n254 /* this function will not increase the pointer */\n255 void print_bytes_noInc(char* text, void *object, size_t size, enum FORMAT f) {\n256 void* obj = object; //copying the data, and passing\n257 print_bytes(text, obj, size, f);\n258 }\n79\nB Appendix: Tables\nB.1 Protocol Types of <netinet/in.h>\nConstant Description\nIPPROTO_IP Dummy protocol.\nIPPROTO_HOPOPTS IPv6 Hop-by-Hop options.\nIPPROTO_ICMP Internet Control Message Protocol.\nIPPROTO_IGMP Internet Group Management Protocol.\nIPPROTO_IPIP IPIP tunnels (older KA9Q tunnels use 94).\nIPPROTO_TCP Transmission Control Protocol.\nIPPROTO_EGP Exterior Gateway Protocol.\nIPPROTO_PUP PUP protocol.\nIPPROTO_UDP User Datagram Protocol.\nIPPROTO_IDP XNS IDP protocol.\nIPPROTO_TP SO Transport Protocol Class 4.\nIPPROTO_IPV6 IPv6 header.\nIPPROTO_ROUTING IPv6 routing header.\nIPPROTO_FRAGMENT IPv6 fragmentation header.\nIPPROTO_RSVP Reservation Protocol.\nIPPROTO_GRE General Routing Encapsulation.\nIPPROTO_ESP Encapsulating security payload.\nIPPROTO_AH Authentication header.\nIPPROTO_ICMPV6 ICMPv6.\nIPPROTO_NONE IPv6 no next header.\nIPPROTO_DSTOPTS IPv6 destination options.\nIPPROTO_MTP Multicast Transport Protocol.\nIPPROTO_ENCAP Encapsulation Header.\nIPPROTO_PIM Protocol Independent Multicast.\nIPPROTO_COMP Compression Header Protocol.\nIPPROTO_SCTP Stream Control Transmission Protocol.\nIPPROTO_RAW Raw IP packets.\nIPPROTO_MAX No description.\nTable 47: Protocol Types defined in <netinet/in.h> [8]\n80\nB.2 Linux Protocol Types defined in linux if_ether.h\nFlag Description\nETH_P_LOOP Ethernet Loopback packet\nETH_P_PUP Xerox PUP packet\nETH_P_PUPAT Xerox PUP Addr Trans packet\nETH_P_IP Internet Protocol packet\nETH_P_X25 CCITT X.25\nETH_P_ARP Address Resolution packet\nETH_P_BPQ G8BPQ AX.25 Ethernet Packet [ not officially registered ]\nETH_P_IEEEPUP Xerox IEEE802.3 PUP packet\nETH_P_IEEEPUPAT Xerox IEEE802.3 PUP Address Transport packet\nETH_P_DEC DEC Assigned protocol\nETH_P_DNA_DL DEC DNA Dump/Load\nETH_P_DNA_RC DEC DNA Remote Console\nETH_P_DNA_RT DEC DNA Routing\nETH_P_LAT DEC LAT\nETH_P_DIAG DEC Diagnostics\nETH_P_CUST DEC Customer use\nETH_P_SCA DEC Systems Communications Architecture\nETH_P_RARP Reverse Address Resolution packet\nETH_P_ATALK Appletalk DDP\nETH_P_AARP Appletalk AARP\nETH_P_8021Q 802.1Q VLAN Extended Header\nETH_P_IPX IPX over DIX\nETH_P_IPV6 IPv6 over bluebook\nETH_P_WCCP Web-cache coordination protocol\nETH_P_PPP_DISC PPPoE discovery messages\nETH_P_PPP_SES PPPoE session messages\nETH_P_MPLS_UC MPLS Unicast traffic\nETH_P_MPLS_MC MPLS Multicast traffic\nETH_P_ATMMPOA MultiProtocol Over ATM\nETH_P_ATMFATE Frame-based ATM Transport over Ethernet\nETH_P_AOE ATA over Ethernet\nETH_P_802_3 Dummy type for 802.3 frames\nETH_P_AX25 Dummy protocol id for AX.25\nETH_P_ALL Every packet\nETH_P_802_2 802.2 frames\nETH_P_SNAP Internal only\nETH_P_DDCMP DEC DDCMP: Internal only\nETH_P_WAN_PPP Dummy type for WAN PPP frames\nETH_P_PPP_MP Dummy type for PPP MP frames\nETH_P_LOCALTALK Localtalk pseudo type\nETH_P_PPPTALK Dummy type for Atalk over PPP\nETH_P_TR_802_2 802.2 frames\nETH_P_MOBITEX Mobitex\nETH_P_CONTROL Card specific control frames\nETH_P_IRDA Linux-IrDA\nETH_P_ECONET Acorn Econet\nETH_P_HDLC HDLC frames\nETH_P_ARCNET ArcNet\nTable 48: Linux Protocol Types defined in\n<linux/if_ether.h>\n81\nB.3 Socket level options for setsocketopt()\nFlag Description\nSO_ACCEPTCONN Indicates whether or not this socket has been marked to accept connections.\nSO_BINDTODEVICE Bind this socket to a particular device like \u2018eth0\u2018.\nSO_BROADCAST Set or get the broadcast flag.\nSO_BSDCOMPAT Enable BSD bug-to-bug compatibility. If enabled ICMP errors received for a UDP socket\nwill not be passed to the user program.\nSO_DEBUG Enablesocketdebugging. OnlyallowedforprocesseswiththeCAP_NET_ADMINcapability\nor an effective user ID of 0.\nSO_DONTROUTE Don\u2019t send via a gateway, only send to directly connected hosts. The same effect can be\nachieved by setting the MSG_DONTROUTE flag on a socket send() operation. Expects an\ninteger boolean flag.\nSO_KEEPALIVE Enable sending of keep-alive messages on connection-oriented sockets. Expects an integer\nBoolean flag.\nSO_LINGER When enabled, a close() or shutdown() will not return until all queued messages for the\nsocket have been successfully sent or the linger timeout has been reached.\nSO_MARK Set the mark for each packet sent through this socket.\nSO_OOBINLINE If this option is enabled, out-of-band data is directly placed into the receive data stream.\nSO_PASSCRED Enable or disable the receiving of the SCM_CREDENTIALS control message\nSO_PRIORITY Set the protocol-defined priority for all packets to be sent on this socket. Linux uses this\nvalue to order the networking queues. Setting a priority outside the range 0 to 6 requires\nthe CAP_NET_ADMIN capability.\nSO_RCVBUF Sets or gets the maximum socket receive buffer in bytes. The kernel doubles this value.\nThe minimum (doubled) value for this option is 256.\nSO_RCVBUFFORCE Using this socket option, a privileged process can perform the same task as SO_RCVBUF,\nbut the rmem_max limit can be overridden.\nSO_RCVLOWAT Specifytheminimumnumberofbytesinthebufferuntilthesocketlayerwillpassthedata\nto the user on receiving.\nSO_SNDLOWAT Specifytheminimumnumberofbytesinthebufferuntilthesocketlayerwillpassthedata\nto the user on receiving.\nSO_RCVTIMEO Specifythereceivingorsendingtimeoutsuntilreportinganerror. Theargumentisastruct\ntimeval.\nSO_SNDTIMEO Specifythereceivingorsendingtimeoutsuntilreportinganerror. Theargumentisastruct\ntimeval.\nSO_REUSEADDR Indicatesthattherulesusedinvalidatingaddressessuppliedinabind()callshouldallow\nreuse of local addresses.\nSO_SNDBUF Sets or gets the maximum socket send buffer in bytes. The kernel doubles this value when\nit is set.\nSO_SNDBUFFORCE Privileged process can perform the same task as SO_SNDBUF, but the wmem_max limit\ncan be overridden.\nSO_TIMESTAMP Enable or disable the receiving of the SO_TIMESTAMP control message.\nTable 49: Socket level options for setsockopt() as defined in\n<errno.h> [8]\n82\nB.4 IP level options for setsockopt()\nFlag Description\nIP_ADD_MEMBERSHIP Join a multicast group. Argument is an ip_mreqn structure.\nIP_ADD_SOURCE_MEMBERSHIP Joinamulticastgroupandallowreceivingdataonlyfromaspecifiedsource.\nIP_BLOCK_SOURCE Stop receiving multicast data from a specific source in a given group.\nIP_DROP_MEMBERSHIP Leave a multicast group.\nIP_DROP_SOURCE_MEMBERSHIP Leave a source-specific group-that.\nIP_FREEBIND If enabled, this boolean option allows binding to an IP address that is non-\nlocal/does not exist.\nIP_HDRINCL If enabled, the user supplies an IP header in front of the user data. Only\nvalid for SOCK_RAW sockets.\nIP_MSFILTER This option provides access to the advanced full-state filtering API.\nIP_MTU_DISCOVER Set or receive the Path MTU Discovery setting for a socket.\nIP_MULTICAST_IF Set the local device for a multicast socket.\nIP_MULTICAST_LOOP Setorreadanargumentthatdeterminesifmulticastpacketsshouldbelooped\nback to the local sockets.\nIP_MULTICAST_TTL Setorreadthetime-to-livevalueofoutgoingmulticastpacketsforthissocket.\nIP_NODEFRAG If enabled (nonzero), the reassembly of outgoing packets is disabled in the\nnetfilter layer.\nIP_OPTIONS Set or get the IP options to be sent with every packet from this socket.\nIP_PKTINFO PassanIP_PKTINFOancillarymessagethatsuppliesinformationaboutthe\nincoming packet.\nIP_RECVERR Enable extended reliable error message passing. On a datagram socket, all\ngenerated errors are stored in a per-socket error queue.\nIP_RECVTOS If enabled the IP_TOS ancillary message is passed with incoming packets.\nIP_RECVTTL If set, pass a IP_TTL control message with the received packets TTL. Not\nsupported for SOCK_STREAM sockets.\nIP_RETOPTS IdenticaltoIP_RECVOPTS,butreturnsrawunprocessedoptionswithtimes-\ntamp and route record options not filled in for this hop.\nIP_ROUTER_ALERT Pass all to-be forwarded packets with the IP Router Alert option set to this\nsocket. Only valid for raw sockets.\nIP_TOS Set or get the TOS field that is sent with every IP packet originating from\nthis socket.\nIP_TRANSPARENT Setting this boolean option enables transparent proxying on this socket.\nIP_TTL Setorgetthecurrenttime-to-livefieldthatisusedineverypacketsentfrom\nthis socket.\nIP_UNBLOCK_SOURCE Unblock previously blocked multicast source.\nTable 50: IP level options for setsockopt() as defined in\n<errno.h> [8]\n83\nB.5 Errno flags for connect()\nFlag Description\nEACCES For UNIX domain sockets, which are identified by path-name: Write permission is denied on\nthe socket file, or search permission is denied for one of the directories in the path prefix.\nEACCES The user tried to connect to a broadcast address without having the socket broadcast flag\nenabled or the connection request failed because of a local firewall rule.\nEPERM The user tried to connect to a broadcast address without having the socket broadcast flag\nenabled or the connection request failed because of a local firewall rule.\nEADDRINUSE Local address is already in use.\nEAFNOSUPPORT The passed address didn\u2019t have the correct address family in its source address family field.\nEAGAIN No more free local ports or insufficient entries in the routing cache.\nEALREADY The socket is non-blocking and a previous connection attempt has not yet been completed.\nEBADF The file descriptor is not a valid index in the descriptor table.\nECONNREFUSED No-one listening on the remote address.\nEFAULT The socket structure address is outside the user\u2019s address space.\nEINPROGRESS The socket is non-blocking and the connection cannot be completed immediately.\nEINTR The system call was interrupted by a signal that was caught.\nEISCONN The socket is already connected.\nENETUNREACH Network is unreachable.\nENOTSOCK The file descriptor is not associated with a socket.\nETIMEDOUT Timeout while attempting connection.\nTable 51: Errno flags for connect() as defined in <errno.h>\n[8]\n84\nB.6 ioctl() flags defined in bpf.h\nConstant Description\nBIOCGBLEN (u_int) Returns the required buffer length for reads on bpf files.\nBIOCSBLEN (u_int) Sets the buffer length for reads on bpf files.\nBIOCGDLT (u_int) Returns the type of the data link layer underlying the attached interface.\nBIOCPROMISC (u_int) Forces the interface into promiscuous mode.\nBIOCFLUSH (u_int) Flushes the bufferof incoming packets, and resets the statistics that are returned\nby BIOCGSTATS.\nBIOCGETIF (struct ifreq) Returns the name of the hardware interface that the file is listening on.\nBIOCSETIF (struct ifreq) Sets the hardware interface associate with the file.\nBIOCGRTIMEOUT (struct timeval) Set or get the read timeout parameter.\nBIOCGSTATS (struct bpf_stat) Returns packet statistics.\nBIOCIMMEDIATE (u_int)Enableordisableimmediatemode,basedonthetruthvalueoftheargument. When\nimmediate mode is enabled, reads return immediately upon packet reception. Otherwise,\na read will block untileither the kernel buffer becomes full or a timeout occurs.\nBIOCSETFNR (struct bpf_program) Sets the read filter program used bythe kernel to discard uninter-\nesting packets.\nBIOCSETWF (structbpf_program)Setsthewritefilterprogramusedbythekerneltocontrolwhattype\nof packets can be written to the interface.\nBIOCVERSION (struct bpf_version) Returns the major and minor version numbers of the filter language\ncurrently recognized by the kernel.\nBIOCGHDRCMPLT (u_int)Setorgetthestatusoftheheadercompleteflag. Settozeroifthelinklevelsource\naddress should be filled in automatically by the interface output routine.\nBIOCGDIRECTION (u_int) Set or get the setting determining whether incoming, outgoing, or all packets on\nthe interface should be returned by BPF ( BPF_D_IN = only incoming, BPF_D_INOUT\n= packets originating locally and remotely, BPF_D_OUT = only outgoing packets).\nBIOCGTSTAMP (u_int)SetorgetformatandresolutionofthetimestampsreturnedbyBPF.SeeManpage\nfor further details.\nBIOCFEEDBACK (u_int) Set packet feedback mode. This allows injected packets to be fed back as input to\nthe interface when output via the interface is successful.\nBIOCLOCK Set the locked flag on the bpf descriptor. This prevents the execution of ioctl commands\nwhich could change the underlying operating parameters of the device.\nBIOCSETBUFMODE (u_int) Get or set the current bpf buffering mode.\nBIOCSETZBUF (struct bpf_zbuf) Set the current zero-copy buffer locations.\nBIOCGETZMAX (size_t) Get the largest individual zero-copy buffer size allowed.\nBIOCROTZBUF Force ownership of the next buffer to be assigned to userspace, if any data present in the\nbuffer.\nTable 52: ioctl() flags defined in <bpf.h> [2]\n85\n",
  "context": "Telecooperation Report No. TR\u00ad19,\nThe Technical Reports Series of the TK Research Division, TU Darmstadt\nISSN 1864\u00ad0516",
  "source_file": "resources\\Year 3\\Socket Programming\\raw socket 02.pdf",
  "line_numbers": [
    10,
    3397
  ]
}
{
  "title": "howto-isolating-extensions",
  "language": "cpp",
  "topics": [
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "3.1 ManagingGlobalState .",
  "code": "3.4 ModuleStateAccessfromFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n4 HeapTypes 4\n4.1 ChangingStaticTypestoHeapTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n4.2 DefiningHeapTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n4.3 Garbage-CollectionProtocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n4.4 ModuleStateAccessfromClasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n4.5 ModuleStateAccessfromRegularMethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n4.6 ModuleStateAccessfromSlotMethods,GettersandSetters . . . . . . . . . . . . . . . . . . . . . 8\n4.7 LifetimeoftheModuleState . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n5 OpenIssues 9\n5.1 Per-ClassScope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n5.2 LosslessConversiontoHeapTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nAbstract\nTraditionally,statebelongingtoPythonextensionmoduleswaskeptinCstaticvariables,whichhaveprocess-\nwide scope. This document describes problems of such per-process state and shows a safer way: per-module\nstate.\nThedocumentalsodescribeshowtoswitchtoper-modulestatewherepossible. Thistransitioninvolvesallocating\nspace for that state, potentially switching from static types to heap types, and\u2014perhaps most importantly\u2014\naccessingper-modulestatefromcode.\n1\n1 Who should read this\nThis guide is written for maintainers of C-API extensions who would like to make that extension safer to use in\napplicationswherePythonitselfisusedasalibrary.\n2 Background\nAninterpreteristhecontextinwhichPythoncoderuns. Itcontainsconfiguration(e.g. theimportpath)andruntime\nstate(e.g. thesetofimportedmodules).\nPython supports running multiple interpreters in one process. There are two cases to think about\u2014users may run\ninterpreters:\n\u2022 insequence,withseveralPy_InitializeEx()/Py_FinalizeEx()cycles,and\n\u2022 inparallel,managing\u201csub-interpreters\u201dusingPy_NewInterpreter()/Py_EndInterpreter().\nBoth cases (and combinations of them) would be most useful when embedding Python within a library. Libraries\ngenerallyshouldn\u2019tmakeassumptionsabouttheapplicationthatusesthem,whichincludeassumingaprocess-wide\n\u201cmainPythoninterpreter\u201d.\nHistorically,Pythonextensionmodulesdon\u2019thandlethisusecasewell. Manyextensionmodules(andevensomestdlib\nmodules)useper-processglobalstate,becauseCstaticvariablesareextremelyeasytouse. Thus,datathatshould\nbespecifictoaninterpreterendsupbeingsharedbetweeninterpreters. Unlesstheextensiondeveloperiscareful,it\nisveryeasytointroduceedgecasesthatleadtocrasheswhenamoduleisloadedinmorethanoneinterpreterinthe\nsameprocess.\nUnfortunately,per-interpreterstateisnoteasytoachieve. Extensionauthorstendtonotkeepmultipleinterpretersin\nmindwhendeveloping,anditiscurrentlycumbersometotestthebehavior.\n2.1 Enter Per-Module State\nInstead of focusing on per-interpreter state, Python\u2019s C API is evolving to better support the more granular per-\nmodulestate. ThismeansthatC-leveldatashouldbeattachedtoamoduleobject. Eachinterpretercreatesitsown\nmoduleobject,keepingthedataseparate. Fortestingtheisolation,multiplemoduleobjectscorrespondingtoasingle\nextensioncanevenbeloadedinasingleinterpreter.\nPer-module state provides an easy way to think about lifetime and resource ownership: the extension module will\ninitializewhenamoduleobjectiscreated,andcleanupwhenit\u2019sfreed. Inthisregard,amoduleisjustlikeanyother\nPyObject*;thereareno\u201coninterpretershutdown\u201dhookstothink\u2014orforget\u2014about.\nNotethatthereareusecasesfordifferentkindsof\u201cglobals\u201d: per-process,per-interpreter,per-threadorper-taskstate.\nWithper-modulestateasthedefault,thesearestillpossible,butyoushouldtreatthemasexceptionalcases: ifyou\nneedthem,youshouldgivethemadditionalcareandtesting. (Notethatthisguidedoesnotcoverthem.)\n2.2 Isolated Module Objects\nThekeypointtokeepinmindwhendevelopinganextensionmoduleisthatseveralmoduleobjectscanbecreated\nfromasinglesharedlibrary. Forexample:\n>>> import sys\n>>> import binascii\n>>> old_binascii = binascii\n>>> del sys.modules['binascii']\n>>> import binascii # create a new module object\n>>> old_binascii == binascii\nFalse\nAsaruleofthumb,thetwomodulesshouldbecompletelyindependent. Allobjectsandstatespecifictothemodule\nshould be encapsulated within the module object, not shared with other module objects, and cleaned up when the\nmoduleobjectisdeallocated. Sincethisjustisaruleofthumb,exceptionsarepossible(seeManagingGlobalState),\nbuttheywillneedmorethoughtandattentiontoedgecases.\n2\nWhilesomemodulescoulddowithlessstringentrestrictions,isolatedmodulesmakeiteasiertosetclearexpectations\nandguidelinesthatworkacrossavarietyofusecases.\n2.3 Surprising Edge Cases\nNote that isolated modules do create some surprising edge cases. Most notably, each module object will typically\nnot share its classes and exceptions with other similar modules. Continuing from the example above, note that\nold_binascii.Error and binascii.Error are separate objects. In the following code, the exception is not\ncaught:\n>>> old_binascii.Error == binascii.Error\nFalse\n>>> try:\n... old_binascii.unhexlify(b'qwertyuiop')\n... except binascii.Error:\n... print('boo')\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nbinascii.Error: Non-hexadecimal digit found\nThisisexpected. Noticethatpure-Pythonmodulesbehavethesameway: itisapartofhowPythonworks.\nThe goal is to make extension modules safe at the C level, not to make hacks behave intuitively. Mutating sys.\nmodules\u201cmanually\u201dcountsasahack.\n3 Making Modules Safe with Multiple Interpreters\n3.1 Managing Global State\nSometimes, the state associated with a Python module is not specific to that module, but to the entire process (or\nsomethingelse\u201cmoreglobal\u201dthanamodule). Forexample:\n\u2022 Thereadlinemodulemanagestheterminal.\n\u2022 Amodulerunningonacircuitboardwantstocontroltheon-boardLED.\nInthesecases,thePythonmoduleshouldprovideaccesstotheglobalstate,ratherthanownit. Ifpossible,writethe\nmodulesothatmultiplecopiesofitcanaccessthestateindependently(alongwithotherlibraries,whetherforPython\norotherlanguages). Ifthatisnotpossible,considerexplicitlocking.\nIfitisnecessarytouseprocess-globalstate,thesimplestwaytoavoidissueswithmultipleinterpretersistoexplicitly\npreventamodulefrombeingloadedmorethanonceperprocess\u2014seeOpt-Out: LimitingtoOneModuleObjectper\nProcess.\n3.2 Managing Per-Module State\nTo use per-module state, use multi-phase extension module initialization. This signals that your module supports\nmultipleinterpreterscorrectly.\nSetPyModuleDef.m_sizetoapositivenumbertorequestthatmanybytesofstoragelocaltothemodule. Usually,\nthis will be set to the size of some module-specific struct, which can store all of the module\u2019s C-level state. In\nparticular,itiswhereyoushouldputpointerstoclasses(includingexceptions,butexcludingstatictypes)andsettings\n(e.g. csv\u2019sfield_size_limit)whichtheCcodeneedstofunction.\n(cid:174) Note\nAnother option is to store state in the module\u2019s __dict__, but you must avoid crashing when users modify\n__dict__fromPythoncode. Thisusuallymeanserror-andtype-checkingattheClevel,whichiseasytoget\nwrongandhardtotestsufficiently.\n3\nHowever,ifmodulestateisnotneededinCcode,storingitin__dict__onlyisagoodidea.\nIfthemodulestateincludesPyObject pointers, themoduleobjectmustholdreferencesto thoseobjectsandim-\nplementthemodule-levelhooksm_traverse,m_clearandm_free. Theseworkliketp_traverse,tp_clear\nandtp_freeofaclass. Addingthemwillrequiresomeworkandmakethecodelonger;thisisthepriceformodules\nwhichcanbeunloadedcleanly.\nAn example of a module with per-module state is currently available as xxlimited; example module initialization\nshownatthebottomofthefile.\n3.3 Opt-Out: Limiting to One Module Object per Process\nAnon-negativePyModuleDef.m_sizesignalsthatamodulesupportsmultipleinterpreterscorrectly. Ifthisisnot\nyetthecaseforyourmodule,youcanexplicitlymakeyourmoduleloadableonlyonceperprocess. Forexample:\nstatic int loaded = 0;\nstatic int\nexec_module(PyObject* module)\n{\nif (loaded) {\nPyErr_SetString(PyExc_ImportError,\n\"cannot load module more than once per process\");\nreturn -1;\n}\nloaded = 1;\n// ... rest of initialization\n}\n3.4 Module State Access from Functions\nAccessing the state from module-level functions is straightforward. Functions get the module object as their first\nargument;forextractingthestate,youcanusePyModule_GetState:\nstatic PyObject *\nfunc(PyObject *module, PyObject *args)\n{\nmy_struct *state = (my_struct*)PyModule_GetState(module);\nif (state == NULL) {\nreturn NULL;\n}\n// ... rest of logic\n}\n(cid:174) Note\nPyModule_GetState may return NULL without setting an exception if there is no module state, i.e.\nPyModuleDef.m_size was zero. In your own module, you\u2019re in control of m_size, so this is easy to pre-\nvent.\n4 Heap Types\nTraditionally,typesdefinedinCcodearestatic;thatis,static PyTypeObjectstructuresdefineddirectlyincode\nandinitializedusingPyType_Ready().\n4\nSuchtypesarenecessarilysharedacrosstheprocess. Sharingthembetweenmoduleobjectsrequirespayingattention\nto any state they own or access. To limit the possible issues, static types are immutable at the Python level: for\nexample,youcan\u2019tsetstr.myattribute = 123.\nCPythonimplementationdetail: Sharingtrulyimmutableobjectsbetweeninterpretersisfine,aslongastheydon\u2019t\nprovideaccesstomutableobjects. However,inCPython,everyPythonobjecthasamutableimplementationdetail:\nthe reference count. Changes to the refcount are guarded by the GIL. Thus, code that shares any Python objects\nacrossinterpretersimplicitlydependsonCPython\u2019scurrent,process-wideGIL.\nBecausetheyareimmutableandprocess-global, statictypescannotaccess\u201ctheir\u201d modulestate. If anymethodof\nsuch a type requires access to module state, the type must be converted to a heap-allocated type, or heap type for\nshort. ThesecorrespondmorecloselytoclassescreatedbyPython\u2019sclassstatement.\nFornewmodules,usingheaptypesbydefaultisagoodruleofthumb.\n4.1 Changing Static Types to Heap Types\nStatictypescanbeconvertedtoheaptypes,butnotethattheheaptypeAPIwasnotdesignedfor\u201clossless\u201dconversion\nfrom static types\u2014that is, creating a type that works exactly like a given static type. So, when rewriting the class\ndefinitioninanewAPI,youarelikelytounintentionallychangeafewdetails(e.g. pickleabilityorinheritedslots).\nAlwaystestthedetailsthatareimportanttoyou.\nWatchoutforthefollowingtwopointsinparticular(butnotethatthisisnotacomprehensivelist):\n\u2022 Unlikestatictypes,heaptypeobjectsaremutablebydefault. UsethePy_TPFLAGS_IMMUTABLETYPEflagto\npreventmutability.\n\u2022 Heaptypesinherittp_newbydefault,soitmaybecomepossibletoinstantiatethemfromPythoncode. You\ncanpreventthiswiththePy_TPFLAGS_DISALLOW_INSTANTIATIONflag.\n4.2 Defining Heap Types\nHeaptypescanbecreatedbyfillingaPyType_Specstructure, adescriptionor\u201cblueprint\u201dofaclass, andcalling\nPyType_FromModuleAndSpec()toconstructanewclassobject.\n(cid:174) Note\nOtherfunctions,likePyType_FromSpec(),canalsocreateheaptypes,butPyType_FromModuleAndSpec()\nassociatesthemodulewiththeclass,allowingaccesstothemodulestatefrommethods.\nTheclassshouldgenerallybestoredinboththemodulestate(forsafeaccessfromC)andthemodule\u2019s__dict__\n(foraccessfromPythoncode).\n4.3 Garbage-Collection Protocol\nInstancesofheaptypesholdareferencetotheirtype. Thisensuresthatthetypeisn\u2019tdestroyedbeforeallitsinstances\nare,butmayresultinreferencecyclesthatneedtobebrokenbythegarbagecollector.\nToavoidmemoryleaks,instancesofheaptypesmustimplementthegarbagecollectionprotocol. Thatis,heaptypes\nshould:\n\u2022 HavethePy_TPFLAGS_HAVE_GCflag.\n\u2022 Define a traverse function using Py_tp_traverse, which visits the type (e.g. using\nPy_VISIT(Py_TYPE(self))).\nPleaserefertothedocumentationofPy_TPFLAGS_HAVE_GCandtp_traverseforadditionalconsiderations.\nThe API for defining heap types grew organically, leaving it somewhat awkward to use in its current state. The\nfollowingsectionswillguideyouthroughcommonissues.\n5\ntp_traverseinPython3.8andlower\nTherequirementtovisitthetypefromtp_traversewasaddedinPython3.9. IfyousupportPython3.8andlower,\nthetraversefunctionmustnotvisitthetype,soitmustbemorecomplicated:\nstatic int my_traverse(PyObject *self, visitproc visit, void *arg)\n{\nif (Py_Version >= 0x03090000) {\nPy_VISIT(Py_TYPE(self));\n}\nreturn 0;\n}\nUnfortunately,Py_VersionwasonlyaddedinPython3.11. Asareplacement,use:\n\u2022 PY_VERSION_HEX,ifnotusingthestableABI,or\n\u2022 sys.version_info(viaPySys_GetObject()andPyArg_ParseTuple()).\nDelegatingtp_traverse\nIf your traverse function delegates to the tp_traverse of its base class (or another type), ensure that\nPy_TYPE(self)isvisitedonlyonce. Notethatonlyheaptypeareexpectedtovisitthetypeintp_traverse.\nForexample,ifyourtraversefunctionincludes:\nbase->tp_traverse(self, visit, arg)\n\u2026andbasemaybeastatictype,thenitshouldalsoinclude:\nif (base->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n// a heap type's tp_traverse already visited Py_TYPE(self)\n} else {\nif (Py_Version >= 0x03090000) {\nPy_VISIT(Py_TYPE(self));\n}\n}\nItisnotnecessarytohandlethetype\u2019sreferencecountintp_newandtp_clear.\nDefiningtp_dealloc\nIfyourtypehasacustomtp_deallocfunction,itneedsto:\n\u2022 callPyObject_GC_UnTrack()beforeanyfieldsareinvalidated,and\n\u2022 decrementthereferencecountofthetype.\nTo keep the type valid while tp_free is called, the type\u2019s refcount needs to be decremented after the instance is\ndeallocated. Forexample:\nstatic void my_dealloc(PyObject *self)\n{\nPyObject_GC_UnTrack(self);\n...\nPyTypeObject *type = Py_TYPE(self);\ntype->tp_free(self);\nPy_DECREF(type);\n}\nThedefaulttp_deallocfunctiondoesthis,soifyourtypedoesnot overridetp_deallocyoudon\u2019tneedtoadd\nit.\n6\nNotoverridingtp_free\nThetp_freeslotofaheaptypemustbesettoPyObject_GC_Del(). Thisisthedefault;donotoverrideit.\nAvoidingPyObject_New\nGC-trackedobjectsneedtobeallocatedusingGC-awarefunctions.\nIfyouuseusePyObject_New()orPyObject_NewVar():\n\u2022 Get and call type\u2019s tp_alloc slot, if possible. That is, replace TYPE *o = PyObject_New(TYPE,\ntypeobj)with:\nTYPE *o = typeobj->tp_alloc(typeobj, 0);\nReplaceo = PyObject_NewVar(TYPE, typeobj, size)withthesame,butusesizeinsteadofthe0.\n\u2022 If the above is not possible (e.g. inside a custom tp_alloc), call PyObject_GC_New() or\nPyObject_GC_NewVar():\nTYPE *o = PyObject_GC_New(TYPE, typeobj);\nTYPE *o = PyObject_GC_NewVar(TYPE, typeobj, size);\n4.4 Module State Access from Classes\nIfyouhaveatypeobjectdefinedwithPyType_FromModuleAndSpec(),youcancallPyType_GetModule()to\ngettheassociatedmodule,andthenPyModule_GetState()togetthemodule\u2019sstate.\nTo save a some tedious error-handling boilerplate code, you can combine these two steps with\nPyType_GetModuleState(),resultingin:\nmy_struct *state = (my_struct*)PyType_GetModuleState(type);\nif (state == NULL) {\nreturn NULL;\n}\n4.5 Module State Access from Regular Methods\nAccessingthemodule-levelstatefrommethodsofaclassissomewhatmorecomplicated,butispossiblethanksto\nAPIintroducedinPython3.9. Togetthestate,youneedtofirstgetthedefiningclass,andthengetthemodulestate\nfromit.\nThelargestroadblockisgettingtheclassamethodwasdefinedin, orthatmethod\u2019s\u201cdefiningclass\u201dforshort. The\ndefiningclasscanhaveareferencetothemoduleitispartof.\nDo not confuse the defining class with Py_TYPE(self). If the method is called on a subclass of your type,\nPy_TYPE(self)willrefertothatsubclass,whichmaybedefinedindifferentmodulethanyours.\n(cid:174) Note\nThe following Python code can illustrate the concept. Base.get_defining_class returns Base even if\ntype(self) == Sub:\nclass Base:\ndef get_type_of_self(self):\nreturn type(self)\ndef get_defining_class(self):\nreturn __class__\nclass Sub(Base):\npass\n7\nFor a method to get its \u201cdefining class\u201d, it must use the METH_METHOD | METH_FASTCALL |\nMETH_KEYWORDScalling conventionandthecorrespondingPyCMethodsignature:\nPyObject *PyCMethod(\nPyObject *self, // object the method was called on\nPyTypeObject *defining_class, // defining class\nPyObject *const *args, // C array of arguments\nPy_ssize_t nargs, // length of \"args\"\nPyObject *kwnames) // NULL, or dict of keyword arguments\nOnceyouhavethedefiningclass,callPyType_GetModuleState()togetthestateofitsassociatedmodule.\nForexample:\nstatic PyObject *\nexample_method(PyObject *self,\nPyTypeObject *defining_class,\nPyObject *const *args,\nPy_ssize_t nargs,\nPyObject *kwnames)\n{\nmy_struct *state = (my_struct*)PyType_GetModuleState(defining_class);\nif (state == NULL) {\nreturn NULL;\n}\n... // rest of logic\n}\nPyDoc_STRVAR(example_method_doc, \"...\");\nstatic PyMethodDef my_methods[] = {\n{\"example_method\",\n(PyCFunction)(void(*)(void))example_method,\nMETH_METHOD|METH_FASTCALL|METH_KEYWORDS,\nexample_method_doc}\n{NULL},\n}\n4.6 Module State Access from Slot Methods, Getters and Setters\n(cid:174) Note\nThisisnewinPython3.11.\nSlot methods\u2014the fast C equivalents for special methods, such as nb_add for __add__ or tp_new for\ninitialization\u2014have a very simple API that doesn\u2019t allow passing in the defining class, unlike with PyCMethod.\nThesamegoesforgettersandsettersdefinedwithPyGetSetDef.\nToaccessthemodulestateinthesecases,usethePyType_GetModuleByDef()function,andpassinthemodule\ndefinition. Onceyouhavethemodule,callPyModule_GetState()togetthestate:\nPyObject *module = PyType_GetModuleByDef(Py_TYPE(self), &module_def);\nmy_struct *state = (my_struct*)PyModule_GetState(module);\nif (state == NULL) {\n(continuesonnextpage)\n8\n(continuedfrompreviouspage)\nreturn NULL;\n}\nPyType_GetModuleByDef() works by searching the method resolution order (i.e. all superclasses) for the first\nsuperclassthathasacorrespondingmodule.\n(cid:174) Note\nIn very exotic cases (inheritance chains spanning multiple modules created from the same definition),\nPyType_GetModuleByDef()mightnotreturnthemoduleofthetruedefiningclass. However,itwillalways\nreturnamodulewiththesamedefinition,ensuringacompatibleCmemorylayout.\n4.7 Lifetime of the Module State\nWhenamoduleobjectisgarbage-collected,itsmodulestateisfreed. Foreachpointerto(apartof)themodulestate,\nyoumustholdareferencetothemoduleobject.\nUsuallythisisnotanissue,becausetypescreatedwithPyType_FromModuleAndSpec(),andtheirinstances,hold\nareferencetothemodule. However,youmustbecarefulinreferencecountingwhenyoureferencemodulestatefrom\notherplaces,suchascallbacksforexternallibraries.\n5 Open Issues\nSeveralissuesaroundper-modulestateandheaptypesarestillopen.\nDiscussionsaboutimprovingthesituationarebestheldonthecapi-sigmailinglist.\n5.1 Per-Class Scope\nIt is currently (as of Python 3.11) not possible to attach state to individual types without relying on CPython im-\nplementationdetails(whichmaychangeinthefuture\u2014perhaps, ironically, toallowapropersolutionforper-class\nscope).\n5.2 Lossless Conversion to Heap Types\nTheheaptypeAPIwasnotdesignedfor\u201clossless\u201dconversionfromstatictypes; thatis, creatingatypethatworks\nexactlylikeagivenstatictype.\n9\n",
  "context": "3.1 ManagingGlobalState . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n3.2 ManagingPer-ModuleState . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n3.3 Opt-Out: LimitingtoOneModuleObjectperProcess . . . . . . . . . . . . . . . . . . . . . . . . 4",
  "source_file": "resources\\Year 3\\Python\\howto-isolating-extensions.pdf",
  "line_numbers": [
    17,
    365
  ]
}
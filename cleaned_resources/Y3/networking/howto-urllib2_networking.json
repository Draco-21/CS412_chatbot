{
  "title": "howto-urllib2",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "\u2022 BasicAuthentication AtutorialonBasicAuthentication,withexamplesinPython.",
  "code": "intheformoftheurlopenfunction. ThisiscapableoffetchingURLsusingavarietyofdifferentprotocols. Italso\noffersaslightlymorecomplexinterfaceforhandlingcommonsituations-likebasicauthentication,cookies,proxies\nandsoon. Theseareprovidedbyobjectscalledhandlersandopeners.\nurllib.request supports fetching URLs for many \u201cURL schemes\u201d (identified by the string before the \":\" in URL -\nforexample\"ftp\"istheURLschemeof\"ftp://python.org/\")usingtheirassociatednetworkprotocols(e.g.\nFTP,HTTP).Thistutorialfocusesonthemostcommoncase,HTTP.\nForstraightforwardsituationsurlopenisveryeasytouse. Butassoonasyouencountererrorsornon-trivialcases\nwhenopeningHTTPURLs,youwillneedsomeunderstandingoftheHyperTextTransferProtocol. Themostcom-\nprehensiveandauthoritativereferencetoHTTPisRFC2616. Thisisatechnicaldocumentandnotintendedtobe\neasytoread. ThisHOWTOaimstoillustrateusingurllib,withenoughdetailaboutHTTPtohelpyouthrough. Itis\nnotintendedtoreplacetheurllib.requestdocs,butissupplementarytothem.\n2 Fetching URLs\nThesimplestwaytouseurllib.requestisasfollows:\nimport urllib.request\nwith urllib.request.urlopen('http://python.org/') as response:\nhtml = response.read()\nIf you wish to retrieve a resource via URL and store it in a temporary location, you can do so via the shutil.\ncopyfileobj()andtempfile.NamedTemporaryFile()functions:\nimport shutil\nimport tempfile\nimport urllib.request\nwith urllib.request.urlopen('http://python.org/') as response:\nwith tempfile.NamedTemporaryFile(delete=False) as tmp_file:\nshutil.copyfileobj(response, tmp_file)\nwith open(tmp_file.name) as html:\npass\nManyusesofurllibwillbethatsimple(notethatinsteadofan\u2018http:\u2019 URLwecouldhaveusedaURLstartingwith\n\u2018ftp:\u2019,\u2018file:\u2019,etc.). However,it\u2019sthepurposeofthistutorialtoexplainthemorecomplicatedcases,concentratingon\nHTTP.\nHTTP is based on requests and responses - the client makes requests and servers send responses. urllib.request\nmirrorsthiswithaRequestobjectwhichrepresentstheHTTPrequestyouaremaking. Initssimplestformyou\ncreateaRequestobjectthatspecifiestheURLyouwanttofetch. CallingurlopenwiththisRequestobjectreturns\naresponseobjectfortheURLrequested. Thisresponseisafile-likeobject,whichmeansyoucanforexamplecall\n.read()ontheresponse:\nimport urllib.request\nreq = urllib.request.Request('http://python.org/')\nwith urllib.request.urlopen(req) as response:\nthe_page = response.read()\nNotethaturllib.requestmakesuseofthesameRequestinterfacetohandleallURLschemes. Forexample,youcan\nmakeanFTPrequestlikeso:\n2\nreq = urllib.request.Request('ftp://example.com/')\nInthecaseofHTTP,therearetwoextrathingsthatRequestobjectsallowyoutodo: First,youcanpassdatatobe\nsenttotheserver. Second,youcanpassextrainformation(\u201cmetadata\u201d)aboutthedataorabouttherequestitself,to\ntheserver-thisinformationissentasHTTP\u201cheaders\u201d. Let\u2019slookateachoftheseinturn.\n2.1 Data\nSometimesyouwanttosenddatatoaURL(oftentheURLwillrefertoaCGI(CommonGatewayInterface)script\norotherwebapplication). WithHTTP,thisisoftendoneusingwhat\u2019sknownasaPOSTrequest. Thisisoftenwhat\nyourbrowserdoeswhenyousubmitaHTMLformthatyoufilledinontheweb. NotallPOSTshavetocomefrom\nforms: youcanuseaPOSTtotransmitarbitrarydatatoyourownapplication. InthecommoncaseofHTMLforms,\nthedataneedstobeencodedinastandardway,andthenpassedtotheRequestobjectasthedataargument. The\nencodingisdoneusingafunctionfromtheurllib.parselibrary.\nimport urllib.parse\nimport urllib.request\nurl = 'http://www.someserver.com/cgi-bin/register.cgi'\nvalues = {'name' : 'Michael Foord',\n'location' : 'Northampton',\n'language' : 'Python' }\ndata = urllib.parse.urlencode(values)\ndata = data.encode('ascii') # data should be bytes\nreq = urllib.request.Request(url, data)\nwith urllib.request.urlopen(req) as response:\nthe_page = response.read()\nNotethatotherencodingsaresometimesrequired(e.g. forfileuploadfromHTMLforms-seeHTMLSpecification,\nFormSubmissionformoredetails).\nIfyoudonotpassthedataargument,urllibusesaGETrequest. OnewayinwhichGETandPOSTrequestsdiffer\nis that POST requests often have \u201cside-effects\u201d: they change the state of the system in some way (for example by\nplacing an order with the website for a hundredweight of tinned spam to be delivered to your door). Though the\nHTTP standard makes it clear that POSTs are intended to always cause side-effects, and GET requests never to\ncause side-effects, nothing prevents a GET request from having side-effects, nor a POST requests from having no\nside-effects. DatacanalsobepassedinanHTTPGETrequestbyencodingitintheURLitself.\nThisisdoneasfollows:\n>>> import urllib.request\n>>> import urllib.parse\n>>> data = {}\n>>> data['name'] = 'Somebody Here'\n>>> data['location'] = 'Northampton'\n>>> data['language'] = 'Python'\n>>> url_values = urllib.parse.urlencode(data)\n>>> print(url_values) # The order may differ from below.\nname=Somebody+Here&language=Python&location=Northampton\n>>> url = 'http://www.example.com/example.cgi'\n>>> full_url = url + '?' + url_values\n>>> data = urllib.request.urlopen(full_url)\nNoticethatthefullURLiscreatedbyaddinga?totheURL,followedbytheencodedvalues.\n3\n2.2 Headers\nWe\u2019lldiscusshereoneparticularHTTPheader,toillustratehowtoaddheaderstoyourHTTPrequest.\nSome websites1 dislike being browsed by programs, or send different versions to different browsers2. By default\nurllib identifies itself as Python-urllib/x.y (where x and y are the major and minor version numbers of the\nPythonrelease,e.g. Python-urllib/2.5),whichmayconfusethesite,orjustplainnotwork. Thewayabrowser\nidentifiesitselfisthroughtheUser-Agentheader3. WhenyoucreateaRequestobjectyoucanpassadictionary\nofheadersin. Thefollowingexamplemakesthesamerequestasabove,butidentifiesitselfasaversionofInternet\nExplorer4.\nimport urllib.parse\nimport urllib.request\nurl = 'http://www.someserver.com/cgi-bin/register.cgi'\nuser_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\nvalues = {'name': 'Michael Foord',\n'location': 'Northampton',\n'language': 'Python' }\nheaders = {'User-Agent': user_agent}\ndata = urllib.parse.urlencode(values)\ndata = data.encode('ascii')\nreq = urllib.request.Request(url, data, headers)\nwith urllib.request.urlopen(req) as response:\nthe_page = response.read()\nTheresponsealsohastwousefulmethods. Seethesectiononinfoandgeturl whichcomesafterwehavealookat\nwhathappenswhenthingsgowrong.\n3 Handling Exceptions\nurlopenraisesURLErrorwhenitcannothandlearesponse(thoughasusualwithPythonAPIs,built-inexceptions\nsuchasValueError,TypeErroretc. mayalsoberaised).\nHTTPErroristhesubclassofURLErrorraisedinthespecificcaseofHTTPURLs.\nTheexceptionclassesareexportedfromtheurllib.errormodule.\n3.1 URLError\nOften,URLErrorisraisedbecausethereisnonetworkconnection(noroutetothespecifiedserver),orthespecified\nserver doesn\u2019t exist. In this case, the exception raised will have a \u2018reason\u2019 attribute, which is a tuple containing an\nerrorcodeandatexterrormessage.\ne.g.\n>>> req = urllib.request.Request('http://www.pretend_server.org')\n>>> try: urllib.request.urlopen(req)\n... except urllib.error.URLError as e:\n... print(e.reason)\n...\n(4, 'getaddrinfo failed')\n1Googleforexample.\n2Browsersniffingisaverybadpracticeforwebsitedesign-buildingsitesusingwebstandardsismuchmoresensible.Unfortunatelyalotof\nsitesstillsenddifferentversionstodifferentbrowsers.\n3TheuseragentforMSIE6is\u2018Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1;SV1;.NETCLR1.1.4322)\u2019\n4FordetailsofmoreHTTPrequestheaders,seeQuickReferencetoHTTPHeaders.\n4\n3.2 HTTPError\nEveryHTTPresponsefromtheservercontainsanumeric\u201cstatuscode\u201d. Sometimesthestatuscodeindicatesthatthe\nserverisunabletofulfiltherequest. Thedefaulthandlerswillhandlesomeoftheseresponsesforyou(forexample,\niftheresponseisa\u201credirection\u201dthatrequeststheclientfetchthedocumentfromadifferentURL,urllibwillhandle\nthat for you). For those it can\u2019t handle, urlopen will raise an HTTPError. Typical errors include \u2018404\u2019 (page not\nfound),\u2018403\u2019(requestforbidden),and\u2018401\u2019(authenticationrequired).\nSeesection10ofRFC2616forareferenceonalltheHTTPerrorcodes.\nTheHTTPErrorinstanceraisedwillhaveaninteger\u2018code\u2019attribute,whichcorrespondstotheerrorsentbytheserver.\nErrorCodes\nBecause the default handlers handle redirects (codes in the 300 range), and codes in the 100\u2013299 range indicate\nsuccess,youwillusuallyonlyseeerrorcodesinthe400\u2013599range.\nhttp.server.BaseHTTPRequestHandler.responses is a useful dictionary of response codes in that shows\nalltheresponsecodesusedbyRFC2616. Thedictionaryisreproducedhereforconvenience\n# Table mapping response codes to messages; entries have the\n# form {code: (shortmessage, longmessage)}.\nresponses = {\n100: ('Continue', 'Request received, please continue'),\n101: ('Switching Protocols',\n'Switching to new protocol; obey Upgrade header'),\n200: ('OK', 'Request fulfilled, document follows'),\n201: ('Created', 'Document created, URL follows'),\n202: ('Accepted',\n'Request accepted, processing continues off-line'),\n203: ('Non-Authoritative Information', 'Request fulfilled from cache'),\n204: ('No Content', 'Request fulfilled, nothing follows'),\n205: ('Reset Content', 'Clear input form for further input.'),\n206: ('Partial Content', 'Partial content follows.'),\n300: ('Multiple Choices',\n'Object has several resources -- see URI list'),\n301: ('Moved Permanently', 'Object moved permanently -- see URI list'),\n302: ('Found', 'Object moved temporarily -- see URI list'),\n303: ('See Other', 'Object moved -- see Method and URL list'),\n304: ('Not Modified',\n'Document has not changed since given time'),\n305: ('Use Proxy',\n'You must use proxy specified in Location to access this '\n'resource.'),\n307: ('Temporary Redirect',\n'Object moved temporarily -- see URI list'),\n400: ('Bad Request',\n'Bad request syntax or unsupported method'),\n401: ('Unauthorized',\n'No permission -- see authorization schemes'),\n402: ('Payment Required',\n'No payment -- see charging schemes'),\n403: ('Forbidden',\n'Request forbidden -- authorization will not help'),\n404: ('Not Found', 'Nothing matches the given URI'),\n405: ('Method Not Allowed',\n'Specified method is invalid for this server.'),\n(continuesonnextpage)\n5\n(continuedfrompreviouspage)\n406: ('Not Acceptable', 'URI not available in preferred format.'),\n407: ('Proxy Authentication Required', 'You must authenticate with '\n'this proxy before proceeding.'),\n408: ('Request Timeout', 'Request timed out; try again later.'),\n409: ('Conflict', 'Request conflict.'),\n410: ('Gone',\n'URI no longer exists and has been permanently removed.'),\n411: ('Length Required', 'Client must specify Content-Length.'),\n412: ('Precondition Failed', 'Precondition in headers is false.'),\n413: ('Request Entity Too Large', 'Entity is too large.'),\n414: ('Request-URI Too Long', 'URI is too long.'),\n415: ('Unsupported Media Type', 'Entity body in unsupported format.'),\n416: ('Requested Range Not Satisfiable',\n'Cannot satisfy request range.'),\n417: ('Expectation Failed',\n'Expect condition could not be satisfied.'),\n500: ('Internal Server Error', 'Server got itself in trouble'),\n501: ('Not Implemented',\n'Server does not support this operation'),\n502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),\n503: ('Service Unavailable',\n'The server cannot process the request due to a high load'),\n504: ('Gateway Timeout',\n'The gateway server did not receive a timely response'),\n505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),\n}\nWhenanerrorisraisedtheserverrespondsbyreturninganHTTPerrorcodeand anerrorpage. Youcanusethe\nHTTPErrorinstanceasaresponseonthepagereturned. Thismeansthataswellasthecodeattribute, italsohas\nread,geturl,andinfo,methodsasreturnedbytheurllib.responsemodule:\n>>> req = urllib.request.Request('http://www.python.org/fish.html')\n>>> try:\n... urllib.request.urlopen(req)\n... except urllib.error.HTTPError as e:\n... print(e.code)\n... print(e.read())\n...\n404\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\\n\\n\\n<html\n...\n<title>Page Not Found</title>\\n\n...\n3.3 Wrapping it Up\nSo if you want to be prepared for HTTPError or URLError there are two basic approaches. I prefer the second\napproach.\nNumber1\nfrom urllib.request import Request, urlopen\nfrom urllib.error import URLError, HTTPError\nreq = Request(someurl)\n(continuesonnextpage)\n6\n(continuedfrompreviouspage)\ntry:\nresponse = urlopen(req)\nexcept HTTPError as e:\nprint('The server couldn\\'t fulfill the request.')\nprint('Error code: ', e.code)\nexcept URLError as e:\nprint('We failed to reach a server.')\nprint('Reason: ', e.reason)\nelse:\n# everything is fine\n(cid:174) Note\nTheexcept HTTPErrormustcomefirst,otherwiseexcept URLErrorwillalsocatchanHTTPError.\nNumber2\nfrom urllib.request import Request, urlopen\nfrom urllib.error import URLError\nreq = Request(someurl)\ntry:\nresponse = urlopen(req)\nexcept URLError as e:\nif hasattr(e, 'reason'):\nprint('We failed to reach a server.')\nprint('Reason: ', e.reason)\nelif hasattr(e, 'code'):\nprint('The server couldn\\'t fulfill the request.')\nprint('Error code: ', e.code)\nelse:\n# everything is fine\n4 info and geturl\nTheresponsereturnedbyurlopen(ortheHTTPErrorinstance)hastwousefulmethodsinfo()andgeturl()and\nisdefinedinthemoduleurllib.response.\n\u2022 geturl-thisreturnstherealURLofthepagefetched. Thisisusefulbecauseurlopen(ortheopenerobject\nused)mayhavefollowedaredirect. TheURLofthepagefetchedmaynotbethesameastheURLrequested.\n\u2022 info-thisreturnsadictionary-likeobjectthatdescribesthepagefetched,particularlytheheaderssentbythe\nserver. Itiscurrentlyanhttp.client.HTTPMessageinstance.\nTypicalheadersinclude\u2018Content-length\u2019,\u2018Content-type\u2019,andsoon. SeetheQuickReferencetoHTTPHeadersfor\nausefullistingofHTTPheaderswithbriefexplanationsoftheirmeaninganduse.\n5 Openers and Handlers\nWhen you fetch a URL you use an opener (an instance of the perhaps confusingly named urllib.request.\nOpenerDirector). Normallywehavebeenusingthedefaultopener-viaurlopen-butyoucancreatecustom\nopeners. Openers use handlers. All the \u201cheavy lifting\u201d is done by the handlers. Each handler knows how to open\nURLsforaparticularURLscheme(http,ftp,etc.),orhowtohandleanaspectofURLopening,forexampleHTTP\nredirectionsorHTTPcookies.\n7\nYou will want to create openers if you want to fetch URLs with specific handlers installed, for example to get an\nopenerthathandlescookies,ortogetanopenerthatdoesnothandleredirections.\nTocreateanopener,instantiateanOpenerDirector,andthencall.add_handler(some_handler_instance)\nrepeatedly.\nAlternatively,youcanusebuild_opener,whichisaconveniencefunctionforcreatingopenerobjectswithasingle\nfunctioncall. build_openeraddsseveralhandlersbydefault,butprovidesaquickwaytoaddmoreand/oroverride\nthedefaulthandlers.\nOther sorts of handlers you might want to can handle proxies, authentication, and other common but slightly spe-\ncialisedsituations.\ninstall_opener can be used to make an opener object the (global) default opener. This means that calls to\nurlopenwillusetheopeneryouhaveinstalled.\nOpenerobjectshavean open method, whichcanbe calleddirectlyto fetchurlsinthesamewayas theurlopen\nfunction: there\u2019snoneedtocallinstall_opener,exceptasaconvenience.\n6 Basic Authentication\nToillustratecreatingandinstallingahandlerwewillusetheHTTPBasicAuthHandler. Foramoredetaileddis-\ncussionofthissubject\u2013includinganexplanationofhowBasicAuthenticationworks-seetheBasicAuthentication\nTutorial.\nWhenauthenticationisrequired,theserversendsaheader(aswellasthe401errorcode)requestingauthentication.\nThis specifies the authentication scheme and a \u2018realm\u2019. The header looks like: WWW-Authenticate: SCHEME\nrealm=\"REALM\".\ne.g.\nWWW-Authenticate: Basic realm=\"cPanel Users\"\nThe client should then retry the request with the appropriate name and password for the realm included as a\nheader in the request. This is \u2018basic authentication\u2019. In order to simplify this process we can create an instance\nofHTTPBasicAuthHandlerandanopenertousethishandler.\nTheHTTPBasicAuthHandlerusesanobjectcalledapasswordmanagertohandlethemappingofURLsandrealms\ntopasswordsandusernames. Ifyouknowwhattherealmis(fromtheauthenticationheadersentbytheserver),then\nyoucanuseaHTTPPasswordMgr. Frequentlyonedoesn\u2019tcarewhattherealmis. Inthatcase,itisconvenienttouse\nHTTPPasswordMgrWithDefaultRealm. ThisallowsyoutospecifyadefaultusernameandpasswordforaURL.\nThiswillbesuppliedintheabsenceofyouprovidinganalternativecombinationforaspecificrealm. Weindicate\nthisbyprovidingNoneastherealmargumenttotheadd_passwordmethod.\nThe top-level URL is the first URL that requires authentication. URLs \u201cdeeper\u201d than the URL you pass to\n.add_password()willalsomatch.\n# create a password manager\npassword_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n# Add the username and password.\n# If we knew the realm, we could use it instead of None.\ntop_level_url = \"http://example.com/foo/\"\npassword_mgr.add_password(None, top_level_url, username, password)\nhandler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n# create \"opener\" (OpenerDirector instance)\nopener = urllib.request.build_opener(handler)\n# use the opener to fetch a URL\n(continuesonnextpage)\n8\n(continuedfrompreviouspage)\nopener.open(a_url)\n# Install the opener.\n# Now all calls to urllib.request.urlopen use our opener.\nurllib.request.install_opener(opener)\n(cid:174) Note\nIntheaboveexampleweonlysuppliedourHTTPBasicAuthHandlertobuild_opener. Bydefaultopeners\nhavethehandlersfornormalsituations\u2013ProxyHandler(ifaproxysettingsuchasanhttp_proxyenvironment\nvariableisset),UnknownHandler,HTTPHandler,HTTPDefaultErrorHandler,HTTPRedirectHandler,\nFTPHandler,FileHandler,DataHandler,HTTPErrorProcessor.\ntop_level_urlisinfacteitherafullURL(includingthe\u2018http:\u2019schemecomponentandthehostnameandoptionally\nthe port number) e.g. \"http://example.com/\" or an \u201cauthority\u201d (i.e. the hostname, optionally including the\nportnumber)e.g. \"example.com\"or\"example.com:8080\"(thelatterexampleincludesaportnumber). The\nauthority,ifpresent,mustNOTcontainthe\u201cuserinfo\u201dcomponent-forexample\"joe:password@example.com\"\nisnotcorrect.\n7 Proxies\nurllibwillauto-detectyourproxysettingsandusethose. ThisisthroughtheProxyHandler,whichispartofthe\nnormalhandlerchainwhenaproxysettingisdetected. Normallythat\u2019sagoodthing,butthereareoccasionswhenit\nmaynotbehelpful5. OnewaytodothisistosetupourownProxyHandler,withnoproxiesdefined. Thisisdone\nusingsimilarstepstosettingupaBasicAuthenticationhandler:\n>>> proxy_support = urllib.request.ProxyHandler({})\n>>> opener = urllib.request.build_opener(proxy_support)\n>>> urllib.request.install_opener(opener)\n(cid:174) Note\nCurrentlyurllib.requestdoesnot supportfetchingofhttpslocationsthroughaproxy. However,thiscan\nbeenabledbyextendingurllib.requestasshownintherecipe6.\n(cid:174) Note\nHTTP_PROXYwillbeignoredifavariableREQUEST_METHODisset;seethedocumentationongetproxies().\n8 Sockets and Layers\nThePythonsupportforfetchingresourcesfromthewebislayered. urllibusesthehttp.clientlibrary,whichin\nturnusesthesocketlibrary.\nAsofPython2.3youcanspecifyhowlongasocketshouldwaitforaresponsebeforetimingout. Thiscanbeuseful\ninapplicationswhichhavetofetchwebpages. Bydefaultthesocketmodulehasnotimeoutandcanhang. Currently,\nthesockettimeoutisnotexposedatthehttp.clientorurllib.requestlevels. However,youcansetthedefaulttimeout\ngloballyforallsocketsusing\n5InmycaseIhavetouseaproxytoaccesstheinternetatwork.IfyouattempttofetchlocalhostURLsthroughthisproxyitblocksthem.IE\nissettousetheproxy,whichurllibpicksupon.Inordertotestscriptswithalocalhostserver,Ihavetopreventurllibfromusingtheproxy.\n6urllibopenerforSSLproxy(CONNECTmethod):ASPNCookbookRecipe.\n9\nimport socket\nimport urllib.request\n# timeout in seconds\ntimeout = 10\nsocket.setdefaulttimeout(timeout)\n# this call to urllib.request.urlopen now uses the default timeout\n# we have set in the socket module\nreq = urllib.request.Request('http://www.voidspace.org.uk')\nresponse = urllib.request.urlopen(req)\n9 Footnotes\nThisdocumentwasreviewedandrevisedbyJohnLee.\n10\nIndex\nR\nRFC\nRFC 2616,2,5\n11\n",
  "context": "\u2022 BasicAuthentication\nAtutorialonBasicAuthentication,withexamplesinPython.\nurllib.requestisaPythonmoduleforfetchingURLs(UniformResourceLocators). Itoffersaverysimpleinterface,",
  "source_file": "resources\\Year 3\\Python\\howto-urllib2.pdf",
  "line_numbers": [
    33,
    413
  ]
}
{
  "title": "howto-ipaddress",
  "language": "cpp",
  "topics": [
    "networking",
    "data_structures",
    "machine_learning",
    "fundamentals"
  ],
  "purpose": "forcetheuseofoneversionortheother.",
  "code": "simplest way to create addresses is to use the ipaddress.ip_address() factory function, which automatically\ndetermineswhethertocreateanIPv4orIPv6addressbasedonthepassedinvalue:\n>>> ipaddress.ip_address('192.0.2.1')\nIPv4Address('192.0.2.1')\n>>> ipaddress.ip_address('2001:DB8::1')\nIPv6Address('2001:db8::1')\nAddresses can also be created directly from integers. Values that will fit within 32 bits are assumed to be IPv4\naddresses:\n>>> ipaddress.ip_address(3221225985)\nIPv4Address('192.0.2.1')\n>>> ipaddress.ip_address(42540766411282592856903984951653826561)\nIPv6Address('2001:db8::1')\nToforcetheuseofIPv4orIPv6addresses,therelevantclassescanbeinvokeddirectly. Thisisparticularlyusefulto\nforcecreationofIPv6addressesforsmallintegers:\n>>> ipaddress.ip_address(1)\nIPv4Address('0.0.0.1')\n>>> ipaddress.IPv4Address(1)\nIPv4Address('0.0.0.1')\n>>> ipaddress.IPv6Address(1)\nIPv6Address('::1')\n1.3 Defining Networks\nHost addresses are usually grouped together into IP networks, so ipaddress provides a way to create, inspect\nand manipulate network definitions. IP network objects are constructed from strings that define the range of host\naddressesthatarepartofthatnetwork. Thesimplestformforthatinformationisa\u201cnetworkaddress/networkprefix\u201d\npair,wheretheprefixdefinesthenumberofleadingbitsthatarecomparedtodeterminewhetherornotanaddress\nispartofthenetworkandthenetworkaddressdefinestheexpectedvalueofthosebits.\nAsforaddresses,afactoryfunctionisprovidedthatdeterminesthecorrectIPversionautomatically:\n>>> ipaddress.ip_network('192.0.2.0/24')\nIPv4Network('192.0.2.0/24')\n>>> ipaddress.ip_network('2001:db8::0/96')\nIPv6Network('2001:db8::/96')\nNetworkobjectscannothaveanyhostbitsset. Thepracticaleffectofthisisthat192.0.2.1/24doesnotdescribe\nanetwork. Suchdefinitionsarereferredtoasinterfaceobjectssincetheip-on-a-networknotationiscommonlyused\ntodescribenetworkinterfacesofacomputeronagivennetworkandaredescribedfurtherinthenextsection.\nBy default, attempting to create a network object with host bits set will result in ValueError being raised. To\nrequestthattheadditionalbitsinsteadbecoercedtozero,theflagstrict=Falsecanbepassedtotheconstructor:\n2\n>>> ipaddress.ip_network('192.0.2.1/24')\nTraceback (most recent call last):\n...\nValueError: 192.0.2.1/24 has host bits set\n>>> ipaddress.ip_network('192.0.2.1/24', strict=False)\nIPv4Network('192.0.2.0/24')\nWhilethestringformofferssignificantlymoreflexibility,networkscanalsobedefinedwithintegers,justlikehost\naddresses. Inthiscase,thenetworkisconsideredtocontainonlythesingleaddressidentifiedbytheinteger,sothe\nnetworkprefixincludestheentirenetworkaddress:\n>>> ipaddress.ip_network(3221225984)\nIPv4Network('192.0.2.0/32')\n>>> ipaddress.ip_network(42540766411282592856903984951653826560)\nIPv6Network('2001:db8::/128')\nAs with addresses, creation of a particular kind of network can be forced by calling the class constructor directly\ninsteadofusingthefactoryfunction.\n1.4 Host Interfaces\nAs mentioned just above, if you need to describe an address on a particular network, neither the address nor the\nnetworkclassesaresufficient. Notationlike192.0.2.1/24iscommonlyusedbynetworkengineersandthepeople\nwhowritetoolsforfirewallsandroutersasshorthandfor\u201cthehost192.0.2.1onthenetwork192.0.2.0/24\u201d,\nAccordingly,ipaddressprovidesasetofhybridclassesthatassociateanaddresswithaparticularnetwork. The\ninterfaceforcreationisidenticaltothatfordefiningnetworkobjects,exceptthattheaddressportionisn\u2019tconstrained\ntobeinganetworkaddress.\n>>> ipaddress.ip_interface('192.0.2.1/24')\nIPv4Interface('192.0.2.1/24')\n>>> ipaddress.ip_interface('2001:db8::1/96')\nIPv6Interface('2001:db8::1/96')\nIntegerinputsareaccepted(aswithnetworks),anduseofaparticularIPversioncanbeforcedbycallingtherelevant\nconstructordirectly.\n2 Inspecting Address/Network/Interface Objects\nYou\u2019vegonetothetroubleofcreatinganIPv(4|6)(Address|Network|Interface)object,soyouprobablywanttoget\ninformationaboutit. ipaddresstriestomakedoingthiseasyandintuitive.\nExtractingtheIPversion:\n>>> addr4 = ipaddress.ip_address('192.0.2.1')\n>>> addr6 = ipaddress.ip_address('2001:db8::1')\n>>> addr6.version\n6\n>>> addr4.version\n4\nObtainingthenetworkfromaninterface:\n>>> host4 = ipaddress.ip_interface('192.0.2.1/24')\n>>> host4.network\nIPv4Network('192.0.2.0/24')\n>>> host6 = ipaddress.ip_interface('2001:db8::1/96')\n>>> host6.network\nIPv6Network('2001:db8::/96')\n3\nFindingouthowmanyindividualaddressesareinanetwork:\n>>> net4 = ipaddress.ip_network('192.0.2.0/24')\n>>> net4.num_addresses\n256\n>>> net6 = ipaddress.ip_network('2001:db8::0/96')\n>>> net6.num_addresses\n4294967296\nIteratingthroughthe\u201cusable\u201daddressesonanetwork:\n>>> net4 = ipaddress.ip_network('192.0.2.0/24')\n>>> for x in net4.hosts():\n... print(x)\n192.0.2.1\n192.0.2.2\n192.0.2.3\n192.0.2.4\n...\n192.0.2.252\n192.0.2.253\n192.0.2.254\nObtainingthenetmask(i.e. setbitscorrespondingtothenetworkprefix)orthehostmask(anybitsthatarenotpart\nofthenetmask):\n>>> net4 = ipaddress.ip_network('192.0.2.0/24')\n>>> net4.netmask\nIPv4Address('255.255.255.0')\n>>> net4.hostmask\nIPv4Address('0.0.0.255')\n>>> net6 = ipaddress.ip_network('2001:db8::0/96')\n>>> net6.netmask\nIPv6Address('ffff:ffff:ffff:ffff:ffff:ffff::')\n>>> net6.hostmask\nIPv6Address('::ffff:ffff')\nExplodingorcompressingtheaddress:\n>>> addr6.exploded\n'2001:0db8:0000:0000:0000:0000:0000:0001'\n>>> addr6.compressed\n'2001:db8::1'\n>>> net6.exploded\n'2001:0db8:0000:0000:0000:0000:0000:0000/96'\n>>> net6.compressed\n'2001:db8::/96'\nWhileIPv4doesn\u2019tsupportexplosionorcompression,theassociatedobjectsstillprovidetherelevantpropertiesso\nthatversionneutralcodecaneasilyensurethemostconciseormostverboseformisusedforIPv6addresseswhile\nstillcorrectlyhandlingIPv4addresses.\n3 Networks as lists of Addresses\nIt\u2019ssometimesusefultotreatnetworksaslists. Thismeansitispossibletoindexthemlikethis:\n>>> net4[1]\nIPv4Address('192.0.2.1')\n(continuesonnextpage)\n4\n(continuedfrompreviouspage)\n>>> net4[-1]\nIPv4Address('192.0.2.255')\n>>> net6[1]\nIPv6Address('2001:db8::1')\n>>> net6[-1]\nIPv6Address('2001:db8::ffff:ffff')\nItalsomeansthatnetworkobjectslendthemselvestousingthelistmembershiptestsyntaxlikethis:\nif address in network:\n# do something\nContainmenttestingisdoneefficientlybasedonthenetworkprefix:\n>>> addr4 = ipaddress.ip_address('192.0.2.1')\n>>> addr4 in ipaddress.ip_network('192.0.2.0/24')\nTrue\n>>> addr4 in ipaddress.ip_network('192.0.3.0/24')\nFalse\n4 Comparisons\nipaddressprovidessomesimple,hopefullyintuitivewaystocompareobjects,whereitmakessense:\n>>> ipaddress.ip_address('192.0.2.1') < ipaddress.ip_address('192.0.2.2')\nTrue\nATypeErrorexceptionisraisedifyoutrytocompareobjectsofdifferentversionsordifferenttypes.\n5 Using IP Addresses with other modules\nOthermodulesthatuseIPaddresses(suchassocket)usuallywon\u2019tacceptobjectsfromthismoduledirectly. Instead,\ntheymustbecoercedtoanintegerorstringthattheothermodulewillaccept:\n>>> addr4 = ipaddress.ip_address('192.0.2.1')\n>>> str(addr4)\n'192.0.2.1'\n>>> int(addr4)\n3221225985\n6 Getting more detail when instance creation fails\nWhen creating address/network/interface objects using the version-agnostic factory functions, any errors will be\nreportedasValueErrorwithagenericerrormessagethatsimplysaysthepassedinvaluewasnotrecognizedasan\nobjectofthattype. Thelackofaspecificerrorisbecauseit\u2019snecessarytoknowwhetherthevalueissupposedtobe\nIPv4orIPv6inordertoprovidemoredetailonwhyithasbeenrejected.\nTosupportusecaseswhereitisusefultohaveaccesstothisadditionaldetail,theindividualclassconstructorsactually\nraisetheValueErrorsubclassesipaddress.AddressValueErrorandipaddress.NetmaskValueErrorto\nindicateexactlywhichpartofthedefinitionfailedtoparsecorrectly.\nTheerrormessagesaresignificantlymoredetailedwhenusingtheclassconstructorsdirectly. Forexample:\n>>> ipaddress.ip_address(\"192.168.0.256\")\nTraceback (most recent call last):\n(continuesonnextpage)\n5\n(continuedfrompreviouspage)\n...\nValueError: '192.168.0.256' does not appear to be an IPv4 or IPv6 address\n>>> ipaddress.IPv4Address(\"192.168.0.256\")\nTraceback (most recent call last):\n...\nipaddress.AddressValueError: Octet 256 (> 255) not permitted in '192.168.0.256'\n>>> ipaddress.ip_network(\"192.168.0.1/64\")\nTraceback (most recent call last):\n...\nValueError: '192.168.0.1/64' does not appear to be an IPv4 or IPv6 network\n>>> ipaddress.IPv4Network(\"192.168.0.1/64\")\nTraceback (most recent call last):\n...\nipaddress.NetmaskValueError: '64' is not a valid netmask\nHowever,bothofthemodulespecificexceptionshaveValueErrorastheirparentclass,soifyou\u2019renotconcerned\nwiththeparticulartypeoferror,youcanstillwritecodelikethefollowing:\ntry:\nnetwork = ipaddress.IPv4Network(address)\nexcept ValueError:\nprint('address/netmask is invalid for IPv4:', address)\n6\n",
  "context": "forcetheuseofoneversionortheother.\n1.2 IP Host Addresses\nAddresses, often referred to as \u201chost addresses\u201d are the most basic unit when working with IP addressing. The",
  "source_file": "resources\\Year 3\\Python\\howto-ipaddress.pdf",
  "line_numbers": [
    41,
    237
  ]
}
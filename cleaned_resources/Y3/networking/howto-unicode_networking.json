{
  "title": "howto-unicode",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "data_structures",
    "networking",
    "database"
  ],
  "purpose": "1 Introduction to Unicode 1.1 Definitions Today\u2019sprogramsneedtobeabletohandleawidevarietyofcharacters.",
  "code": "displaymessagesandoutputinavarietyofuser-selectablelanguages;thesameprogrammightneedtooutputanerror\nmessageinEnglish, French, Japanese, Hebrew, orRussian. Webcontentcanbewritteninanyoftheselanguages\n1\nand can also include a variety of emoji symbols. Python\u2019s string type uses the Unicode Standard for representing\ncharacters,whichletsPythonprogramsworkwithallthesedifferentpossiblecharacters.\nUnicode(https://www.unicode.org/)isaspecificationthataimstolisteverycharacterusedbyhumanlanguagesand\ngiveeachcharacteritsownuniquecode. TheUnicodespecificationsarecontinuallyrevisedandupdatedtoaddnew\nlanguagesandsymbols.\nAcharacteristhesmallestpossiblecomponentofatext. \u2018A\u2019,\u2018B\u2019,\u2018C\u2019,etc.,arealldifferentcharacters. Soare\u2018E\u0300\u2019and\n\u2018I\u2019\u0301.Charactersvarydependingonthelanguageorcontextyou\u2019retalkingabout. Forexample,there\u2019sacharacterfor\n\u201cRomanNumeralOne\u201d,\u2018\u2160\u2019,that\u2019sseparatefromtheuppercaseletter\u2018I\u2019.They\u2019llusuallylookthesame,buttheseare\ntwodifferentcharactersthathavedifferentmeanings.\nTheUnicodestandarddescribeshowcharactersarerepresentedbycodepoints. Acodepointvalueisanintegerin\ntherange0to0x10FFFF(about1.1millionvalues,theactualnumberassignedislessthanthat). Inthestandardand\ninthisdocument,acodepointiswrittenusingthenotationU+265Etomeanthecharacterwithvalue0x265e(9,822\nindecimal).\nTheUnicodestandardcontainsalotoftableslistingcharactersandtheircorrespondingcodepoints:\n0061 'a'; LATIN SMALL LETTER A\n0062 'b'; LATIN SMALL LETTER B\n0063 'c'; LATIN SMALL LETTER C\n...\n007B '{'; LEFT CURLY BRACKET\n...\n2167 '\u2167'; ROMAN NUMERAL EIGHT\n2168 '\u2168'; ROMAN NUMERAL NINE\n...\n265E '\u265e'; BLACK CHESS KNIGHT\n265F '\u265f'; BLACK CHESS PAWN\n...\n1F600 '(cid:0)'; GRINNING FACE\n1F609 '(cid:0)'; WINKING FACE\n...\nStrictly,thesedefinitionsimplythatit\u2019smeaninglesstosay\u2018thisischaracterU+265E\u2019.U+265Eisacodepoint,which\nrepresents some particular character; in this case, it represents the character \u2018BLACK CHESS KNIGHT\u2019, \u2018\u265e\u2019. In\ninformalcontexts,thisdistinctionbetweencodepointsandcharacterswillsometimesbeforgotten.\nAcharacterisrepresentedonascreenoronpaperbyasetofgraphicalelementsthat\u2019scalledaglyph. Theglyphfor\nanuppercaseA,forexample,istwodiagonalstrokesandahorizontalstroke,thoughtheexactdetailswilldependon\nthefontbeingused. MostPythoncodedoesn\u2019tneedtoworryaboutglyphs;figuringoutthecorrectglyphtodisplay\nisgenerallythejobofaGUItoolkitoraterminal\u2019sfontrenderer.\n1.2 Encodings\nTosummarizetheprevioussection: aUnicodestringisasequenceofcodepoints,whicharenumbersfrom0through\n0x10FFFF(1,114,111decimal). Thissequenceofcodepointsneedstoberepresentedinmemoryasasetofcode\nunits,andcodeunitsarethenmappedto8-bitbytes. TherulesfortranslatingaUnicodestringintoasequenceof\nbytesarecalledacharacterencoding,orjustanencoding.\nThefirstencodingyoumightthinkofisusing32-bitintegersasthecodeunit,andthenusingtheCPU\u2019srepresentation\nof32-bitintegers. Inthisrepresentation,thestring\u201cPython\u201dmightlooklikethis:\nP y t h o n\n0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\nThisrepresentationisstraightforwardbutusingitpresentsanumberofproblems.\n1. It\u2019snotportable;differentprocessorsorderthebytesdifferently.\n2\n2. It\u2019sverywastefulofspace. Inmosttexts,themajorityofthecodepointsarelessthan127,orlessthan255,so\nalotofspaceisoccupiedby0x00bytes. Theabovestringtakes24bytescomparedtothe6bytesneededfor\nanASCIIrepresentation. IncreasedRAMusagedoesn\u2019tmattertoomuch(desktopcomputershavegigabytes\nofRAM,andstringsaren\u2019tusuallythatlarge),butexpandingourusageofdiskandnetworkbandwidthbya\nfactorof4isintolerable.\n3. It\u2019snotcompatiblewithexistingCfunctionssuchasstrlen(),soanewfamilyofwidestringfunctionswould\nneedtobeused.\nThereforethisencodingisn\u2019tusedverymuch,andpeopleinsteadchooseotherencodingsthataremoreefficientand\nconvenient,suchasUTF-8.\nUTF-8isoneofthemostcommonlyusedencodings,andPythonoftendefaultstousingit. UTFstandsfor\u201cUnicode\nTransformationFormat\u201d,andthe\u20188\u2019meansthat8-bitvaluesareusedintheencoding. (TherearealsoUTF-16and\nUTF-32encodings,buttheyarelessfrequentlyusedthanUTF-8.) UTF-8usesthefollowingrules:\n1. Ifthecodepointis<128,it\u2019srepresentedbythecorrespondingbytevalue.\n2. If the code point is >= 128, it\u2019s turned into a sequence of two, three, or four bytes, where each byte of the\nsequenceisbetween128and255.\nUTF-8hasseveralconvenientproperties:\n1. ItcanhandleanyUnicodecodepoint.\n2. AUnicodestringisturnedintoasequenceofbytesthatcontainsembeddedzerobytesonlywheretheyrepresent\nthenullcharacter(U+0000). ThismeansthatUTF-8stringscanbeprocessedbyCfunctionssuchasstrcpy()\nandsentthroughprotocolsthatcan\u2019thandlezerobytesforanythingotherthanend-of-stringmarkers.\n3. AstringofASCIItextisalsovalidUTF-8text.\n4. UTF-8isfairlycompact;themajorityofcommonlyusedcharacterscanberepresentedwithoneortwobytes.\n5. Ifbytesarecorruptedorlost,it\u2019spossibletodeterminethestartofthenextUTF-8-encodedcodepointand\nresynchronize. It\u2019salsounlikelythatrandom8-bitdatawilllooklikevalidUTF-8.\n6. UTF-8 is a byte oriented encoding. The encoding specifies that each character is represented by a specific\nsequence of one or more bytes. This avoids the byte-ordering issues that can occur with integer and word\norientedencodings,likeUTF-16andUTF-32,wherethesequenceofbytesvariesdependingonthehardware\nonwhichthestringwasencoded.\n1.3 References\nThe Unicode Consortium site has character charts, a glossary, and PDF versions of the Unicode specification. Be\npreparedforsomedifficultreading. AchronologyoftheoriginanddevelopmentofUnicodeisalsoavailableonthe\nsite.\nOntheComputerphileYoutubechannel,TomScottbrieflydiscussesthehistoryofUnicodeandUTF-8(9minutes\n36seconds).\nTohelpunderstandthestandard,JukkaKorpelahaswrittenanintroductoryguidetoreadingtheUnicodecharacter\ntables.\nAnothergoodintroductoryarticlewaswrittenbyJoelSpolsky. Ifthisintroductiondidn\u2019tmakethingscleartoyou,\nyoushouldtryreadingthisalternatearticlebeforecontinuing.\nWikipediaentriesareoftenhelpful;seetheentriesfor\u201ccharacterencoding\u201dandUTF-8,forexample.\n2 Python\u2019s Unicode Support\nNowthatyou\u2019velearnedtherudimentsofUnicode,wecanlookatPython\u2019sUnicodefeatures.\n3\n2.1 The String Type\nSincePython3.0,thelanguage\u2019sstrtypecontainsUnicodecharacters,meaninganystringcreatedusing\"unicode\nrocks!\",'unicode rocks!',orthetriple-quotedstringsyntaxisstoredasUnicode.\nThedefaultencodingforPythonsourcecodeisUTF-8, soyoucansimplyincludeaUnicodecharacterinastring\nliteral:\ntry:\nwith open('/tmp/input.txt', 'r') as f:\n...\nexcept OSError:\n# 'File not found' error message.\nprint(\"Fichier non trouv\u00e9\")\nSidenote: Python3alsosupportsusingUnicodecharactersinidentifiers:\nr\u00e9pertoire = \"/tmp/records.log\"\nwith open(r\u00e9pertoire, \"w\") as f:\nf.write(\"test\\n\")\nIfyoucan\u2019tenteraparticularcharacterinyoureditororwanttokeepthesourcecodeASCII-onlyforsomereason,\nyoucanalsouseescapesequencesinstringliterals. (Dependingonyoursystem,youmayseetheactualcapital-delta\nglyphinsteadofauescape.)\n>>> \"\\N{GREEK CAPITAL LETTER DELTA}\" # Using the character name\n'\\u0394'\n>>> \"\\u0394\" # Using a 16-bit hex value\n'\\u0394'\n>>> \"\\U00000394\" # Using a 32-bit hex value\n'\\u0394'\nInaddition,onecancreateastringusingthedecode()methodofbytes. Thismethodtakesanencodingargument,\nsuchasUTF-8,andoptionallyanerrorsargument.\nThe errors argument specifies the response when the input string can\u2019t be converted according to the encoding\u2019s\nrules. Legal values for this argument are 'strict' (raise a UnicodeDecodeError exception), 'replace'\n(use U+FFFD, REPLACEMENT CHARACTER), 'ignore' (just leave the character out of the Unicode result), or\n'backslashreplace'(insertsa\\xNNescapesequence). Thefollowingexamplesshowthedifferences:\n>>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\nTraceback (most recent call last):\n...\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\ninvalid start byte\n>>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n'\\ufffdabc'\n>>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n'\\\\x80abc'\n>>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n'abc'\nEncodingsarespecifiedasstringscontainingtheencoding\u2019sname. Pythoncomeswithroughly100differentencod-\nings; seethePythonLibraryReferenceatstandard-encodingsforalist. Someencodingshavemultiplenames; for\nexample,'latin-1','iso_8859_1'and'8859\u2019areallsynonymsforthesameencoding.\nOne-characterUnicodestringscanalsobecreatedwiththechr()built-infunction,whichtakesintegersandreturns\naUnicodestringoflength1thatcontainsthecorrespondingcodepoint. Thereverseoperationisthebuilt-inord()\nfunctionthattakesaone-characterUnicodestringandreturnsthecodepointvalue:\n4\n>>> chr(57344)\n'\\ue000'\n>>> ord('\\ue000')\n57344\n2.2 Converting to Bytes\nTheoppositemethodofbytes.decode()isstr.encode(),whichreturnsabytesrepresentationoftheUnicode\nstring,encodedintherequestedencoding.\nThe errors parameter is the same as the parameter of the decode() method but supports a few more possible\nhandlers. As well as 'strict', 'ignore', and 'replace' (which in this case inserts a question mark in-\nsteadoftheunencodablecharacter),thereisalso'xmlcharrefreplace'(insertsanXMLcharacterreference),\nbackslashreplace(insertsa\\uNNNNescapesequence)andnamereplace(insertsa\\N{...}escapesequence).\nThefollowingexampleshowsthedifferentresults:\n>>> u = chr(40960) + 'abcd' + chr(1972)\n>>> u.encode('utf-8')\nb'\\xea\\x80\\x80abcd\\xde\\xb4'\n>>> u.encode('ascii')\nTraceback (most recent call last):\n...\nUnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\nposition 0: ordinal not in range(128)\n>>> u.encode('ascii', 'ignore')\nb'abcd'\n>>> u.encode('ascii', 'replace')\nb'?abcd?'\n>>> u.encode('ascii', 'xmlcharrefreplace')\nb'&#40960;abcd&#1972;'\n>>> u.encode('ascii', 'backslashreplace')\nb'\\\\ua000abcd\\\\u07b4'\n>>> u.encode('ascii', 'namereplace')\nb'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'\nThelow-levelroutinesforregisteringandaccessingtheavailableencodingsarefoundinthecodecsmodule. Im-\nplementingnewencodingsalsorequiresunderstandingthecodecsmodule. However, theencodinganddecoding\nfunctions returned by this module are usually more low-level than is comfortable, and writing new encodings is a\nspecializedtask,sothemodulewon\u2019tbecoveredinthisHOWTO.\n2.3 Unicode Literals in Python Source Code\nInPythonsourcecode,specificUnicodecodepointscanbewrittenusingthe\\uescapesequence,whichisfollowed\nbyfourhexdigitsgivingthecodepoint. The\\Uescapesequenceissimilar,butexpectseighthexdigits,notfour:\n>>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n... # ^^^^ two-digit hex escape\n... # ^^^^^^ four-digit Unicode escape\n... # ^^^^^^^^^^ eight-digit Unicode escape\n>>> [ord(c) for c in s]\n[97, 172, 4660, 8364, 32768]\nUsingescapesequencesforcodepointsgreaterthan127isfineinsmalldoses,butbecomesanannoyanceifyou\u2019re\nusing many accented characters, as you would in a program with messages in French or some other accent-using\nlanguage. Youcanalsoassemblestringsusingthechr()built-infunction,butthisisevenmoretedious.\nIdeally,you\u2019dwanttobeabletowriteliteralsinyourlanguage\u2019snaturalencoding. YoucouldtheneditPythonsource\ncodewithyourfavoriteeditorwhichwoulddisplaytheaccentedcharactersnaturally,andhavetherightcharacters\n5\nusedatruntime.\nPythonsupportswritingsourcecodeinUTF-8bydefault, butyoucanusealmostanyencodingifyoudeclarethe\nencodingbeingused. Thisisdonebyincludingaspecialcommentaseitherthefirstorsecondlineofthesourcefile:\n#!/usr/bin/env python\n# -*- coding: latin-1 -*-\nu = 'abcd\u00e9'\nprint(ord(u[-1]))\nThe syntax is inspired by Emacs\u2019s notation for specifying variables local to a file. Emacs supports many different\nvariables,butPythononlysupports\u2018coding\u2019. The-*-symbolsindicatetoEmacsthatthecommentisspecial;they\nhave no significance to Python but are a convention. Python looks for coding: name or coding=name in the\ncomment.\nIfyoudon\u2019tincludesuchacomment,thedefaultencodingusedwillbeUTF-8asalreadymentioned. SeealsoPEP\n263formoreinformation.\n2.4 Unicode Properties\nTheUnicodespecificationincludesadatabaseofinformationaboutcodepoints. Foreachdefinedcodepoint, the\ninformationincludesthecharacter\u2019sname,itscategory,thenumericvalueifapplicable(forcharactersrepresenting\nnumeric concepts such as the Roman numerals, fractions such as one-third and four-fifths, etc.). There are also\ndisplay-relatedproperties,suchashowtousethecodepointinbidirectionaltext.\nThe following program displays some information about several characters, and prints the numeric value of one\nparticularcharacter:\nimport unicodedata\nu = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\nfor i, c in enumerate(u):\nprint(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\nprint(unicodedata.name(c))\n# Get numeric value of second character\nprint(unicodedata.numeric(u[1]))\nWhenrun,thisprints:\n0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n1 0bf2 No TAMIL NUMBER ONE THOUSAND\n2 0f84 Mn TIBETAN MARK HALANTA\n3 1770 Lo TAGBANWA LETTER SA\n4 33af So SQUARE RAD OVER S SQUARED\n1000.0\nThe category codes are abbreviations describing the nature of the character. These are grouped into categories\nsuch as \u201cLetter\u201d, \u201cNumber\u201d, \u201cPunctuation\u201d, or \u201cSymbol\u201d, which in turn are broken up into subcategories. To take\nthe codes from the above output, 'Ll' means \u2018Letter, lowercase\u2019, 'No' means \u201cNumber, other\u201d, 'Mn' is \u201cMark,\nnonspacing\u201d, and 'So' is \u201cSymbol, other\u201d. See the General Category Values section of the Unicode Character\nDatabasedocumentationforalistofcategorycodes.\n2.5 Comparing Strings\nUnicode adds some complication to comparing strings, because the same set of characters can be represented by\ndifferentsequencesofcodepoints. Forexample,aletterlike\u2018e\u0302\u2019canberepresentedasasinglecodepointU+00EA,\norasU+0065U+0302,whichisthecodepointfor\u2018e\u2019followedbyacodepointfor\u2018COMBININGCIRCUMFLEX\n6\nACCENT\u2019.Thesewillproducethesameoutputwhenprinted,butoneisastringoflength1andtheotherisoflength\n2.\nOne tool for a case-insensitive comparison is the casefold() string method that converts a string to a case-\ninsensitive form following an algorithm described by the Unicode Standard. This algorithm has special handling\nforcharacterssuchastheGermanletter\u2018\u00df\u2019(codepointU+00DF),whichbecomesthepairoflowercaseletters\u2018ss\u2019.\n>>> street = 'G\u00fcrzenichstra\u00dfe'\n>>> street.casefold()\n'g\u00fcrzenichstrasse'\nAsecondtoolistheunicodedatamodule\u2019snormalize()functionthatconvertsstringstooneofseveralnormal\nforms, where letters followed by a combining character are replaced with single characters. normalize() can\nbe used to perform string comparisons that won\u2019t falsely report inequality if two strings use combining characters\ndifferently:\nimport unicodedata\ndef compare_strs(s1, s2):\ndef NFD(s):\nreturn unicodedata.normalize('NFD', s)\nreturn NFD(s1) == NFD(s2)\nsingle_char = '\u00ea'\nmultiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX ACCENT}'\nprint('length of first string=', len(single_char))\nprint('length of second string=', len(multiple_chars))\nprint(compare_strs(single_char, multiple_chars))\nWhenrun,thisoutputs:\n$ python compare-strs.py\nlength of first string= 1\nlength of second string= 2\nTrue\nThefirstargumenttothenormalize()functionisastringgivingthedesirednormalizationform,whichcanbeone\nof\u2018NFC\u2019,\u2018NFKC\u2019,\u2018NFD\u2019,and\u2018NFKD\u2019.\nTheUnicodeStandardalsospecifieshowtodocaselesscomparisons:\nimport unicodedata\ndef compare_caseless(s1, s2):\ndef NFD(s):\nreturn unicodedata.normalize('NFD', s)\nreturn NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n# Example usage\nsingle_char = '\u00ea'\nmultiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX ACCENT}'\nprint(compare_caseless(single_char, multiple_chars))\nThiswillprintTrue. (WhyisNFD()invokedtwice? Becausethereareafewcharactersthatmakecasefold()\nreturnanon-normalizedstring,sotheresultneedstobenormalizedagain. Seesection3.13oftheUnicodeStandard\nforadiscussionandanexample.)\n7\n2.6 Unicode Regular Expressions\nTheregularexpressionssupportedbytheremodulecanbeprovidedeitherasbytesorstrings. Someofthespecial\ncharactersequencessuchas\\dand\\whavedifferentmeaningsdependingonwhetherthepatternissuppliedasbytes\norastring. Forexample,\\dwillmatchthecharacters[0-9]inbytesbutinstringswillmatchanycharacterthat\u2019s\ninthe'Nd'category.\nThestringinthisexamplehasthenumber57writteninbothThaiandArabicnumerals:\nimport re\np = re.compile(r'\\d+')\ns = \"Over \\u0e55\\u0e57 57 flavours\"\nm = p.search(s)\nprint(repr(m.group()))\nWhen executed, \\d+ will match the Thai numerals and print them out. If you supply the re.ASCII flag to\ncompile(),\\d+willmatchthesubstring\u201c57\u201dinstead.\nSimilarly, \\w matches a wide variety of Unicode characters but only [a-zA-Z0-9_] in bytes or if re.ASCII is\nsupplied,and\\swillmatcheitherUnicodewhitespacecharactersor[ \\t\\n\\r\\f\\v].\n2.7 References\nSomegoodalternativediscussionsofPython\u2019sUnicodesupportare:\n\u2022 ProcessingTextFilesinPython3,byNickCoghlan.\n\u2022 PragmaticUnicode,aPyCon2012presentationbyNedBatchelder.\nThestrtypeisdescribedinthePythonlibraryreferenceattextseq.\nThedocumentationfortheunicodedatamodule.\nThedocumentationforthecodecsmodule.\nMarc-Andre\u0301Lemburggaveapresentationtitled\u201cPythonandUnicode\u201d(PDFslides)atEuroPython2002. Theslides\nare an excellent overview of the design of Python 2\u2019s Unicode features (where the Unicode string type is called\nunicodeandliteralsstartwithu).\n3 Reading and Writing Unicode Data\nOnce you\u2019ve written some code that works with Unicode data, the next problem is input/output. How do you get\nUnicodestringsintoyourprogram,andhowdoyouconvertUnicodeintoaformsuitableforstorageortransmission?\nIt\u2019spossiblethatyoumaynotneedtodoanythingdependingonyourinputsourcesandoutputdestinations;youshould\ncheckwhetherthelibrariesusedinyourapplicationsupportUnicodenatively. XMLparsersoftenreturnUnicode\ndata,forexample. ManyrelationaldatabasesalsosupportUnicode-valuedcolumnsandcanreturnUnicodevalues\nfromanSQLquery.\nUnicode data is usually converted to a particular encoding before it gets written to disk or sent over a socket. It\u2019s\npossibletodoalltheworkyourself: openafile,readan8-bitbytesobjectfromit,andconvertthebyteswithbytes.\ndecode(encoding). However,themanualapproachisnotrecommended.\nOneproblemisthemulti-bytenatureofencodings; oneUnicodecharactercanberepresentedbyseveralbytes. If\nyouwanttoreadthefileinarbitrary-sizedchunks(say,1024or4096bytes),youneedtowriteerror-handlingcode\ntocatchthecasewhereonlypartofthebytesencodingasingleUnicodecharacterarereadattheendofachunk.\nOnesolutionwouldbetoreadtheentirefileintomemoryandthenperformthedecoding,butthatpreventsyoufrom\nworkingwithfilesthatareextremelylarge;ifyouneedtoreada2GiBfile,youneed2GiBofRAM.(More,really,\nsinceforatleastamomentyou\u2019dneedtohaveboththeencodedstringanditsUnicodeversioninmemory.)\nThesolutionwouldbetousethelow-leveldecodinginterfacetocatchthecaseofpartialcodingsequences. Thework\nofimplementingthishasalreadybeendoneforyou: thebuilt-inopen()functioncanreturnafile-likeobjectthat\nassumesthefile\u2019scontentsareinaspecifiedencodingandacceptsUnicodeparametersformethodssuchasread()\n8\nandwrite(). Thisworksthroughopen()\u2019sencodinganderrorsparameterswhichareinterpretedjustlikethosein\nstr.encode()andbytes.decode().\nReadingUnicodefromafileisthereforesimple:\nwith open('unicode.txt', encoding='utf-8') as f:\nfor line in f:\nprint(repr(line))\nIt\u2019salsopossibletoopenfilesinupdatemode,allowingbothreadingandwriting:\nwith open('test', encoding='utf-8', mode='w+') as f:\nf.write('\\u4500 blah blah blah\\n')\nf.seek(0)\nprint(repr(f.readline()[:1]))\nTheUnicodecharacterU+FEFFisusedasabyte-ordermark(BOM),andisoftenwrittenasthefirstcharacterofa\nfileinordertoassistwithautodetectionofthefile\u2019sbyteordering. Someencodings,suchasUTF-16,expectaBOM\ntobepresentatthestartofafile;whensuchanencodingisused,theBOMwillbeautomaticallywrittenasthefirst\ncharacterandwillbesilentlydroppedwhenthefileisread. Therearevariantsoftheseencodings,suchas\u2018utf-16-le\u2019\nand\u2018utf-16-be\u2019forlittle-endianandbig-endianencodings,thatspecifyoneparticularbyteorderinganddon\u2019tskipthe\nBOM.\nInsomeareas,itisalsoconventiontousea\u201cBOM\u201datthestartofUTF-8encodedfiles;thenameismisleadingsince\nUTF-8isnotbyte-orderdependent. ThemarksimplyannouncesthatthefileisencodedinUTF-8. Forreadingsuch\nfiles,usethe\u2018utf-8-sig\u2019codectoautomaticallyskipthemarkifpresent.\n3.1 Unicode filenames\nMost of the operating systems in common use today support filenames that contain arbitrary Unicode characters.\nUsuallythisisimplementedbyconvertingtheUnicodestringintosomeencodingthatvariesdependingonthesystem.\nTodayPythonisconvergingonusingUTF-8: PythononMacOShasusedUTF-8forseveralversions,andPython3.6\nswitchedtousingUTF-8onWindowsaswell. OnUnixsystems,therewillonlybeafilesystemencoding. ifyou\u2019ve\nsettheLANGorLC_CTYPEenvironmentvariables;ifyouhaven\u2019t,thedefaultencodingisagainUTF-8.\nThesys.getfilesystemencoding()functionreturnstheencodingtouseonyourcurrentsystem,incaseyou\nwanttodotheencodingmanually,butthere\u2019snotmuchreasontobother. Whenopeningafileforreadingorwriting,\nyoucanusuallyjustprovidetheUnicodestringasthefilename, anditwillbeautomaticallyconvertedtotheright\nencodingforyou:\nfilename = 'filename\\u4500abc'\nwith open(filename, 'w') as f:\nf.write('blah\\n')\nFunctionsintheosmodulesuchasos.stat()willalsoacceptUnicodefilenames.\nTheos.listdir()functionreturnsfilenames,whichraisesanissue: shoulditreturntheUnicodeversionoffile-\nnames,orshoulditreturnbytescontainingtheencodedversions? os.listdir()candoboth,dependingonwhether\nyouprovidedthedirectorypathasbytesoraUnicodestring. IfyoupassaUnicodestringasthepath,filenameswill\nbedecodedusingthefilesystem\u2019sencodingandalistofUnicodestringswillbereturned,whilepassingabytepath\nwill return the filenames as bytes. For example, assuming the default filesystem encoding is UTF-8, running the\nfollowingprogram:\nfn = 'filename\\u4500abc'\nf = open(fn, 'w')\nf.close()\nimport os\nprint(os.listdir(b'.'))\nprint(os.listdir('.'))\n9\nwillproducethefollowingoutput:\n$ python listdir-test.py\n[b'filename\\xe4\\x94\\x80abc', ...]\n['filename\\u4500abc', ...]\nThefirstlistcontainsUTF-8-encodedfilenames,andthesecondlistcontainstheUnicodeversions.\nNotethatonmostoccasions,youshouldcanjuststickwithusingUnicodewiththeseAPIs. ThebytesAPIsshould\nonlybeusedonsystemswhereundecodablefilenamescanbepresent;that\u2019sprettymuchonlyUnixsystemsnow.\n3.2 Tips for Writing Unicode-aware Programs\nThissectionprovidessomesuggestionsonwritingsoftwarethatdealswithUnicode.\nThemostimportanttipis:\nSoftwareshouldonlyworkwithUnicodestringsinternally,decodingtheinputdataassoonaspossible\nandencodingtheoutputonlyattheend.\nIfyouattempttowriteprocessingfunctionsthatacceptbothUnicodeandbytestrings,youwillfindyourprogram\nvulnerable to bugs wherever you combine the two different kinds of strings. There is no automatic encoding or\ndecoding: ifyoudoe.g. str + bytes,aTypeErrorwillberaised.\nWhenusingdatacomingfromawebbrowserorsomeotheruntrustedsource,acommontechniqueistocheckfor\nillegalcharactersinastringbeforeusingthestringinageneratedcommandlineorstoringitinadatabase. Ifyou\u2019re\ndoingthis,becarefultocheckthedecodedstring,nottheencodedbytesdata;someencodingsmayhaveinteresting\nproperties,suchasnotbeingbijectiveornotbeingfullyASCII-compatible. Thisisespeciallytrueiftheinputdata\nalso specifies the encoding, since the attacker can then choose a clever way to hide malicious text in the encoded\nbytestream.\nConvertingBetweenFileEncodings\nTheStreamRecoderclasscantransparentlyconvertbetweenencodings,takingastreamthatreturnsdatainencod-\ning#1andbehavinglikeastreamreturningdatainencoding#2.\nForexample, ifyouhaveaninputfilef that\u2019sinLatin-1, youcanwrapitwithaStreamRecodertoreturnbytes\nencodedinUTF-8:\nnew_f = codecs.StreamRecoder(f,\n# en/decoder: used by read() to encode its results and\n# by write() to decode its input.\ncodecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n# reader/writer: used to read and write to the stream.\ncodecs.getreader('latin-1'), codecs.getwriter('latin-1') )\nFilesinanUnknownEncoding\nWhat can you do if you need to make a change to a file, but don\u2019t know the file\u2019s encoding? If you know the\nencodingisASCII-compatibleandonlywanttoexamineormodifytheASCIIparts,youcanopenthefilewiththe\nsurrogateescapeerrorhandler:\nwith open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\ndata = f.read()\n# make changes to the string 'data'\nwith open(fname + '.new', 'w',\nencoding=\"ascii\", errors=\"surrogateescape\") as f:\nf.write(data)\n10\nThesurrogateescapeerrorhandlerwilldecodeanynon-ASCIIbytesascodepointsinaspecialrangerunning\nfromU+DC80toU+DCFF.Thesecodepointswillthenturnbackintothesamebyteswhenthesurrogateescape\nerrorhandlerisusedtoencodethedataandwriteitbackout.\n3.3 References\nOnesectionofMasteringPython3Input/Output,aPyCon2010talkbyDavidBeazley,discussestextprocessingand\nbinarydatahandling.\nThe PDF slides for Marc-Andre\u0301 Lemburg\u2019s presentation \u201cWriting Unicode-aware Applications in Python\u201d discuss\nquestionsofcharacterencodingsas wellas howto internationalizeandlocalizean application. Theseslidescover\nPython2.xonly.\nThe Guts of Unicode in Python is a PyCon 2013 talk by Benjamin Peterson that discusses the internal Unicode\nrepresentationinPython3.3.\n4 Acknowledgements\nTheinitialdraftofthisdocumentwaswrittenbyAndrewKuchling. IthassincebeenrevisedfurtherbyAlexander\nBelopolsky,GeorgBrandl,AndrewKuchling,andEzioMelotti.\nThankstothefollowingpeoplewhohavenotederrorsorofferedsuggestionsonthisarticle: E\u0301ricAraujo,Nicholas\nBastin, Nick Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-Andre\u0301 Lemburg, Martin von Lo\u0308wis,\nTerryJ.Reedy,SerhiyStorchaka,ErykSun,ChadWhitacre,GrahamWideman.\n11\nIndex\nP\nPython Enhancement Proposals\nPEP 263,6\n12\n",
  "context": "1 Introduction to Unicode\n1.1 Definitions\nToday\u2019sprogramsneedtobeabletohandleawidevarietyofcharacters. Applicationsareofteninternationalizedto",
  "source_file": "resources\\Year 3\\Python\\howto-unicode.pdf",
  "line_numbers": [
    33,
    469
  ]
}
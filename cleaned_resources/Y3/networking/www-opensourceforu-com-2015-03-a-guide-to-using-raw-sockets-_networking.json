{
  "title": "www-opensourceforu-com-2015-03-a-guide-to-using-raw-sockets-",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "web_dev",
    "fundamentals",
    "algorithms",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "protocol.",
  "code": "int sock_r;\ns i o f c ( k s _ o r c = k s _ o r c < k 0 e ) t(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL)); Sign Up Now\n{\nprintf(\u0093error in socket\\n\u0094);\nreturn -1;\n}\nReception of the network packet\nAfter successfully opening a raw socket, it\u0092s time to receive network packets, for which\nyou need to use the recvfrom api. We can also use the recv api. But recvfrom provides\nadditional information.\nunsigned char *buffer = (unsigned char *) malloc(65536); //to receive data\nmemset(buffer,0,65536);\nstruct sockaddr saddr;\nint saddr_len = sizeof (saddr);\n//Receive a network packet and copy in to buffer\nbuflen=recvfrom(sock_r,buffer,65536,0,&saddr,(socklen_t *)&saddr_len);\nif(buflen<0)\n{\nprintf(\u0093error in reading recvfrom function\\n\u0094);\nreturn -1;\n}\nIn saddr, the underlying protocol provides the source address of the packet.\nExtracting the Ethernet header\nNow that we have the network packets in our buffer, we will get information about the\nEthernet header. The Ethernet header contains the physical address of the source and\ndestination, or the MAC address and protocol of the receiving packet. The if_ether.h header\ncontains the structure of the Ethernet header (see Figure 5).\nFigure 5: Structure of Ethernet header\nNow, we can easily access these fields:\nstruct ethhdr *eth = (struct ethhdr *)(buffer);\nprintf(\u0093\\nEthernet Header\\n\u0094);\nprintf(\u0093\\t|-Source Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\\n\u0094,eth->h_source[0],eth->h_source[1\nprintf(\u0093\\t|-Destination Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\\n\u0094,eth->h_dest[0],eth->h_dest[\nprintf(\u0093\\t|-Protocol : %d\\n\u0094,eth->h_proto);\nh_proto gives information about the next layer. If you get 0x800 (ETH_P_IP), it means that\nthe next header is the IP header. Later, we will consider the next header as the IP header. \ue809\nNote 1: The physical address is 6 bytes.\nNote 2: We can also direct the output to a file for better understanding.\nfprintf(log_txt,\u0094\\t|-Source Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\\n\u0094,eth->h_source[0],eth->h\nUse fflush to avoid the input-output buffer problem when writing into a file.\nExtracting the IP header\nThe IP layer gives various pieces of information like the source and destination IP address,\nthe transport layer protocol, etc. The structure of the IP header is defined in the ip.h\nheader file (see Figure 6).\nFigure 6: Structure of IP Header\nNow, to get this information, you need to increment your buffer pointer by the size of the\nEthernet header because the IP header comes after the Ethernet header:\nunsigned short iphdrlen;\nstruct iphdr *ip = (struct iphdr*)(buffer + sizeof(struct ethhdr));\nmemset(&source, 0, sizeof(source));\nsource.sin_addr.s_addr = ip->saddr;\nmemset(&dest, 0, sizeof(dest));\ndest.sin_addr.s_addr = ip->daddr;\nfprintf(log_txt, \u0093\\t|-Version : %d\\n\u0094,(unsigned int)ip->version);\nfprintf(log_txt , \u0093\\t|-Internet Header Length : %d DWORDS or %d Bytes\\n\u0094,(unsigned int)ip->ihl\nfprintf(log_txt , \u0093\\t|-Type Of Service : %d\\n\u0094,(unsigned int)ip->tos);\nfprintf(log_txt , \u0093\\t|-Total Length : %d Bytes\\n\u0094,ntohs(ip->tot_len));\nfprintf(log_txt , \u0093\\t|-Identification : %d\\n\u0094,ntohs(ip->id));\nfprintf(log_txt , \u0093\\t|-Time To Live : %d\\n\u0094,(unsigned int)ip->ttl);\nfprintf(log_txt , \u0093\\t|-Protocol : %d\\n\u0094,(unsigned int)ip->protocol);\nfprintf(log_txt , \u0093\\t|-Header Checksum : %d\\n\u0094,ntohs(ip->check));\nfprintf(log_txt , \u0093\\t|-Source IP : %s\\n\u0094, inet_ntoa(source.sin_addr));\nfprintf(log_txt , \u0093\\t|-Destination IP : %s\\n\u0094,inet_ntoa(dest.sin_addr));\nFigure 7: Structure of TCP Header\n\ue809\nFigure 8: Structure of UDP Header\nThe transport layer header\nThere are various transport layer protocols. Since the underlying header was the IP header,\nwe have various IP or Internet protocols. You can see these protocols in the /etc/protocls\nfile. The TCP and UDP protocol structures are defined in tcp.h and udp.h respectively. These\nstructures provide the port number of the source and destination. With the help of the port\nnumber, the system gives data to a particular application (see Figures 7 and 8).\nThe size of the IP header varies from 20 bytes to 60 bytes. We can calculate this from the\nIP header field or IHL. IHL means Internet Header Length (IHL), which is the number of\n32-bit words in the header. So we have to multiply the IHL by 4 to get the size of the\nheader in bytes:\nstruct iphdr *ip = (struct iphdr *)( buffer + sizeof(struct ethhdr) );\n/* getting actual size of IP header*/\niphdrlen = ip->ihl*4;\n/* getting pointer to udp header*/\nstruct tcphdr *udp=(struct udphdr*)(buffer + iphdrlen + sizeof(struct ethhdr));\nWe now have the pointer to the UDP header. So let\u0092s check some of its fields.\nNote: If your machine is little endian, you have to use ntohs because the network uses the\nbig endian scheme.\nfprintf(log_txt , \u0093\\t|-Source Port : %d\\n\u0094 , ntohs(udp->source));\nfprintf(log_txt , \u0093\\t|-Destination Port : %d\\n\u0094 , ntohs(udp->dest));\nfprintf(log_txt , \u0093\\t|-UDP Length : %d\\n\u0094 , ntohs(udp->len));\nfprintf(log_txt , \u0093\\t|-UDP Checksum : %d\\n\u0094 , ntohs(udp->check));\nSimilarly, we can access the TCP header field.\nExtracting data\nAfter the transport layer header, there is data payload remaining. For this, we will move the\npointer to the data, and then print.\nunsigned char * data = (buffer + iphdrlen + sizeof(struct ethhdr) + sizeof(struct udphdr));\nNow, let\u0092s print data, and for better representation, let us print 16 bytes in a line.\nint remaining_data = buflen - (iphdrlen + sizeof(struct ethhdr) + sizeof(struct udphdr));\nfor(i=0;i<remaining_data;i++)\n{\nif(i!=0 && i%16==0)\nfprintf(log_txt,\u0094\\n\u0094);\nfprintf(log_txt,\u0094 %.2X \u0093,data[i]);\n}\nWhen you receive a packet, it will look like what\u0092s shown is Figures 9 and 10.\nFigure 9: UDP Packet\n\ue809\nFigure 10: TCP Packet\nSending packets with a raw socket\nTo send a packet, we first have to know the source and destination IP addresses as well as\nthe MAC address. Use your friend\u0092s MAC & IP address as the destination IP and MAC\naddress. There are two ways to find out your IP address and MAC address:\n1. Enter ifconfig and get the IP and MAC for a particular interface.\n2. Enter ioctl and get the IP and MAC.\nThe second way is more efficient and will make your program machine-independent, which\nmeans you should not enter ifconfig in each machine.\nOpening a raw socket\nTo open a raw socket, you have to know three fields of socket API \u2014 Family- AF_PACKET,\nType- SOCK_RAW and for the protocol, let\u0092s use IPPROTO_RAW because we are trying to\nsend an IP packet. IPPROTO_RAW macro is defined in the in.h header file:\nsock_raw=socket(AF_PACKET,SOCK_RAW,IPPROTO_RAW);\nif(sock_raw == -1)\nprintf(\u0093error in socket\u0094);\nWhat is struct ifreq?\nLinux supports some standard ioctls to configure network devices. They can be used on any\nsocket\u0092s file descriptor, regardless of the family or type. They pass an ifreq structure,\nwhich means that if you want to know some information about the network, like the\ninterface index or interface name, you can use ioctl and it will fill the value of the ifreq\nstructure passed as a third argument. In short, the ifreq structure is a way to get and set\nthe network configuration. It is defined in the if.h header file or you can check the man\npage of netdevice (see Figure 11).\n\ue809\nFigure 11: Structure of ifreq\nFigure 12\nFigure 12: Graphical representation of packets with their\nstructure and payload\nGetting the index of the interface to send a packet\nThere may be various interfaces in your machine like loopback, wired interface and wireless\ninterface. So you have to decide the interface through which we can send our packet. After\ndeciding on the interface, you have to get the index of that interface. For this, first give the\nname of the interface by setting the field ifr_name of ifreq structure, and then use ioctl.\nThen use the SIOCGIFINDEX macro defined in sockios.h and you will receive the index\nnumber in the ifreq structure:\nstruct ifreq ifreq_i;\nmemset(&ifreq_i,0,sizeof(ifreq_i));\nstrncpy(ifreq_i.ifr_name,\u0094wlan0\u0094,IFNAMSIZ-1); //giving name of Interface\nif((ioctl(sock_raw,SIOCGIFINDEX,&ifreq_i))<0)\nprintf(\u0093error in index ioctl reading\u0094);//getting Index Name\nprintf(\u0093index=%d\\n\u0094,ifreq_i.ifr_ifindex);\nGetting the MAC address of the interface\nSimilarly, you can get the MAC address of the interface, for which you need to use the\nSIOCGIFHWADDR macro to ioctl:\nstruct ifreq ifreq_c;\nmemset(&ifreq_c,0,sizeof(ifreq_c));\nstrncpy(ifreq_c.ifr_name,\u0094wlan0\u0094,IFNAMSIZ-1);//giving name of Interface\nif((ioctl(sock_raw,SIOCGIFHWADDR,&ifreq_c))<0) //getting MAC Address\nprintf(\u0093error in SIOCGIFHWADDR ioctl reading\u0094);\nGetting the IP address of the interface\nFor this, use the SIOCGIFADDR macro:\nstruct ifreq ifreq_ip;\nmemset(&ifreq_ip,0,sizeof(ifreq_ip));\nstrncpy(ifreq_ip.ifr_name,\u0094wlan0\u0094,IFNAMSIZ-1);//giving name of Interface\nif(ioctl(sock_raw,SIOCGIFADDR,&ifreq_ip)<0) //getting IP Address\n{\nprintf(\u0093error in SIOCGIFADDR \\n\u0094);\n}\nConstructing the Ethernet header\nAfter getting the index, as well as the MAC and IP addresses of an interface, it\u0092s time to\nconstruct the Ethernet header. First, take a buffer in which you will place all information like\nthe Ethernet header, IP header, UDP header and data. That buffer will be your packet.\nsendbuff=(unsigned char*)malloc(64); // increase in case of more data\nmemset(sendbuff,0,64);\nTo construct the Ethernet header, fill all the fields of the ethhdr structure:\nstruct ethhdr *eth = (struct ethhdr *)(sendbuff);\neth->h_source[0] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[0]);\neth->h_source[1] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[1]);\neth->h_source[2] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[2]);\neth->h_source[3] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[3]); \ue809\neth->h_source[4] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[4]);\neth->h_source[5] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[5]);\n/* filling destination mac. DESTMAC0 to DESTMAC5 are macro having octets of mac address. */\neth->h_dest[0] = DESTMAC0;\neth->h_dest[1] = DESTMAC1;\neth->h_dest[2] = DESTMAC2;\neth->h_dest[3] = DESTMAC3;\neth->h_dest[4] = DESTMAC4;\neth->h_dest[5] = DESTMAC5;\neth->h_proto = htons(ETH_P_IP); //means next header will be IP header\n/* end of ethernet header */\ntotal_len+=sizeof(struct ethhdr);\nConstructing the IP header\nTo construct the IP header, increment sendbuff by the size of the Ethernet header and fill\neach field of the iphdr structure. Data after the IP header is called the payload for the IP\nheader and, in the same way, data after the Ethernet header is called the payload for the\nEthernet header. In the IP header, there is a field called Total Length, which contains the\nsize of the IP header plus the payload. To know the size of the payload of the IP header,\nyou must know the size of the UDP header and the UDP payload. So, some field of the\niphdr structure will get the value after filling the UDP header field.\nstruct iphdr *iph = (struct iphdr*)(sendbuff + sizeof(struct ethhdr));\niph->ihl = 5;\niph->version = 4;\niph->tos = 16;\niph->id = htons(10201);\niph->ttl = 64;\niph->protocol = 17;\niph->saddr = inet_addr(inet_ntoa((((struct sockaddr_in *)&(ifreq_ip.ifr_addr))->sin_addr)));\niph->daddr = inet_addr(\u0093destination_ip\u0094); // put destination IP address\ntotal_len += sizeof(struct iphdr);\nConstruct the UDP header\nConstructing the UDP header is very similar to constructing the IP header. Assign values to\nthe fields of the udphdr structure. For this, increment the sendbuff pointer by the size of\nthe Ethernet and the IP headers.\nstruct udphdr *uh = (struct udphdr *)(sendbuff + sizeof(struct iphdr) + sizeof(struct ethhdr));\nuh->source = htons(23451);\nuh->dest = htons(23452);\nuh->check = 0;\ntotal_len+= sizeof(struct udphdr);\nLike the IP header, the UDP also has the field len, which contains the size of the UDP\nheader and its payload. So, first, you have to know the UDP payload, which is the actual\ndata that will be sent.\nAdding data or the UDP payload\nWe can send any data:\nsendbuff[total_len++] = 0xAA;\nsendbuff[total_len++] = 0xBB;\nsendbuff[total_len++] = 0xCC;\nsendbuff[total_len++] = 0xDD;\nsendbuff[total_len++] = 0xEE;\nFilling the remaining fields of the IP and UDP headers\nWe now have the total_len pointer and with the help of this, we can fill the remaining fields\nof the IP and UDP headers:\nuh->len = htons((total_len - sizeof(struct iphdr) - sizeof(struct ethhdr)));\n//UDP length field\niph->tot_len = htons(total_len - sizeof(struct ethhdr));\n//IP length field\nThe IP header checksum\nThere is one more field remaining in the IP header check, which is used to have a\nchecksum. A checksum is used for error checking of the header.\nWhen the packet arrives at the router, it calculates the checksum, and if the calculated\nchecksum does not match with the checksum field of the header, the router will drop the\npacket; and if it matches, the router will decrement the time to the live field by one, and\nforward it.\nTo calculate the checksum, sum up all the 16-bit words of the IP header and if there is any\ncarry, add it again to get a 16-bit word. After this, find the complement of 1\u0092s and that is \ue809\nour checksum. To check whether our checksum is correct, use the above algorithm.\nunsigned short checksum(unsigned short* buff, int _16bitword)\n{\nunsigned long sum;\nfor(sum=0;_16bitword>0;_16bitword--)\nsum+=htons(*(buff)++);\nsum = ((sum >> 16) + (sum & 0xFFFF));\nsum += (sum>>16);\nreturn (unsigned short)(~sum);\n}\niph->check = checksum((unsigned short*)(sendbuff + sizeof(struct ethhdr)), (sizeof(struct iphdr)\nSending the packet\nNow we have our packet but before sending it, let\u0092s fill the sockaddr_ll structure with the\ndestination MAC address:\nstruct sockaddr_ll sadr_ll;\nsadr_ll.sll_ifindex = ifreq_i.ifr_ifindex; // index of interface\nsadr_ll.sll_halen = ETH_ALEN; // length of destination mac address\nsadr_ll.sll_addr[0] = DESTMAC0;\nsadr_ll.sll_addr[1] = DESTMAC1;\nsadr_ll.sll_addr[2] = DESTMAC2;\nsadr_ll.sll_addr[3] = DESTMAC3;\nsadr_ll.sll_addr[4] = DESTMAC4;\nsadr_ll.sll_addr[5] = DESTMAC5;\nAnd now its time to send it, for which let\u0092s use the sendto api:\nsend_len = sendto(sock_raw,sendbuff,64,0,(const struct sockaddr*)&sadr_ll,sizeof(struct sockaddr\nif(send_len<0)\n{\nprintf(\u0093error in sending....sendlen=%d....errno=%d\\n\u0094,send_len,errno);\nreturn -1;\n}\nHow to run the program\nGo to root user, then compile and run your program in a machine. And in another machine,\nor in your destination machine, run the packet sniffer program as the root user and analyse\nthe data that you are sending.\nWhat to do next\nWe made a packet sniffer as well as a packet sender, but this is a user space task. Now lets\ntry the same things in kernel space. For this, try to understand struct sk_buff and make a\nmodule that can perform the same things in kernel space.\nNote: you can download the complete code here\nPrevious article Next article\nExploring Big Data on a Desktop: Archiving and Qt5: Let\u0092s Learn Some Theory\nRetrieving Emails using HBase and Phoenix\nSubodh Saxena\nThe author works at Effortsys Technologies in the network device driver space. He is\ninterested in new technologies, and especially open source technologies.\nRELATED ARTICLES MORE FROM AUTHOR\nAdmin Admin Admin\nSecure Your Network with Snort Setting Up A Status Page To Monitor Using Wireshark for Network Packet\nCloud Infrastructure Analysis: An Overview\n\ue80c \ue80d\nShow/Write Comments\n\ue809\nEDITOR PICKS POPULAR POSTS POPULAR CATEGORY\nSecure Your Network with Snort Search file and create backup News 3151\nMay 23, 2025 according to creation or\nmodification date Developers 1757\nJuly 12, 2018 Blogs 1083\nAgentic AI: Towards Smarter and Database Programming in OSFY 1079\nIndependent AI Systems Python For U & Me 953\nMay 22, 2025 April 10, 2019\nAdmin 740\nBuilding a Zero Trust Network A Beginner\u2019s Guide To Grep: Tools / Apps 632\nEnvironment with OpenZiti Basics And Regular Expressions How-Tos 617\nMay 21, 2025 June 28, 2012 Basics 520\nABOUT US FOLLOW US\nOpen Source For You is Asia's leading IT publication focused on\n\ue818 \ue81f \ue831\nopen source technologies. Launched in February 2003 (as Linux\nFor You), the magazine/website aims to help techies avail the\nbenefits of open source software and solutions. Techies that\nconnect with the magazine include software developers, IT\nmanagers, CIOs, hackers, etc.\n\u00a9 Open Source For You 2025\n",
  "context": "protocol. For a raw socket, the socket family is AF_PACKET, the socket type is SOCK_RAW\nand for the protocol, see the if_ether.h header file. To receive all packets, the macro is\nETH_P_ALL and to receive IP packets, the macro is ETH_P_IP for the protocol field. First name",
  "source_file": "resources\\Year 3\\Socket Programming\\www-opensourceforu-com-2015-03-a-guide-to-using-raw-sockets-.pdf",
  "line_numbers": [
    101,
    414
  ]
}
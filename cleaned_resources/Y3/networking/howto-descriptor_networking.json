{
  "title": "howto-descriptor",
  "language": "cpp",
  "topics": [
    "machine_learning",
    "fundamentals",
    "algorithms",
    "networking",
    "data_structures",
    "database"
  ],
  "purpose": "Email: docs@python.org Contents 1 Primer 3",
  "code": "1.1 Simpleexample: Adescriptorthatreturnsaconstant . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2 Dynamiclookups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.3 Managedattributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.4 Customizednames. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.5 Closingthoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n2 CompletePracticalExample 6\n2.1 Validatorclass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.2 Customvalidators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.3 Practicalapplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n3 TechnicalTutorial 9\n3.1 Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.2 Definitionandintroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.3 Descriptorprotocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.4 Overviewofdescriptorinvocation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.5 Invocationfromaninstance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.6 Invocationfromaclass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.7 Invocationfromsuper . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.8 Summaryofinvocationlogic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.9 Automaticnamenotification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.10 ORMexample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n4 PurePythonEquivalents 13\n4.1 Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n4.2 Functionsandmethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n4.3 Kindsofmethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n4.4 Staticmethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n4.5 Classmethods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n4.6 Memberobjectsand__slots__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nAuthor\nRaymondHettinger\nContact\n<pythonatrcndotcom>\n1\nContents\n\u2022 DescriptorGuide\n\u2013 Primer\n\u2217 Simpleexample: Adescriptorthatreturnsaconstant\n\u2217 Dynamiclookups\n\u2217 Managedattributes\n\u2217 Customizednames\n\u2217 Closingthoughts\n\u2013 CompletePracticalExample\n\u2217 Validatorclass\n\u2217 Customvalidators\n\u2217 Practicalapplication\n\u2013 TechnicalTutorial\n\u2217 Abstract\n\u2217 Definitionandintroduction\n\u2217 Descriptorprotocol\n\u2217 Overviewofdescriptorinvocation\n\u2217 Invocationfromaninstance\n\u2217 Invocationfromaclass\n\u2217 Invocationfromsuper\n\u2217 Summaryofinvocationlogic\n\u2217 Automaticnamenotification\n\u2217 ORMexample\n\u2013 PurePythonEquivalents\n\u2217 Properties\n\u2217 Functionsandmethods\n\u2217 Kindsofmethods\n\u2217 Staticmethods\n\u2217 Classmethods\n\u2217 Memberobjectsand__slots__\nDescriptorsletobjectscustomizeattributelookup,storage,anddeletion.\nThisguidehasfourmajorsections:\n1) The\u201cprimer\u201dgivesabasicoverview,movinggentlyfromsimpleexamples,addingonefeatureatatime. Start\nhereifyou\u2019renewtodescriptors.\n2) Thesecondsectionshowsacomplete,practicaldescriptorexample. Ifyoualreadyknowthebasics,startthere.\n3) Thethirdsectionprovidesamoretechnicaltutorialthatgoesintothedetailedmechanicsofhowdescriptors\nwork. Mostpeopledon\u2019tneedthislevelofdetail.\n2\n4) ThelastsectionhaspurePythonequivalentsforbuilt-indescriptorsthatarewritteninC.Readthisifyou\u2019re\ncurious about how functions turn into bound methods or about the implementation of common tools like\nclassmethod(),staticmethod(),property(),and__slots__.\n1 Primer\nInthisprimer,westartwiththemostbasicpossibleexampleandthenwe\u2019lladdnewcapabilitiesonebyone.\n1.1 Simple example: A descriptor that returns a constant\nTheTenclassisadescriptorwhose__get__()methodalwaysreturnstheconstant10:\nclass Ten:\ndef __get__(self, obj, objtype=None):\nreturn 10\nTousethedescriptor,itmustbestoredasaclassvariableinanotherclass:\nclass A:\nx = 5 # Regular class attribute\ny = Ten() # Descriptor instance\nAninteractivesessionshowsthedifferencebetweennormalattributelookupanddescriptorlookup:\n>>> a = A() # Make an instance of class A\n>>> a.x # Normal attribute lookup\n5\n>>> a.y # Descriptor lookup\n10\nInthea.xattributelookup,thedotoperatorfinds'x': 5intheclassdictionary. Inthea.ylookup,thedotoperator\nfindsadescriptorinstance,recognizedbyits__get__method. Callingthatmethodreturns10.\nNotethatthevalue10isnotstoredineithertheclassdictionaryortheinstancedictionary. Instead,thevalue10is\ncomputedondemand.\nThisexampleshowshowasimpledescriptorworks,butitisn\u2019tveryuseful. Forretrievingconstants,normalattribute\nlookupwouldbebetter.\nInthenextsection,we\u2019llcreatesomethingmoreuseful,adynamiclookup.\n1.2 Dynamic lookups\nInterestingdescriptorstypicallyruncomputationsinsteadofreturningconstants:\nimport os\nclass DirectorySize:\ndef __get__(self, obj, objtype=None):\nreturn len(os.listdir(obj.dirname))\nclass Directory:\nsize = DirectorySize() # Descriptor instance\ndef __init__(self, dirname):\nself.dirname = dirname # Regular instance attribute\nAninteractivesessionshowsthatthelookupisdynamic\u2014itcomputesdifferent,updatedanswerseachtime:\n3\n>>> s = Directory('songs')\n>>> g = Directory('games')\n>>> s.size # The songs directory has twenty files\n20\n>>> g.size # The games directory has three files\n3\n>>> os.remove('games/chess') # Delete a game\n>>> g.size # File count is automatically updated\n2\nBesidesshowinghowdescriptorscanruncomputations,thisexamplealsorevealsthepurposeoftheparametersto\n__get__(). Theselfparameterissize,aninstanceofDirectorySize. Theobjparameteriseithergors,aninstanceof\nDirectory. Itistheobjparameterthatletsthe__get__()methodlearnthetargetdirectory. Theobjtypeparameter\nistheclassDirectory.\n1.3 Managed attributes\nApopularusefordescriptorsismanagingaccesstoinstancedata. Thedescriptorisassignedtoapublicattributein\ntheclassdictionarywhiletheactualdataisstoredasaprivateattributeintheinstancedictionary. Thedescriptor\u2019s\n__get__()and__set__()methodsaretriggeredwhenthepublicattributeisaccessed.\nInthefollowingexample, ageisthepublicattributeand_ageistheprivateattribute. Whenthepublicattributeis\naccessed,thedescriptorlogsthelookuporupdate:\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass LoggedAgeAccess:\ndef __get__(self, obj, objtype=None):\nvalue = obj._age\nlogging.info('Accessing %r giving %r', 'age', value)\nreturn value\ndef __set__(self, obj, value):\nlogging.info('Updating %r to %r', 'age', value)\nobj._age = value\nclass Person:\nage = LoggedAgeAccess() # Descriptor instance\ndef __init__(self, name, age):\nself.name = name # Regular instance attribute\nself.age = age # Calls __set__()\ndef birthday(self):\nself.age += 1 # Calls both __get__() and __set__()\nAninteractivesessionshowsthatallaccesstothemanagedattributeageislogged,butthattheregularattributename\nisnotlogged:\n>>> mary = Person('Mary M', 30) # The initial age update is logged\nINFO:root:Updating 'age' to 30\n>>> dave = Person('David D', 40)\nINFO:root:Updating 'age' to 40\n(continuesonnextpage)\n4\n(continuedfrompreviouspage)\n>>> vars(mary) # The actual data is in a private attribute\n{'name': 'Mary M', '_age': 30}\n>>> vars(dave)\n{'name': 'David D', '_age': 40}\n>>> mary.age # Access the data and log the lookup\nINFO:root:Accessing 'age' giving 30\n30\n>>> mary.birthday() # Updates are logged as well\nINFO:root:Accessing 'age' giving 30\nINFO:root:Updating 'age' to 31\n>>> dave.name # Regular attribute lookup isn't logged\n'David D'\n>>> dave.age # Only the managed attribute is logged\nINFO:root:Accessing 'age' giving 40\n40\nOne major issue with this example is that the private name _age is hardwired in the LoggedAgeAccess class. That\nmeansthateachinstancecanonlyhaveoneloggedattributeandthatitsnameisunchangeable. Inthenextexample,\nwe\u2019llfixthatproblem.\n1.4 Customized names\nWhenaclassusesdescriptors,itcaninformeachdescriptoraboutwhichvariablenamewasused.\nInthisexample,thePersonclasshastwodescriptorinstances,nameandage. WhenthePersonclassisdefined,\nit makes a callback to __set_name__() in LoggedAccess so that the field names can be recorded, giving each\ndescriptoritsownpublic_nameandprivate_name:\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass LoggedAccess:\ndef __set_name__(self, owner, name):\nself.public_name = name\nself.private_name = '_' + name\ndef __get__(self, obj, objtype=None):\nvalue = getattr(obj, self.private_name)\nlogging.info('Accessing %r giving %r', self.public_name, value)\nreturn value\ndef __set__(self, obj, value):\nlogging.info('Updating %r to %r', self.public_name, value)\nsetattr(obj, self.private_name, value)\nclass Person:\nname = LoggedAccess() # First descriptor instance\nage = LoggedAccess() # Second descriptor instance\ndef __init__(self, name, age):\nself.name = name # Calls the first descriptor\nself.age = age # Calls the second descriptor\n(continuesonnextpage)\n5\n(continuedfrompreviouspage)\ndef birthday(self):\nself.age += 1\nAninteractivesessionshowsthatthePersonclasshascalled__set_name__()sothatthefieldnameswouldbe\nrecorded. Herewecallvars()tolookupthedescriptorwithouttriggeringit:\n>>> vars(vars(Person)['name'])\n{'public_name': 'name', 'private_name': '_name'}\n>>> vars(vars(Person)['age'])\n{'public_name': 'age', 'private_name': '_age'}\nThenewclassnowlogsaccesstobothnameandage:\n>>> pete = Person('Peter P', 10)\nINFO:root:Updating 'name' to 'Peter P'\nINFO:root:Updating 'age' to 10\n>>> kate = Person('Catherine C', 20)\nINFO:root:Updating 'name' to 'Catherine C'\nINFO:root:Updating 'age' to 20\nThetwoPersoninstancescontainonlytheprivatenames:\n>>> vars(pete)\n{'_name': 'Peter P', '_age': 10}\n>>> vars(kate)\n{'_name': 'Catherine C', '_age': 20}\n1.5 Closing thoughts\nAdescriptoriswhatwecallanyobjectthatdefines__get__(),__set__(),or__delete__().\nOptionally,descriptorscanhavea__set_name__()method. Thisisonlyusedincaseswhereadescriptorneedsto\nknoweithertheclasswhereitwascreatedorthenameofclassvariableitwasassignedto. (Thismethod,ifpresent,\niscalledeveniftheclassisnotadescriptor.)\nDescriptors get invoked by the dot operator during attribute lookup. If a descriptor is accessed indirectly with\nvars(some_class)[descriptor_name],thedescriptorinstanceisreturnedwithoutinvokingit.\nDescriptorsonlyworkwhenusedasclassvariables. Whenputininstances,theyhavenoeffect.\nThemainmotivationfordescriptorsistoprovideahookallowingobjectsstoredinclassvariablestocontrolwhat\nhappensduringattributelookup.\nTraditionally, thecallingclasscontrolswhathappensduringlookup. Descriptorsinvertthatrelationshipandallow\nthedatabeinglooked-uptohaveasayinthematter.\nDescriptors are used throughout the language. It is how functions turn into bound methods. Common tools like\nclassmethod(),staticmethod(),property(),andfunctools.cached_property()areallimplemented\nasdescriptors.\n2 Complete Practical Example\nInthisexample,wecreateapracticalandpowerfultoolforlocatingnotoriouslyhardtofinddatacorruptionbugs.\n6\n2.1 Validator class\nAvalidatorisadescriptorformanagedattributeaccess. Priortostoringanydata,itverifiesthatthenewvaluemeets\nvarioustypeandrangerestrictions. Ifthoserestrictionsaren\u2019tmet,itraisesanexceptiontopreventdatacorruption\natitssource.\nThisValidatorclassisbothanabstractbaseclassandamanagedattributedescriptor:\nfrom abc import ABC, abstractmethod\nclass Validator(ABC):\ndef __set_name__(self, owner, name):\nself.private_name = '_' + name\ndef __get__(self, obj, objtype=None):\nreturn getattr(obj, self.private_name)\ndef __set__(self, obj, value):\nself.validate(value)\nsetattr(obj, self.private_name, value)\n@abstractmethod\ndef validate(self, value):\npass\nCustomvalidatorsneedtoinheritfromValidatorandmustsupplyavalidate()methodtotestvariousrestric-\ntionsasneeded.\n2.2 Custom validators\nHerearethreepracticaldatavalidationutilities:\n1) OneOfverifiesthatavalueisoneofarestrictedsetofoptions.\n2) Numberverifiesthatavalueiseitheranintorfloat. Optionally,itverifiesthatavalueisbetweenagiven\nminimumormaximum.\n3) Stringverifiesthatavalueisastr. Optionally, itvalidatesagivenminimumormaximumlength. Itcan\nvalidateauser-definedpredicateaswell.\nclass OneOf(Validator):\ndef __init__(self, *options):\nself.options = set(options)\ndef validate(self, value):\nif value not in self.options:\nraise ValueError(\nf'Expected {value!r} to be one of {self.options!r}'\n)\nclass Number(Validator):\ndef __init__(self, minvalue=None, maxvalue=None):\nself.minvalue = minvalue\nself.maxvalue = maxvalue\ndef validate(self, value):\nif not isinstance(value, (int, float)):\n(continuesonnextpage)\n7\n(continuedfrompreviouspage)\nraise TypeError(f'Expected {value!r} to be an int or float')\nif self.minvalue is not None and value < self.minvalue:\nraise ValueError(\nf'Expected {value!r} to be at least {self.minvalue!r}'\n)\nif self.maxvalue is not None and value > self.maxvalue:\nraise ValueError(\nf'Expected {value!r} to be no more than {self.maxvalue!r}'\n)\nclass String(Validator):\ndef __init__(self, minsize=None, maxsize=None, predicate=None):\nself.minsize = minsize\nself.maxsize = maxsize\nself.predicate = predicate\ndef validate(self, value):\nif not isinstance(value, str):\nraise TypeError(f'Expected {value!r} to be an str')\nif self.minsize is not None and len(value) < self.minsize:\nraise ValueError(\nf'Expected {value!r} to be no smaller than {self.minsize!r}'\n)\nif self.maxsize is not None and len(value) > self.maxsize:\nraise ValueError(\nf'Expected {value!r} to be no bigger than {self.maxsize!r}'\n)\nif self.predicate is not None and not self.predicate(value):\nraise ValueError(\nf'Expected {self.predicate} to be true for {value!r}'\n)\n2.3 Practical application\nHere\u2019showthedatavalidatorscanbeusedinarealclass:\nclass Component:\nname = String(minsize=3, maxsize=10, predicate=str.isupper)\nkind = OneOf('wood', 'metal', 'plastic')\nquantity = Number(minvalue=0)\ndef __init__(self, name, kind, quantity):\nself.name = name\nself.kind = kind\nself.quantity = quantity\nThedescriptorspreventinvalidinstancesfrombeingcreated:\n>>> Component('Widget', 'metal', 5) # Blocked: 'Widget' is not all uppercase\nTraceback (most recent call last):\n...\nValueError: Expected <method 'isupper' of 'str' objects> to be true for 'Widget'\n>>> Component('WIDGET', 'metle', 5) # Blocked: 'metle' is misspelled\n(continuesonnextpage)\n8\n(continuedfrompreviouspage)\nTraceback (most recent call last):\n...\nValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n>>> Component('WIDGET', 'metal', -5) # Blocked: -5 is negative\nTraceback (most recent call last):\n...\nValueError: Expected -5 to be at least 0\n>>> Component('WIDGET', 'metal', 'V') # Blocked: 'V' isn't a number\nTraceback (most recent call last):\n...\nTypeError: Expected 'V' to be an int or float\n>>> c = Component('WIDGET', 'metal', 5) # Allowed: The inputs are valid\n3 Technical Tutorial\nWhatfollowsisamoretechnicaltutorialforthemechanicsanddetailsofhowdescriptorswork.\n3.1 Abstract\nDefinesdescriptors,summarizestheprotocol,andshowshowdescriptorsarecalled. Providesanexampleshowing\nhowobjectrelationalmappingswork.\nLearning about descriptors not only provides access to a larger toolset, it creates a deeper understanding of how\nPythonworks.\n3.2 Definition and introduction\nIngeneral,adescriptorisanattributevaluethathasoneofthemethodsinthedescriptorprotocol. Thosemethods\nare__get__(),__set__(),and__delete__(). Ifanyofthosemethodsaredefinedforanattribute,itissaidto\nbeadescriptor.\nThedefaultbehaviorforattributeaccessistoget,set,ordeletetheattributefromanobject\u2019sdictionary. Forinstance,\na.xhasalookupchainstartingwitha.__dict__['x'],thentype(a).__dict__['x'],andcontinuingthrough\nthemethodresolutionorderoftype(a). Ifthelooked-upvalueisanobjectdefiningoneofthedescriptormethods,\nthenPythonmayoverridethedefaultbehaviorandinvokethedescriptormethodinstead. Wherethisoccursinthe\nprecedencechaindependsonwhichdescriptormethodsweredefined.\nDescriptors are a powerful, general purpose protocol. They are the mechanism behind properties, methods, static\nmethods,classmethods,andsuper(). TheyareusedthroughoutPythonitself. Descriptorssimplifytheunderlying\nCcodeandofferaflexiblesetofnewtoolsforeverydayPythonprograms.\n3.3 Descriptor protocol\ndescr.__get__(self, obj, type=None)\ndescr.__set__(self, obj, value)\ndescr.__delete__(self, obj)\nThatisallthereistoit. Defineanyofthesemethodsandanobjectisconsideredadescriptorandcanoverridedefault\nbehavioruponbeinglookedupasanattribute.\nIfanobjectdefines__set__()or__delete__(),itisconsideredadatadescriptor. Descriptorsthatonlydefine\n__get__()arecallednon-datadescriptors(theyareoftenusedformethodsbutotherusesarepossible).\nDataandnon-datadescriptorsdifferinhowoverridesarecalculatedwithrespecttoentriesinaninstance\u2019sdictionary.\nIfaninstance\u2019sdictionaryhasanentrywiththesamenameasadatadescriptor,thedatadescriptortakesprecedence.\n9\nIf an instance\u2019s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes\nprecedence.\nTo make a read-only data descriptor, define both __get__() and __set__() with the __set__() raising an\nAttributeErrorwhencalled. Definingthe__set__()methodwithanexceptionraisingplaceholderisenough\ntomakeitadatadescriptor.\n3.4 Overview of descriptor invocation\nAdescriptorcanbecalleddirectlywithdesc.__get__(obj)ordesc.__get__(None, cls).\nButitismorecommonforadescriptortobeinvokedautomaticallyfromattributeaccess.\nTheexpressionobj.xlooksuptheattributexinthechainofnamespacesforobj. Ifthesearchfindsadescriptor\noutsideoftheinstance__dict__,its__get__()methodisinvokedaccordingtotheprecedenceruleslistedbelow.\nThedetailsofinvocationdependonwhetherobjisanobject,class,orinstanceofsuper.\n3.5 Invocation from an instance\nInstancelookupscansthroughachainofnamespacesgivingdatadescriptorsthehighestpriority,followedbyinstance\nvariables,thennon-datadescriptors,thenclassvariables,andlastly__getattr__()ifitisprovided.\nIfadescriptorisfoundfora.x,thenitisinvokedwith: desc.__get__(a, type(a)).\nThelogicforadottedlookupisinobject.__getattribute__(). HereisapurePythonequivalent:\ndef find_name_in_mro(cls, name, default):\n\"Emulate _PyType_Lookup() in Objects/typeobject.c\"\nfor base in cls.__mro__:\nif name in vars(base):\nreturn vars(base)[name]\nreturn default\ndef object_getattribute(obj, name):\n\"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\nnull = object()\nobjtype = type(obj)\ncls_var = find_name_in_mro(objtype, name, null)\ndescr_get = getattr(type(cls_var), '__get__', null)\nif descr_get is not null:\nif (hasattr(type(cls_var), '__set__')\nor hasattr(type(cls_var), '__delete__')):\nreturn descr_get(cls_var, obj, objtype) # data descriptor\nif hasattr(obj, '__dict__') and name in vars(obj):\nreturn vars(obj)[name] # instance variable\nif descr_get is not null:\nreturn descr_get(cls_var, obj, objtype) # non-data descriptor\nif cls_var is not null:\nreturn cls_var # class variable\nraise AttributeError(name)\nNote, there is no __getattr__() hook in the __getattribute__() code. That is why calling\n__getattribute__()directlyorwithsuper().__getattribute__willbypass__getattr__()entirely.\nInstead,itisthedotoperatorandthegetattr()functionthatareresponsibleforinvoking__getattr__()when-\never__getattribute__()raisesanAttributeError. Theirlogicisencapsulatedinahelperfunction:\ndef getattr_hook(obj, name):\n\"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\ntry:\n(continuesonnextpage)\n10\n(continuedfrompreviouspage)\nreturn obj.__getattribute__(name)\nexcept AttributeError:\nif not hasattr(type(obj), '__getattr__'):\nraise\nreturn type(obj).__getattr__(obj, name) # __getattr__\n3.6 Invocation from a class\nThe logic for a dotted lookup such as A.x is in type.__getattribute__(). The steps are similar to those\nforobject.__getattribute__()buttheinstancedictionarylookupisreplacedbyasearchthroughtheclass\u2019s\nmethodresolutionorder.\nIfadescriptorisfound,itisinvokedwithdesc.__get__(None, A).\nThefullCimplementationcanbefoundintype_getattro()and_PyType_Lookup()inObjects/typeobject.c.\n3.7 Invocation from super\nThelogicforsuper\u2019sdottedlookupisinthe__getattribute__()methodforobjectreturnedbysuper().\nAdottedlookupsuchassuper(A, obj).msearchesobj.__class__.__mro__forthebaseclassBimmediately\nfollowingAandthenreturnsB.__dict__['m'].__get__(obj, A).Ifnotadescriptor,misreturnedunchanged.\nThefullCimplementationcanbefoundinsuper_getattro()inObjects/typeobject.c. ApurePythonequivalent\ncanbefoundinGuido\u2019sTutorial.\n3.8 Summary of invocation logic\nThe mechanism for descriptors is embedded in the __getattribute__() methods for object, type, and\nsuper().\nTheimportantpointstorememberare:\n\u2022 Descriptorsareinvokedbythe__getattribute__()method.\n\u2022 Classesinheritthismachineryfromobject,type,orsuper().\n\u2022 Overriding__getattribute__()preventsautomaticdescriptorcallsbecauseallthedescriptorlogicisin\nthatmethod.\n\u2022 object.__getattribute__() and type.__getattribute__() make different calls to __get__().\nThefirstincludestheinstanceandmayincludetheclass. ThesecondputsinNonefortheinstanceandalways\nincludestheclass.\n\u2022 Datadescriptorsalwaysoverrideinstancedictionaries.\n\u2022 Non-datadescriptorsmaybeoverriddenbyinstancedictionaries.\n3.9 Automatic name notification\nSometimesitisdesirableforadescriptortoknowwhatclassvariablenameitwasassignedto. Whenanewclassis\ncreated,thetypemetaclassscansthedictionaryofthenewclass. Ifanyoftheentriesaredescriptorsandifthey\ndefine__set_name__(),thatmethodiscalledwithtwoarguments. Theowneristheclasswherethedescriptoris\nused,andthenameistheclassvariablethedescriptorwasassignedto.\nTheimplementationdetailsareintype_new()andset_names()inObjects/typeobject.c.\nSincetheupdatelogicisintype.__new__(),notificationsonlytakeplaceatthetimeofclasscreation. Ifdescriptors\nareaddedtotheclassafterwards,__set_name__()willneedtobecalledmanually.\n11\n3.10 ORM example\nThe following code is a simplified skeleton showing how data descriptors could be used to implement an object\nrelationalmapping.\nThe essential idea is that the data is stored in an external database. The Python instances only hold keys to the\ndatabase\u2019stables. Descriptorstakecareoflookupsorupdates:\nclass Field:\ndef __set_name__(self, owner, name):\nself.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'\nself.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'\ndef __get__(self, obj, objtype=None):\nreturn conn.execute(self.fetch, [obj.key]).fetchone()[0]\ndef __set__(self, obj, value):\nconn.execute(self.store, [value, obj.key])\nconn.commit()\nWecanusetheFieldclasstodefinemodelsthatdescribetheschemaforeachtableinadatabase:\nclass Movie:\ntable = 'Movies' # Table name\nkey = 'title' # Primary key\ndirector = Field()\nyear = Field()\ndef __init__(self, key):\nself.key = key\nclass Song:\ntable = 'Music'\nkey = 'title'\nartist = Field()\nyear = Field()\ngenre = Field()\ndef __init__(self, key):\nself.key = key\nTousethemodels,firstconnecttothedatabase:\n>>> import sqlite3\n>>> conn = sqlite3.connect('entertainment.db')\nAninteractivesessionshowshowdataisretrievedfromthedatabaseandhowitcanbeupdated:\n>>> Movie('Star Wars').director\n'George Lucas'\n>>> jaws = Movie('Jaws')\n>>> f'Released in {jaws.year} by {jaws.director}'\n'Released in 1975 by Steven Spielberg'\n>>> Song('Country Roads').artist\n'John Denver'\n>>> Movie('Star Wars').director = 'J.J. Abrams'\n(continuesonnextpage)\n12\n(continuedfrompreviouspage)\n>>> Movie('Star Wars').director\n'J.J. Abrams'\n4 Pure Python Equivalents\nThedescriptorprotocolissimpleandoffersexcitingpossibilities. Severalusecasesaresocommonthattheyhave\nbeenprepackagedintobuilt-intools. Properties, boundmethods, staticmethods, classmethods, and__slots__are\nallbasedonthedescriptorprotocol.\n4.1 Properties\nCallingproperty()isasuccinctwayofbuildingadatadescriptorthattriggersafunctioncalluponaccesstoan\nattribute. Itssignatureis:\nproperty(fget=None, fset=None, fdel=None, doc=None) -> property\nThedocumentationshowsatypicalusetodefineamanagedattributex:\nclass C:\ndef getx(self): return self.__x\ndef setx(self, value): self.__x = value\ndef delx(self): del self.__x\nx = property(getx, setx, delx, \"I'm the 'x' property.\")\nToseehowproperty()isimplementedintermsofthedescriptorprotocol,hereisapurePythonequivalentthat\nimplementsmostofthecorefunctionality:\nclass Property:\n\"Emulate PyProperty_Type() in Objects/descrobject.c\"\ndef __init__(self, fget=None, fset=None, fdel=None, doc=None):\nself.fget = fget\nself.fset = fset\nself.fdel = fdel\nif doc is None and fget is not None:\ndoc = fget.__doc__\nself.__doc__ = doc\ndef __set_name__(self, owner, name):\nself.__name__ = name\ndef __get__(self, obj, objtype=None):\nif obj is None:\nreturn self\nif self.fget is None:\nraise AttributeError\nreturn self.fget(obj)\ndef __set__(self, obj, value):\nif self.fset is None:\nraise AttributeError\nself.fset(obj, value)\ndef __delete__(self, obj):\nif self.fdel is None:\nraise AttributeError\n(continuesonnextpage)\n13\n(continuedfrompreviouspage)\nself.fdel(obj)\ndef getter(self, fget):\nreturn type(self)(fget, self.fset, self.fdel, self.__doc__)\ndef setter(self, fset):\nreturn type(self)(self.fget, fset, self.fdel, self.__doc__)\ndef deleter(self, fdel):\nreturn type(self)(self.fget, self.fset, fdel, self.__doc__)\nTheproperty()builtinhelpswheneverauserinterfacehasgrantedattributeaccessandthensubsequentchanges\nrequiretheinterventionofamethod.\nForinstance,aspreadsheetclassmaygrantaccesstoacellvaluethroughCell('b10').value. Subsequentim-\nprovementstotheprogramrequirethecelltoberecalculatedoneveryaccess; however, theprogrammerdoesnot\nwanttoaffectexistingclientcodeaccessingtheattributedirectly. Thesolutionistowrapaccesstothevalueattribute\ninapropertydatadescriptor:\nclass Cell:\n...\n@property\ndef value(self):\n\"Recalculate the cell before returning value\"\nself.recalc()\nreturn self._value\nEitherthebuilt-inproperty()orourProperty()equivalentwouldworkinthisexample.\n4.2 Functions and methods\nPython\u2019sobjectorientedfeaturesarebuiltuponafunctionbasedenvironment. Usingnon-datadescriptors,thetwo\naremergedseamlessly.\nFunctionsstoredinclassdictionariesgetturnedintomethodswheninvoked. Methodsonlydifferfromregularfunc-\ntionsinthattheobjectinstanceisprependedtotheotherarguments. Byconvention,theinstanceiscalledself but\ncouldbecalledthisoranyothervariablename.\nMethodscanbecreatedmanuallywithtypes.MethodTypewhichisroughlyequivalentto:\nclass MethodType:\n\"Emulate PyMethod_Type in Objects/classobject.c\"\ndef __init__(self, func, obj):\nself.__func__ = func\nself.__self__ = obj\ndef __call__(self, *args, **kwargs):\nfunc = self.__func__\nobj = self.__self__\nreturn func(obj, *args, **kwargs)\ndef __getattribute__(self, name):\n\"Emulate method_getset() in Objects/classobject.c\"\nif name == '__doc__':\nreturn self.__func__.__doc__\nreturn object.__getattribute__(self, name)\n(continuesonnextpage)\n14\n(continuedfrompreviouspage)\ndef __getattr__(self, name):\n\"Emulate method_getattro() in Objects/classobject.c\"\nreturn getattr(self.__func__, name)\ndef __get__(self, obj, objtype=None):\n\"Emulate method_descr_get() in Objects/classobject.c\"\nreturn self\nTo support automatic creation of methods, functions include the __get__() method for binding methods during\nattributeaccess. Thismeansthatfunctionsarenon-datadescriptorsthatreturnboundmethodsduringdottedlookup\nfromaninstance. Here\u2019showitworks:\nclass Function:\n...\ndef __get__(self, obj, objtype=None):\n\"Simulate func_descr_get() in Objects/funcobject.c\"\nif obj is None:\nreturn self\nreturn MethodType(self, obj)\nRunningthefollowingclassintheinterpretershowshowthefunctiondescriptorworksinpractice:\nclass D:\ndef f(self):\nreturn self\nclass D2:\npass\nThefunctionhasaqualifiednameattributetosupportintrospection:\n>>> D.f.__qualname__\n'D.f'\nAccessingthefunctionthroughtheclassdictionarydoesnotinvoke__get__(). Instead,itjustreturnstheunderlying\nfunctionobject:\n>>> D.__dict__['f']\n<function D.f at 0x00C45070>\nDottedaccessfromaclasscalls__get__()whichjustreturnstheunderlyingfunctionunchanged:\n>>> D.f\n<function D.f at 0x00C45070>\nTheinterestingbehavioroccursduringdottedaccessfromaninstance. Thedottedlookupcalls__get__()which\nreturnsaboundmethodobject:\n>>> d = D()\n>>> d.f\n<bound method D.f of <__main__.D object at 0x00B18C90>>\nInternally,theboundmethodstorestheunderlyingfunctionandtheboundinstance:\n>>> d.f.__func__\n<function D.f at 0x00C45070>\n(continuesonnextpage)\n15\n(continuedfrompreviouspage)\n>>> d.f.__self__\n<__main__.D object at 0x00B18C90>\nIfyouhaveeverwonderedwhereselfcomesfrominregularmethodsorwhereclscomesfrominclassmethods,this\nisit!\n4.3 Kinds of methods\nNon-datadescriptorsprovideasimplemechanismforvariationsontheusualpatternsofbindingfunctionsintometh-\nods.\nTorecap,functionshavea__get__()methodsothattheycanbeconvertedtoamethodwhenaccessedasattributes.\nThe non-data descriptor transforms an obj.f(*args) call into f(obj, *args). Calling cls.f(*args) be-\ncomesf(*args).\nThischartsummarizesthebindinganditstwomostusefulvariants:\nTransformation Calledfromanobject Calledfromaclass\nfunction f(obj,*args) f(*args)\nstaticmethod f(*args) f(*args)\nclassmethod f(type(obj),*args) f(cls,*args)\n4.4 Static methods\nStaticmethodsreturntheunderlyingfunctionwithoutchanges. Callingeitherc.forC.fistheequivalentofadirect\nlookup into object.__getattribute__(c, \"f\") or object.__getattribute__(C, \"f\"). As a result,\nthefunctionbecomesidenticallyaccessiblefromeitheranobjectoraclass.\nGoodcandidatesforstaticmethodsaremethodsthatdonotreferencetheselfvariable.\nFor instance, a statistics package may include a container class for experimental data. The class provides normal\nmethodsforcomputingtheaverage,mean,median,andotherdescriptivestatisticsthatdependonthedata. However,\ntheremaybeusefulfunctionswhichareconceptuallyrelatedbutdonotdependonthedata. Forinstance,erf(x)is\nhandyconversionroutinethatcomesupinstatisticalworkbutdoesnotdirectlydependonaparticulardataset. Itcan\nbecalledeitherfromanobjectortheclass: s.erf(1.5) --> 0.9332orSample.erf(1.5) --> 0.9332.\nSincestaticmethodsreturntheunderlyingfunctionwithnochanges,theexamplecallsareunexciting:\nclass E:\n@staticmethod\ndef f(x):\nreturn x * 10\n>>> E.f(3)\n30\n>>> E().f(3)\n30\nUsingthenon-datadescriptorprotocol,apurePythonversionofstaticmethod()wouldlooklikethis:\nimport functools\nclass StaticMethod:\n\"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\ndef __init__(self, f):\n(continuesonnextpage)\n16\n(continuedfrompreviouspage)\nself.f = f\nfunctools.update_wrapper(self, f)\ndef __get__(self, obj, objtype=None):\nreturn self.f\ndef __call__(self, *args, **kwds):\nreturn self.f(*args, **kwds)\nThefunctools.update_wrapper()calladdsa__wrapped__attributethatreferstotheunderlyingfunction.\nAlso it carries forward the attributes necessary to make the wrapper look like the wrapped function: __name__,\n__qualname__,__doc__,and__annotations__.\n4.5 Class methods\nUnlikestaticmethods,classmethodsprependtheclassreferencetotheargumentlistbeforecallingthefunction. This\nformatisthesameforwhetherthecallerisanobjectoraclass:\nclass F:\n@classmethod\ndef f(cls, x):\nreturn cls.__name__, x\n>>> F.f(3)\n('F', 3)\n>>> F().f(3)\n('F', 3)\nThisbehaviorisusefulwheneverthemethodonlyneedstohaveaclassreferenceanddoesnotrelyondatastoredin\naspecificinstance. Oneuseforclassmethodsistocreatealternateclassconstructors. Forexample,theclassmethod\ndict.fromkeys()createsanewdictionaryfromalistofkeys. ThepurePythonequivalentis:\nclass Dict(dict):\n@classmethod\ndef fromkeys(cls, iterable, value=None):\n\"Emulate dict_fromkeys() in Objects/dictobject.c\"\nd = cls()\nfor key in iterable:\nd[key] = value\nreturn d\nNowanewdictionaryofuniquekeyscanbeconstructedlikethis:\n>>> d = Dict.fromkeys('abracadabra')\n>>> type(d) is Dict\nTrue\n>>> d\n{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}\nUsingthenon-datadescriptorprotocol,apurePythonversionofclassmethod()wouldlooklikethis:\nimport functools\nclass ClassMethod:\n\"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\ndef __init__(self, f):\n(continuesonnextpage)\n17\n(continuedfrompreviouspage)\nself.f = f\nfunctools.update_wrapper(self, f)\ndef __get__(self, obj, cls=None):\nif cls is None:\ncls = type(obj)\nreturn MethodType(self.f, cls)\nThe functools.update_wrapper() call in ClassMethod adds a __wrapped__ attribute that refers to the\nunderlying function. Also it carries forward the attributes necessary to make the wrapper look like the wrapped\nfunction: __name__,__qualname__,__doc__,and__annotations__.\n4.6 Member objects and __slots__\nWhenaclassdefines__slots__,itreplacesinstancedictionarieswithafixed-lengtharrayofslotvalues. Froma\nuserpointofviewthathasseveraleffects:\n1. Providesimmediatedetectionofbugsduetomisspelledattributeassignments. Onlyattributenamesspecifiedin\n__slots__areallowed:\nclass Vehicle:\n__slots__ = ('id_number', 'make', 'model')\n>>> auto = Vehicle()\n>>> auto.id_nubmer = 'VYE483814LQEX'\nTraceback (most recent call last):\n...\nAttributeError: 'Vehicle' object has no attribute 'id_nubmer'\n2. Helpscreateimmutableobjectswheredescriptorsmanageaccesstoprivateattributesstoredin__slots__:\nclass Immutable:\n__slots__ = ('_dept', '_name') # Replace the instance dictionary\ndef __init__(self, dept, name):\nself._dept = dept # Store to private attribute\nself._name = name # Store to private attribute\n@property # Read-only descriptor\ndef dept(self):\nreturn self._dept\n@property\ndef name(self): # Read-only descriptor\nreturn self._name\n>>> mark = Immutable('Botany', 'Mark Watney')\n>>> mark.dept\n'Botany'\n>>> mark.dept = 'Space Pirate'\nTraceback (most recent call last):\n...\nAttributeError: property 'dept' of 'Immutable' object has no setter\n>>> mark.location = 'Mars'\nTraceback (most recent call last):\n(continuesonnextpage)\n18\n(continuedfrompreviouspage)\n...\nAttributeError: 'Immutable' object has no attribute 'location'\n3. Savesmemory. Ona64-bitLinuxbuild,aninstancewithtwoattributestakes48byteswith__slots__and152\nbytes without. This flyweight design pattern likely only matters when a large number of instances are going to be\ncreated.\n4. Improvesspeed. Readinginstancevariablesis35%fasterwith__slots__(asmeasuredwithPython3.10onan\nAppleM1processor).\n5. Blockstoolslikefunctools.cached_property()whichrequireaninstancedictionarytofunctioncorrectly:\nfrom functools import cached_property\nclass CP:\n__slots__ = () # Eliminates the instance dict\n@cached_property # Requires an instance dict\ndef pi(self):\nreturn 4 * sum((-1.0)**n / (2.0*n + 1.0)\nfor n in reversed(range(100_000)))\n>>> CP().pi\nTraceback (most recent call last):\n...\nTypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property.\nItisnotpossibletocreateanexactdrop-inpurePythonversionof__slots__becauseitrequiresdirectaccessto\nCstructuresandcontroloverobjectmemoryallocation. However,wecanbuildamostlyfaithfulsimulationwhere\ntheactualCstructureforslotsisemulatedbyaprivate_slotvalueslist. Readsandwritestothatprivatestructure\naremanagedbymemberdescriptors:\nnull = object()\nclass Member:\ndef __init__(self, name, clsname, offset):\n'Emulate PyMemberDef in Include/structmember.h'\n# Also see descr_new() in Objects/descrobject.c\nself.name = name\nself.clsname = clsname\nself.offset = offset\ndef __get__(self, obj, objtype=None):\n'Emulate member_get() in Objects/descrobject.c'\n# Also see PyMember_GetOne() in Python/structmember.c\nif obj is None:\nreturn self\nvalue = obj._slotvalues[self.offset]\nif value is null:\nraise AttributeError(self.name)\nreturn value\ndef __set__(self, obj, value):\n'Emulate member_set() in Objects/descrobject.c'\nobj._slotvalues[self.offset] = value\n(continuesonnextpage)\n19\n(continuedfrompreviouspage)\ndef __delete__(self, obj):\n'Emulate member_delete() in Objects/descrobject.c'\nvalue = obj._slotvalues[self.offset]\nif value is null:\nraise AttributeError(self.name)\nobj._slotvalues[self.offset] = null\ndef __repr__(self):\n'Emulate member_repr() in Objects/descrobject.c'\nreturn f'<Member {self.name!r} of {self.clsname!r}>'\nThetype.__new__()methodtakescareofaddingmemberobjectstoclassvariables:\nclass Type(type):\n'Simulate how the type metaclass adds member objects for slots'\ndef __new__(mcls, clsname, bases, mapping, **kwargs):\n'Emulate type_new() in Objects/typeobject.c'\n# type_new() calls PyTypeReady() which calls add_methods()\nslot_names = mapping.get('slot_names', [])\nfor offset, name in enumerate(slot_names):\nmapping[name] = Member(name, clsname, offset)\nreturn type.__new__(mcls, clsname, bases, mapping, **kwargs)\nTheobject.__new__()methodtakescareofcreatinginstancesthathaveslotsinsteadofaninstancedictionary.\nHereisaroughsimulationinpurePython:\nclass Object:\n'Simulate how object.__new__() allocates memory for __slots__'\ndef __new__(cls, *args, **kwargs):\n'Emulate object_new() in Objects/typeobject.c'\ninst = super().__new__(cls)\nif hasattr(cls, 'slot_names'):\nempty_slots = [null] * len(cls.slot_names)\nobject.__setattr__(inst, '_slotvalues', empty_slots)\nreturn inst\ndef __setattr__(self, name, value):\n'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\ncls = type(self)\nif hasattr(cls, 'slot_names') and name not in cls.slot_names:\nraise AttributeError(\nf'{cls.__name__!r} object has no attribute {name!r}'\n)\nsuper().__setattr__(name, value)\ndef __delattr__(self, name):\n'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\ncls = type(self)\nif hasattr(cls, 'slot_names') and name not in cls.slot_names:\nraise AttributeError(\nf'{cls.__name__!r} object has no attribute {name!r}'\n)\nsuper().__delattr__(name)\nTousethesimulationinarealclass,justinheritfromObjectandsetthemetaclasstoType:\n20\nclass H(Object, metaclass=Type):\n'Instance variables stored in slots'\nslot_names = ['x', 'y']\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nAtthispoint,themetaclasshasloadedmemberobjectsforxandy:\n>>> from pprint import pp\n>>> pp(dict(vars(H)))\n{'__module__': '__main__',\n'__doc__': 'Instance variables stored in slots',\n'slot_names': ['x', 'y'],\n'__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n'x': <Member 'x' of 'H'>,\n'y': <Member 'y' of 'H'>}\nWheninstancesarecreated,theyhaveaslot_valueslistwheretheattributesarestored:\n>>> h = H(10, 20)\n>>> vars(h)\n{'_slotvalues': [10, 20]}\n>>> h.x = 55\n>>> vars(h)\n{'_slotvalues': [55, 20]}\nMisspelledorunassignedattributeswillraiseanexception:\n>>> h.xz\nTraceback (most recent call last):\n...\nAttributeError: 'H' object has no attribute 'xz'\n21\n",
  "context": "Email: docs@python.org\nContents\n1 Primer 3",
  "source_file": "resources\\Year 3\\Python\\howto-descriptor.pdf",
  "line_numbers": [
    9,
    899
  ]
}
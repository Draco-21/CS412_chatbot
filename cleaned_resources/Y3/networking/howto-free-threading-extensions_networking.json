{
  "title": "howto-free-threading-extensions",
  "language": "python",
  "topics": [
    "web_dev",
    "networking",
    "algorithms",
    "data_structures",
    "database"
  ],
  "purpose": "1 Identifying the Free-Threaded Build in C TheCPythonCAPIexposesthePy_GIL_DISABLEDmacro: inthefree-threadedbuildit\u2019sdefinedto1,andinthe regularbuildit\u2019snotdefined.",
  "code": "#ifdef Py_GIL_DISABLED\n/* code that only runs in the free-threaded build */\n#endif\n1\n2 Module Initialization\nExtensionmodulesneedtoexplicitlyindicatethattheysupportrunningwiththeGILdisabled;otherwiseimporting\ntheextensionwillraiseawarningandenabletheGILatruntime.\nTherearetwowaystoindicatethatanextensionmodulesupportsrunningwiththeGILdisableddependingonwhether\ntheextensionusesmulti-phaseorsingle-phaseinitialization.\n2.1 Multi-Phase Initialization\nExtensions that use multi-phase initialization (i.e., PyModuleDef_Init()) should add a Py_mod_gil slot in\nthe module definition. If your extension supports older versions of CPython, you should guard the slot with a\nPY_VERSION_HEXcheck.\nstatic struct PyModuleDef_Slot module_slots[] = {\n...\n#if PY_VERSION_HEX >= 0x030D0000\n{Py_mod_gil, Py_MOD_GIL_NOT_USED},\n#endif\n{0, NULL}\n};\nstatic struct PyModuleDef moduledef = {\nPyModuleDef_HEAD_INIT,\n.m_slots = module_slots,\n...\n};\n2.2 Single-Phase Initialization\nExtensions that use single-phase initialization (i.e., PyModule_Create()) should call\nPyUnstable_Module_SetGIL() to indicate that they support running with the GIL disabled. The func-\ntion is only defined in the free-threaded build, so you should guard the call with #ifdef Py_GIL_DISABLED to\navoidcompilationerrorsintheregularbuild.\nstatic struct PyModuleDef moduledef = {\nPyModuleDef_HEAD_INIT,\n...\n};\nPyMODINIT_FUNC\nPyInit_mymodule(void)\n{\nPyObject *m = PyModule_Create(&moduledef);\nif (m == NULL) {\nreturn NULL;\n}\n#ifdef Py_GIL_DISABLED\nPyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n#endif\nreturn m;\n}\n2\n3 General API Guidelines\nMostoftheCAPIisthread-safe,buttherearesomeexceptions.\n\u2022 StructFields: AccessingfieldsinPythonCAPIobjectsorstructsdirectlyisnotthread-safeifthefieldmay\nbeconcurrentlymodified.\n\u2022 Macros: AccessormacroslikePyList_GET_ITEMandPyList_SET_ITEMdonotperformanyerrorcheck-\ningorlocking. Thesemacrosarenotthread-safeifthecontainerobjectmaybemodifiedconcurrently.\n\u2022 BorrowedReferences: CAPIfunctionsthatreturnborrowedreferencesmaynotbethread-safeifthecon-\ntainingobjectismodifiedconcurrently. Seethesectiononborrowedreferencesformoreinformation.\n3.1 Container Thread Safety\nContainerslikePyListObject,PyDictObject,andPySetObjectperforminternallockinginthefree-threaded\nbuild. Forexample,thePyList_Append()willlockthelistbeforeappendinganitem.\nPyDict_Next\nA notable exception is PyDict_Next(), which does not lock the dictionary. You should use\nPy_BEGIN_CRITICAL_SECTION to protect the dictionary while iterating over it if the dictionary may be\nconcurrentlymodified:\nPy_BEGIN_CRITICAL_SECTION(dict);\nPyObject *key, *value;\nPy_ssize_t pos = 0;\nwhile (PyDict_Next(dict, &pos, &key, &value)) {\n...\n}\nPy_END_CRITICAL_SECTION();\n4 Borrowed References\nSomeCAPIfunctionsreturnborrowedreferences. TheseAPIsarenotthread-safeifthecontainingobjectismodified\nconcurrently. Forexample,it\u2019snotsafetousePyList_GetItem()ifthelistmaybemodifiedconcurrently.\nThefollowingtablelistssomeborrowedreferenceAPIsandtheirreplacementsthatreturnstrongreferences.\nBorrowedreferenceAPI StrongreferenceAPI\nPyList_GetItem() PyList_GetItemRef()\nPyDict_GetItem() PyDict_GetItemRef()\nPyDict_GetItemWithError() PyDict_GetItemRef()\nPyDict_GetItemString() PyDict_GetItemStringRef()\nPyDict_SetDefault() PyDict_SetDefaultRef()\nPyDict_Next() none(seePyDict_Next)\nPyWeakref_GetObject() PyWeakref_GetRef()\nPyWeakref_GET_OBJECT() PyWeakref_GetRef()\nPyImport_AddModule() PyImport_AddModuleRef()\nNotallAPIsthatreturnborrowedreferencesareproblematic. Forexample,PyTuple_GetItem()issafebecause\ntuplesareimmutable. Similarly,notallusesoftheaboveAPIsareproblematic. Forexample,PyDict_GetItem()\nisoftenusedforparsingkeywordargumentdictionariesinfunctioncalls; thosekeywordargumentdictionariesare\neffectivelyprivate(notaccessiblebyotherthreads),sousingborrowedreferencesinthatcontextissafe.\nSomeofthesefunctionswereaddedinPython3.13. Youcanusethepythoncapi-compatpackagetoprovideimple-\nmentationsofthesefunctionsforolderPythonversions.\n3\n5 Memory Allocation APIs\nPython\u2019smemorymanagementCAPIprovidesfunctionsinthreedifferentallocationdomains: \u201craw\u201d,\u201cmem\u201d,and\n\u201cobject\u201d. Forthread-safety,thefree-threadedbuildrequiresthatonlyPythonobjectsareallocatedusingtheobject\ndomain,andthatallPythonobjectareallocatedusingthatdomain. ThisdiffersfromthepriorPythonversions,where\nthiswasonlyabestpracticeandnotahardrequirement.\n(cid:174) Note\nSearch for uses of PyObject_Malloc() in your extension and check that the allocated memory is used for\nPythonobjects. UsePyMem_Malloc()toallocatebuffersinsteadofPyObject_Malloc().\n6 Thread State and GIL APIs\nPythonprovidesasetoffunctionsandmacrostomanagethreadstateandtheGIL,suchas:\n\u2022 PyGILState_Ensure()andPyGILState_Release()\n\u2022 PyEval_SaveThread()andPyEval_RestoreThread()\n\u2022 Py_BEGIN_ALLOW_THREADSandPy_END_ALLOW_THREADS\nThesefunctionsshouldstillbeusedinthefree-threadedbuildtomanagethreadstateevenwhentheGILisdisabled.\nForexample, ifyoucreateathreadoutsideofPython, youmustcallPyGILState_Ensure()beforecallinginto\nthePythonAPItoensurethatthethreadhasavalidPythonthreadstate.\nYoushouldcontinuetocallPyEval_SaveThread()orPy_BEGIN_ALLOW_THREADSaroundblockingoperations,\nsuchasI/Oorlockacquisitions,toallowotherthreadstorunthecyclicgarbagecollector.\n7 Protecting Internal Extension State\nYourextensionmayhaveinternalstatethatwaspreviouslyprotectedbytheGIL.Youmayneedtoaddlockingto\nprotectthisstate. Theapproachwilldependonyourextension,butsomecommonpatternsinclude:\n\u2022 Caches: global caches are a common source of shared state. Consider using a lock to protect the cache or\ndisablingitinthefree-threadedbuildifthecacheisnotcriticalforperformance.\n\u2022 Global State: global state may need to be protected by a lock or moved to thread local storage. C11 and\nC++11providethethread_localor_Thread_localforthread-localstorage.\n8 Building Extensions for the Free-Threaded Build\nCAPIextensionsneedtobebuiltspecificallyforthefree-threadedbuild. Thewheels,sharedlibraries,andbinaries\nareindicatedbyatsuffix.\n\u2022 pypa/manylinuxsupportsthefree-threadedbuild,withthetsuffix,suchaspython3.13t.\n\u2022 pypa/cibuildwheelsupportsthefree-threadedbuildifyousetCIBW_FREE_THREADED_SUPPORT.\n8.1 Limited C API and Stable ABI\nThe free-threaded build does not currently support the Limited C API or the stable ABI. If you use setuptools to\nbuildyourextensionandcurrentlysetpy_limited_api=Trueyoucanusepy_limited_api=not sysconfig.\nget_config_var(\"Py_GIL_DISABLED\") to opt out of the limited API when building with the free-threaded\nbuild.\n4\n(cid:174) Note\nYou will need to build separate wheels specifically for the free-threaded build. If you currently use the stable\nABI,youcancontinuetobuildasinglewheelformultiplenon-free-threadedPythonversions.\n8.2 Windows\nDuetoalimitationoftheofficialWindowsinstaller,youwillneedtomanuallydefinePy_GIL_DISABLED=1when\nbuildingextensionsfromsource.\n(cid:181) Seealso\nPorting Extension Modules to Support Free-Threading: A community-maintained porting guide for extension\nauthors.\n5\n",
  "context": "1 Identifying the Free-Threaded Build in C\nTheCPythonCAPIexposesthePy_GIL_DISABLEDmacro: inthefree-threadedbuildit\u2019sdefinedto1,andinthe\nregularbuildit\u2019snotdefined. Youcanuseittoenablecodethatonlyrunsunderthefree-threadedbuild:",
  "source_file": "resources\\Year 3\\Python\\howto-free-threading-extensions.pdf",
  "line_numbers": [
    28,
    164
  ]
}